// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_LEANPACKET_LEANPACKET_H_
#define FLATBUFFERS_GENERATED_LEANPACKET_LEANPACKET_H_

#include "flatbuffers/flatbuffers.h"

#include "LeanType_generated.h"

namespace LeanPacket {

struct Pos;

struct ReactionInfo;

struct EffectTargetInfo;

struct PingNotify;

struct KeepAliveNotify;

struct GamePingRequest;

struct GamePingResponse;

struct GameContentsConfigNotify;

struct AccountReconnectRequest;

struct AccountReconnectResponse;

struct HiveTopPcInfoRequest;

struct HiveTopPcInfoResponse;

struct HiveCompanionCountRequest;

struct HiveCompanionCountResponse;

struct HiveShopPurchaseProductNotify;

struct DelayPingNotify;

struct CheckClientVersionRequest;

struct CheckClientVersionResponse;

struct AccountAuthRequest;

struct AccountAuthResponse;

struct AccountAuthAgentTicketRequest;

struct ColonyData;

struct CharacterData;

struct GroupData;

struct PcAbility;

struct ColonyListRequest;

struct ColonyListResponse;

struct CharacterListRequest;

struct CharacterListResponse;

struct HiveAuthRequest;

struct HiveAuthResponse;

struct SelectColonyRequest;

struct SelectColonyResponse;

struct SelectRealmRequest;

struct SelectRealmResponse;

struct SelectColonyBotRequest;

struct ColonyWaitingNotify;

struct InquireWaitingRequest;

struct InquireWaitingResponse;

struct CancelWaitingRequest;

struct CancelWaitingResponse;

struct StringMessageNotify;

struct UserKickNotify;

struct ItemPartsInfo;

struct CostumePartsInfo;

struct AccountLoginRequest;

struct AccountLoginResponse;

struct ServerLocalTimeNotify;

struct DevicePerformancePointNotify;

struct SeasonInfoNotify;

struct ServerLocalTimeRequest;

struct ServerLocalTimeResponse;

struct SlotListRequest;

struct PCSlotData;

struct PcTutorialSkipRequest;

struct PcTutorialSkipResponse;

struct SlotListResponse;

struct PCCheckNewNameRequest;

struct PCCheckNewNameResponse;

struct PCRenameRequest;

struct PCRenameResponse;

struct CustomizeInfo;

struct PCCreationRequest;

struct PCCreationResponse;

struct PCDeleteRequest;

struct PCDeleteResponse;

struct PCCancelDeleteRequest;

struct PCCancelDeleteResponse;

struct PCLoginRequest;

struct PCLoginResponse;

struct PcGotoLobbyRequest;

struct PcGotoLobbyResponse;

struct AccountLogoutRequest;

struct AccountLogoutResponse;

struct GotoServerListRequest;

struct GotoServerListResponse;

struct TicketNotify;

struct TicketAllNotify;

struct PcSpawnCompleteNotify;

struct UpcSpawnCompleteNotify;

struct ChannelInfo;

struct SMapChannelListRequest;

struct SMapChannelListResponse;

struct SMapChannelMoveRequest;

struct SMapChannelMoveResponse;

struct JoinEventSetChannelRequest;

struct JoinEventSetChannelResponse;

struct TeleportRequest;

struct TeleportResponse;

struct TeleportNotifyOhterPcInView;

struct EnterEventAreaRequest;

struct EnterEventAreaResponse;

struct EventMessageNotify;

struct SafeZoneInRequest;

struct SafeZoneInResponse;

struct SafeZoneOutRequest;

struct SafeZoneOutResponse;

struct ClientCreatureMoveNotify;

struct ServerCreatureMoveNotify;

struct ClientShortTermMoveNotify;

struct ClientLongTermMoveNotify;

struct ServerShortTermMoveNotify;

struct ServerLongTermMoveNotify;

struct EventDirectionBeginNotify;

struct EventDirectionFinishNotify;

struct ContributionPoint;

struct EventContribution;

struct NotifyEventContribution;

struct BattleRealmGuildContribution;

struct EventBattleRealmContributionNotify;

struct RewardItemInfo;

struct RewardInfo;

struct ResultRewardInfo;

struct ContributionCategoryInfo;

struct EventContributionRewardInfo;

struct ContributionResultInfo;

struct EventPraiserInfo;

struct EventRecommendPraiserInfo;

struct NotifyEventTotalReward;

struct NotifyEventStart;

struct NotifyEventEnd;

struct NotifyNextNormalEventSetInfo;

struct NotifyEventPhaseStart;

struct EventSpeechBubbleNotify;

struct EventChannelCloseNotify;

struct EventGoTownRequest;

struct EventGoTownResponse;

struct EventDisappearBarriorNotify;

struct transformWithCutScene;

struct NpcSceneMapInfoUpdateNotify;

struct NpcSceneMapInfoDestroyNotify;

struct PcSceneMapInfoUpdateNotify;

struct PcSceneMapInfoDestroyNotify;

struct CraftItemRequest;

struct CraftItemResponse;

struct TransmuteCrystalItemRequest;

struct TransmuteCrystalItemResponse;

struct PrismTransmutationRequest;

struct PrismTransmutationResponse;

struct StorageData;

struct ClientLItem;

struct SkillSlotInfo;

struct SkillSlot;

struct PurseInfo;

struct CostInfo;

struct FollowerInfo;

struct TicketInfo;

struct PcGuildInfo;

struct PcLoginDataNotify;

struct StorageDataNotify;

struct StorageItemDataNotify;

struct EquipDataNotify;

struct SkillSlotNotify;

struct SkillOpenShieldNotify;

struct SkillClosedShieldNotify;

struct SkillErrorNotify;

struct EnterStateNotify;

struct LeaveStateNotify;

struct LoadData;

struct LoadDataRequest;

struct LoadDataResponse;

struct WorldObjectDespawnNotify;

struct PCSpawnNotify;

struct UPCSpawnNotify;

struct NPCSpawnNotify;

struct ProjectileSpawnNotify;

struct ProjectileEffectNotify;

struct ReactionEnterNotify;

struct ReactionLeaveNotify;

struct ReactionUpdateNotify;

struct InstantShotSpawnNotify;

struct InstantShotDespawnNotify;

struct UseSkillRequest;

struct StartSkillNotify;

struct EndSkillNotify;

struct SkillEffectNotify;

struct DamageResult;

struct HealResult;

struct ReactionResult;

struct HpDrainResult;

struct SkillEffectResultNotify;

struct EffectResultDamageNotify;

struct EffectResultReactionNotify;

struct EffectResultHealNotify;

struct AddBuffNotify;

struct UpdateBuffNotify;

struct CreatureHpChangeNotify;

struct NpcAggroTimerNotify;

struct CreatureTargetedNotify;

struct NpcReturnWarningNotify;

struct InsertItemResponse;

struct DeleteItemRequest;

struct DeleteItemResponse;

struct EquipItemRecommendationRequest;

struct EquipItemObjectRequest;

struct EquipItemResponse;

struct UnequipItemRequest;

struct UnequipItemResponse;

struct RefreshInvenRequest;

struct RefreshInvenResponse;

struct ServerTimeRequest;

struct ServerTimeResponse;

struct UpdateItemNotify;

struct ToggleSafeGuardRequest;

struct ToggleSafeGuardResponse;

struct UseItemRequest;

struct UseItemResponse;

struct ItemBoundStateUpdateNotify;

struct AddItemNotify;

struct RemoveItemNotify;

struct ArtifactInfo;

struct UpdateArtifactNotify;

struct ChangeItemStackCountNotify;

struct MoveItemNotify;

struct ClientSItem;

struct DisenchantItemRequest;

struct DisenchantItemResponse;

struct EnchantItemRequest;

struct EnchantItemResponse;

struct EquipmentTransmutationRequest;

struct EquipmentTransmutationResponse;

struct UpgradeItemRequest;

struct UpgradeItemResponse;

struct PcLevelupExpNotify;

struct PcExpUpNotify;

struct DropRewardNotify;

struct ClientItemStackInfo;

struct SaleItemRequest;

struct SaleItemResponse;

struct UpdatePurseNotify;

struct WorkObjectSpawnNotify;

struct WorkObjectUpdateNotify;

struct InteractionStateNotify;

struct StartInteractionRequest;

struct StartMiniGameInteractionNotify;

struct StartDialogInteractionNotify;

struct OtherPcStartInteractionNotify;

struct MiniGameInteractionResultNotify;

struct CancelInteractionNotify;

struct EndInteractionNotify;

struct OtherPcEndInteractionNotify;

struct CameraObjectStartNotify;

struct CameraObjectEndNotify;

struct CameraObjectMoveNotify;

struct Stats;

struct StatUpdateNotify;

struct AiActionStartNotify;

struct AiActionEndNotify;

struct PlayerReviveRequest;

struct PlayerReviveResponse;

struct ChangedSuperArmorGaugeNotify;

struct PenaltySkillNotify;

struct PenaltySkillCancelNotify;

struct AdminCommandNotify;

struct SystemDebugMessageNotify;

struct SkillSlotPlaceRequest;

struct SkillSlotPlaceResponse;

struct SkillLevelUpInfo;

struct SkillLevelUpRequest;

struct SkillLevelUpResponse;

struct ChangeIffNotify;

struct UpdateEnergyPointNotify;

struct EquipInfo;

struct CostumeSlotInfo;

struct CostumeInfo;

struct EventCounterInfo;

struct EventCounterProgressInfo;

struct EventHiddenContentsStart;

struct EventHiddenContentsEnd;

struct EventHiddenGatheringCollected;

struct EventOutOfPlayNotify;

struct EventMiddleNotify;

struct QuestRewardNotify;

struct QuestReceiveRewardResponse;

struct QuestCountData;

struct QuestContextData;

struct QuestContextDataSetNotify;

struct QuestContextDataNotify;

struct MainStreamEventJoinSwitchStateNotify;

struct MainStreamEventJoinSwitchRequest;

struct MainStreamEventJoinSwitchResponse;

struct MainStreamStateNotify;

struct MainStreamData;

struct MainStreamDataNotify;

struct MainStreamDataSetNotify;

struct MainStreamDirectNotify;

struct MainStreamPreActionRequest;

struct MainStreamPreActionResponse;

struct MainStreamFinishedBackNotify;

struct MainStreamDoButtonActionRequest;

struct MainStreamDoButtonActionResponse;

struct MainStreamOnRewardUiNotify;

struct DailyHomeworkData;

struct DailyHomeworkActivityRewardStatus;

struct DailyHomeworkDataAllNotify;

struct DailyHomeworkDataUpdateNotify;

struct DailyHomeworkGetRewardRequest;

struct DailyHomeworkGetRewardResponse;

struct ChapterClearSMapRequest;

struct ChapterClearSMapResponse;

struct ChapterJoinSmapRequest;

struct ChapterJoinSmapResponse;

struct ChapterJoinRequest;

struct ChapterJoinResponse;

struct ChapterDataNotify;

struct ChapterNotify;

struct ExitInstanceDungeonRequest;

struct ExitInstanceDungeonResponse;

struct EventMoveStartLocRequest;

struct EventMoveStartLocResponse;

struct EventReturnLastLocRequest;

struct EventReturnLastLocResponse;

struct GoldDungeonInfoRequest;

struct GoldDungeonInfoResponse;

struct GoldDungeonEnterFailed;

struct QuestBonusData;

struct QuestBonusRewardRequest;

struct QuestBonusRewardResponse;

struct QuestBonusRewardNotify;

struct PraiserInfo;

struct RecommendGetPraiserRequest;

struct RecommendGetPraiserResponse;

struct RecommendChoicePraiserRequest;

struct RecommendChoicePraiserReponse;

struct RecommendPraiserResultNotify;

struct RecommendChoiceResultNotify;

struct PresetChangeRequest;

struct PresetChangeResponse;

struct PresetItemInfo;

struct PresetSkillInfo;

struct PresetCostumeSlotInfo;

struct PresetCostumeInfo;

struct PresetInfo;

struct CostumePresetInfo;

struct PresetItemSlotUpdateNotify;

struct DailyDungeonJoinRequest;

struct DailyDungeonJoinResponse;

struct FieldJoinRequest;

struct FieldJoinResponse;

struct ClientItemResultInfo;

struct UpdateItemGradeLevelNotify;

struct UpateItemOptionNotify;

struct FeatureInfo;

struct LoadedSkillFeatureInfo;

struct SkillFeatureInitializeRequest;

struct SkillFeatureInitializeResponse;

struct UpdateSkillPointNotify;

struct ACRewardItemInfo;

struct DailyDungeonInfo;

struct DailyDungeonInfoRequest;

struct DailyDungeonInfoResponse;

struct DailyDungeonOtherJoinRequest;

struct DailyDungeonOtherJoinResponse;

struct StartResurrectionRequest;

struct StartResurrectionNotify;

struct EndResurrectionNotify;

struct CancelResurrectionRequest;

struct CancelResurrectionNotify;

struct MoveItem;

struct MoveItemRequest;

struct MoveItemResponse;

struct CreatureDetectTargetNotify;

struct SocialMotionStartRequest;

struct SocialMotionStartNotify;

struct SoloDungeonStageElem;

struct SoloDungeonReloadElem;

struct SoloDungeonReloadRequest;

struct SoloDungeonReloadResponse;

struct SoloDungeonLoadNotify;

struct SoloDungeonJoinRequest;

struct SoloDungeonJoinResponse;

struct SoloDungeonClearNotify;

struct ChatRequest;

struct ChatWhisperRequest;

struct ChatPcInfo;

struct ChatCommonInfo;

struct ChatGuildInfo;

struct ChatWhisperInfo;

struct ChatErrorNotify;

struct ChatCommonNotify;

struct ChatGuildNotify;

struct ChatWhisperNotify;

struct ChatGuildMsgListRequest;

struct ChatGuildMsgListResponse;

struct ChatWhisperMsgListRequest;

struct ChatWhisperMsgListResponse;

struct ChatLastWhisperMessage;

struct ChatNewMessageNotify;

struct NewWhisperMessageNotify;

struct NewGuildMessageNotify;

struct ChatCheckReceiverRequest;

struct ChatCheckReceiverResponse;

struct ChatReadWhisperNotify;

struct ChatReadGuildNotify;

struct ChatDeleteRoom;

struct ChatAdmin;

struct ChatAdminWhisper;

struct SystemTime;

struct MailItemInfo;

struct MailContentInfo;

struct MailSystemInfo;

struct MailTimeInfo;

struct BundleRewardInfo;

struct MailRewardInfo;

struct MailInfo;

struct MailResultItem;

struct MailResultInfo;

struct MailReceiveNotify;

struct MailReceiveRequest;

struct MailReceiveResponse;

struct MailRemoveNotify;

struct PlayerImmediatelyDeadRequest;

struct PcGuildInfoUpdateNotify;

struct DailyDungeonClearNotify;

struct PlayerReviveInfo;

struct PlayerReviveInfoNotify;

struct UpcLoadStartNotify;

struct UpcLoadFinishNotify;

struct UpcHostRequest;

struct UpcHostResponse;

struct UpcUnHostNotify;

struct UpcLoadStartNotifyRequest;

struct PlayerDespawnNotify;

struct AddSoulStoneInfo;

struct FollowerAddSoulStoneNotify;

struct FollowerEnchantRequest;

struct FollowerEnchantResponse;

struct FollowerStartMissionRequest;

struct FollowerStartMissionNotify;

struct FollowerEndMissionRequest;

struct FollowerEndMissionResponse;

struct MissionRemainTimeInfo;

struct FollowerMissionRemainTimeRequest;

struct FollowerMissionRemainTimeResponse;

struct FollowerMissionCompleteRequest;

struct FollowerMissionCompleteResponse;

struct GameReconnectRequest;

struct GameReconnectResponse;

struct FollowerLoadInfoNotify;

struct ReconnectLoadDataRequest;

struct ReconnectLoadDataResponse;

struct LoadDataCompleteNotify;

struct FollowerMissionRewardResponse;

struct ArenaMemberBasic;

struct ArenaMember;

struct ArenaMemberDetail;

struct ArenaTeamClass;

struct PcRankInfo;

struct OtherPcItemInfo;

struct OtherPcCostumeInfo;

struct ArenaTeamRequest;

struct ArenaTeamResponse;

struct ArenaTeamRefreshRequest;

struct ArenaTeamRefreshResponse;

struct ArenaJoinRequest;

struct ArenaJoinResponse;

struct ArenaFinishRequest;

struct ArenaFinishNotify;

struct ArenaFinishNotifyRequest;

struct ArenaPlayInfoNotify;

struct DBItemGetTradeJob;

struct DBTradeItemContxt;

struct DBTradeItemContxts;

struct TradeGetTradeItemListRequest;

struct TradeGetTradeItemListResponse;

struct TradeSetTradeItemRequest;

struct TradeSetTradeItemResponse;

struct TradeBuyTradeItemRequest;

struct TradeBuyTradeItemResponse;

struct TradeMySaleListRequest;

struct TradeMySaleListResponse;

struct TradeSaleLogListRequest;

struct TradeSaleLogListResponse;

struct TradeCancelTradeItemRequest;

struct TradeCancelTradeItemResponse;

struct Influence;

struct InfluencePointUpNoti;

struct InfluenceDataNotify;

struct InfluenceAfterRefreshNotify;

struct BundleResult;

struct BundleBoxResultNotify;

struct ArenaInfoRequest;

struct ArenaInfo;

struct RaidJoinFailNotify;

struct RaidInfoRequest;

struct RaidInfoResponse;

struct RaidRandomRewardPcNotify;

struct PcLoginDataCompleteNotify;

struct PcLoginDataStartNotify;

struct ArenaInfoResponse;

struct CrystalSlot;

struct DimensionCrystalInsertRequest;

struct DimensionCrystalInsertResponse;

struct DimensionCrystalRemoveRequest;

struct DimensionCrystalRemoveResponse;

struct DimensionCrystalLevelUpRequest;

struct DimensionCrystalLevelUpResponse;

struct DimensionCrystalUpgradeRequest;

struct DimensionCrystalUpgradeResponse;

struct DailyRechargeManualRequest;

struct DailyRechargeManualResponse;

struct BonusDailyRechargeInfoRequest;

struct BonusDailyRechargeInfoResponse;

struct InfiniteTowerInfo;

struct InfiniteTowerInfoRequest;

struct InfiniteTowerInfoResponse;

struct InfiniteTowerJoinRequest;

struct InfiniteTowerJoinResponse;

struct InfiniteTowerSweepRequest;

struct InfiniteTowerSweepResponse;

struct InfiniteTowerClearNotify;

struct ShopPurchaseProductMissionInfo;

struct ShopPurchaseProductInfo;

struct ShopPurchaseProductRequest;

struct EffectGrade;

struct ShopPurchaseProductResponse;

struct ShopPurchaseProductRewardRequest;

struct ShopPurchaseProductRewardResponse;

struct ShopPurchaseProductBonusRewardRequest;

struct ShopPurchaseProductBonusRewardResponse;

struct ShopPurchaseProductPromotionRewardRequest;

struct ShopPurchaseProductPromotionRewardResponse;

struct ShopPurchaseProductListNotify;

struct ShopPurchaseProductExpireDateNotify;

struct ShopPurchaseProductMissionUpdateInfo;

struct ShopPurchaseProductMissionUpdateNotify;

struct ShopPurchaseProductBonusPointUpdateNotify;

struct ShopPurchaseProductPromotionUpdateNotify;

struct RankGetPcDetailInfoRequest;

struct RedisGetMyRankRequest;

struct RedisGetMyRankResponse;

struct RedisGetRangeRankInfoRequest;

struct RedisGetRangeRankInfoResponse;

struct AttendanceInfo;

struct AttendanceInfoRequest;

struct AttendanceInfoResponse;

struct AttendanceStampRequest;

struct AttendanceStampResponse;

struct AccessTimeInfoRequest;

struct AccessTimeInfoResponse;

struct AccessTimeRewardRequest;

struct AccessTimeRewardResponse;

struct RestTimeInfoRequest;

struct RestTimeInfoResponse;

struct RestTimeRewardRequest;

struct RestTimeRewardResponse;

struct AcquireContributionNotify;

struct GuildBasicInfo;

struct GuildDetailInfo;

struct GuildRankingInfo;

struct GuildInfo;

struct GuildLoginInfo;

struct GuildMemberInfo;

struct GuildJoinRequestInfo;

struct GuildInfoNotify;

struct GuildNotImplNotify;

struct GuildCrest;

struct GuildCreateRequest;

struct GuildCreateResponse;

struct GuildCheckNameRequest;

struct GuildCheckNameResponse;

struct GuildDestroyRequest;

struct GuildDestroyResponse;

struct GuildInfoRequest;

struct GuildInfoResponse;

struct GuildFindRequest;

struct GuildFindResponse;

struct GuildJoinReqRequest;

struct GuildJoinReqResponse;

struct GuildApplicantUpdateNotify;

struct GuildNewMemberNotify;

struct GuildLeaveRequest;

struct GuildLeaveResponse;

struct GuildJoinNotify;

struct GuildLeaveNotify;

struct GuildLeaveMemberNotify;

struct GuildMemberListRequest;

struct GuildMemberListResponse;

struct GuildAttendRequest;

struct GuildAttendResponse;

struct GuildDonateRequest;

struct GuildDonateResponse;

struct GuildRankingListRequest;

struct GuildRankingListResponse;

struct GuildListRequest;

struct GuildListResponse;

struct GuildDetailInfoRequest;

struct GuildDetailInfoResponse;

struct GuildMyJoinReqListRequest;

struct GuildMyJoinReqListResponse;

struct GuildRemoveJoinReqRequest;

struct GuildRemoveJoinReqResponse;

struct GuildJoinReqListRequest;

struct GuildJoinReqListResponse;

struct GuildAcceptJoinReqRequest;

struct GuildAcceptJoinReqResponse;

struct GuildRejectJoinReqRequest;

struct GuildRejectJoinReqResponse;

struct GuildChangeJoinConditionRequest;

struct GuildChangeJoinConditionResponse;

struct GuildChangeMsgRequest;

struct GuildChangeMsgResponse;

struct GuildKickMemberRequest;

struct GuildKickMemberResponse;

struct GuildLevelUpNotify;

struct GuildChangeMemberGradeRequest;

struct GuildChangeMemberGradeResponse;

struct GuildChangeMemberGradeNotify;

struct GuildHistoryRequest;

struct GuildHistoryItem;

struct GuildHistoryResponse;

struct GuildBuffPurchaseRequest;

struct GuildBuffPurchaseResponse;

struct GuildChangeLeaderRequest;

struct GuildChangeLeaderResponse;

struct GuildCandidateLeaderListRequest;

struct GuildCandidateLeaderListResponse;

struct GuildChangeCrestRequest;

struct GuildChangeCrestResponse;

struct GuildShareSettingData;

struct GuildShareSettingInfoRequest;

struct GuildShareSettingInfoResponse;

struct GuildSaveShareSettingRequest;

struct GuildSaveShareSettingResponse;

struct GuildInviteMessageRequest;

struct GuildInviteMessageResponse;

struct GuildMemberDetailInfoRequest;

struct GuildMemberDetailInfoResponse;

struct GuildRejectJoinReqNotify;

struct GuildChangeNameRequest;

struct GuildChangeNameResponse;

struct GuildChangeNameNotify;

struct GuildDungeonScoreRequest;

struct GuildDungeonScoreResponse;

struct GuildUnityRankingInfo;

struct GuildUnityRankingListRequest;

struct GuildUnityRankingListResponse;

struct SeasonGuildInfo;

struct SeasonCurrentInfoRequest;

struct SeasonCurrentInfoResponse;

struct SeasonRewardInfoRequest;

struct SeasonRewardInfoResponse;

struct SeasonDungeonInfoRequest;

struct SeasonDungeonInfoResponse;

struct Elixir;

struct ElixirListNotify;

struct ElixirEnchantRequest;

struct ElixirEnchantResponse;

struct TerraStone;

struct TerraStoneListNotify;

struct TerraStoneEnchantRequest;

struct TerraStoneEnchantResponse;

struct Research;

struct ResearchListNotify;

struct ResearchEnchant;

struct ResearchEnchantRequest;

struct ResearchEnchantResponse;

struct GuardianStar;

struct GuardianStarListNofity;

struct GuardianStarEnchantRequest;

struct GuardianStarEnchantResponse;

struct GuardianStarUpgradeRequest;

struct GuardianStarUpgradeResponse;

struct PassiveSkill;

struct PassiveSkillListNotify;

struct PassiveSkillEnchantRequest;

struct PassiveSkillEnchantResponse;

struct PotionGrowth;

struct PotionGrowthListNotify;

struct PotionGrowthUpdateNotify;

struct PotionGrowthLevelUpRequest;

struct PotionGrowthLevelUpResponse;

struct UpcCacheInfo;

struct RVRStandbyOrderRequest;

struct RVRStandbyOrderResponse;

struct RVRJoinRequest;

struct RVRJoinResponse;

struct RVRReservationRequest;

struct RVRReservationResponse;

struct RVRCancelRequest;

struct RVRCancelResponse;

struct RVRLeaveBattleServerRequest;

struct RVRLeaveBattleServerResponse;

struct RVRReservationStateNotify;

struct RVRPassCheckStandbyOrderRequest;

struct RVRRelayCheckStandbyOrderRequest;

struct RVRPassCheckStandbyOrderResponse;

struct RVRRelayCheckStandbyOrderResponse;

struct RVRPermissionToJoinPassRequest;

struct RVRPermissionToJoinRelayRequest;

struct RVRPermissionToJoinPassResponse;

struct RVRPermissionToJoinRelayResponse;

struct RVRCancelToJoinPassRequest;

struct RVRCancelToJoinRelayRequest;

struct RVRCancelToJoinPassResponse;

struct RVRCancelToJoinRelayResponse;

struct RVRAskToStandbyPassRequest;

struct RVRAskToStandbyRelayRequest;

struct RVRAskToStandbyPassResponse;

struct RVRAskToStandbyRelayResponse;

struct RVRQaCommandPassNotify;

struct RVRQaCommandRelayNotify;

struct RVRMoveClientQuestLocRequest;

struct RVRMoveClientQuestLocResponse;

struct RVRMoveBaseCampRequest;

struct RVRMoveBaseCampResponse;

struct WatchTargetInfo;

struct RVRMainHudInfoNotify;

struct RvrEventTotalRewardNotify;

struct NoticeNotify;

struct ClientDebugMessageNotify;

struct PcClientConfig;

struct PcClientConfigNotify;

struct PcClientConfigSaveRequest;

struct NoticeItemNotify;

struct NoticeUserNotify;

struct NoticeShopPurchaseNotify;

struct NoticePetNotify;

struct RVRBattleFieldEventStartNotify;

struct RVRBattleFieldEventEndNotify;

struct RVRBattleFieldCloseNotify;

struct RVRBattleFieldTimeInfoRequest;

struct RVRBattleFieldTimeInfoNotify;

struct RVRBattleFieldTimeInfoResponse;

struct RVRBattleFieldTimeExpiredNotify;

struct RVRBattleFieldFreeTimeExpiredNotify;

struct RVRBattleFieldRemainTimeNotify;

struct RVRBattleFieldPKNotify;

struct RVRBattleFieldShortTermMaxNotify;

struct RVRBattleFieldOtherPcShortTermMaxNotify;

struct ArenaRewardRequest;

struct ArenaRewardResponse;

struct ChangeReactionImmuneInfoNotify;

struct ArenaExitRequest;

struct PublicKeyNotify;

struct CryptKeyPair;

struct CryptKeyNotify;

struct BattleFieldEventInfo;

struct BattleFieldPlayerPerRealm;

struct BattleFieldChannelInfo;

struct BattleFieldGuildPlayerPerRVR;

struct BattleFieldPcInfo;

struct RVRBattleFieldRemainTimeRequest;

struct RVRBattleFieldRemainTimeResponse;

struct RVRBattleFieldInfoRequest;

struct RVRBattleFieldInfoResponse;

struct RVRBattleFieldAllInfosRequest;

struct RVRBattleFieldAllInfosResponse;

struct ArenaStateNotify;

struct ArenaMemberListRequest;

struct ArenaMemberListResponse;

struct ItemCoolData;

struct UpdateItemCoolTimeNotify;

struct AggroTickerInfoNotify;

struct ItemFusionRequest;

struct ItemFusionResponse;

struct KillAssistCountInfo;

struct KillAssistCountNotify;

struct PCPKHonorInfoRequest;

struct PCPKHonorInfoResponse;

struct BuddyInfo;

struct BuddyReceiveInvitationInfo;

struct BuddySendInvitationInfo;

struct BuddyDataAllNotify;

struct BuddySendInvitationRequest;

struct BuddySendInvitationResponse;

struct BuddyAcceptInvitationRequest;

struct BuddyAcceptInvitationResponse;

struct BuddyRejectInvitationRequest;

struct BuddyRejectInvitationResponse;

struct BuddyDeleteRequest;

struct BuddyDeleteResponse;

struct BuddyReceiveInvitationNotify;

struct BuddyAddedNotify;

struct BuddySendInvitationRejectedNotify;

struct BuddyDeletedNotify;

struct BuddySearchRequest;

struct BuddySearchResponse;

struct BuddyRecommendRequest;

struct BuddyRecommendResponse;

struct BuddyRefreshInfo;

struct BuddyRefreshRequest;

struct BuddyRefreshResponse;

struct BuddyInvitationRefreshInfo;

struct BuddyReceiveInvitationRefreshRequest;

struct BuddyReceiveInvitationRefreshResponse;

struct PcDetailInfo;

struct BuddyDetailInfoRequest;

struct TargetPcDetailInfoRequest;

struct TargetPcDetailInfoResponse;

struct DeniedInfo;

struct PlayerDeniedRequest;

struct PlayerDeniedResponse;

struct PlayerUndeniedRequest;

struct PlayerUndeniedResponse;

struct PlayerDeniedListNotify;

struct PcStatHardCapData;

struct PcStatHardCapDataNotify;

struct SummonRequest;

struct SummonResponse;

struct SummonAcceptRequest;

struct SummonAcceptResponse;

struct SummonReceivedNotify;

struct SummonAcceptedNotify;

struct SummonAbleStateNotify;

struct MoveToPcRequest;

struct MoveToPcResponse;

struct ShortTermRewardData;

struct ShortTermDataNotify;

struct ShortTermDataAllNotify;

struct ShortTermRewardGiveRequest;

struct ShortTermRewardGiveResponse;

struct ShortTermRewardDataAllRequest;

struct ShortTermRewardDataAllResponse;

struct KillerData;

struct KillerDataNotify;

struct KillerDataAllNotify;

struct FindReservedNickNameRequest;

struct FindReservedNickNameResponse;

struct SelectReservedNickNameRequest;

struct SelectReservedNickNameResponse;

struct FindReservedCharRequest;

struct FindReservedCharResponse;

struct SelectReservedCharRequest;

struct SelectReservedCharResponse;

struct SwitchSkillSlotRequest;

struct ContentConfig;

struct ContentConfigList;

struct UseItemContentsEffectRequest;

struct UseItemContentsEffectResponse;

struct TranscendStat;

struct TranscendItemRequest;

struct TranscendItemResponse;

struct TranscendChangeStatRequest;

struct TranscendChangeStatResponse;

struct BattleFieldCollection;

struct BattleFieldCollectionNotify;

struct PushCreateNotify;

struct PushUpdateNotify;

struct PushAloneJoinRequest;

struct PushAloneJoinResponse;

struct PushMatchingQuickJoinRequest;

struct PushQuickMatchingJoinResponse;

struct PushQuickMatchingLeaveRequest;

struct PushMatchingAddedNotify;

struct PushMatchingRemovedNotify;

struct JoinedClassElem;

struct PushMatchingJoinedPcClassUpdate;

struct PushMatchedSuccessNotify;

struct PushMatchingFailedNotify;

struct PushPromotionRequest;

struct PushPromotionResponse;

struct GroupMatchingMakeRequest;

struct GroupMatchingInvitee;

struct GroupMatchingMakeResponse;

struct GroupMatchingLeaveRequest;

struct GroupMatchingGuildMemberListRequest;

struct GroupMatchingGuildMemberListResponse;

struct GroupMatchingBuddyListRequest;

struct GroupMatchingBuddyListResponse;

struct GroupMatchingInviteRequest;

struct GroupMatchingInviteResponse;

struct GroupMatchingMemberLeaveNotify;

struct GroupMatchingInvitationAddNotify;

struct GroupMatchingInvitationRemoveNotify;

struct GroupMatchingInvitationAcceptedNotify;

struct GroupMatchingInvitationRejectedNotify;

struct GroupMatchingInviteAcceptRequest;

struct GroupMatchingInviteAcceptResponse;

struct GroupMatchingInviteRejectRequest;

struct GroupMatchingInviteRejectResponse;

struct GroupMatchingStartRequest;

struct GroupMatchingStartResponse;

struct GroupMatchingConvertToQuickRequest;

struct GroupMatchingConvertToQuickResponse;

struct GroupMatchingRematchingRequest;

struct GroupMatchingRematchingResponse;

struct GuildDungeonInfoRequest;

struct GuildDungeonInfoResponse;

struct GuildDungeonEnterFailed;

struct GuildDungeonClearNotify;

struct GuildDungeonRewardRequest;

struct GuildDungeonRewardResponse;

struct EquipCostumeRequest;

struct EquipCostumeResponse;

struct UnequipCostumeRequest;

struct UnequipCostumeResponse;

struct CostumePresetChangeRequest;

struct CostumePresetChangeResponse;

struct CostumePresetCostumeSlotUpdateNotify;

struct EnchantCostumeRequest;

struct EnchantCostumeResponse;

struct UpgradeCostumeRequest;

struct UpgradeCostumeResponse;

struct ShowCostumeRequest;

struct ShowCostumeResponse;

struct HideCostumeRequest;

struct HideCostumeResponse;

struct LiveEventTimestamp;

struct LiveEventPeriod;

struct LiveEventHeader;

struct LiveEventBuyLimit;

struct LiveEventTradeResultItem;

struct LiveEventTradeCostItem;

struct LiveEventTradeData;

struct LiveEventDiaMissionRewardData;

struct LiveEventLevelRange;

struct LiveEventDiaMissionData;

struct LiveEventDiaBuyDataSheet;

struct LiveEventDiaSpentDataSheet;

struct LiveEventTradeDataSheet;

struct LiveEventLimitShopResultItem;

struct LiveEventLimitShopCost;

struct LiveEventLimitShopData;

struct LiveEventLimitShopDataSheet;

struct LiveEventItemDropRewardData;

struct LiveEventItemDropData;

struct LiveEventItemDropDataSheet;

struct LiveEventStopNotify;

struct LiveEventAttentionReward;

struct LiveEventAttentionEndReward;

struct LiveEventAttentionActiveReward;

struct LiveEventAttentionTarget;

struct LiveEventAttentionDataSheet;

struct LiveEventTradeDataNotify;

struct LiveEventBuffData;

struct LiveEventBuffDataSheet;

struct LiveEventBuffDataNotify;

struct LiveEventAttentionDataNotify;

struct LiveEventNewbieAttentionDataNotify;

struct LiveEventReturnAttentionDataNotify;

struct LiveEventDiaBuyDataNotify;

struct LiveEventDiaSpentDataNotify;

struct LiveEventLimitSellShopDataNotify;

struct LiveEventItemDropDataNotify;

struct LiveEventTradeProductInstance;

struct LiveEventTradeInstance;

struct LiveEventBuffInstance;

struct LiveEventTradeInstaceNotify;

struct LiveEventTradeInstancePurchaseExpireNotify;

struct LiveEventTradePurchaseRequest;

struct LiveEventTradePurchaseResponse;

struct LiveEventDiaMission;

struct LiveEventDiaBuyInstance;

struct LiveEventDiaBuyNotify;

struct LiveEventDiaBuyMissionUpdateNotify;

struct LiveEventDiaBuyAmountUpdateNotify;

struct LiveEventDiaBuyRewardRequest;

struct LiveEventDiaBuyRewardResponse;

struct LiveEventDiaSpentInstance;

struct LiveEventDiaSpentNotify;

struct LiveEventDiaSpentMissionNotify;

struct LiveEventDiaSpentAmountUpdateNotify;

struct LiveEventDiaSpentRewardRequest;

struct LiveEventDiaSpentRewardResponse;

struct LiveEventLimitSellShopProductInstance;

struct LiveEventLimitSellShopInstance;

struct LiveEventBuffInfoInstance;

struct LiveEventLimitSellShopInstanceNotify;

struct LiveEventLimitSellShopInstanceExpireNotify;

struct LiveEventLimitSellShopPurchaseRequest;

struct LiveEventLimitSellShopPurchaseResponse;

struct LiveEventBuffInfoInstanceNotify;

struct LiveEventAttentionReceive;

struct LiveEventAttentionInstance;

struct LiveEventAttentionNotify;

struct LiveEventAttentionReceiveNotify;

struct LiveEventAttentionEndReceiveNotify;

struct LiveEventLevelBuffDataNotify;

struct LiveEventNewbieBuffDataNotify;

struct LiveEventAttentionRewardReceiveRequest;

struct LiveEventAttentionRewardReceiveResponse;

struct LiveEventAttentionReturnRewardReceiveRequest;

struct LiveEventAttentionReturnRewardReceiveResponse;

struct LiveEventAttentionNewbieRewardReceiveRequest;

struct LiveEventAttentionNewbieRewardReceiveResponse;

struct LiveEventAttentionEndRewardReceiveRequest;

struct LiveEventAttentionEndRewardReceiveResponse;

struct LiveEventAttentionEndReturnRewardReceiveRequest;

struct LiveEventAttentionEndReturnRewardReceiveResponse;

struct LiveEventAttentionEndNewbieRewardReceiveRequest;

struct LiveEventAttentionEndNewbieRewardReceiveResponse;

struct LiveEventLevelUpReward;

struct LiveEventLevelUpData;

struct LiveEventLevelUpDataSheet;

struct LiveEventLevelUpDataNotify;

struct LiveEventLevelUpReceive;

struct LiveEventLevelUpInstance;

struct LiveEventLevelUpNotify;

struct LiveEventLevelUpReceiveNotify;

struct LiveEventLevelUpRewardReceiveRequest;

struct LiveEventLevelUpRewardReceiveResponse;

struct StorageSlotExpansionRequest;

struct StorageSlotExpansionResponse;

struct BrawlTimeInfoRequest;

struct BrawlTimeInfoNotify;

struct BrawlTimeInfoResponse;

struct BrawlTimeExpiredNotify;

struct BrawlFreeTimeExpiredNotify;

struct BrawlRemainTimeNotify;

struct BrawlShortTermInfo;

struct BrawlShortTermDataNotify;

struct BrawlShortTermRewardRequest;

struct BrawlShortTermRewardResponse;

struct BrawlShortTermDataRequest;

struct BrawlShortTermDataResponse;

struct BrawlPKNotify;

struct BrawlShortTermMaxNotify;

struct BrawlOtherPcShortTermMaxNotify;

struct BrawlPointNotify;

struct BrawlEnhanceInfo;

struct BrawlEnhanceDataNotify;

struct BrawlEnhanceLevelUpRequest;

struct BrawlEnhanceLevelUpResponse;

struct AddItemFailedNotEnoughStorageSpaceNotify;

struct ScrollQuestInProgressInfo;

struct ScrollQuestDailyInfoNotify;

struct ScrollQuestProgressInfoNotify;

struct ScrollQuestStartProgressRequest;

struct ScrollQuestStartProgressResponse;

struct ScrollQuestGiveUpRequest;

struct ScrollQuestGiveUpResponse;

struct ScrollQuestRewardRequest;

struct ScrollQuestRewardResponse;

struct BrawlLastLeavedTimeRequest;

struct BrawlLastLeavedTimeResponse;

struct BrawlLastLeavedTimeNotify;

struct PetStat;

struct Pet;

struct PetCreatedNotify;

struct PetCreatedWithEffectNotify;

struct PetDeletedNotify;

struct PetDataNotify;

struct PetFeedRequest;

struct PetFeedResponse;

struct PetDigestionCompleteNotify;

struct PetSummonRequest;

struct PetSummonResponse;

struct PetSummonCancelRequest;

struct PetSummonCancelResponse;

struct PetSupportRequest;

struct PetSupportResponse;

struct PetSupportCancelRequest;

struct PetSupportCancelResponse;

struct PetDigestionTime;

struct PetRemainDigestionTimeRequest;

struct PetRemainDigestionTimeResponse;

struct PetFusionRequest;

struct PetFusionResponse;

struct PetLevelExpUpNotify;

struct PetToggleSafeGuardRequest;

struct PetToggleSafeGuardResponse;

struct AltarActiveSkill;

struct PetAltar;

struct PetAltarDataNotify;

struct PetAltarLevelExpNotify;

struct PetAltarPointNotify;

struct AltarDonateItem;

struct PetAltarDonateRequest;

struct PetAltarDonateResponse;

struct PetAltarActiveSkillLevelUpRequest;

struct PetAltarActiveSKillLevelUpResponse;

struct PetHatchery;

struct PetHatcheryDataNotify;

struct PetHatcherySpawnRequest;

struct PetHatcherySpawnResponse;

struct PetHatcheryHatchRequest;

struct PetHatcheryHatchResponse;

struct InheritCostumeResultInfo;

struct InheritCostumeRequest;

struct InheritCostumeResponse;

struct CrystalItemChangeCountInfo;

struct ChangeCrystalItemRequest;

struct ChangeCrystalItemResponse;

struct CrystalItemChangeCountNotify;

struct NoticeEliteMonsterKillNotify;

struct ConflictFieldMoveHomeServerRequest;

struct ConflictFieldMoveHomeServerResponse;

struct KingsRoadMainStreamQuestRequest;

struct KingsRoadMainStreamQuestResponse;

struct RVRPointPerRealm;

struct RVRMainHudPointInfoNotify;

struct RVROccupyingGaugePerRealm;

struct RVROccupyingGaugeInfo;

struct RVROccupyingGaugeApproximateInfoNotify;

struct RVROccupyingGaugeInfoNotify;

///-----------------------------------------------------------------------------
/// COMMON
///-----------------------------------------------------------------------------
/// 패킷 버전(패킷이 수정되면 올리자.)
enum PacketVersion {
  /// 패킷 버전 구조 10000자리 이상 major버전 이하 패치 버전
  /// 예) 10001 major: 1, patch: 1 버전
  PacketVersion_NOW = 10004,
  PacketVersion_MIN = PacketVersion_NOW,
  PacketVersion_MAX = PacketVersion_NOW
};

inline const PacketVersion (&EnumValuesPacketVersion())[1] {
  static const PacketVersion values[] = {
    PacketVersion_NOW
  };
  return values;
}

inline const char * const *EnumNamesPacketVersion() {
  static const char * const names[] = {
    "NOW",
    nullptr
  };
  return names;
}

inline const char *EnumNamePacketVersion(PacketVersion e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(PacketVersion_NOW);
  return EnumNamesPacketVersion()[index];
}

/// 사용할 수 있는 총 범위(넘어서면 기획 스트링 테이블 ID랑 겹친다.)
/// 1 ~ 9999999(7자리)
/// 시스템:	1		~ 99999
/// 성장:	100000	~ 199999
/// 전투:	200000	~ 299999
/// 월드:	300000	~ 399999
///- ErrorCode ----------
enum ErrorCode {
  ErrorCode_NONE = 0  ///-----------------------------------------------------------------------------
  /// 시스템(1 - 99999)
  ///-----------------------------------------------------------------------------
,
  ErrorCode_OK = 1,
  ErrorCode_FAILED = 2  /// DB 처리 실패
,
  ErrorCode_DB_FAILED = 3  /// 존재하지 않는 account id
,
  ErrorCode_AUTH_ACCOUNT_NAME_FAILED = 50  /// 패스워드 오류
,
  ErrorCode_AUTH_PASSWORD_FAILED = 51  /// 해당 콜로니에 접속할 수 없습니다.
,
  ErrorCode_AUTH_NOT_SERVICE_COLONY = 52  /// 계정 블럭
,
  ErrorCode_AUTH_ACCOUNT_BLOCKED = 53  /// 국가 차단
,
  ErrorCode_AUTH_COUNTRY_BANNED = 54  /// 서버 장애로 접속불가
,
  ErrorCode_AUTH_CRASH_COLONY = 55  /// 캐릭터 생성 이름 중복
,
  ErrorCode_DUPLICATE_PC_NAME = 100  /// 사용할 수 없는 이름입니다.
,
  ErrorCode_PROHIBIT_WORDS_PC_NAME = 101,
  ErrorCode_CANNOT_JOIN_SERVICE = 120,
  ErrorCode_RESTRICT_COLONY = 121  /// 중복 접속
,
  ErrorCode_DUPLICATE_LOGIN = 150,
  ErrorCode_LIMIT_REALM = 151,
  ErrorCode_ADMIN_TOOL_KICK = 152  /// 알 수 없는 시스템 오류
,
  ErrorCode_UNKNOWN_SYSTEM_ERROR = 153  /// 이미 지급된 아이템입니다.
,
  ErrorCode_HIVE_ITEM_ALREADY_GIVEN = 160  /// 이미 연동된 계정입니다.
,
  ErrorCode_ALREADY_LINKED = 170  /// 대기열 찾기에 실패했습니다.
,
  ErrorCode_NOT_FOUND_WAITING_LIST = 180  /// 대기열 취소에 실패했습니다.
,
  ErrorCode_FAILED_CANCEL_WAITING = 181  /// 대기열 등록에 실패했습니다.
,
  ErrorCode_FAILED_ADD_WAITING = 182  /// 비정상적인 닉네임 사전 예약 코드입니다.
,
  ErrorCode_INVALID_RESERVED_NICK_NAME_CODE = 183  /// 이미 사용된 닉네임 사전 예약 코드입니다.
,
  ErrorCode_ALREADY_USED_RESERVED_NICK_NAME_CODE = 184  /// 등록되지 않은 닉네임 사전 예약 코드입니다.
,
  ErrorCode_UNREGISTERED_RESERVED_NICK_NAME_CODE = 185  /// 선점한 캐릭터 렐름과 다른 렐름을 이미 선택하셨습니다.
,
  ErrorCode_ALREADY_SELECTED_OTHER_REALM_RESERVED_NICK_NAME_CODE = 186,
  ErrorCode_ALREADY_USED_RESERVED_NICK_NAME_ACCOUNT = 187,
  ErrorCode_ALREADY_CHAR_JOIN_GUILD = 188  ///-----------------------------------------------------------------------------
  /// 공통 에러코드
  ///-----------------------------------------------------------------------------
,
  ErrorCode_INVALID_PC_CONTROLLER = 5000,
  ErrorCode_INVALID_TEMPLATE_DATA = 5001  ///-----------------------------------------------------------------------------
  /// 성장(100000 ~ 199999)
  ///-----------------------------------------------------------------------------
  /// INVENTORY
,
  ErrorCode_FAILED_DELETE_ITEM = 50000  /// 아이템이 존재하지 않습니다.
,
  ErrorCode_NOT_EXIST_ITEM = 50001  /// 사용불가능한 클래스
,
  ErrorCode_INVALID_USE_CLASS = 50002  /// 장착 불가능한 아이템
,
  ErrorCode_NOT_EQUIPABLE_ITEM = 50003  /// 중복착용 불가능 그룹 검출
,
  ErrorCode_DUPLICATE_EQUIP_EXCLUSIVE_GROUP_ID = 50004  /// 강화 불가능한 아이템
,
  ErrorCode_NOT_ENCHANTABLE_ITEM = 50005  /// 골드 부족
,
  ErrorCode_NOT_ENOUGH_GOLD = 50006  /// 장착중인 아이템
,
  ErrorCode_ALREADY_EQUIPED_ITEM = 50007  /// 분해 불가능한 아이템
,
  ErrorCode_NOT_DISENCHANT_ITEM = 50008  /// 스토리지 공간 부족
,
  ErrorCode_NOT_ENOUGH_STORAGE_SPACE = 50009  /// 재료 아이템 부족
,
  ErrorCode_NOT_ENOUGH_MATERIAL_ITEM = 50010  /// 프리셋에 설정된 아이템
,
  ErrorCode_ALREADY_PRESET_ITEM = 50011  /// 아이템 수량 부족
,
  ErrorCode_NOT_ENOUGH_ITEM = 50012  /// 승급 불가능한 아이템
,
  ErrorCode_NOT_UPGRADABLE_ITEM = 50013  /// 다이아가 부족합니다.
,
  ErrorCode_NOT_ENOUGH_DIA = 50014  /// 레벨 부족
,
  ErrorCode_INVALID_USE_LEVEL = 50015  /// 존재하지 않는 메일입니다.
,
  ErrorCode_NOT_EXIST_MAIL = 50016,
  ErrorCode_EXPIRED_MAIL = 50017  /// 존재하지 않는 상품입니다.
,
  ErrorCode_NOT_EXIST_SHOP_PRODUCT = 50019  /// 구매가능 수량을 초과하였습니다.
,
  ErrorCode_LIMIT_PURCHASABLE_COUNT = 50020  /// 아직 충분한 시간이 지나지 않았습니다.
,
  ErrorCode_NOT_ENOUGH_COOLTIME = 50021  /// 구매 가능 레벨에 도달하지 못했습니다
,
  ErrorCode_PURCHASE_UNDER_RANGE_LEVEL = 50022  /// 구매 가능 레벨을 초과했습니다
,
  ErrorCode_PURCHASE_OVER_RANGE_LEVEL = 50023  /// 기부 할 수 없는 아이템 타입입니다.
,
  ErrorCode_NOT_DONATE_ITEM = 50024  /// 최대 마스터리 레벨을 초과하였습니다.
,
  ErrorCode_OVERRANGE_MASTERY_LEVEL = 50025  /// 아이템 등급이 낮아 기부를 할 수 없습니다.
,
  ErrorCode_NOT_ENOUGH_ITEM_GRADE = 50026  /// 골드를 더 이상 획득할 수 없습니다.
,
  ErrorCode_GOLD_IS_FULL = 50027  /// 요청한 기부 타입과 맞지 않은 아이템이 있습니다.
,
  ErrorCode_NOT_EQUAL_DONATION_ITEM_TYPE = 50028  /// 해당 아이템의 구매 이력이 있습니다.
,
  ErrorCode_EXIST_RECORD_PURCHASE_ITEM = 50029  /// 갱신 시간이 초과되었습니다.
,
  ErrorCode_OVERRANGE_SHOP_COOLTIME = 50030,
  ErrorCode_NOT_ENOUGH_TICKET = 50031,
  ErrorCode_INVALID_TICKET_TYPE = 50032,
  ErrorCode_NOT_EXIST_RECEIVEABLE_MAIL = 50033,
  ErrorCode_FAILED_ALL_RECEIVE_MAIL_NOT_ENOUGH_STORAGE = 50034,
  ErrorCode_EMPTY_MAIL_BOX = 50035,
  ErrorCode_EMPTY_REWARD_INFO = 50036,
  ErrorCode_NOT_FOUND_MY_RANK = 50037,
  ErrorCode_CAN_NOT_USE_ITEM_STATE = 50038,
  ErrorCode_FAILED_ALL_USE_ITEM_NOT_ENOUGH_STORAGE = 50039,
  ErrorCode_NOT_AVAILABLE_USED_ITEM_TYPE = 50040,
  ErrorCode_OVER_COUNT_ALL_USE_ITEM = 50041,
  ErrorCode_CANT_USE_ITEM_WITH_COOLTIME = 50042,
  ErrorCode_UNABLE_ACQUIRE_EXP = 50043,
  ErrorCode_NOT_MATCH_TRADE_TAX_RATE = 50100,
  ErrorCode_LOWER_THAN_RARE_RATINGS_ARE_NOT_POSSIBLE = 50151,
  ErrorCode_OVER_COUNT_SLOT_INDEX = 50152,
  ErrorCode_NOT_EXIST_CRYSTAL_IN_SLOT = 50153,
  ErrorCode_NOT_EXIST_ITEM_IN_INVENTORY = 50154,
  ErrorCode_MISS_MATCH_ITEM_CATEGORY = 50155,
  ErrorCode_ALREADY_EQUIPED_IN_SLOT = 50156,
  ErrorCode_MISS_MATCH_CRYSTAL_TYPE = 50157,
  ErrorCode_NOT_REACHED_MAX_LEVEL = 50158,
  ErrorCode_MAX_GRADE = 50159,
  ErrorCode_CAN_NOT_UPGRADE = 50160,
  ErrorCode_CAN_NOT_LEVEL_UP = 50161,
  ErrorCode_HIGHEST_LEVEL_OF_THE_GRADE = 50162  /// 존재하지 않는 캐릭터입니다.
,
  ErrorCode_NOT_EXIST_CHARACTER = 50200  /// 다음 입력까지 잠시만 기다려 주십시오.
,
  ErrorCode_NOT_ENOUGH_CHAT_TERM = 50201  /// 동일한 캐릭터와 1:1 대화를 할 수 없습니다.
,
  ErrorCode_CAN_NOT_SEND_MESSAGE_FOR_SAME_CHARACTER = 50202  /// 전쟁필드 밖에선 전쟁채팅을 할 수 없습니다.
,
  ErrorCode_CAN_NOT_SEND_MESSAGE_AT_OUTSIDE_WARFIELD = 50203  /// 채팅메세지 최대길이를 넘었습니다 
,
  ErrorCode_OVERRANGE_CHAT_MESSAGE_LENGTH = 50204  /// 정의되지않은 채팅 타입입니다
,
  ErrorCode_INVALID_CHATTING_TYPE = 50205  /// 채팅을 할 수 없는 컨텐츠입니다.
,
  ErrorCode_UNABLE_CHATTING_CONTENTS_TYPE = 50206  /// 영향력 일일 제한으로 더이상 획득할 수 없습니다.
,
  ErrorCode_INFLUENCE_DAILY_COUNT_OVER = 50300  /// 추종자를 소유하고 있지 않습니다.
,
  ErrorCode_NOT_EXIST_FOLLOWER = 100000  /// 임무를 수행할 수 있는 추종자의 수를 초과 하였습니다.
,
  ErrorCode_FOLLOWER_JOIN_MISSION_OVER_COUNT = 100001  /// 추종자가 집결지 위치에 다른 추종자가 존재합니다.
,
  ErrorCode_FOLLOWER_ALREADY_TO_BE_PLACED = 100002  /// 추종자가 이미 임무를 수행하지 않고 있습니다.
,
  ErrorCode_FOLLOWER_ALREADY_HAS_NOT_MISSION = 100003  /// 프리즘이 부족합니다.
,
  ErrorCode_NOT_ENOUGH_PRISM = 100004  /// 프리즘을 더 이상 획득할 수 없습니다.
,
  ErrorCode_PRISM_IS_FULL = 100005,
  ErrorCode_BUY_TRADE_ITEM_NOT_EXIST = 100006,
  ErrorCode_REG_TRADE_ITEM_IS_FULL = 100007,
  ErrorCode_BUY_TRADE_ITEM_FAILED = 100008,
  ErrorCode_SHOP_PROUDCT_IS_DISABLED = 100009,
  ErrorCode_SHOP_PRODUCT_ALREADY_PURCHASED = 100010,
  ErrorCode_SHOP_PRODUCT_PURCHASE_LIMIT_COUNT_OVER = 100011  /// 행운 포인트가 부족합니다.
,
  ErrorCode_NOT_ENOUGH_FORTUNE_POINT = 100012  /// 행운포인트를 더 이상 획득할 수 없습니다.
,
  ErrorCode_FORTUNE_POINT_IS_FULL = 100013  /// 거래소 등록 취소 아이템 없음
,
  ErrorCode_CANCEL_TRADE_ITEM_NOT_EXIST = 100014  /// 길드주화가 부족합니다
,
  ErrorCode_NOT_ENOUGH_GUILD_COIN = 100015  /// 군주포인트가 부족합니다
,
  ErrorCode_NOT_ENOUGH_MONARCH_POINT = 100016  /// 구매 실패 - 캐릭터 상태
,
  ErrorCode_SHOP_PRODUCT_PURCAHSE_FAILED_CHAR_STATE = 100017  /// 구매 실패 - 메인스트림 단계
,
  ErrorCode_SHOP_PRODUCT_PURCAHSE_FAILED_MAINSTREAM = 100018  /// 구매 실패 - 캐릭터 레벨
,
  ErrorCode_SHOP_PRODUCT_PURCAHSE_FAILED_CHAR_LEVEL = 100019  /// 구매 실패 - 길드 가입하지 않음
,
  ErrorCode_SHOP_PRODUCT_PURCAHSE_FAILED_NO_GUILD = 100020  /// 구매 실패 - 길드 레벨 부족
,
  ErrorCode_SHOP_PRODUCT_PURCAHSE_FAILED_GUILD_LEVEL = 100021  /// 구매 실패 - 길드 멤버 등급 부족
,
  ErrorCode_SHOP_PRODUCT_PURCAHSE_FAILED_GUILD_MEMBER_RANK = 100022  /// 길드 코인을 더 이상 획득할 수 없습니다.
,
  ErrorCode_GUILD_COIN_IS_FULL = 100023  /// 군주 포인트를 더 이상 획득할 수 없습니다.
,
  ErrorCode_MONARCH_POINT_IS_FULL = 100024  /// __UNUSED = 100025,
  /// 가신의 영혼석 갯수가 부족합니다.
,
  ErrorCode_NOT_ENOUGH_FOLLOWER_SOUL_STONE = 100026  /// 가신의 레벨이 만렙 입니다.
,
  ErrorCode_FOLLOWER_ALREADY_FULL_LEVEL = 100027  /// 보너스 포인트가 부족합니다.
,
  ErrorCode_SHOP_PRODUCT_NOT_ENOUGH_BONUS_POINT = 100028  /// 다이아를 더 이상 획득할 수 없습니다.
,
  ErrorCode_DIA_IS_FULL = 100029  /// 라이브 이벤트 기간이 아닙니다.
,
  ErrorCode_NOT_LIVE_EVET_PERIOD = 100030  /// 라이브 이벤트 정보를 업데이트 중입니다.
,
  ErrorCode_UPDATING_LIVE_EVENT_DATA = 100031  /// 존재하지 않는 이벤트 상점 상품 입니다.
,
  ErrorCode_NOT_EXIST_LIVE_EVENT_PRODUCT = 100032  /// 존재하지 않는 이벤트 미션입니다.
,
  ErrorCode_NOT_EXIST_LIVE_EVENT_MISSION = 100033,
  ErrorCode_EXCEEDED_LIVE_EVENT_PURCHASE_COUNT = 100034,
  ErrorCode_NOT_EXIST_LIVE_EVENT_ATTETION = 100035,
  ErrorCode_FAILED_TO_RECEIVE_ATTENTION_REWARD = 100036,
  ErrorCode_CANNOT_RECEIVE_ATTENTION_REWARD = 100037,
  ErrorCode_NOT_EXIST_LIVE_EVENT_ATTENTION_REWARD = 100038,
  ErrorCode_ALREADY_RECEIVE_ATTENTION_REWARD = 100039,
  ErrorCode_NOT_ENOUGH_GROWTH_INHERIT_MATERIAL_ITEM = 100040,
  ErrorCode_CAN_NOT_INHERIT_DIFFERENT_COSTUME_TYPE = 100041,
  ErrorCode_NOT_ENOUGH_JUMPING_COUNT = 100042  /// PvP코인이 부족합니다
,
  ErrorCode_NOT_ENOUGH_PVP_COIN = 100043  /// PvP코인을 더 이상 획득할 수 없습니다.
,
  ErrorCode_PVP_COIN_IS_FULL = 100044  ///-----------------------------------------------------------------------------
  /// 전투(200000 ~ 299999)
  ///-----------------------------------------------------------------------------
,
  ErrorCode_NOT_FOUND_EVENT_SET = 200001,
  ErrorCode_INVALID_CHANNEL_STATE = 200002,
  ErrorCode_INVALID_WEEK = 200004  /// __UNUSED = 200005,
,
  ErrorCode_FAILED_ADDITIONAL_ENTER = 200006,
  ErrorCode_INVALID_PAID_TYPE = 200008,
  ErrorCode_FAILED_DAILY_DUNGEON_INVALID_CHAPTER = 200009,
  ErrorCode_FAILED_SOLO_DUNGEON_LARGE_CONDITION = 200010,
  ErrorCode_FAILED_SOLO_DUNGEON_MIDDLE_CONDITION = 200011,
  ErrorCode_FAILED_SOLO_DUNGEON_STAGE_CONDITION = 200012,
  ErrorCode_FAILED_SOLO_DUNGEON_TODAY_CLEAR_COUNT_OVER = 200013,
  ErrorCode_FAILED_SOLO_DUNGEON_NOT_ENOUGH_TICKET = 200014,
  ErrorCode_INVALID_SOLO_DUNGEON_STAGE_ID = 200016,
  ErrorCode_ALREADY_DUNGEON_ENTER_PROCESSING = 200018,
  ErrorCode_ARENA_PLEASE_APPLY_AGAIN_AFTER_A_WHILE = 200019,
  ErrorCode_ARENA_NOT_ENOUGH_ENTER_COUNT = 200021,
  ErrorCode_ARENA_REWARD_INFO_ERROR = 200022  ///-----------------------------------------------------------------------------
  /// 월드(300000 ~ 399999)
  ///-----------------------------------------------------------------------------
,
  ErrorCode_WORLD_INVALID_EVENT_SET_ID = 300001,
  ErrorCode_WORLD_INVALID_EVENT_ID = 300002,
  ErrorCode_WORLD_INVALID_CHANNEL = 300004,
  ErrorCode_WORLD_NO_FIELD_CONTENTS = 300006  /// 알 수 없는 채널이동 에러
,
  ErrorCode_CHANNEL_UNKNOWN = 300010  /// 채널이 존재하지 않습니다
,
  ErrorCode_CHANNEL_NOT_EXIST = 300011  /// 채널이동을 할 수 없는 지역입니다.
,
  ErrorCode_CHANNEL_CAN_NOT_MOVE_SMAP = 300012  /// 현재는 채널 이동을 할 수 없습니다. (이동중이거나 스폰중이거나)
,
  ErrorCode_CHANNEL_CAN_NOT_MOVE_NOW = 300013  /// 채널 인원 제한으로 입장 할 수 없습니다.
,
  ErrorCode_CHANNEL_USER_COUNT_LIMIT = 300014  /// 채널이동 시간 제한으로 이동할 수 없음
,
  ErrorCode_CHANNEL_MOVE_TIME_LIMIT = 300015,
  ErrorCode_EVENT_NO_EVENT_INSTANCE = 300050,
  ErrorCode_EVENT_INVALID_DEST_POS = 300053,
  ErrorCode_EVENT_RETURN_NO_SAVE_POS = 300054,
  ErrorCode_EVENT_RETURN_DISCORD_ID = 300055,
  ErrorCode_EVENT_RETURN_DISCORD_SMAP_ID = 300056,
  ErrorCode_EVENT_RETURN_NO_FIELD_CONTENT = 300057,
  ErrorCode_QUEST_INVALID_ID_FAIL = 300101,
  ErrorCode_QUEST_LACK_COUNT_FAIL = 300102,
  ErrorCode_QUEST_ACCEPTED_REWARD_FAIL = 300103,
  ErrorCode_QUEST_PROCESSING_REWARD_FAIL = 300104,
  ErrorCode_QUEST_DB_UPDATE_FAIL = 300105  /// 퀘스트의 보너스 보상 300200 번대
,
  ErrorCode_ALREADY_HAD_A_QUEST_BONUS_REWARD = 300201,
  ErrorCode_INVALID_QUEST_BONUS_ID = 300202,
  ErrorCode_FAILED_CONDITION_QUEST_BONUS = 300203,
  ErrorCode_CHAPTER_FAIL_INVALID_CHAPTER_INDEX = 300301,
  ErrorCode_CHAPTER_FAIL_INVALID_ASSIGN_SMAP_ID = 300302,
  ErrorCode_CHAPTER_FAIL_INVALID_ASSIGN_CINEMA_ID = 300303,
  ErrorCode_CHAPTER_FAIL_CLEAR_PREVIOUS_CHAPTER = 300304,
  ErrorCode_CHAPTER_FAIL_LACK_FIGHT_POWER = 300305,
  ErrorCode_CHAPTER_FAIL_LACK_SMAP_RATE = 300306,
  ErrorCode_CHAPTER_FAIL_NO_SEE_CINEMA = 300307,
  ErrorCode_CHAPTER_FAIL_LACK_LEVEL = 300308,
  ErrorCode_CHAPTER_FAIL_LACK_MMAP_RATE = 300309,
  ErrorCode_CHAPTER_FAIL_UPDATE_DB = 300310,
  ErrorCode_CHAPTER_FAIL_INVALID_TEMPLTE = 300311,
  ErrorCode_CHAPTER_FAIL_INVALID_PER_DATA = 300312,
  ErrorCode_CHAPTER_LESS_LEVEL = 300313,
  ErrorCode_CHAPTER_LESS_ACHIEVEMENT_RATE = 300314,
  ErrorCode_CHAPTER_NOT_CLEARED_QUEST = 300315,
  ErrorCode_CHAPTER_NO_NEXT_SMAP = 300316,
  ErrorCode_CHAPTER_NOT_FOUND_SMAP_CLEAR_TEMPLATE = 300317,
  ErrorCode_CHAPTER_LOCKED_SMAP = 300318,
  ErrorCode_CHAPTER_NOT_CLEARED_MAIN_STREAM = 300319,
  ErrorCode_RECOMMEND_NO_LIST = 300401,
  ErrorCode_RECOMMEND_EXPIRED_TIME = 300402,
  ErrorCode_RECOMMEND_VOTED_INVALID_PC_DB_ID = 300403,
  ErrorCode_RECOMMEND_ALREADY_VOTED = 300404,
  ErrorCode_TRADE_FAIL_ALREADY_TRYING_SEARCH = 300501,
  ErrorCode_TRADE_FAIL_SET_ITEM_INVALID_CREATE_TYPE = 300502,
  ErrorCode_DUNGEON_NOT_ENOUGH_CLEAR_COUNT = 300550,
  ErrorCode_PUSH_JOIN_FAILED_NOT_ENOUGH_MATCHING_COUNT = 300600,
  ErrorCode_RAID_JOIN_FAILED_NOT_ENOUGH_COUNT = 300700,
  ErrorCode_RAID_JOIN_FAILED_NOT_ENOUGH_COST_ITEM = 300701,
  ErrorCode_RAID_JOIN_FAILED_INVALID_CHAPTER = 300702  /// 일일과제
  /// 활약도 보상 아이디가 잘못됐다
,
  ErrorCode_DAILY_HW_INVALID_POINT_REWARD_ID = 300800,
  ErrorCode_DAILY_HW_NOT_ENOUGH_POINT_REWARD = 300801,
  ErrorCode_DAILY_HW_COMPLETED_REWARD = 300802  ///  보너스-일일충전
,
  ErrorCode_BONUS_DAILY_RECHARGE_FAILED_ALREADY_REWARDED = 300810  /// 무한의 탑
,
  ErrorCode_INFINITE_TOWER_INVALID_STAGE = 300820,
  ErrorCode_INFINITE_TOWER_INVALID_STAGE_ALREADY_CLEARED = 300821,
  ErrorCode_INFINITE_TOWER_ALREADY_REWARDED = 300822,
  ErrorCode_INFINITE_TOWER_INVALID_PAID_TYPE = 300823,
  ErrorCode_INFINITE_TOWER_INVALID_SWEEP_STAGE = 300824  /// 출석체크	
,
  ErrorCode_ATTENDANCE_ALREADY_STAMPED = 300830,
  ErrorCode_ATTENDANCE_INVALID_BOARD = 300831  /// 접속보상
,
  ErrorCode_ACCESS_TIME_INVALID_TIME = 300833,
  ErrorCode_ACCESS_TIME_ALREADY_TODAY_ALL_REWARDED = 300834,
  ErrorCode_ACCESS_TIME_ALREADY_REWARDED = 300835,
  ErrorCode_ACCESS_TIME_NOT_ENOUGH_TIME = 300836  /// 휴식보상
,
  ErrorCode_REST_TIME_NOT_ENOUGH_REST_POINT = 300838  ///
  /// SMAP 조인 관련 에러
  ///
  ///
,
  ErrorCode_JOIN_FAIL_UNKNOWN = 300900  /// 채널 이동중이다
,
  ErrorCode_JOIN_FAIL_CHANNELING = 300901  /// 스폰이 아직 안되서 채널이동이 불가
,
  ErrorCode_JOIN_FAIL_NO_SPAWNED = 300902  /// 데이터가 잘못됨
,
  ErrorCode_JOIN_FAIL_NO_DATA = 300903  /// SMAP ID가 잘못됨. 데이터 문제
,
  ErrorCode_JOIN_FAIL_INVALID_SMAPID = 300904  /// 동일한 SMAP으로 이동하려고 했다
,
  ErrorCode_JOIN_FAIL_SAME_SMAPID = 300905  ///
  /// #골드던전
  ///	
  /// 골드던전 템플릿 아이디가 잘못됨
,
  ErrorCode_GOLD_DUNGEON_INVALID_ID = 301001  /// 입장 횟수 제한으로 입장 불가
,
  ErrorCode_GOLD_DUNGEON_LIMIT_ENTER_COUNT = 301002  /// 입장아이템 부족
,
  ErrorCode_GOLD_DUNGEON_NOT_ENOUGH_ITEM = 301003  /// 입장 조건을 만족하지 못함
,
  ErrorCode_GOLD_DUNGEON_LIMIT_ENTER = 301004  ///
  /// 인터랙션
  ///
  /// 알수 없는 에러
,
  ErrorCode_INTERACT_UNKNOWN = 301010  /// 취소함
,
  ErrorCode_INTERACT_CANCEL = 301011  /// 알 수 없는 오브젝트
,
  ErrorCode_INTERACT_INVALID_OBJECT = 301012  /// 인터렉션 할 수 없음
,
  ErrorCode_INTERACT_CANNOT_INTERACTION = 301013  /// 거리가 멀어 인터랙션 할 수 없음
,
  ErrorCode_INTERACT_TOO_FAR_DISTANCE = 301014  /// 공동 채집인원 초과
,
  ErrorCode_INTERACT_OVER_MAX_USER = 301015  /// 비용이 부족함
,
  ErrorCode_INTERACT_NOT_ENOUGH_COST = 301016  /// 인벤에 공간이 부족함
,
  ErrorCode_INTERACT_NOT_ENOUGH_INVEN_SLOT = 301017  /// 메인 스트림 때문에 할수 없음.
,
  ErrorCode_INTERACT_CANNOT_BY_MAINSTREAM = 301018  /// 점유시간 충분하지 않음.
,
  ErrorCode_INTERACT_NOT_ENOUGH_OCCUPIED_TIME = 301019  /// 전쟁필드 채집횟수 제한으로 채집할 수 없음
,
  ErrorCode_INTERACT_BATTLE_FIELD_COLLECTION_COUNT_OVER = 301020  /// 유효하지 않은 데이터
,
  ErrorCode_INTERACT_INVALID_DATA = 301021  /// 인터랙션 할 대상을 찾을 수 없다
,
  ErrorCode_INTERACT_CANNOT_FIND_TARGET_OBJECT = 301022  /// pc가 죽거나 죽어갈땐 인터랙션 할 수 없다
,
  ErrorCode_INTERACT_CANNOT_ON_DEAD = 301023  /// pc가 다른 행동중엔 인터랙션 할 수 없다
,
  ErrorCode_INTERACT_CANNOT_ON_DOING_SOMETHING = 301024  /// 다른 대상과 인터랙션 중이어서, 추가로 할 수 없다
,
  ErrorCode_INTERACT_CANNOT_ALREADY_DOING_WITH_OTHER = 301025  /// 이미 동일 대상과 인터랙션 중이다
,
  ErrorCode_INTERACT_CANNOT_ALREADY_DOING_WITH_THIS = 301026  /// 다른 유저가 점유중인 오브젝트여서 인터랙션 할 수 없다
,
  ErrorCode_INTERACT_CANNOT_OCCUPIED_OBJECT = 301027  /// 대상이 스폰상태가 아니라서 인터랙션 할 수 없다
,
  ErrorCode_INTERACT_CANNOT_OBJECT_NOT_SPAWNED = 301028  /// pc가 사망상태라 인터랙션 보상받기에 실패했다
,
  ErrorCode_INTERACT_CANNOT_REWARDED_ON_DEAD = 301029  /// pc가 대상과 거리가 멀어져 인터랙션 보상받기에 실패했다
,
  ErrorCode_INTERACT_CANNOT_REWARDED_TOO_FAR_DISTANCE = 301030  ///
  /// #길드
  ///
,
  ErrorCode_GUILD_UNKNOWN = 301100  /// 사용자 입력 데이터가 잘못됨
,
  ErrorCode_GUILD_INVALID_PARAM = 301102  /// 길드를 생성할 수 없음
,
  ErrorCode_GUILD_CANNOT_CREATE_GUILD = 301103  /// 길드를 가입할 수 없음
,
  ErrorCode_GUILD_CANNOT_JOIN_BY_CONDITION = 301104  /// 이미 길드에 가입되어 있다
,
  ErrorCode_GUILD_ALREADY_JOINED = 301105  /// 길드 최대 인원을 초과해서 가입할 수 없음
,
  ErrorCode_GUILD_CANNOT_JOIN_LIMIT_COUNT = 301106  /// 이미 가입 신청을 했음
,
  ErrorCode_GUILD_ALREADY_JOIN_REQUEST = 301107  /// 길드장은 탈퇴를 할 수 없음
,
  ErrorCode_GUILD_CANNOT_LEAVE_LEADER = 301108  /// 길드장을 강퇴할 수 없음
,
  ErrorCode_GUILD_CANNOT_KICK_LEADER = 301109  /// 길드장은 캐릭터를 삭제할 수 없다
,
  ErrorCode_GUILD_CANNOT_LEADER_DELETE_PC = 301110  /// 권한이 없습니다.
,
  ErrorCode_GUILD_DO_NOT_HAVE_PERMISSION = 301111  /// 길드명 중복 (길드 생성시 발생)
,
  ErrorCode_GUILD_NAME_DUPLICATED = 301112  /// 길드에 가입되어 있지 않음.
,
  ErrorCode_GUILD_NOT_JOIN = 301113  /// 길드에 멤버가 있어 해산 불가
,
  ErrorCode_GUILD_MEMBER_NOT_EMPTY = 301114  /// 내 길드를 찾을 수 없음 (내길드)
,
  ErrorCode_GUILD_NOT_FOUND_MY_GUILD = 301115  /// 길드원이 아님
,
  ErrorCode_GUILD_NOT_MEMBER = 301116  /// 이미 출석했음
,
  ErrorCode_GUILD_ALREADY_ATTEND = 301117  /// 길드를 찾을 수 없음 (다른 길드 정보를 요청했을 때 발생할 수 있음)
,
  ErrorCode_GUILD_NOT_FOUND = 301118  /// 같은 등급으로 변경할 수 없음
,
  ErrorCode_GUILD_CAN_NOT_CHANGE_SAME_MEMBER_GRADE = 301119  /// 길드 버프가 최대치이다 (최대치인데 레벨업 할 경우)
,
  ErrorCode_GUILD_BUFF_MAX_LEVEL = 301120  /// 구매할 수 없는 길드 버프
,
  ErrorCode_GUILD_BUFF_CAN_NOT_PURCHASE = 301121  /// 잘못된 페이지 번호 (음수 또는 페이지 번호 초과)
,
  ErrorCode_GUILD_INVALID_PAGE_NUMBER = 301122  /// 길드 가입 or 창설이 아직 안됨. 탈퇴 후 24시간이 지나야 할 수 있다
,
  ErrorCode_GUILD_CAN_NOT_JOIN_OR_CREATE_YET = 301123  /// 길드장으로 위임할 수 없는 대상이다
,
  ErrorCode_GUILD_INVALID_CADIDATE_LEADER = 301124  /// 내 계급을 변경할 수 없다
,
  ErrorCode_GUILD_CAN_NOT_CHANGE_MY_GRADE = 301125  /// 길드에 가입요청이 최대치라 가입 신청 불가
,
  ErrorCode_GUILD_MAX_APPLICANT = 301126  /// 유저의 가입 요청이 최대라 가입 신청 불가
,
  ErrorCode_GUILD_MAX_JOIN_REQUEST = 301127  /// 길드 레벨 제한이 걸림
,
  ErrorCode_GUILD_LEVEL_LIMIT = 301128  /// 길드 레벨이 최대 레벨이다 (레벨업 불가)
,
  ErrorCode_GUILD_MAX_LEVEL = 301129  /// 길드 경험치가 부족하다 (레벨업 불가)
,
  ErrorCode_GUILD_NOT_ENOUGH_EXP = 301130  /// 비용이 부족함
,
  ErrorCode_GUILD_NOT_ENOUGH_COST = 301131  /// 리더의 계급을 변경할 수 없다
,
  ErrorCode_GUILD_CAN_NOT_CHANGE_LEADER_GRADE = 301132  /// 길드명에 금칙어가 포함되어 있다
,
  ErrorCode_GUILD_PROHIBIT_WORDS_IN_NAME = 301133  /// 길드 메시지(소개문, 공지)에 금칙어가 포함되어 있다
,
  ErrorCode_GUILD_PROHIBIT_WORDS_IN_MESSAGE = 301134  /// 길드명이 길거나 짧다.
,
  ErrorCode_GUILD_INVALID_NAME_LENGTH = 301135  /// 소개문이 길거나 짧다
,
  ErrorCode_GUILD_INVALID_INTRO_LENGTH = 301136  /// 공지문이 길거나 짧다
,
  ErrorCode_GUILD_INVALID_NOTICE_LENGTH = 301137  /// 가입 요청이 취소됐거나 PcDbId가 잘못됐다.
,
  ErrorCode_GUILD_NOT_FOUND_JOIN_REQ = 301138  /// 자신을 추방할 수 없다
,
  ErrorCode_GUILD_CAN_NOT_KICK_SELF = 301139  /// 계급 인원 제한으로 계급을 변경할 수 없다
,
  ErrorCode_GUILD_LIMIT_MEMBER_GRADE_COUNT = 301140  /// 프리징 기간에는 길드탈퇴를 할 수 없습니다.
,
  ErrorCode_GUILD_CAN_NOT_LEAVE_IN_SEASON_OFF = 301141  /// 프리징 기간에는 할 수 없습니다.
,
  ErrorCode_GUILD_CAN_NOT_ACTION_IN_SEASON_OFF = 301142  /// 높은 계급은 강퇴할 수 없습니다.
,
  ErrorCode_GUILD_CAN_NOT_KICK_HIGHER_GRADE_MEMBER = 301143  /// 높은 계급의 길드원 계급을 변경할 수 없습니다
,
  ErrorCode_GUILD_CAN_NOT_CHANGE_HIGHER_GRADE_MEMBER = 301144  /// 자신보다 높은 계급으로 설정할 수 없습니다.
,
  ErrorCode_GUILD_CAN_NOT_CHANGE_GRADE_TO_HIGHER = 301145  /// 길드명 변경 대상 길드가 아닙니다.
,
  ErrorCode_GUILD_CAN_NOT_CHANGE_NAME = 301146  /// 플레이어와 길드의 렐름이 상이함
,
  ErrorCode_GUILD_CAN_NOT_JOIN_DIFFERENT_REALM = 301147  ///
  /// #RVR 전쟁필드
  ///
  /// 전쟁필드 요청가능한 채널컨텐츠타입이 아님(마을,필드에서만 신청가능)
,
  ErrorCode_RVR_NOT_JOINABLE_CONTENTS_TYPE = 301301  /// 전쟁필드 입장가능 메인스트림 아이디 조건에 맞지않음
,
  ErrorCode_RVR_NOT_JOINABLE_MAINSTREAM_ID = 301302  /// 보유한 전쟁필드 시간이 없어서 입장할 수 없음
,
  ErrorCode_RVR_NOT_ENOUGH_TIME = 301303  /// 컨트롤러 오브젝트 참조 불가
,
  ErrorCode_RVR_INVALID_CONTROLLER_OBJECT = 301304  /// 이미 진행중 
,
  ErrorCode_RVR_ALREADY_RPOCESSING = 301305  /// 잘못된 RVR ID
,
  ErrorCode_RVR_INVALID_RVRID = 301306  /// 배틀 서버와 접속이 끓어짐.
,
  ErrorCode_RVR_DISCONNECT_BATTLE_SERVER = 301307  /// 신청한 데이터가 존재 하지 않음
,
  ErrorCode_RVR_NOT_EXIST_INFO = 301308  /// 신청했던 RVRID와 불일치
,
  ErrorCode_RVR_DISCORD_EXIST_RVRID = 301309  /// 참여 가능한 순번이 아니다
,
  ErrorCode_RVR_NOT_JOINABLE_ORDER = 301310,
  ErrorCode_RVR_NOT_EXIST_REALM_CONTEXT = 301311  /// __UNUSED = 301312,
,
  ErrorCode_RVR_CLOSED_BATTLE_FIELD = 301313,
  ErrorCode_RVR_JOINED_OTHER_BATTLE_FIELD = 301314,
  ErrorCode_RVR_DEFAULT_FAILED = 301315,
  ErrorCode_RVR_CLOSED_BATTLE_FIELD_BRAWL = 301316,
  ErrorCode_RVR_TEMPORARY_INSPECT_BRAWL = 301321,
  ErrorCode_BUDDY_ALREADY_MAX_BUDDY_COUNT = 301401,
  ErrorCode_BUDDY_ALREADY_BUDDY = 301402,
  ErrorCode_BUDDY_ALREADY_INVITATION_SEND_BUDDY = 301403,
  ErrorCode_BUDDY_ALREADY_INVITATION_RECEIVE_BUDDY = 301404,
  ErrorCode_BUDDY_CANNOT_FIND_IVNITATION_FROM_PC = 301405,
  ErrorCode_BUDDY_CANNOT_FIND_IVNITATION_TO_PC = 301406,
  ErrorCode_BUDDY_DELETE_FAILED_NOT_BUDDY = 301407,
  ErrorCode_BUDDY_INVITATION_EXPIRED = 301410,
  ErrorCode_BUDDY_SEND_INVITATION_MAX_COUNT = 301411,
  ErrorCode_BUDDY_RECEIVE_INVITATION_MAX_COUNT = 301412,
  ErrorCode_BUDDY_OTHER_BUDDY_COUNT_ALREADY_MAX = 301413,
  ErrorCode_BUDDY_INVALID_BUDDY = 301415  ///
  /// 친구소환	
  /// 
,
  ErrorCode_SUMMON_REQUEST_FAILED_INVALID_EVENT_STATE = 301419,
  ErrorCode_SUMMON_REQUEST_FAILED_CANNOT_FIND_BUDDY = 301420,
  ErrorCode_SUMMON_REQUEST_FAILED_INVALID_CHANNEL = 301421,
  ErrorCode_SUMMON_REQUEST_FAILED_INVALID_POS = 301422,
  ErrorCode_SUMMON_REQUEST_FAILED_INVALID_CONTENTS_TYPE = 301423,
  ErrorCode_SUMMON_REQUEST_FAILED_MAX_PC_COUNT_IN_CHANNEL = 301424  /// 잘못된 요청 (친구나, 길드원이 아님)
,
  ErrorCode_SUMMON_REQUEST_INVALID_TARGET = 301425  /// 소환하기 요청 개수가 이미 최대입니다
,
  ErrorCode_SUMMON_REQUEST_FAILED_MAX_COUNT = 301426  /// 이미 해당 유저에게 소환하기 요청을 보냈습니다
,
  ErrorCode_SUMMON_REQUEST_FAILED_ALREADY_SEND_BUDDY = 301427  /// 해당 유저에게 받은 소환하기 요청이 있습니다
,
  ErrorCode_SUMMON_REQUEST_FAILED_ALREADY_RECEIVE_BUDDY = 301428,
  ErrorCode_SUMMON_RECEIVE_FAILED_INVALID_CONTENTS_TYPE = 301429,
  ErrorCode_SUMMON_RECEIVE_FAILED_CANNOT_ENTER_SMAP = 301430,
  ErrorCode_SUMMON_RECEIVE_FAILED_MAX_COUNT = 301431,
  ErrorCode_SUMMON_ACCEPT_FAILED_CALL_EXPIRED = 301432,
  ErrorCode_SUMMON_ACCEPT_FAILED_CANNOT_FIND_CHANNEL = 301433,
  ErrorCode_SUMMON_ACCEPT_FAILED_CANNOT_FIND_CALLER = 301434,
  ErrorCode_MOVE_TO_PC_FAILED_NOT_ENOUGH_TICKET = 301435,
  ErrorCode_SUMMON_REQUEST_FAILED_INVALID_MAINSTREAM_ID = 301436,
  ErrorCode_SUMMON_ACCEPT_FAILED_INVALID_MAINSTREAM_ID = 301437,
  ErrorCode_SUMMON_ACCEPT_FAILED_NOT_ALIVE_STATE = 301438,
  ErrorCode_SUMMON_ACCEPT_FAILED_INVALID_EVENT_STATE = 301439  ///
  /// 친구위치로 이동하기
  /// 
,
  ErrorCode_MOVE_TO_PC_FAILED_CANNOT_FIND_BUDDY = 301440  /// 친구의 채널이 없는경우(친구가 스폰되지 않았을때도)
,
  ErrorCode_MOVE_TO_PC_FAILED_INVALID_CHANNEL_STATE = 301441,
  ErrorCode_MOVE_TO_PC_FAILED_INVALID_CONTENTS_TYPE_SRC = 301442,
  ErrorCode_MOVE_TO_PC_FAILED_INVALID_CONTENTS_TYPE_DES = 301443,
  ErrorCode_MOVE_TO_PC_FAILED_INVALID_SMAP = 301444,
  ErrorCode_MOVE_TO_PC_FAILED_INVALID_MAINSTREAM_ID = 301445,
  ErrorCode_MOVE_TO_PC_FAILED_TARGET_INVALID_MAINSTREAM_ID = 301446,
  ErrorCode_MOVE_TO_PC_FAILED_NOT_ALIVE_STATE = 301447,
  ErrorCode_MOVE_TO_PC_FAILED_MAX_PC_COUNT_IN_CHANNEL = 301448,
  ErrorCode_MOVE_TO_PC_FAILED_INVALID_EVENT_STATE = 301449  /// 
  /// 차단
  ///
,
  ErrorCode_ALREADY_DENIED_CHARACTER = 301500,
  ErrorCode_ALREADY_UNDENIED_CHARACTER = 301501  ///
  /// 매칭
  ///
  /// 인원 미달 매칭 취소
,
  ErrorCode_MATCHING_CANCEL_MIN_USER_TIMEOUT = 301600  /// 인원이 가득차서 더이상 매칭 홍보할 수 없습니다.
,
  ErrorCode_MATCHING_PROMOTION_FAILED_ALREADY_MAX_PC = 301601  /// 홍보 가능한 시간이 아닙니다 (쿨타임 중)
,
  ErrorCode_MATCHING_PROMOTION_FAILED_COOLTIME = 301602  /// 마을, 필드에서만 매칭 참여신청 가능합니다.
,
  ErrorCode_MATCHING_FAILED_INVALID_CHANNEL_CONTENTS_TYPE = 301610  /// 푸시 정보를 찾을 수 없을때 (푸시가 종료된 경우 OR 푸시알림 받지않은 PC가 요청올 때)
,
  ErrorCode_PUSH_JOIN_FAILED_CANNOT_FIND_PUSH = 301620  /// 이미 다른 매칭 진행중입니다.
,
  ErrorCode_PUSH_JOIN_FAILED_ALREADY_JOINED_OTHER_MATCH = 301621  /// 해당 방을 찾을 수 없습니다.(존재하지 않는 매칭)
,
  ErrorCode_PUSH_JOINED_FAILED_CANNOT_FIND_MATCHING = 301630  /// 이미 방이 가득차서 입장할 수 없습니다.
,
  ErrorCode_PUSH_JOINED_FAILED_ALREADY_FULL = 301631  /// 그룹매칭에 초대할 상대방을 찾을 수 없다.
,
  ErrorCode_GROUP_MATCHING_FAILED_CANNOT_FIND_TARGET = 301632  /// 그룹매칭 초대자가 없다.(오프라인)
,
  ErrorCode_GROUP_MATCHING_CANNOT_FIND_INVITER_PC = 301633  /// 그룹매칭 받은 초대장을 찾을 수 없다. (시간이 만료됐거나, 취소된 경우)
,
  ErrorCode_GROUP_MATCHING_CANNOT_FIND_INVITATION = 301634  /// 그룹매칭 그룹원끼리 시작하기 실패. 최소인원을 만족하지 않음
,
  ErrorCode_GROUP_MATCHING_START_FAILED_MIN_PC = 301635,
  ErrorCode_MATCHING_CANCEL_GROUP_LEADER_LEAVE = 301636,
  ErrorCode_GROUP_MATCHING_REMATCHING_FAILED_EXPIRED = 301637  ///
  /// #길드던전
  ///	
  /// 길드던전 길드가 맞지 않음
,
  ErrorCode_GUILD_DUNGEON_GUILD_NOT_JOIN = 301701  /// 길드던전 템플릿 아이디가 잘못됨
,
  ErrorCode_GUILD_DUNGEON_INVALID_ID = 301702  /// 입장 횟수 부족
,
  ErrorCode_GUILD_DUNGEON_LIMIT_ENTER_COUNT = 301703  /// 입장 아이템 부족
,
  ErrorCode_GUILD_DUNGEON_NOT_ENOUGH_ITEM = 301704  /// 입장 조건을 만족하지 못함(해금 조건)
,
  ErrorCode_GUILD_DUNGEON_LIMIT_ENTER = 301705  /// 길드던전 시즌 종료
,
  ErrorCode_GUILD_DUNGEON_SEASON_CLOSED = 301706  /// 길드던전에서는 길드원만 소환가능하다
,
  ErrorCode_GUILD_DUNGEON_INVALID_SUMMON_TARGET = 301707  /// 다른 길드 친구의 길드던전으로 이동할 수 없다.
,
  ErrorCode_GUILD_DUNGEON_INVALID_MOVE_TARGET = 301708  ///
  /// 난투장
  ///
,
  ErrorCode_BRAWL_POINT_FULL = 301709,
  ErrorCode_RVR_NOT_ENOUGH_BRAWL_TIME = 301710,
  ErrorCode_BRAWL_ENHANCE_FAILED_NOT_ENOUGH_BRAWL_POINT = 301711,
  ErrorCode_BRAWL_ENHANCE_FAILED_NOT_ENOUGH_CHANCE_ITEM = 301712,
  ErrorCode_BRAWL_ENHANCE_FAILED_CHANCE_ITEM_COUNT_OVERFLOW = 301713,
  ErrorCode_BRAWL_ENHANCE_FAILED_ALREADY_MAX_LEVEL = 301714,
  ErrorCode_BRAWL_ENHANCE_FAILED_ALREADY_PROCESS = 301715  /// 
,
  ErrorCode_BRAWL_ENHANCE_FAILED_INVALID_LEVEL = 301716  ///
  /// 스크롤 퀘스트
  ///
,
  ErrorCode_SCROLL_QUEST_INVALID_DATA = 301720,
  ErrorCode_SCROLL_QUEST_INVALID_SCROLL_ID = 301721,
  ErrorCode_SCROLL_QUEST_CREATE_FAILED_ALREADY_HAVE_ANOTHER = 301722,
  ErrorCode_SCROLL_QUEST_CREATE_FAILED_LIMIT_DAILY_COUNT = 301723,
  ErrorCode_SCROLL_QUEST_CREATE_FAILED_MAINSTERAM = 301724,
  ErrorCode_SCROLL_QUEST_REMOVE_FAILED_ALREADY_HAVE_NOTING = 301725,
  ErrorCode_SCROLL_QUEST_REMOVE_FAILED_INVALID_STATE_TO_CANCEL = 301726,
  ErrorCode_SCROLL_QUEST_REMOVE_FAILED_ALREADY_REMOVED = 301727,
  ErrorCode_BRAWL_ENTER_FAILED_REENTER_DELAY = 301728  ///
  /// 펫 시스템
  ///	
,
  ErrorCode_PET_INVEN_FULL = 301729,
  ErrorCode_PET_INVALID_PET = 301730,
  ErrorCode_PET_INVALID_PET_DATA = 301731,
  ErrorCode_PET_SUMMON_FAILED_LIMIT = 301750,
  ErrorCode_PET_SUPPORT_FAILED_LIMIT = 301751,
  ErrorCode_PET_SUMMON_SUPPORT_FAILED_ALREADY_DOING = 301752,
  ErrorCode_PET_SUMMON_RELEASE_FAILED_NOT_SUMMONED = 301753,
  ErrorCode_PET_SUPPORT_RELEASE_FAILED_NOT_SUPPORTED = 301754,
  ErrorCode_PET_FEED_FAILED_ALREADY_MAX_LEVEL = 301769,
  ErrorCode_PET_FEED_FAILED_NOT_FOOD = 301770,
  ErrorCode_PET_FEED_FAILED_NOT_EQUIPED = 301771,
  ErrorCode_PET_FEED_FAILED_COOLTIME = 301772,
  ErrorCode_PET_ALTAR_ACTIVE_SKILL_LEVEL_UP_FAILED_INVALID_LEVEL = 301773,
  ErrorCode_PET_HATCHERY_NOT_OPENED_HATCHERY = 301789,
  ErrorCode_PET_HATCHERY_SUMMON_FAILED_INVALID_STATE = 301790,
  ErrorCode_PET_HATCHERY_HATCH_FAILED_INVALID_STATE = 301791,
  ErrorCode_PET_NOT_ENOUGH_ALTAR_POINT = 301800,
  ErrorCode_PET_ALTAR_POINT_FULL = 301801,
  ErrorCode_PET_FUSION_FAILED_NOT_EQUAL_GRADE = 301802,
  ErrorCode_PET_FUSION_FAILED_INVALID_PET_COUNT = 301803,
  ErrorCode_CONFLICT_FILED_IS_NOT_CONFLICT_CHANNEL = 301900,
  ErrorCode_BATTLE_SERVER_CAN_NOT_MOVE_SMAP = 301901,
  ErrorCode_MIN = ErrorCode_NONE,
  ErrorCode_MAX = ErrorCode_BATTLE_SERVER_CAN_NOT_MOVE_SMAP
};

inline const ErrorCode (&EnumValuesErrorCode())[425] {
  static const ErrorCode values[] = {
    ErrorCode_NONE,
    ErrorCode_OK,
    ErrorCode_FAILED,
    ErrorCode_DB_FAILED,
    ErrorCode_AUTH_ACCOUNT_NAME_FAILED,
    ErrorCode_AUTH_PASSWORD_FAILED,
    ErrorCode_AUTH_NOT_SERVICE_COLONY,
    ErrorCode_AUTH_ACCOUNT_BLOCKED,
    ErrorCode_AUTH_COUNTRY_BANNED,
    ErrorCode_AUTH_CRASH_COLONY,
    ErrorCode_DUPLICATE_PC_NAME,
    ErrorCode_PROHIBIT_WORDS_PC_NAME,
    ErrorCode_CANNOT_JOIN_SERVICE,
    ErrorCode_RESTRICT_COLONY,
    ErrorCode_DUPLICATE_LOGIN,
    ErrorCode_LIMIT_REALM,
    ErrorCode_ADMIN_TOOL_KICK,
    ErrorCode_UNKNOWN_SYSTEM_ERROR,
    ErrorCode_HIVE_ITEM_ALREADY_GIVEN,
    ErrorCode_ALREADY_LINKED,
    ErrorCode_NOT_FOUND_WAITING_LIST,
    ErrorCode_FAILED_CANCEL_WAITING,
    ErrorCode_FAILED_ADD_WAITING,
    ErrorCode_INVALID_RESERVED_NICK_NAME_CODE,
    ErrorCode_ALREADY_USED_RESERVED_NICK_NAME_CODE,
    ErrorCode_UNREGISTERED_RESERVED_NICK_NAME_CODE,
    ErrorCode_ALREADY_SELECTED_OTHER_REALM_RESERVED_NICK_NAME_CODE,
    ErrorCode_ALREADY_USED_RESERVED_NICK_NAME_ACCOUNT,
    ErrorCode_ALREADY_CHAR_JOIN_GUILD,
    ErrorCode_INVALID_PC_CONTROLLER,
    ErrorCode_INVALID_TEMPLATE_DATA,
    ErrorCode_FAILED_DELETE_ITEM,
    ErrorCode_NOT_EXIST_ITEM,
    ErrorCode_INVALID_USE_CLASS,
    ErrorCode_NOT_EQUIPABLE_ITEM,
    ErrorCode_DUPLICATE_EQUIP_EXCLUSIVE_GROUP_ID,
    ErrorCode_NOT_ENCHANTABLE_ITEM,
    ErrorCode_NOT_ENOUGH_GOLD,
    ErrorCode_ALREADY_EQUIPED_ITEM,
    ErrorCode_NOT_DISENCHANT_ITEM,
    ErrorCode_NOT_ENOUGH_STORAGE_SPACE,
    ErrorCode_NOT_ENOUGH_MATERIAL_ITEM,
    ErrorCode_ALREADY_PRESET_ITEM,
    ErrorCode_NOT_ENOUGH_ITEM,
    ErrorCode_NOT_UPGRADABLE_ITEM,
    ErrorCode_NOT_ENOUGH_DIA,
    ErrorCode_INVALID_USE_LEVEL,
    ErrorCode_NOT_EXIST_MAIL,
    ErrorCode_EXPIRED_MAIL,
    ErrorCode_NOT_EXIST_SHOP_PRODUCT,
    ErrorCode_LIMIT_PURCHASABLE_COUNT,
    ErrorCode_NOT_ENOUGH_COOLTIME,
    ErrorCode_PURCHASE_UNDER_RANGE_LEVEL,
    ErrorCode_PURCHASE_OVER_RANGE_LEVEL,
    ErrorCode_NOT_DONATE_ITEM,
    ErrorCode_OVERRANGE_MASTERY_LEVEL,
    ErrorCode_NOT_ENOUGH_ITEM_GRADE,
    ErrorCode_GOLD_IS_FULL,
    ErrorCode_NOT_EQUAL_DONATION_ITEM_TYPE,
    ErrorCode_EXIST_RECORD_PURCHASE_ITEM,
    ErrorCode_OVERRANGE_SHOP_COOLTIME,
    ErrorCode_NOT_ENOUGH_TICKET,
    ErrorCode_INVALID_TICKET_TYPE,
    ErrorCode_NOT_EXIST_RECEIVEABLE_MAIL,
    ErrorCode_FAILED_ALL_RECEIVE_MAIL_NOT_ENOUGH_STORAGE,
    ErrorCode_EMPTY_MAIL_BOX,
    ErrorCode_EMPTY_REWARD_INFO,
    ErrorCode_NOT_FOUND_MY_RANK,
    ErrorCode_CAN_NOT_USE_ITEM_STATE,
    ErrorCode_FAILED_ALL_USE_ITEM_NOT_ENOUGH_STORAGE,
    ErrorCode_NOT_AVAILABLE_USED_ITEM_TYPE,
    ErrorCode_OVER_COUNT_ALL_USE_ITEM,
    ErrorCode_CANT_USE_ITEM_WITH_COOLTIME,
    ErrorCode_UNABLE_ACQUIRE_EXP,
    ErrorCode_NOT_MATCH_TRADE_TAX_RATE,
    ErrorCode_LOWER_THAN_RARE_RATINGS_ARE_NOT_POSSIBLE,
    ErrorCode_OVER_COUNT_SLOT_INDEX,
    ErrorCode_NOT_EXIST_CRYSTAL_IN_SLOT,
    ErrorCode_NOT_EXIST_ITEM_IN_INVENTORY,
    ErrorCode_MISS_MATCH_ITEM_CATEGORY,
    ErrorCode_ALREADY_EQUIPED_IN_SLOT,
    ErrorCode_MISS_MATCH_CRYSTAL_TYPE,
    ErrorCode_NOT_REACHED_MAX_LEVEL,
    ErrorCode_MAX_GRADE,
    ErrorCode_CAN_NOT_UPGRADE,
    ErrorCode_CAN_NOT_LEVEL_UP,
    ErrorCode_HIGHEST_LEVEL_OF_THE_GRADE,
    ErrorCode_NOT_EXIST_CHARACTER,
    ErrorCode_NOT_ENOUGH_CHAT_TERM,
    ErrorCode_CAN_NOT_SEND_MESSAGE_FOR_SAME_CHARACTER,
    ErrorCode_CAN_NOT_SEND_MESSAGE_AT_OUTSIDE_WARFIELD,
    ErrorCode_OVERRANGE_CHAT_MESSAGE_LENGTH,
    ErrorCode_INVALID_CHATTING_TYPE,
    ErrorCode_UNABLE_CHATTING_CONTENTS_TYPE,
    ErrorCode_INFLUENCE_DAILY_COUNT_OVER,
    ErrorCode_NOT_EXIST_FOLLOWER,
    ErrorCode_FOLLOWER_JOIN_MISSION_OVER_COUNT,
    ErrorCode_FOLLOWER_ALREADY_TO_BE_PLACED,
    ErrorCode_FOLLOWER_ALREADY_HAS_NOT_MISSION,
    ErrorCode_NOT_ENOUGH_PRISM,
    ErrorCode_PRISM_IS_FULL,
    ErrorCode_BUY_TRADE_ITEM_NOT_EXIST,
    ErrorCode_REG_TRADE_ITEM_IS_FULL,
    ErrorCode_BUY_TRADE_ITEM_FAILED,
    ErrorCode_SHOP_PROUDCT_IS_DISABLED,
    ErrorCode_SHOP_PRODUCT_ALREADY_PURCHASED,
    ErrorCode_SHOP_PRODUCT_PURCHASE_LIMIT_COUNT_OVER,
    ErrorCode_NOT_ENOUGH_FORTUNE_POINT,
    ErrorCode_FORTUNE_POINT_IS_FULL,
    ErrorCode_CANCEL_TRADE_ITEM_NOT_EXIST,
    ErrorCode_NOT_ENOUGH_GUILD_COIN,
    ErrorCode_NOT_ENOUGH_MONARCH_POINT,
    ErrorCode_SHOP_PRODUCT_PURCAHSE_FAILED_CHAR_STATE,
    ErrorCode_SHOP_PRODUCT_PURCAHSE_FAILED_MAINSTREAM,
    ErrorCode_SHOP_PRODUCT_PURCAHSE_FAILED_CHAR_LEVEL,
    ErrorCode_SHOP_PRODUCT_PURCAHSE_FAILED_NO_GUILD,
    ErrorCode_SHOP_PRODUCT_PURCAHSE_FAILED_GUILD_LEVEL,
    ErrorCode_SHOP_PRODUCT_PURCAHSE_FAILED_GUILD_MEMBER_RANK,
    ErrorCode_GUILD_COIN_IS_FULL,
    ErrorCode_MONARCH_POINT_IS_FULL,
    ErrorCode_NOT_ENOUGH_FOLLOWER_SOUL_STONE,
    ErrorCode_FOLLOWER_ALREADY_FULL_LEVEL,
    ErrorCode_SHOP_PRODUCT_NOT_ENOUGH_BONUS_POINT,
    ErrorCode_DIA_IS_FULL,
    ErrorCode_NOT_LIVE_EVET_PERIOD,
    ErrorCode_UPDATING_LIVE_EVENT_DATA,
    ErrorCode_NOT_EXIST_LIVE_EVENT_PRODUCT,
    ErrorCode_NOT_EXIST_LIVE_EVENT_MISSION,
    ErrorCode_EXCEEDED_LIVE_EVENT_PURCHASE_COUNT,
    ErrorCode_NOT_EXIST_LIVE_EVENT_ATTETION,
    ErrorCode_FAILED_TO_RECEIVE_ATTENTION_REWARD,
    ErrorCode_CANNOT_RECEIVE_ATTENTION_REWARD,
    ErrorCode_NOT_EXIST_LIVE_EVENT_ATTENTION_REWARD,
    ErrorCode_ALREADY_RECEIVE_ATTENTION_REWARD,
    ErrorCode_NOT_ENOUGH_GROWTH_INHERIT_MATERIAL_ITEM,
    ErrorCode_CAN_NOT_INHERIT_DIFFERENT_COSTUME_TYPE,
    ErrorCode_NOT_ENOUGH_JUMPING_COUNT,
    ErrorCode_NOT_ENOUGH_PVP_COIN,
    ErrorCode_PVP_COIN_IS_FULL,
    ErrorCode_NOT_FOUND_EVENT_SET,
    ErrorCode_INVALID_CHANNEL_STATE,
    ErrorCode_INVALID_WEEK,
    ErrorCode_FAILED_ADDITIONAL_ENTER,
    ErrorCode_INVALID_PAID_TYPE,
    ErrorCode_FAILED_DAILY_DUNGEON_INVALID_CHAPTER,
    ErrorCode_FAILED_SOLO_DUNGEON_LARGE_CONDITION,
    ErrorCode_FAILED_SOLO_DUNGEON_MIDDLE_CONDITION,
    ErrorCode_FAILED_SOLO_DUNGEON_STAGE_CONDITION,
    ErrorCode_FAILED_SOLO_DUNGEON_TODAY_CLEAR_COUNT_OVER,
    ErrorCode_FAILED_SOLO_DUNGEON_NOT_ENOUGH_TICKET,
    ErrorCode_INVALID_SOLO_DUNGEON_STAGE_ID,
    ErrorCode_ALREADY_DUNGEON_ENTER_PROCESSING,
    ErrorCode_ARENA_PLEASE_APPLY_AGAIN_AFTER_A_WHILE,
    ErrorCode_ARENA_NOT_ENOUGH_ENTER_COUNT,
    ErrorCode_ARENA_REWARD_INFO_ERROR,
    ErrorCode_WORLD_INVALID_EVENT_SET_ID,
    ErrorCode_WORLD_INVALID_EVENT_ID,
    ErrorCode_WORLD_INVALID_CHANNEL,
    ErrorCode_WORLD_NO_FIELD_CONTENTS,
    ErrorCode_CHANNEL_UNKNOWN,
    ErrorCode_CHANNEL_NOT_EXIST,
    ErrorCode_CHANNEL_CAN_NOT_MOVE_SMAP,
    ErrorCode_CHANNEL_CAN_NOT_MOVE_NOW,
    ErrorCode_CHANNEL_USER_COUNT_LIMIT,
    ErrorCode_CHANNEL_MOVE_TIME_LIMIT,
    ErrorCode_EVENT_NO_EVENT_INSTANCE,
    ErrorCode_EVENT_INVALID_DEST_POS,
    ErrorCode_EVENT_RETURN_NO_SAVE_POS,
    ErrorCode_EVENT_RETURN_DISCORD_ID,
    ErrorCode_EVENT_RETURN_DISCORD_SMAP_ID,
    ErrorCode_EVENT_RETURN_NO_FIELD_CONTENT,
    ErrorCode_QUEST_INVALID_ID_FAIL,
    ErrorCode_QUEST_LACK_COUNT_FAIL,
    ErrorCode_QUEST_ACCEPTED_REWARD_FAIL,
    ErrorCode_QUEST_PROCESSING_REWARD_FAIL,
    ErrorCode_QUEST_DB_UPDATE_FAIL,
    ErrorCode_ALREADY_HAD_A_QUEST_BONUS_REWARD,
    ErrorCode_INVALID_QUEST_BONUS_ID,
    ErrorCode_FAILED_CONDITION_QUEST_BONUS,
    ErrorCode_CHAPTER_FAIL_INVALID_CHAPTER_INDEX,
    ErrorCode_CHAPTER_FAIL_INVALID_ASSIGN_SMAP_ID,
    ErrorCode_CHAPTER_FAIL_INVALID_ASSIGN_CINEMA_ID,
    ErrorCode_CHAPTER_FAIL_CLEAR_PREVIOUS_CHAPTER,
    ErrorCode_CHAPTER_FAIL_LACK_FIGHT_POWER,
    ErrorCode_CHAPTER_FAIL_LACK_SMAP_RATE,
    ErrorCode_CHAPTER_FAIL_NO_SEE_CINEMA,
    ErrorCode_CHAPTER_FAIL_LACK_LEVEL,
    ErrorCode_CHAPTER_FAIL_LACK_MMAP_RATE,
    ErrorCode_CHAPTER_FAIL_UPDATE_DB,
    ErrorCode_CHAPTER_FAIL_INVALID_TEMPLTE,
    ErrorCode_CHAPTER_FAIL_INVALID_PER_DATA,
    ErrorCode_CHAPTER_LESS_LEVEL,
    ErrorCode_CHAPTER_LESS_ACHIEVEMENT_RATE,
    ErrorCode_CHAPTER_NOT_CLEARED_QUEST,
    ErrorCode_CHAPTER_NO_NEXT_SMAP,
    ErrorCode_CHAPTER_NOT_FOUND_SMAP_CLEAR_TEMPLATE,
    ErrorCode_CHAPTER_LOCKED_SMAP,
    ErrorCode_CHAPTER_NOT_CLEARED_MAIN_STREAM,
    ErrorCode_RECOMMEND_NO_LIST,
    ErrorCode_RECOMMEND_EXPIRED_TIME,
    ErrorCode_RECOMMEND_VOTED_INVALID_PC_DB_ID,
    ErrorCode_RECOMMEND_ALREADY_VOTED,
    ErrorCode_TRADE_FAIL_ALREADY_TRYING_SEARCH,
    ErrorCode_TRADE_FAIL_SET_ITEM_INVALID_CREATE_TYPE,
    ErrorCode_DUNGEON_NOT_ENOUGH_CLEAR_COUNT,
    ErrorCode_PUSH_JOIN_FAILED_NOT_ENOUGH_MATCHING_COUNT,
    ErrorCode_RAID_JOIN_FAILED_NOT_ENOUGH_COUNT,
    ErrorCode_RAID_JOIN_FAILED_NOT_ENOUGH_COST_ITEM,
    ErrorCode_RAID_JOIN_FAILED_INVALID_CHAPTER,
    ErrorCode_DAILY_HW_INVALID_POINT_REWARD_ID,
    ErrorCode_DAILY_HW_NOT_ENOUGH_POINT_REWARD,
    ErrorCode_DAILY_HW_COMPLETED_REWARD,
    ErrorCode_BONUS_DAILY_RECHARGE_FAILED_ALREADY_REWARDED,
    ErrorCode_INFINITE_TOWER_INVALID_STAGE,
    ErrorCode_INFINITE_TOWER_INVALID_STAGE_ALREADY_CLEARED,
    ErrorCode_INFINITE_TOWER_ALREADY_REWARDED,
    ErrorCode_INFINITE_TOWER_INVALID_PAID_TYPE,
    ErrorCode_INFINITE_TOWER_INVALID_SWEEP_STAGE,
    ErrorCode_ATTENDANCE_ALREADY_STAMPED,
    ErrorCode_ATTENDANCE_INVALID_BOARD,
    ErrorCode_ACCESS_TIME_INVALID_TIME,
    ErrorCode_ACCESS_TIME_ALREADY_TODAY_ALL_REWARDED,
    ErrorCode_ACCESS_TIME_ALREADY_REWARDED,
    ErrorCode_ACCESS_TIME_NOT_ENOUGH_TIME,
    ErrorCode_REST_TIME_NOT_ENOUGH_REST_POINT,
    ErrorCode_JOIN_FAIL_UNKNOWN,
    ErrorCode_JOIN_FAIL_CHANNELING,
    ErrorCode_JOIN_FAIL_NO_SPAWNED,
    ErrorCode_JOIN_FAIL_NO_DATA,
    ErrorCode_JOIN_FAIL_INVALID_SMAPID,
    ErrorCode_JOIN_FAIL_SAME_SMAPID,
    ErrorCode_GOLD_DUNGEON_INVALID_ID,
    ErrorCode_GOLD_DUNGEON_LIMIT_ENTER_COUNT,
    ErrorCode_GOLD_DUNGEON_NOT_ENOUGH_ITEM,
    ErrorCode_GOLD_DUNGEON_LIMIT_ENTER,
    ErrorCode_INTERACT_UNKNOWN,
    ErrorCode_INTERACT_CANCEL,
    ErrorCode_INTERACT_INVALID_OBJECT,
    ErrorCode_INTERACT_CANNOT_INTERACTION,
    ErrorCode_INTERACT_TOO_FAR_DISTANCE,
    ErrorCode_INTERACT_OVER_MAX_USER,
    ErrorCode_INTERACT_NOT_ENOUGH_COST,
    ErrorCode_INTERACT_NOT_ENOUGH_INVEN_SLOT,
    ErrorCode_INTERACT_CANNOT_BY_MAINSTREAM,
    ErrorCode_INTERACT_NOT_ENOUGH_OCCUPIED_TIME,
    ErrorCode_INTERACT_BATTLE_FIELD_COLLECTION_COUNT_OVER,
    ErrorCode_INTERACT_INVALID_DATA,
    ErrorCode_INTERACT_CANNOT_FIND_TARGET_OBJECT,
    ErrorCode_INTERACT_CANNOT_ON_DEAD,
    ErrorCode_INTERACT_CANNOT_ON_DOING_SOMETHING,
    ErrorCode_INTERACT_CANNOT_ALREADY_DOING_WITH_OTHER,
    ErrorCode_INTERACT_CANNOT_ALREADY_DOING_WITH_THIS,
    ErrorCode_INTERACT_CANNOT_OCCUPIED_OBJECT,
    ErrorCode_INTERACT_CANNOT_OBJECT_NOT_SPAWNED,
    ErrorCode_INTERACT_CANNOT_REWARDED_ON_DEAD,
    ErrorCode_INTERACT_CANNOT_REWARDED_TOO_FAR_DISTANCE,
    ErrorCode_GUILD_UNKNOWN,
    ErrorCode_GUILD_INVALID_PARAM,
    ErrorCode_GUILD_CANNOT_CREATE_GUILD,
    ErrorCode_GUILD_CANNOT_JOIN_BY_CONDITION,
    ErrorCode_GUILD_ALREADY_JOINED,
    ErrorCode_GUILD_CANNOT_JOIN_LIMIT_COUNT,
    ErrorCode_GUILD_ALREADY_JOIN_REQUEST,
    ErrorCode_GUILD_CANNOT_LEAVE_LEADER,
    ErrorCode_GUILD_CANNOT_KICK_LEADER,
    ErrorCode_GUILD_CANNOT_LEADER_DELETE_PC,
    ErrorCode_GUILD_DO_NOT_HAVE_PERMISSION,
    ErrorCode_GUILD_NAME_DUPLICATED,
    ErrorCode_GUILD_NOT_JOIN,
    ErrorCode_GUILD_MEMBER_NOT_EMPTY,
    ErrorCode_GUILD_NOT_FOUND_MY_GUILD,
    ErrorCode_GUILD_NOT_MEMBER,
    ErrorCode_GUILD_ALREADY_ATTEND,
    ErrorCode_GUILD_NOT_FOUND,
    ErrorCode_GUILD_CAN_NOT_CHANGE_SAME_MEMBER_GRADE,
    ErrorCode_GUILD_BUFF_MAX_LEVEL,
    ErrorCode_GUILD_BUFF_CAN_NOT_PURCHASE,
    ErrorCode_GUILD_INVALID_PAGE_NUMBER,
    ErrorCode_GUILD_CAN_NOT_JOIN_OR_CREATE_YET,
    ErrorCode_GUILD_INVALID_CADIDATE_LEADER,
    ErrorCode_GUILD_CAN_NOT_CHANGE_MY_GRADE,
    ErrorCode_GUILD_MAX_APPLICANT,
    ErrorCode_GUILD_MAX_JOIN_REQUEST,
    ErrorCode_GUILD_LEVEL_LIMIT,
    ErrorCode_GUILD_MAX_LEVEL,
    ErrorCode_GUILD_NOT_ENOUGH_EXP,
    ErrorCode_GUILD_NOT_ENOUGH_COST,
    ErrorCode_GUILD_CAN_NOT_CHANGE_LEADER_GRADE,
    ErrorCode_GUILD_PROHIBIT_WORDS_IN_NAME,
    ErrorCode_GUILD_PROHIBIT_WORDS_IN_MESSAGE,
    ErrorCode_GUILD_INVALID_NAME_LENGTH,
    ErrorCode_GUILD_INVALID_INTRO_LENGTH,
    ErrorCode_GUILD_INVALID_NOTICE_LENGTH,
    ErrorCode_GUILD_NOT_FOUND_JOIN_REQ,
    ErrorCode_GUILD_CAN_NOT_KICK_SELF,
    ErrorCode_GUILD_LIMIT_MEMBER_GRADE_COUNT,
    ErrorCode_GUILD_CAN_NOT_LEAVE_IN_SEASON_OFF,
    ErrorCode_GUILD_CAN_NOT_ACTION_IN_SEASON_OFF,
    ErrorCode_GUILD_CAN_NOT_KICK_HIGHER_GRADE_MEMBER,
    ErrorCode_GUILD_CAN_NOT_CHANGE_HIGHER_GRADE_MEMBER,
    ErrorCode_GUILD_CAN_NOT_CHANGE_GRADE_TO_HIGHER,
    ErrorCode_GUILD_CAN_NOT_CHANGE_NAME,
    ErrorCode_GUILD_CAN_NOT_JOIN_DIFFERENT_REALM,
    ErrorCode_RVR_NOT_JOINABLE_CONTENTS_TYPE,
    ErrorCode_RVR_NOT_JOINABLE_MAINSTREAM_ID,
    ErrorCode_RVR_NOT_ENOUGH_TIME,
    ErrorCode_RVR_INVALID_CONTROLLER_OBJECT,
    ErrorCode_RVR_ALREADY_RPOCESSING,
    ErrorCode_RVR_INVALID_RVRID,
    ErrorCode_RVR_DISCONNECT_BATTLE_SERVER,
    ErrorCode_RVR_NOT_EXIST_INFO,
    ErrorCode_RVR_DISCORD_EXIST_RVRID,
    ErrorCode_RVR_NOT_JOINABLE_ORDER,
    ErrorCode_RVR_NOT_EXIST_REALM_CONTEXT,
    ErrorCode_RVR_CLOSED_BATTLE_FIELD,
    ErrorCode_RVR_JOINED_OTHER_BATTLE_FIELD,
    ErrorCode_RVR_DEFAULT_FAILED,
    ErrorCode_RVR_CLOSED_BATTLE_FIELD_BRAWL,
    ErrorCode_RVR_TEMPORARY_INSPECT_BRAWL,
    ErrorCode_BUDDY_ALREADY_MAX_BUDDY_COUNT,
    ErrorCode_BUDDY_ALREADY_BUDDY,
    ErrorCode_BUDDY_ALREADY_INVITATION_SEND_BUDDY,
    ErrorCode_BUDDY_ALREADY_INVITATION_RECEIVE_BUDDY,
    ErrorCode_BUDDY_CANNOT_FIND_IVNITATION_FROM_PC,
    ErrorCode_BUDDY_CANNOT_FIND_IVNITATION_TO_PC,
    ErrorCode_BUDDY_DELETE_FAILED_NOT_BUDDY,
    ErrorCode_BUDDY_INVITATION_EXPIRED,
    ErrorCode_BUDDY_SEND_INVITATION_MAX_COUNT,
    ErrorCode_BUDDY_RECEIVE_INVITATION_MAX_COUNT,
    ErrorCode_BUDDY_OTHER_BUDDY_COUNT_ALREADY_MAX,
    ErrorCode_BUDDY_INVALID_BUDDY,
    ErrorCode_SUMMON_REQUEST_FAILED_INVALID_EVENT_STATE,
    ErrorCode_SUMMON_REQUEST_FAILED_CANNOT_FIND_BUDDY,
    ErrorCode_SUMMON_REQUEST_FAILED_INVALID_CHANNEL,
    ErrorCode_SUMMON_REQUEST_FAILED_INVALID_POS,
    ErrorCode_SUMMON_REQUEST_FAILED_INVALID_CONTENTS_TYPE,
    ErrorCode_SUMMON_REQUEST_FAILED_MAX_PC_COUNT_IN_CHANNEL,
    ErrorCode_SUMMON_REQUEST_INVALID_TARGET,
    ErrorCode_SUMMON_REQUEST_FAILED_MAX_COUNT,
    ErrorCode_SUMMON_REQUEST_FAILED_ALREADY_SEND_BUDDY,
    ErrorCode_SUMMON_REQUEST_FAILED_ALREADY_RECEIVE_BUDDY,
    ErrorCode_SUMMON_RECEIVE_FAILED_INVALID_CONTENTS_TYPE,
    ErrorCode_SUMMON_RECEIVE_FAILED_CANNOT_ENTER_SMAP,
    ErrorCode_SUMMON_RECEIVE_FAILED_MAX_COUNT,
    ErrorCode_SUMMON_ACCEPT_FAILED_CALL_EXPIRED,
    ErrorCode_SUMMON_ACCEPT_FAILED_CANNOT_FIND_CHANNEL,
    ErrorCode_SUMMON_ACCEPT_FAILED_CANNOT_FIND_CALLER,
    ErrorCode_MOVE_TO_PC_FAILED_NOT_ENOUGH_TICKET,
    ErrorCode_SUMMON_REQUEST_FAILED_INVALID_MAINSTREAM_ID,
    ErrorCode_SUMMON_ACCEPT_FAILED_INVALID_MAINSTREAM_ID,
    ErrorCode_SUMMON_ACCEPT_FAILED_NOT_ALIVE_STATE,
    ErrorCode_SUMMON_ACCEPT_FAILED_INVALID_EVENT_STATE,
    ErrorCode_MOVE_TO_PC_FAILED_CANNOT_FIND_BUDDY,
    ErrorCode_MOVE_TO_PC_FAILED_INVALID_CHANNEL_STATE,
    ErrorCode_MOVE_TO_PC_FAILED_INVALID_CONTENTS_TYPE_SRC,
    ErrorCode_MOVE_TO_PC_FAILED_INVALID_CONTENTS_TYPE_DES,
    ErrorCode_MOVE_TO_PC_FAILED_INVALID_SMAP,
    ErrorCode_MOVE_TO_PC_FAILED_INVALID_MAINSTREAM_ID,
    ErrorCode_MOVE_TO_PC_FAILED_TARGET_INVALID_MAINSTREAM_ID,
    ErrorCode_MOVE_TO_PC_FAILED_NOT_ALIVE_STATE,
    ErrorCode_MOVE_TO_PC_FAILED_MAX_PC_COUNT_IN_CHANNEL,
    ErrorCode_MOVE_TO_PC_FAILED_INVALID_EVENT_STATE,
    ErrorCode_ALREADY_DENIED_CHARACTER,
    ErrorCode_ALREADY_UNDENIED_CHARACTER,
    ErrorCode_MATCHING_CANCEL_MIN_USER_TIMEOUT,
    ErrorCode_MATCHING_PROMOTION_FAILED_ALREADY_MAX_PC,
    ErrorCode_MATCHING_PROMOTION_FAILED_COOLTIME,
    ErrorCode_MATCHING_FAILED_INVALID_CHANNEL_CONTENTS_TYPE,
    ErrorCode_PUSH_JOIN_FAILED_CANNOT_FIND_PUSH,
    ErrorCode_PUSH_JOIN_FAILED_ALREADY_JOINED_OTHER_MATCH,
    ErrorCode_PUSH_JOINED_FAILED_CANNOT_FIND_MATCHING,
    ErrorCode_PUSH_JOINED_FAILED_ALREADY_FULL,
    ErrorCode_GROUP_MATCHING_FAILED_CANNOT_FIND_TARGET,
    ErrorCode_GROUP_MATCHING_CANNOT_FIND_INVITER_PC,
    ErrorCode_GROUP_MATCHING_CANNOT_FIND_INVITATION,
    ErrorCode_GROUP_MATCHING_START_FAILED_MIN_PC,
    ErrorCode_MATCHING_CANCEL_GROUP_LEADER_LEAVE,
    ErrorCode_GROUP_MATCHING_REMATCHING_FAILED_EXPIRED,
    ErrorCode_GUILD_DUNGEON_GUILD_NOT_JOIN,
    ErrorCode_GUILD_DUNGEON_INVALID_ID,
    ErrorCode_GUILD_DUNGEON_LIMIT_ENTER_COUNT,
    ErrorCode_GUILD_DUNGEON_NOT_ENOUGH_ITEM,
    ErrorCode_GUILD_DUNGEON_LIMIT_ENTER,
    ErrorCode_GUILD_DUNGEON_SEASON_CLOSED,
    ErrorCode_GUILD_DUNGEON_INVALID_SUMMON_TARGET,
    ErrorCode_GUILD_DUNGEON_INVALID_MOVE_TARGET,
    ErrorCode_BRAWL_POINT_FULL,
    ErrorCode_RVR_NOT_ENOUGH_BRAWL_TIME,
    ErrorCode_BRAWL_ENHANCE_FAILED_NOT_ENOUGH_BRAWL_POINT,
    ErrorCode_BRAWL_ENHANCE_FAILED_NOT_ENOUGH_CHANCE_ITEM,
    ErrorCode_BRAWL_ENHANCE_FAILED_CHANCE_ITEM_COUNT_OVERFLOW,
    ErrorCode_BRAWL_ENHANCE_FAILED_ALREADY_MAX_LEVEL,
    ErrorCode_BRAWL_ENHANCE_FAILED_ALREADY_PROCESS,
    ErrorCode_BRAWL_ENHANCE_FAILED_INVALID_LEVEL,
    ErrorCode_SCROLL_QUEST_INVALID_DATA,
    ErrorCode_SCROLL_QUEST_INVALID_SCROLL_ID,
    ErrorCode_SCROLL_QUEST_CREATE_FAILED_ALREADY_HAVE_ANOTHER,
    ErrorCode_SCROLL_QUEST_CREATE_FAILED_LIMIT_DAILY_COUNT,
    ErrorCode_SCROLL_QUEST_CREATE_FAILED_MAINSTERAM,
    ErrorCode_SCROLL_QUEST_REMOVE_FAILED_ALREADY_HAVE_NOTING,
    ErrorCode_SCROLL_QUEST_REMOVE_FAILED_INVALID_STATE_TO_CANCEL,
    ErrorCode_SCROLL_QUEST_REMOVE_FAILED_ALREADY_REMOVED,
    ErrorCode_BRAWL_ENTER_FAILED_REENTER_DELAY,
    ErrorCode_PET_INVEN_FULL,
    ErrorCode_PET_INVALID_PET,
    ErrorCode_PET_INVALID_PET_DATA,
    ErrorCode_PET_SUMMON_FAILED_LIMIT,
    ErrorCode_PET_SUPPORT_FAILED_LIMIT,
    ErrorCode_PET_SUMMON_SUPPORT_FAILED_ALREADY_DOING,
    ErrorCode_PET_SUMMON_RELEASE_FAILED_NOT_SUMMONED,
    ErrorCode_PET_SUPPORT_RELEASE_FAILED_NOT_SUPPORTED,
    ErrorCode_PET_FEED_FAILED_ALREADY_MAX_LEVEL,
    ErrorCode_PET_FEED_FAILED_NOT_FOOD,
    ErrorCode_PET_FEED_FAILED_NOT_EQUIPED,
    ErrorCode_PET_FEED_FAILED_COOLTIME,
    ErrorCode_PET_ALTAR_ACTIVE_SKILL_LEVEL_UP_FAILED_INVALID_LEVEL,
    ErrorCode_PET_HATCHERY_NOT_OPENED_HATCHERY,
    ErrorCode_PET_HATCHERY_SUMMON_FAILED_INVALID_STATE,
    ErrorCode_PET_HATCHERY_HATCH_FAILED_INVALID_STATE,
    ErrorCode_PET_NOT_ENOUGH_ALTAR_POINT,
    ErrorCode_PET_ALTAR_POINT_FULL,
    ErrorCode_PET_FUSION_FAILED_NOT_EQUAL_GRADE,
    ErrorCode_PET_FUSION_FAILED_INVALID_PET_COUNT,
    ErrorCode_CONFLICT_FILED_IS_NOT_CONFLICT_CHANNEL,
    ErrorCode_BATTLE_SERVER_CAN_NOT_MOVE_SMAP
  };
  return values;
}

inline const char *EnumNameErrorCode(ErrorCode e) {
  switch (e) {
    case ErrorCode_NONE: return "NONE";
    case ErrorCode_OK: return "OK";
    case ErrorCode_FAILED: return "FAILED";
    case ErrorCode_DB_FAILED: return "DB_FAILED";
    case ErrorCode_AUTH_ACCOUNT_NAME_FAILED: return "AUTH_ACCOUNT_NAME_FAILED";
    case ErrorCode_AUTH_PASSWORD_FAILED: return "AUTH_PASSWORD_FAILED";
    case ErrorCode_AUTH_NOT_SERVICE_COLONY: return "AUTH_NOT_SERVICE_COLONY";
    case ErrorCode_AUTH_ACCOUNT_BLOCKED: return "AUTH_ACCOUNT_BLOCKED";
    case ErrorCode_AUTH_COUNTRY_BANNED: return "AUTH_COUNTRY_BANNED";
    case ErrorCode_AUTH_CRASH_COLONY: return "AUTH_CRASH_COLONY";
    case ErrorCode_DUPLICATE_PC_NAME: return "DUPLICATE_PC_NAME";
    case ErrorCode_PROHIBIT_WORDS_PC_NAME: return "PROHIBIT_WORDS_PC_NAME";
    case ErrorCode_CANNOT_JOIN_SERVICE: return "CANNOT_JOIN_SERVICE";
    case ErrorCode_RESTRICT_COLONY: return "RESTRICT_COLONY";
    case ErrorCode_DUPLICATE_LOGIN: return "DUPLICATE_LOGIN";
    case ErrorCode_LIMIT_REALM: return "LIMIT_REALM";
    case ErrorCode_ADMIN_TOOL_KICK: return "ADMIN_TOOL_KICK";
    case ErrorCode_UNKNOWN_SYSTEM_ERROR: return "UNKNOWN_SYSTEM_ERROR";
    case ErrorCode_HIVE_ITEM_ALREADY_GIVEN: return "HIVE_ITEM_ALREADY_GIVEN";
    case ErrorCode_ALREADY_LINKED: return "ALREADY_LINKED";
    case ErrorCode_NOT_FOUND_WAITING_LIST: return "NOT_FOUND_WAITING_LIST";
    case ErrorCode_FAILED_CANCEL_WAITING: return "FAILED_CANCEL_WAITING";
    case ErrorCode_FAILED_ADD_WAITING: return "FAILED_ADD_WAITING";
    case ErrorCode_INVALID_RESERVED_NICK_NAME_CODE: return "INVALID_RESERVED_NICK_NAME_CODE";
    case ErrorCode_ALREADY_USED_RESERVED_NICK_NAME_CODE: return "ALREADY_USED_RESERVED_NICK_NAME_CODE";
    case ErrorCode_UNREGISTERED_RESERVED_NICK_NAME_CODE: return "UNREGISTERED_RESERVED_NICK_NAME_CODE";
    case ErrorCode_ALREADY_SELECTED_OTHER_REALM_RESERVED_NICK_NAME_CODE: return "ALREADY_SELECTED_OTHER_REALM_RESERVED_NICK_NAME_CODE";
    case ErrorCode_ALREADY_USED_RESERVED_NICK_NAME_ACCOUNT: return "ALREADY_USED_RESERVED_NICK_NAME_ACCOUNT";
    case ErrorCode_ALREADY_CHAR_JOIN_GUILD: return "ALREADY_CHAR_JOIN_GUILD";
    case ErrorCode_INVALID_PC_CONTROLLER: return "INVALID_PC_CONTROLLER";
    case ErrorCode_INVALID_TEMPLATE_DATA: return "INVALID_TEMPLATE_DATA";
    case ErrorCode_FAILED_DELETE_ITEM: return "FAILED_DELETE_ITEM";
    case ErrorCode_NOT_EXIST_ITEM: return "NOT_EXIST_ITEM";
    case ErrorCode_INVALID_USE_CLASS: return "INVALID_USE_CLASS";
    case ErrorCode_NOT_EQUIPABLE_ITEM: return "NOT_EQUIPABLE_ITEM";
    case ErrorCode_DUPLICATE_EQUIP_EXCLUSIVE_GROUP_ID: return "DUPLICATE_EQUIP_EXCLUSIVE_GROUP_ID";
    case ErrorCode_NOT_ENCHANTABLE_ITEM: return "NOT_ENCHANTABLE_ITEM";
    case ErrorCode_NOT_ENOUGH_GOLD: return "NOT_ENOUGH_GOLD";
    case ErrorCode_ALREADY_EQUIPED_ITEM: return "ALREADY_EQUIPED_ITEM";
    case ErrorCode_NOT_DISENCHANT_ITEM: return "NOT_DISENCHANT_ITEM";
    case ErrorCode_NOT_ENOUGH_STORAGE_SPACE: return "NOT_ENOUGH_STORAGE_SPACE";
    case ErrorCode_NOT_ENOUGH_MATERIAL_ITEM: return "NOT_ENOUGH_MATERIAL_ITEM";
    case ErrorCode_ALREADY_PRESET_ITEM: return "ALREADY_PRESET_ITEM";
    case ErrorCode_NOT_ENOUGH_ITEM: return "NOT_ENOUGH_ITEM";
    case ErrorCode_NOT_UPGRADABLE_ITEM: return "NOT_UPGRADABLE_ITEM";
    case ErrorCode_NOT_ENOUGH_DIA: return "NOT_ENOUGH_DIA";
    case ErrorCode_INVALID_USE_LEVEL: return "INVALID_USE_LEVEL";
    case ErrorCode_NOT_EXIST_MAIL: return "NOT_EXIST_MAIL";
    case ErrorCode_EXPIRED_MAIL: return "EXPIRED_MAIL";
    case ErrorCode_NOT_EXIST_SHOP_PRODUCT: return "NOT_EXIST_SHOP_PRODUCT";
    case ErrorCode_LIMIT_PURCHASABLE_COUNT: return "LIMIT_PURCHASABLE_COUNT";
    case ErrorCode_NOT_ENOUGH_COOLTIME: return "NOT_ENOUGH_COOLTIME";
    case ErrorCode_PURCHASE_UNDER_RANGE_LEVEL: return "PURCHASE_UNDER_RANGE_LEVEL";
    case ErrorCode_PURCHASE_OVER_RANGE_LEVEL: return "PURCHASE_OVER_RANGE_LEVEL";
    case ErrorCode_NOT_DONATE_ITEM: return "NOT_DONATE_ITEM";
    case ErrorCode_OVERRANGE_MASTERY_LEVEL: return "OVERRANGE_MASTERY_LEVEL";
    case ErrorCode_NOT_ENOUGH_ITEM_GRADE: return "NOT_ENOUGH_ITEM_GRADE";
    case ErrorCode_GOLD_IS_FULL: return "GOLD_IS_FULL";
    case ErrorCode_NOT_EQUAL_DONATION_ITEM_TYPE: return "NOT_EQUAL_DONATION_ITEM_TYPE";
    case ErrorCode_EXIST_RECORD_PURCHASE_ITEM: return "EXIST_RECORD_PURCHASE_ITEM";
    case ErrorCode_OVERRANGE_SHOP_COOLTIME: return "OVERRANGE_SHOP_COOLTIME";
    case ErrorCode_NOT_ENOUGH_TICKET: return "NOT_ENOUGH_TICKET";
    case ErrorCode_INVALID_TICKET_TYPE: return "INVALID_TICKET_TYPE";
    case ErrorCode_NOT_EXIST_RECEIVEABLE_MAIL: return "NOT_EXIST_RECEIVEABLE_MAIL";
    case ErrorCode_FAILED_ALL_RECEIVE_MAIL_NOT_ENOUGH_STORAGE: return "FAILED_ALL_RECEIVE_MAIL_NOT_ENOUGH_STORAGE";
    case ErrorCode_EMPTY_MAIL_BOX: return "EMPTY_MAIL_BOX";
    case ErrorCode_EMPTY_REWARD_INFO: return "EMPTY_REWARD_INFO";
    case ErrorCode_NOT_FOUND_MY_RANK: return "NOT_FOUND_MY_RANK";
    case ErrorCode_CAN_NOT_USE_ITEM_STATE: return "CAN_NOT_USE_ITEM_STATE";
    case ErrorCode_FAILED_ALL_USE_ITEM_NOT_ENOUGH_STORAGE: return "FAILED_ALL_USE_ITEM_NOT_ENOUGH_STORAGE";
    case ErrorCode_NOT_AVAILABLE_USED_ITEM_TYPE: return "NOT_AVAILABLE_USED_ITEM_TYPE";
    case ErrorCode_OVER_COUNT_ALL_USE_ITEM: return "OVER_COUNT_ALL_USE_ITEM";
    case ErrorCode_CANT_USE_ITEM_WITH_COOLTIME: return "CANT_USE_ITEM_WITH_COOLTIME";
    case ErrorCode_UNABLE_ACQUIRE_EXP: return "UNABLE_ACQUIRE_EXP";
    case ErrorCode_NOT_MATCH_TRADE_TAX_RATE: return "NOT_MATCH_TRADE_TAX_RATE";
    case ErrorCode_LOWER_THAN_RARE_RATINGS_ARE_NOT_POSSIBLE: return "LOWER_THAN_RARE_RATINGS_ARE_NOT_POSSIBLE";
    case ErrorCode_OVER_COUNT_SLOT_INDEX: return "OVER_COUNT_SLOT_INDEX";
    case ErrorCode_NOT_EXIST_CRYSTAL_IN_SLOT: return "NOT_EXIST_CRYSTAL_IN_SLOT";
    case ErrorCode_NOT_EXIST_ITEM_IN_INVENTORY: return "NOT_EXIST_ITEM_IN_INVENTORY";
    case ErrorCode_MISS_MATCH_ITEM_CATEGORY: return "MISS_MATCH_ITEM_CATEGORY";
    case ErrorCode_ALREADY_EQUIPED_IN_SLOT: return "ALREADY_EQUIPED_IN_SLOT";
    case ErrorCode_MISS_MATCH_CRYSTAL_TYPE: return "MISS_MATCH_CRYSTAL_TYPE";
    case ErrorCode_NOT_REACHED_MAX_LEVEL: return "NOT_REACHED_MAX_LEVEL";
    case ErrorCode_MAX_GRADE: return "MAX_GRADE";
    case ErrorCode_CAN_NOT_UPGRADE: return "CAN_NOT_UPGRADE";
    case ErrorCode_CAN_NOT_LEVEL_UP: return "CAN_NOT_LEVEL_UP";
    case ErrorCode_HIGHEST_LEVEL_OF_THE_GRADE: return "HIGHEST_LEVEL_OF_THE_GRADE";
    case ErrorCode_NOT_EXIST_CHARACTER: return "NOT_EXIST_CHARACTER";
    case ErrorCode_NOT_ENOUGH_CHAT_TERM: return "NOT_ENOUGH_CHAT_TERM";
    case ErrorCode_CAN_NOT_SEND_MESSAGE_FOR_SAME_CHARACTER: return "CAN_NOT_SEND_MESSAGE_FOR_SAME_CHARACTER";
    case ErrorCode_CAN_NOT_SEND_MESSAGE_AT_OUTSIDE_WARFIELD: return "CAN_NOT_SEND_MESSAGE_AT_OUTSIDE_WARFIELD";
    case ErrorCode_OVERRANGE_CHAT_MESSAGE_LENGTH: return "OVERRANGE_CHAT_MESSAGE_LENGTH";
    case ErrorCode_INVALID_CHATTING_TYPE: return "INVALID_CHATTING_TYPE";
    case ErrorCode_UNABLE_CHATTING_CONTENTS_TYPE: return "UNABLE_CHATTING_CONTENTS_TYPE";
    case ErrorCode_INFLUENCE_DAILY_COUNT_OVER: return "INFLUENCE_DAILY_COUNT_OVER";
    case ErrorCode_NOT_EXIST_FOLLOWER: return "NOT_EXIST_FOLLOWER";
    case ErrorCode_FOLLOWER_JOIN_MISSION_OVER_COUNT: return "FOLLOWER_JOIN_MISSION_OVER_COUNT";
    case ErrorCode_FOLLOWER_ALREADY_TO_BE_PLACED: return "FOLLOWER_ALREADY_TO_BE_PLACED";
    case ErrorCode_FOLLOWER_ALREADY_HAS_NOT_MISSION: return "FOLLOWER_ALREADY_HAS_NOT_MISSION";
    case ErrorCode_NOT_ENOUGH_PRISM: return "NOT_ENOUGH_PRISM";
    case ErrorCode_PRISM_IS_FULL: return "PRISM_IS_FULL";
    case ErrorCode_BUY_TRADE_ITEM_NOT_EXIST: return "BUY_TRADE_ITEM_NOT_EXIST";
    case ErrorCode_REG_TRADE_ITEM_IS_FULL: return "REG_TRADE_ITEM_IS_FULL";
    case ErrorCode_BUY_TRADE_ITEM_FAILED: return "BUY_TRADE_ITEM_FAILED";
    case ErrorCode_SHOP_PROUDCT_IS_DISABLED: return "SHOP_PROUDCT_IS_DISABLED";
    case ErrorCode_SHOP_PRODUCT_ALREADY_PURCHASED: return "SHOP_PRODUCT_ALREADY_PURCHASED";
    case ErrorCode_SHOP_PRODUCT_PURCHASE_LIMIT_COUNT_OVER: return "SHOP_PRODUCT_PURCHASE_LIMIT_COUNT_OVER";
    case ErrorCode_NOT_ENOUGH_FORTUNE_POINT: return "NOT_ENOUGH_FORTUNE_POINT";
    case ErrorCode_FORTUNE_POINT_IS_FULL: return "FORTUNE_POINT_IS_FULL";
    case ErrorCode_CANCEL_TRADE_ITEM_NOT_EXIST: return "CANCEL_TRADE_ITEM_NOT_EXIST";
    case ErrorCode_NOT_ENOUGH_GUILD_COIN: return "NOT_ENOUGH_GUILD_COIN";
    case ErrorCode_NOT_ENOUGH_MONARCH_POINT: return "NOT_ENOUGH_MONARCH_POINT";
    case ErrorCode_SHOP_PRODUCT_PURCAHSE_FAILED_CHAR_STATE: return "SHOP_PRODUCT_PURCAHSE_FAILED_CHAR_STATE";
    case ErrorCode_SHOP_PRODUCT_PURCAHSE_FAILED_MAINSTREAM: return "SHOP_PRODUCT_PURCAHSE_FAILED_MAINSTREAM";
    case ErrorCode_SHOP_PRODUCT_PURCAHSE_FAILED_CHAR_LEVEL: return "SHOP_PRODUCT_PURCAHSE_FAILED_CHAR_LEVEL";
    case ErrorCode_SHOP_PRODUCT_PURCAHSE_FAILED_NO_GUILD: return "SHOP_PRODUCT_PURCAHSE_FAILED_NO_GUILD";
    case ErrorCode_SHOP_PRODUCT_PURCAHSE_FAILED_GUILD_LEVEL: return "SHOP_PRODUCT_PURCAHSE_FAILED_GUILD_LEVEL";
    case ErrorCode_SHOP_PRODUCT_PURCAHSE_FAILED_GUILD_MEMBER_RANK: return "SHOP_PRODUCT_PURCAHSE_FAILED_GUILD_MEMBER_RANK";
    case ErrorCode_GUILD_COIN_IS_FULL: return "GUILD_COIN_IS_FULL";
    case ErrorCode_MONARCH_POINT_IS_FULL: return "MONARCH_POINT_IS_FULL";
    case ErrorCode_NOT_ENOUGH_FOLLOWER_SOUL_STONE: return "NOT_ENOUGH_FOLLOWER_SOUL_STONE";
    case ErrorCode_FOLLOWER_ALREADY_FULL_LEVEL: return "FOLLOWER_ALREADY_FULL_LEVEL";
    case ErrorCode_SHOP_PRODUCT_NOT_ENOUGH_BONUS_POINT: return "SHOP_PRODUCT_NOT_ENOUGH_BONUS_POINT";
    case ErrorCode_DIA_IS_FULL: return "DIA_IS_FULL";
    case ErrorCode_NOT_LIVE_EVET_PERIOD: return "NOT_LIVE_EVET_PERIOD";
    case ErrorCode_UPDATING_LIVE_EVENT_DATA: return "UPDATING_LIVE_EVENT_DATA";
    case ErrorCode_NOT_EXIST_LIVE_EVENT_PRODUCT: return "NOT_EXIST_LIVE_EVENT_PRODUCT";
    case ErrorCode_NOT_EXIST_LIVE_EVENT_MISSION: return "NOT_EXIST_LIVE_EVENT_MISSION";
    case ErrorCode_EXCEEDED_LIVE_EVENT_PURCHASE_COUNT: return "EXCEEDED_LIVE_EVENT_PURCHASE_COUNT";
    case ErrorCode_NOT_EXIST_LIVE_EVENT_ATTETION: return "NOT_EXIST_LIVE_EVENT_ATTETION";
    case ErrorCode_FAILED_TO_RECEIVE_ATTENTION_REWARD: return "FAILED_TO_RECEIVE_ATTENTION_REWARD";
    case ErrorCode_CANNOT_RECEIVE_ATTENTION_REWARD: return "CANNOT_RECEIVE_ATTENTION_REWARD";
    case ErrorCode_NOT_EXIST_LIVE_EVENT_ATTENTION_REWARD: return "NOT_EXIST_LIVE_EVENT_ATTENTION_REWARD";
    case ErrorCode_ALREADY_RECEIVE_ATTENTION_REWARD: return "ALREADY_RECEIVE_ATTENTION_REWARD";
    case ErrorCode_NOT_ENOUGH_GROWTH_INHERIT_MATERIAL_ITEM: return "NOT_ENOUGH_GROWTH_INHERIT_MATERIAL_ITEM";
    case ErrorCode_CAN_NOT_INHERIT_DIFFERENT_COSTUME_TYPE: return "CAN_NOT_INHERIT_DIFFERENT_COSTUME_TYPE";
    case ErrorCode_NOT_ENOUGH_JUMPING_COUNT: return "NOT_ENOUGH_JUMPING_COUNT";
    case ErrorCode_NOT_ENOUGH_PVP_COIN: return "NOT_ENOUGH_PVP_COIN";
    case ErrorCode_PVP_COIN_IS_FULL: return "PVP_COIN_IS_FULL";
    case ErrorCode_NOT_FOUND_EVENT_SET: return "NOT_FOUND_EVENT_SET";
    case ErrorCode_INVALID_CHANNEL_STATE: return "INVALID_CHANNEL_STATE";
    case ErrorCode_INVALID_WEEK: return "INVALID_WEEK";
    case ErrorCode_FAILED_ADDITIONAL_ENTER: return "FAILED_ADDITIONAL_ENTER";
    case ErrorCode_INVALID_PAID_TYPE: return "INVALID_PAID_TYPE";
    case ErrorCode_FAILED_DAILY_DUNGEON_INVALID_CHAPTER: return "FAILED_DAILY_DUNGEON_INVALID_CHAPTER";
    case ErrorCode_FAILED_SOLO_DUNGEON_LARGE_CONDITION: return "FAILED_SOLO_DUNGEON_LARGE_CONDITION";
    case ErrorCode_FAILED_SOLO_DUNGEON_MIDDLE_CONDITION: return "FAILED_SOLO_DUNGEON_MIDDLE_CONDITION";
    case ErrorCode_FAILED_SOLO_DUNGEON_STAGE_CONDITION: return "FAILED_SOLO_DUNGEON_STAGE_CONDITION";
    case ErrorCode_FAILED_SOLO_DUNGEON_TODAY_CLEAR_COUNT_OVER: return "FAILED_SOLO_DUNGEON_TODAY_CLEAR_COUNT_OVER";
    case ErrorCode_FAILED_SOLO_DUNGEON_NOT_ENOUGH_TICKET: return "FAILED_SOLO_DUNGEON_NOT_ENOUGH_TICKET";
    case ErrorCode_INVALID_SOLO_DUNGEON_STAGE_ID: return "INVALID_SOLO_DUNGEON_STAGE_ID";
    case ErrorCode_ALREADY_DUNGEON_ENTER_PROCESSING: return "ALREADY_DUNGEON_ENTER_PROCESSING";
    case ErrorCode_ARENA_PLEASE_APPLY_AGAIN_AFTER_A_WHILE: return "ARENA_PLEASE_APPLY_AGAIN_AFTER_A_WHILE";
    case ErrorCode_ARENA_NOT_ENOUGH_ENTER_COUNT: return "ARENA_NOT_ENOUGH_ENTER_COUNT";
    case ErrorCode_ARENA_REWARD_INFO_ERROR: return "ARENA_REWARD_INFO_ERROR";
    case ErrorCode_WORLD_INVALID_EVENT_SET_ID: return "WORLD_INVALID_EVENT_SET_ID";
    case ErrorCode_WORLD_INVALID_EVENT_ID: return "WORLD_INVALID_EVENT_ID";
    case ErrorCode_WORLD_INVALID_CHANNEL: return "WORLD_INVALID_CHANNEL";
    case ErrorCode_WORLD_NO_FIELD_CONTENTS: return "WORLD_NO_FIELD_CONTENTS";
    case ErrorCode_CHANNEL_UNKNOWN: return "CHANNEL_UNKNOWN";
    case ErrorCode_CHANNEL_NOT_EXIST: return "CHANNEL_NOT_EXIST";
    case ErrorCode_CHANNEL_CAN_NOT_MOVE_SMAP: return "CHANNEL_CAN_NOT_MOVE_SMAP";
    case ErrorCode_CHANNEL_CAN_NOT_MOVE_NOW: return "CHANNEL_CAN_NOT_MOVE_NOW";
    case ErrorCode_CHANNEL_USER_COUNT_LIMIT: return "CHANNEL_USER_COUNT_LIMIT";
    case ErrorCode_CHANNEL_MOVE_TIME_LIMIT: return "CHANNEL_MOVE_TIME_LIMIT";
    case ErrorCode_EVENT_NO_EVENT_INSTANCE: return "EVENT_NO_EVENT_INSTANCE";
    case ErrorCode_EVENT_INVALID_DEST_POS: return "EVENT_INVALID_DEST_POS";
    case ErrorCode_EVENT_RETURN_NO_SAVE_POS: return "EVENT_RETURN_NO_SAVE_POS";
    case ErrorCode_EVENT_RETURN_DISCORD_ID: return "EVENT_RETURN_DISCORD_ID";
    case ErrorCode_EVENT_RETURN_DISCORD_SMAP_ID: return "EVENT_RETURN_DISCORD_SMAP_ID";
    case ErrorCode_EVENT_RETURN_NO_FIELD_CONTENT: return "EVENT_RETURN_NO_FIELD_CONTENT";
    case ErrorCode_QUEST_INVALID_ID_FAIL: return "QUEST_INVALID_ID_FAIL";
    case ErrorCode_QUEST_LACK_COUNT_FAIL: return "QUEST_LACK_COUNT_FAIL";
    case ErrorCode_QUEST_ACCEPTED_REWARD_FAIL: return "QUEST_ACCEPTED_REWARD_FAIL";
    case ErrorCode_QUEST_PROCESSING_REWARD_FAIL: return "QUEST_PROCESSING_REWARD_FAIL";
    case ErrorCode_QUEST_DB_UPDATE_FAIL: return "QUEST_DB_UPDATE_FAIL";
    case ErrorCode_ALREADY_HAD_A_QUEST_BONUS_REWARD: return "ALREADY_HAD_A_QUEST_BONUS_REWARD";
    case ErrorCode_INVALID_QUEST_BONUS_ID: return "INVALID_QUEST_BONUS_ID";
    case ErrorCode_FAILED_CONDITION_QUEST_BONUS: return "FAILED_CONDITION_QUEST_BONUS";
    case ErrorCode_CHAPTER_FAIL_INVALID_CHAPTER_INDEX: return "CHAPTER_FAIL_INVALID_CHAPTER_INDEX";
    case ErrorCode_CHAPTER_FAIL_INVALID_ASSIGN_SMAP_ID: return "CHAPTER_FAIL_INVALID_ASSIGN_SMAP_ID";
    case ErrorCode_CHAPTER_FAIL_INVALID_ASSIGN_CINEMA_ID: return "CHAPTER_FAIL_INVALID_ASSIGN_CINEMA_ID";
    case ErrorCode_CHAPTER_FAIL_CLEAR_PREVIOUS_CHAPTER: return "CHAPTER_FAIL_CLEAR_PREVIOUS_CHAPTER";
    case ErrorCode_CHAPTER_FAIL_LACK_FIGHT_POWER: return "CHAPTER_FAIL_LACK_FIGHT_POWER";
    case ErrorCode_CHAPTER_FAIL_LACK_SMAP_RATE: return "CHAPTER_FAIL_LACK_SMAP_RATE";
    case ErrorCode_CHAPTER_FAIL_NO_SEE_CINEMA: return "CHAPTER_FAIL_NO_SEE_CINEMA";
    case ErrorCode_CHAPTER_FAIL_LACK_LEVEL: return "CHAPTER_FAIL_LACK_LEVEL";
    case ErrorCode_CHAPTER_FAIL_LACK_MMAP_RATE: return "CHAPTER_FAIL_LACK_MMAP_RATE";
    case ErrorCode_CHAPTER_FAIL_UPDATE_DB: return "CHAPTER_FAIL_UPDATE_DB";
    case ErrorCode_CHAPTER_FAIL_INVALID_TEMPLTE: return "CHAPTER_FAIL_INVALID_TEMPLTE";
    case ErrorCode_CHAPTER_FAIL_INVALID_PER_DATA: return "CHAPTER_FAIL_INVALID_PER_DATA";
    case ErrorCode_CHAPTER_LESS_LEVEL: return "CHAPTER_LESS_LEVEL";
    case ErrorCode_CHAPTER_LESS_ACHIEVEMENT_RATE: return "CHAPTER_LESS_ACHIEVEMENT_RATE";
    case ErrorCode_CHAPTER_NOT_CLEARED_QUEST: return "CHAPTER_NOT_CLEARED_QUEST";
    case ErrorCode_CHAPTER_NO_NEXT_SMAP: return "CHAPTER_NO_NEXT_SMAP";
    case ErrorCode_CHAPTER_NOT_FOUND_SMAP_CLEAR_TEMPLATE: return "CHAPTER_NOT_FOUND_SMAP_CLEAR_TEMPLATE";
    case ErrorCode_CHAPTER_LOCKED_SMAP: return "CHAPTER_LOCKED_SMAP";
    case ErrorCode_CHAPTER_NOT_CLEARED_MAIN_STREAM: return "CHAPTER_NOT_CLEARED_MAIN_STREAM";
    case ErrorCode_RECOMMEND_NO_LIST: return "RECOMMEND_NO_LIST";
    case ErrorCode_RECOMMEND_EXPIRED_TIME: return "RECOMMEND_EXPIRED_TIME";
    case ErrorCode_RECOMMEND_VOTED_INVALID_PC_DB_ID: return "RECOMMEND_VOTED_INVALID_PC_DB_ID";
    case ErrorCode_RECOMMEND_ALREADY_VOTED: return "RECOMMEND_ALREADY_VOTED";
    case ErrorCode_TRADE_FAIL_ALREADY_TRYING_SEARCH: return "TRADE_FAIL_ALREADY_TRYING_SEARCH";
    case ErrorCode_TRADE_FAIL_SET_ITEM_INVALID_CREATE_TYPE: return "TRADE_FAIL_SET_ITEM_INVALID_CREATE_TYPE";
    case ErrorCode_DUNGEON_NOT_ENOUGH_CLEAR_COUNT: return "DUNGEON_NOT_ENOUGH_CLEAR_COUNT";
    case ErrorCode_PUSH_JOIN_FAILED_NOT_ENOUGH_MATCHING_COUNT: return "PUSH_JOIN_FAILED_NOT_ENOUGH_MATCHING_COUNT";
    case ErrorCode_RAID_JOIN_FAILED_NOT_ENOUGH_COUNT: return "RAID_JOIN_FAILED_NOT_ENOUGH_COUNT";
    case ErrorCode_RAID_JOIN_FAILED_NOT_ENOUGH_COST_ITEM: return "RAID_JOIN_FAILED_NOT_ENOUGH_COST_ITEM";
    case ErrorCode_RAID_JOIN_FAILED_INVALID_CHAPTER: return "RAID_JOIN_FAILED_INVALID_CHAPTER";
    case ErrorCode_DAILY_HW_INVALID_POINT_REWARD_ID: return "DAILY_HW_INVALID_POINT_REWARD_ID";
    case ErrorCode_DAILY_HW_NOT_ENOUGH_POINT_REWARD: return "DAILY_HW_NOT_ENOUGH_POINT_REWARD";
    case ErrorCode_DAILY_HW_COMPLETED_REWARD: return "DAILY_HW_COMPLETED_REWARD";
    case ErrorCode_BONUS_DAILY_RECHARGE_FAILED_ALREADY_REWARDED: return "BONUS_DAILY_RECHARGE_FAILED_ALREADY_REWARDED";
    case ErrorCode_INFINITE_TOWER_INVALID_STAGE: return "INFINITE_TOWER_INVALID_STAGE";
    case ErrorCode_INFINITE_TOWER_INVALID_STAGE_ALREADY_CLEARED: return "INFINITE_TOWER_INVALID_STAGE_ALREADY_CLEARED";
    case ErrorCode_INFINITE_TOWER_ALREADY_REWARDED: return "INFINITE_TOWER_ALREADY_REWARDED";
    case ErrorCode_INFINITE_TOWER_INVALID_PAID_TYPE: return "INFINITE_TOWER_INVALID_PAID_TYPE";
    case ErrorCode_INFINITE_TOWER_INVALID_SWEEP_STAGE: return "INFINITE_TOWER_INVALID_SWEEP_STAGE";
    case ErrorCode_ATTENDANCE_ALREADY_STAMPED: return "ATTENDANCE_ALREADY_STAMPED";
    case ErrorCode_ATTENDANCE_INVALID_BOARD: return "ATTENDANCE_INVALID_BOARD";
    case ErrorCode_ACCESS_TIME_INVALID_TIME: return "ACCESS_TIME_INVALID_TIME";
    case ErrorCode_ACCESS_TIME_ALREADY_TODAY_ALL_REWARDED: return "ACCESS_TIME_ALREADY_TODAY_ALL_REWARDED";
    case ErrorCode_ACCESS_TIME_ALREADY_REWARDED: return "ACCESS_TIME_ALREADY_REWARDED";
    case ErrorCode_ACCESS_TIME_NOT_ENOUGH_TIME: return "ACCESS_TIME_NOT_ENOUGH_TIME";
    case ErrorCode_REST_TIME_NOT_ENOUGH_REST_POINT: return "REST_TIME_NOT_ENOUGH_REST_POINT";
    case ErrorCode_JOIN_FAIL_UNKNOWN: return "JOIN_FAIL_UNKNOWN";
    case ErrorCode_JOIN_FAIL_CHANNELING: return "JOIN_FAIL_CHANNELING";
    case ErrorCode_JOIN_FAIL_NO_SPAWNED: return "JOIN_FAIL_NO_SPAWNED";
    case ErrorCode_JOIN_FAIL_NO_DATA: return "JOIN_FAIL_NO_DATA";
    case ErrorCode_JOIN_FAIL_INVALID_SMAPID: return "JOIN_FAIL_INVALID_SMAPID";
    case ErrorCode_JOIN_FAIL_SAME_SMAPID: return "JOIN_FAIL_SAME_SMAPID";
    case ErrorCode_GOLD_DUNGEON_INVALID_ID: return "GOLD_DUNGEON_INVALID_ID";
    case ErrorCode_GOLD_DUNGEON_LIMIT_ENTER_COUNT: return "GOLD_DUNGEON_LIMIT_ENTER_COUNT";
    case ErrorCode_GOLD_DUNGEON_NOT_ENOUGH_ITEM: return "GOLD_DUNGEON_NOT_ENOUGH_ITEM";
    case ErrorCode_GOLD_DUNGEON_LIMIT_ENTER: return "GOLD_DUNGEON_LIMIT_ENTER";
    case ErrorCode_INTERACT_UNKNOWN: return "INTERACT_UNKNOWN";
    case ErrorCode_INTERACT_CANCEL: return "INTERACT_CANCEL";
    case ErrorCode_INTERACT_INVALID_OBJECT: return "INTERACT_INVALID_OBJECT";
    case ErrorCode_INTERACT_CANNOT_INTERACTION: return "INTERACT_CANNOT_INTERACTION";
    case ErrorCode_INTERACT_TOO_FAR_DISTANCE: return "INTERACT_TOO_FAR_DISTANCE";
    case ErrorCode_INTERACT_OVER_MAX_USER: return "INTERACT_OVER_MAX_USER";
    case ErrorCode_INTERACT_NOT_ENOUGH_COST: return "INTERACT_NOT_ENOUGH_COST";
    case ErrorCode_INTERACT_NOT_ENOUGH_INVEN_SLOT: return "INTERACT_NOT_ENOUGH_INVEN_SLOT";
    case ErrorCode_INTERACT_CANNOT_BY_MAINSTREAM: return "INTERACT_CANNOT_BY_MAINSTREAM";
    case ErrorCode_INTERACT_NOT_ENOUGH_OCCUPIED_TIME: return "INTERACT_NOT_ENOUGH_OCCUPIED_TIME";
    case ErrorCode_INTERACT_BATTLE_FIELD_COLLECTION_COUNT_OVER: return "INTERACT_BATTLE_FIELD_COLLECTION_COUNT_OVER";
    case ErrorCode_INTERACT_INVALID_DATA: return "INTERACT_INVALID_DATA";
    case ErrorCode_INTERACT_CANNOT_FIND_TARGET_OBJECT: return "INTERACT_CANNOT_FIND_TARGET_OBJECT";
    case ErrorCode_INTERACT_CANNOT_ON_DEAD: return "INTERACT_CANNOT_ON_DEAD";
    case ErrorCode_INTERACT_CANNOT_ON_DOING_SOMETHING: return "INTERACT_CANNOT_ON_DOING_SOMETHING";
    case ErrorCode_INTERACT_CANNOT_ALREADY_DOING_WITH_OTHER: return "INTERACT_CANNOT_ALREADY_DOING_WITH_OTHER";
    case ErrorCode_INTERACT_CANNOT_ALREADY_DOING_WITH_THIS: return "INTERACT_CANNOT_ALREADY_DOING_WITH_THIS";
    case ErrorCode_INTERACT_CANNOT_OCCUPIED_OBJECT: return "INTERACT_CANNOT_OCCUPIED_OBJECT";
    case ErrorCode_INTERACT_CANNOT_OBJECT_NOT_SPAWNED: return "INTERACT_CANNOT_OBJECT_NOT_SPAWNED";
    case ErrorCode_INTERACT_CANNOT_REWARDED_ON_DEAD: return "INTERACT_CANNOT_REWARDED_ON_DEAD";
    case ErrorCode_INTERACT_CANNOT_REWARDED_TOO_FAR_DISTANCE: return "INTERACT_CANNOT_REWARDED_TOO_FAR_DISTANCE";
    case ErrorCode_GUILD_UNKNOWN: return "GUILD_UNKNOWN";
    case ErrorCode_GUILD_INVALID_PARAM: return "GUILD_INVALID_PARAM";
    case ErrorCode_GUILD_CANNOT_CREATE_GUILD: return "GUILD_CANNOT_CREATE_GUILD";
    case ErrorCode_GUILD_CANNOT_JOIN_BY_CONDITION: return "GUILD_CANNOT_JOIN_BY_CONDITION";
    case ErrorCode_GUILD_ALREADY_JOINED: return "GUILD_ALREADY_JOINED";
    case ErrorCode_GUILD_CANNOT_JOIN_LIMIT_COUNT: return "GUILD_CANNOT_JOIN_LIMIT_COUNT";
    case ErrorCode_GUILD_ALREADY_JOIN_REQUEST: return "GUILD_ALREADY_JOIN_REQUEST";
    case ErrorCode_GUILD_CANNOT_LEAVE_LEADER: return "GUILD_CANNOT_LEAVE_LEADER";
    case ErrorCode_GUILD_CANNOT_KICK_LEADER: return "GUILD_CANNOT_KICK_LEADER";
    case ErrorCode_GUILD_CANNOT_LEADER_DELETE_PC: return "GUILD_CANNOT_LEADER_DELETE_PC";
    case ErrorCode_GUILD_DO_NOT_HAVE_PERMISSION: return "GUILD_DO_NOT_HAVE_PERMISSION";
    case ErrorCode_GUILD_NAME_DUPLICATED: return "GUILD_NAME_DUPLICATED";
    case ErrorCode_GUILD_NOT_JOIN: return "GUILD_NOT_JOIN";
    case ErrorCode_GUILD_MEMBER_NOT_EMPTY: return "GUILD_MEMBER_NOT_EMPTY";
    case ErrorCode_GUILD_NOT_FOUND_MY_GUILD: return "GUILD_NOT_FOUND_MY_GUILD";
    case ErrorCode_GUILD_NOT_MEMBER: return "GUILD_NOT_MEMBER";
    case ErrorCode_GUILD_ALREADY_ATTEND: return "GUILD_ALREADY_ATTEND";
    case ErrorCode_GUILD_NOT_FOUND: return "GUILD_NOT_FOUND";
    case ErrorCode_GUILD_CAN_NOT_CHANGE_SAME_MEMBER_GRADE: return "GUILD_CAN_NOT_CHANGE_SAME_MEMBER_GRADE";
    case ErrorCode_GUILD_BUFF_MAX_LEVEL: return "GUILD_BUFF_MAX_LEVEL";
    case ErrorCode_GUILD_BUFF_CAN_NOT_PURCHASE: return "GUILD_BUFF_CAN_NOT_PURCHASE";
    case ErrorCode_GUILD_INVALID_PAGE_NUMBER: return "GUILD_INVALID_PAGE_NUMBER";
    case ErrorCode_GUILD_CAN_NOT_JOIN_OR_CREATE_YET: return "GUILD_CAN_NOT_JOIN_OR_CREATE_YET";
    case ErrorCode_GUILD_INVALID_CADIDATE_LEADER: return "GUILD_INVALID_CADIDATE_LEADER";
    case ErrorCode_GUILD_CAN_NOT_CHANGE_MY_GRADE: return "GUILD_CAN_NOT_CHANGE_MY_GRADE";
    case ErrorCode_GUILD_MAX_APPLICANT: return "GUILD_MAX_APPLICANT";
    case ErrorCode_GUILD_MAX_JOIN_REQUEST: return "GUILD_MAX_JOIN_REQUEST";
    case ErrorCode_GUILD_LEVEL_LIMIT: return "GUILD_LEVEL_LIMIT";
    case ErrorCode_GUILD_MAX_LEVEL: return "GUILD_MAX_LEVEL";
    case ErrorCode_GUILD_NOT_ENOUGH_EXP: return "GUILD_NOT_ENOUGH_EXP";
    case ErrorCode_GUILD_NOT_ENOUGH_COST: return "GUILD_NOT_ENOUGH_COST";
    case ErrorCode_GUILD_CAN_NOT_CHANGE_LEADER_GRADE: return "GUILD_CAN_NOT_CHANGE_LEADER_GRADE";
    case ErrorCode_GUILD_PROHIBIT_WORDS_IN_NAME: return "GUILD_PROHIBIT_WORDS_IN_NAME";
    case ErrorCode_GUILD_PROHIBIT_WORDS_IN_MESSAGE: return "GUILD_PROHIBIT_WORDS_IN_MESSAGE";
    case ErrorCode_GUILD_INVALID_NAME_LENGTH: return "GUILD_INVALID_NAME_LENGTH";
    case ErrorCode_GUILD_INVALID_INTRO_LENGTH: return "GUILD_INVALID_INTRO_LENGTH";
    case ErrorCode_GUILD_INVALID_NOTICE_LENGTH: return "GUILD_INVALID_NOTICE_LENGTH";
    case ErrorCode_GUILD_NOT_FOUND_JOIN_REQ: return "GUILD_NOT_FOUND_JOIN_REQ";
    case ErrorCode_GUILD_CAN_NOT_KICK_SELF: return "GUILD_CAN_NOT_KICK_SELF";
    case ErrorCode_GUILD_LIMIT_MEMBER_GRADE_COUNT: return "GUILD_LIMIT_MEMBER_GRADE_COUNT";
    case ErrorCode_GUILD_CAN_NOT_LEAVE_IN_SEASON_OFF: return "GUILD_CAN_NOT_LEAVE_IN_SEASON_OFF";
    case ErrorCode_GUILD_CAN_NOT_ACTION_IN_SEASON_OFF: return "GUILD_CAN_NOT_ACTION_IN_SEASON_OFF";
    case ErrorCode_GUILD_CAN_NOT_KICK_HIGHER_GRADE_MEMBER: return "GUILD_CAN_NOT_KICK_HIGHER_GRADE_MEMBER";
    case ErrorCode_GUILD_CAN_NOT_CHANGE_HIGHER_GRADE_MEMBER: return "GUILD_CAN_NOT_CHANGE_HIGHER_GRADE_MEMBER";
    case ErrorCode_GUILD_CAN_NOT_CHANGE_GRADE_TO_HIGHER: return "GUILD_CAN_NOT_CHANGE_GRADE_TO_HIGHER";
    case ErrorCode_GUILD_CAN_NOT_CHANGE_NAME: return "GUILD_CAN_NOT_CHANGE_NAME";
    case ErrorCode_GUILD_CAN_NOT_JOIN_DIFFERENT_REALM: return "GUILD_CAN_NOT_JOIN_DIFFERENT_REALM";
    case ErrorCode_RVR_NOT_JOINABLE_CONTENTS_TYPE: return "RVR_NOT_JOINABLE_CONTENTS_TYPE";
    case ErrorCode_RVR_NOT_JOINABLE_MAINSTREAM_ID: return "RVR_NOT_JOINABLE_MAINSTREAM_ID";
    case ErrorCode_RVR_NOT_ENOUGH_TIME: return "RVR_NOT_ENOUGH_TIME";
    case ErrorCode_RVR_INVALID_CONTROLLER_OBJECT: return "RVR_INVALID_CONTROLLER_OBJECT";
    case ErrorCode_RVR_ALREADY_RPOCESSING: return "RVR_ALREADY_RPOCESSING";
    case ErrorCode_RVR_INVALID_RVRID: return "RVR_INVALID_RVRID";
    case ErrorCode_RVR_DISCONNECT_BATTLE_SERVER: return "RVR_DISCONNECT_BATTLE_SERVER";
    case ErrorCode_RVR_NOT_EXIST_INFO: return "RVR_NOT_EXIST_INFO";
    case ErrorCode_RVR_DISCORD_EXIST_RVRID: return "RVR_DISCORD_EXIST_RVRID";
    case ErrorCode_RVR_NOT_JOINABLE_ORDER: return "RVR_NOT_JOINABLE_ORDER";
    case ErrorCode_RVR_NOT_EXIST_REALM_CONTEXT: return "RVR_NOT_EXIST_REALM_CONTEXT";
    case ErrorCode_RVR_CLOSED_BATTLE_FIELD: return "RVR_CLOSED_BATTLE_FIELD";
    case ErrorCode_RVR_JOINED_OTHER_BATTLE_FIELD: return "RVR_JOINED_OTHER_BATTLE_FIELD";
    case ErrorCode_RVR_DEFAULT_FAILED: return "RVR_DEFAULT_FAILED";
    case ErrorCode_RVR_CLOSED_BATTLE_FIELD_BRAWL: return "RVR_CLOSED_BATTLE_FIELD_BRAWL";
    case ErrorCode_RVR_TEMPORARY_INSPECT_BRAWL: return "RVR_TEMPORARY_INSPECT_BRAWL";
    case ErrorCode_BUDDY_ALREADY_MAX_BUDDY_COUNT: return "BUDDY_ALREADY_MAX_BUDDY_COUNT";
    case ErrorCode_BUDDY_ALREADY_BUDDY: return "BUDDY_ALREADY_BUDDY";
    case ErrorCode_BUDDY_ALREADY_INVITATION_SEND_BUDDY: return "BUDDY_ALREADY_INVITATION_SEND_BUDDY";
    case ErrorCode_BUDDY_ALREADY_INVITATION_RECEIVE_BUDDY: return "BUDDY_ALREADY_INVITATION_RECEIVE_BUDDY";
    case ErrorCode_BUDDY_CANNOT_FIND_IVNITATION_FROM_PC: return "BUDDY_CANNOT_FIND_IVNITATION_FROM_PC";
    case ErrorCode_BUDDY_CANNOT_FIND_IVNITATION_TO_PC: return "BUDDY_CANNOT_FIND_IVNITATION_TO_PC";
    case ErrorCode_BUDDY_DELETE_FAILED_NOT_BUDDY: return "BUDDY_DELETE_FAILED_NOT_BUDDY";
    case ErrorCode_BUDDY_INVITATION_EXPIRED: return "BUDDY_INVITATION_EXPIRED";
    case ErrorCode_BUDDY_SEND_INVITATION_MAX_COUNT: return "BUDDY_SEND_INVITATION_MAX_COUNT";
    case ErrorCode_BUDDY_RECEIVE_INVITATION_MAX_COUNT: return "BUDDY_RECEIVE_INVITATION_MAX_COUNT";
    case ErrorCode_BUDDY_OTHER_BUDDY_COUNT_ALREADY_MAX: return "BUDDY_OTHER_BUDDY_COUNT_ALREADY_MAX";
    case ErrorCode_BUDDY_INVALID_BUDDY: return "BUDDY_INVALID_BUDDY";
    case ErrorCode_SUMMON_REQUEST_FAILED_INVALID_EVENT_STATE: return "SUMMON_REQUEST_FAILED_INVALID_EVENT_STATE";
    case ErrorCode_SUMMON_REQUEST_FAILED_CANNOT_FIND_BUDDY: return "SUMMON_REQUEST_FAILED_CANNOT_FIND_BUDDY";
    case ErrorCode_SUMMON_REQUEST_FAILED_INVALID_CHANNEL: return "SUMMON_REQUEST_FAILED_INVALID_CHANNEL";
    case ErrorCode_SUMMON_REQUEST_FAILED_INVALID_POS: return "SUMMON_REQUEST_FAILED_INVALID_POS";
    case ErrorCode_SUMMON_REQUEST_FAILED_INVALID_CONTENTS_TYPE: return "SUMMON_REQUEST_FAILED_INVALID_CONTENTS_TYPE";
    case ErrorCode_SUMMON_REQUEST_FAILED_MAX_PC_COUNT_IN_CHANNEL: return "SUMMON_REQUEST_FAILED_MAX_PC_COUNT_IN_CHANNEL";
    case ErrorCode_SUMMON_REQUEST_INVALID_TARGET: return "SUMMON_REQUEST_INVALID_TARGET";
    case ErrorCode_SUMMON_REQUEST_FAILED_MAX_COUNT: return "SUMMON_REQUEST_FAILED_MAX_COUNT";
    case ErrorCode_SUMMON_REQUEST_FAILED_ALREADY_SEND_BUDDY: return "SUMMON_REQUEST_FAILED_ALREADY_SEND_BUDDY";
    case ErrorCode_SUMMON_REQUEST_FAILED_ALREADY_RECEIVE_BUDDY: return "SUMMON_REQUEST_FAILED_ALREADY_RECEIVE_BUDDY";
    case ErrorCode_SUMMON_RECEIVE_FAILED_INVALID_CONTENTS_TYPE: return "SUMMON_RECEIVE_FAILED_INVALID_CONTENTS_TYPE";
    case ErrorCode_SUMMON_RECEIVE_FAILED_CANNOT_ENTER_SMAP: return "SUMMON_RECEIVE_FAILED_CANNOT_ENTER_SMAP";
    case ErrorCode_SUMMON_RECEIVE_FAILED_MAX_COUNT: return "SUMMON_RECEIVE_FAILED_MAX_COUNT";
    case ErrorCode_SUMMON_ACCEPT_FAILED_CALL_EXPIRED: return "SUMMON_ACCEPT_FAILED_CALL_EXPIRED";
    case ErrorCode_SUMMON_ACCEPT_FAILED_CANNOT_FIND_CHANNEL: return "SUMMON_ACCEPT_FAILED_CANNOT_FIND_CHANNEL";
    case ErrorCode_SUMMON_ACCEPT_FAILED_CANNOT_FIND_CALLER: return "SUMMON_ACCEPT_FAILED_CANNOT_FIND_CALLER";
    case ErrorCode_MOVE_TO_PC_FAILED_NOT_ENOUGH_TICKET: return "MOVE_TO_PC_FAILED_NOT_ENOUGH_TICKET";
    case ErrorCode_SUMMON_REQUEST_FAILED_INVALID_MAINSTREAM_ID: return "SUMMON_REQUEST_FAILED_INVALID_MAINSTREAM_ID";
    case ErrorCode_SUMMON_ACCEPT_FAILED_INVALID_MAINSTREAM_ID: return "SUMMON_ACCEPT_FAILED_INVALID_MAINSTREAM_ID";
    case ErrorCode_SUMMON_ACCEPT_FAILED_NOT_ALIVE_STATE: return "SUMMON_ACCEPT_FAILED_NOT_ALIVE_STATE";
    case ErrorCode_SUMMON_ACCEPT_FAILED_INVALID_EVENT_STATE: return "SUMMON_ACCEPT_FAILED_INVALID_EVENT_STATE";
    case ErrorCode_MOVE_TO_PC_FAILED_CANNOT_FIND_BUDDY: return "MOVE_TO_PC_FAILED_CANNOT_FIND_BUDDY";
    case ErrorCode_MOVE_TO_PC_FAILED_INVALID_CHANNEL_STATE: return "MOVE_TO_PC_FAILED_INVALID_CHANNEL_STATE";
    case ErrorCode_MOVE_TO_PC_FAILED_INVALID_CONTENTS_TYPE_SRC: return "MOVE_TO_PC_FAILED_INVALID_CONTENTS_TYPE_SRC";
    case ErrorCode_MOVE_TO_PC_FAILED_INVALID_CONTENTS_TYPE_DES: return "MOVE_TO_PC_FAILED_INVALID_CONTENTS_TYPE_DES";
    case ErrorCode_MOVE_TO_PC_FAILED_INVALID_SMAP: return "MOVE_TO_PC_FAILED_INVALID_SMAP";
    case ErrorCode_MOVE_TO_PC_FAILED_INVALID_MAINSTREAM_ID: return "MOVE_TO_PC_FAILED_INVALID_MAINSTREAM_ID";
    case ErrorCode_MOVE_TO_PC_FAILED_TARGET_INVALID_MAINSTREAM_ID: return "MOVE_TO_PC_FAILED_TARGET_INVALID_MAINSTREAM_ID";
    case ErrorCode_MOVE_TO_PC_FAILED_NOT_ALIVE_STATE: return "MOVE_TO_PC_FAILED_NOT_ALIVE_STATE";
    case ErrorCode_MOVE_TO_PC_FAILED_MAX_PC_COUNT_IN_CHANNEL: return "MOVE_TO_PC_FAILED_MAX_PC_COUNT_IN_CHANNEL";
    case ErrorCode_MOVE_TO_PC_FAILED_INVALID_EVENT_STATE: return "MOVE_TO_PC_FAILED_INVALID_EVENT_STATE";
    case ErrorCode_ALREADY_DENIED_CHARACTER: return "ALREADY_DENIED_CHARACTER";
    case ErrorCode_ALREADY_UNDENIED_CHARACTER: return "ALREADY_UNDENIED_CHARACTER";
    case ErrorCode_MATCHING_CANCEL_MIN_USER_TIMEOUT: return "MATCHING_CANCEL_MIN_USER_TIMEOUT";
    case ErrorCode_MATCHING_PROMOTION_FAILED_ALREADY_MAX_PC: return "MATCHING_PROMOTION_FAILED_ALREADY_MAX_PC";
    case ErrorCode_MATCHING_PROMOTION_FAILED_COOLTIME: return "MATCHING_PROMOTION_FAILED_COOLTIME";
    case ErrorCode_MATCHING_FAILED_INVALID_CHANNEL_CONTENTS_TYPE: return "MATCHING_FAILED_INVALID_CHANNEL_CONTENTS_TYPE";
    case ErrorCode_PUSH_JOIN_FAILED_CANNOT_FIND_PUSH: return "PUSH_JOIN_FAILED_CANNOT_FIND_PUSH";
    case ErrorCode_PUSH_JOIN_FAILED_ALREADY_JOINED_OTHER_MATCH: return "PUSH_JOIN_FAILED_ALREADY_JOINED_OTHER_MATCH";
    case ErrorCode_PUSH_JOINED_FAILED_CANNOT_FIND_MATCHING: return "PUSH_JOINED_FAILED_CANNOT_FIND_MATCHING";
    case ErrorCode_PUSH_JOINED_FAILED_ALREADY_FULL: return "PUSH_JOINED_FAILED_ALREADY_FULL";
    case ErrorCode_GROUP_MATCHING_FAILED_CANNOT_FIND_TARGET: return "GROUP_MATCHING_FAILED_CANNOT_FIND_TARGET";
    case ErrorCode_GROUP_MATCHING_CANNOT_FIND_INVITER_PC: return "GROUP_MATCHING_CANNOT_FIND_INVITER_PC";
    case ErrorCode_GROUP_MATCHING_CANNOT_FIND_INVITATION: return "GROUP_MATCHING_CANNOT_FIND_INVITATION";
    case ErrorCode_GROUP_MATCHING_START_FAILED_MIN_PC: return "GROUP_MATCHING_START_FAILED_MIN_PC";
    case ErrorCode_MATCHING_CANCEL_GROUP_LEADER_LEAVE: return "MATCHING_CANCEL_GROUP_LEADER_LEAVE";
    case ErrorCode_GROUP_MATCHING_REMATCHING_FAILED_EXPIRED: return "GROUP_MATCHING_REMATCHING_FAILED_EXPIRED";
    case ErrorCode_GUILD_DUNGEON_GUILD_NOT_JOIN: return "GUILD_DUNGEON_GUILD_NOT_JOIN";
    case ErrorCode_GUILD_DUNGEON_INVALID_ID: return "GUILD_DUNGEON_INVALID_ID";
    case ErrorCode_GUILD_DUNGEON_LIMIT_ENTER_COUNT: return "GUILD_DUNGEON_LIMIT_ENTER_COUNT";
    case ErrorCode_GUILD_DUNGEON_NOT_ENOUGH_ITEM: return "GUILD_DUNGEON_NOT_ENOUGH_ITEM";
    case ErrorCode_GUILD_DUNGEON_LIMIT_ENTER: return "GUILD_DUNGEON_LIMIT_ENTER";
    case ErrorCode_GUILD_DUNGEON_SEASON_CLOSED: return "GUILD_DUNGEON_SEASON_CLOSED";
    case ErrorCode_GUILD_DUNGEON_INVALID_SUMMON_TARGET: return "GUILD_DUNGEON_INVALID_SUMMON_TARGET";
    case ErrorCode_GUILD_DUNGEON_INVALID_MOVE_TARGET: return "GUILD_DUNGEON_INVALID_MOVE_TARGET";
    case ErrorCode_BRAWL_POINT_FULL: return "BRAWL_POINT_FULL";
    case ErrorCode_RVR_NOT_ENOUGH_BRAWL_TIME: return "RVR_NOT_ENOUGH_BRAWL_TIME";
    case ErrorCode_BRAWL_ENHANCE_FAILED_NOT_ENOUGH_BRAWL_POINT: return "BRAWL_ENHANCE_FAILED_NOT_ENOUGH_BRAWL_POINT";
    case ErrorCode_BRAWL_ENHANCE_FAILED_NOT_ENOUGH_CHANCE_ITEM: return "BRAWL_ENHANCE_FAILED_NOT_ENOUGH_CHANCE_ITEM";
    case ErrorCode_BRAWL_ENHANCE_FAILED_CHANCE_ITEM_COUNT_OVERFLOW: return "BRAWL_ENHANCE_FAILED_CHANCE_ITEM_COUNT_OVERFLOW";
    case ErrorCode_BRAWL_ENHANCE_FAILED_ALREADY_MAX_LEVEL: return "BRAWL_ENHANCE_FAILED_ALREADY_MAX_LEVEL";
    case ErrorCode_BRAWL_ENHANCE_FAILED_ALREADY_PROCESS: return "BRAWL_ENHANCE_FAILED_ALREADY_PROCESS";
    case ErrorCode_BRAWL_ENHANCE_FAILED_INVALID_LEVEL: return "BRAWL_ENHANCE_FAILED_INVALID_LEVEL";
    case ErrorCode_SCROLL_QUEST_INVALID_DATA: return "SCROLL_QUEST_INVALID_DATA";
    case ErrorCode_SCROLL_QUEST_INVALID_SCROLL_ID: return "SCROLL_QUEST_INVALID_SCROLL_ID";
    case ErrorCode_SCROLL_QUEST_CREATE_FAILED_ALREADY_HAVE_ANOTHER: return "SCROLL_QUEST_CREATE_FAILED_ALREADY_HAVE_ANOTHER";
    case ErrorCode_SCROLL_QUEST_CREATE_FAILED_LIMIT_DAILY_COUNT: return "SCROLL_QUEST_CREATE_FAILED_LIMIT_DAILY_COUNT";
    case ErrorCode_SCROLL_QUEST_CREATE_FAILED_MAINSTERAM: return "SCROLL_QUEST_CREATE_FAILED_MAINSTERAM";
    case ErrorCode_SCROLL_QUEST_REMOVE_FAILED_ALREADY_HAVE_NOTING: return "SCROLL_QUEST_REMOVE_FAILED_ALREADY_HAVE_NOTING";
    case ErrorCode_SCROLL_QUEST_REMOVE_FAILED_INVALID_STATE_TO_CANCEL: return "SCROLL_QUEST_REMOVE_FAILED_INVALID_STATE_TO_CANCEL";
    case ErrorCode_SCROLL_QUEST_REMOVE_FAILED_ALREADY_REMOVED: return "SCROLL_QUEST_REMOVE_FAILED_ALREADY_REMOVED";
    case ErrorCode_BRAWL_ENTER_FAILED_REENTER_DELAY: return "BRAWL_ENTER_FAILED_REENTER_DELAY";
    case ErrorCode_PET_INVEN_FULL: return "PET_INVEN_FULL";
    case ErrorCode_PET_INVALID_PET: return "PET_INVALID_PET";
    case ErrorCode_PET_INVALID_PET_DATA: return "PET_INVALID_PET_DATA";
    case ErrorCode_PET_SUMMON_FAILED_LIMIT: return "PET_SUMMON_FAILED_LIMIT";
    case ErrorCode_PET_SUPPORT_FAILED_LIMIT: return "PET_SUPPORT_FAILED_LIMIT";
    case ErrorCode_PET_SUMMON_SUPPORT_FAILED_ALREADY_DOING: return "PET_SUMMON_SUPPORT_FAILED_ALREADY_DOING";
    case ErrorCode_PET_SUMMON_RELEASE_FAILED_NOT_SUMMONED: return "PET_SUMMON_RELEASE_FAILED_NOT_SUMMONED";
    case ErrorCode_PET_SUPPORT_RELEASE_FAILED_NOT_SUPPORTED: return "PET_SUPPORT_RELEASE_FAILED_NOT_SUPPORTED";
    case ErrorCode_PET_FEED_FAILED_ALREADY_MAX_LEVEL: return "PET_FEED_FAILED_ALREADY_MAX_LEVEL";
    case ErrorCode_PET_FEED_FAILED_NOT_FOOD: return "PET_FEED_FAILED_NOT_FOOD";
    case ErrorCode_PET_FEED_FAILED_NOT_EQUIPED: return "PET_FEED_FAILED_NOT_EQUIPED";
    case ErrorCode_PET_FEED_FAILED_COOLTIME: return "PET_FEED_FAILED_COOLTIME";
    case ErrorCode_PET_ALTAR_ACTIVE_SKILL_LEVEL_UP_FAILED_INVALID_LEVEL: return "PET_ALTAR_ACTIVE_SKILL_LEVEL_UP_FAILED_INVALID_LEVEL";
    case ErrorCode_PET_HATCHERY_NOT_OPENED_HATCHERY: return "PET_HATCHERY_NOT_OPENED_HATCHERY";
    case ErrorCode_PET_HATCHERY_SUMMON_FAILED_INVALID_STATE: return "PET_HATCHERY_SUMMON_FAILED_INVALID_STATE";
    case ErrorCode_PET_HATCHERY_HATCH_FAILED_INVALID_STATE: return "PET_HATCHERY_HATCH_FAILED_INVALID_STATE";
    case ErrorCode_PET_NOT_ENOUGH_ALTAR_POINT: return "PET_NOT_ENOUGH_ALTAR_POINT";
    case ErrorCode_PET_ALTAR_POINT_FULL: return "PET_ALTAR_POINT_FULL";
    case ErrorCode_PET_FUSION_FAILED_NOT_EQUAL_GRADE: return "PET_FUSION_FAILED_NOT_EQUAL_GRADE";
    case ErrorCode_PET_FUSION_FAILED_INVALID_PET_COUNT: return "PET_FUSION_FAILED_INVALID_PET_COUNT";
    case ErrorCode_CONFLICT_FILED_IS_NOT_CONFLICT_CHANNEL: return "CONFLICT_FILED_IS_NOT_CONFLICT_CHANNEL";
    case ErrorCode_BATTLE_SERVER_CAN_NOT_MOVE_SMAP: return "BATTLE_SERVER_CAN_NOT_MOVE_SMAP";
    default: return "";
  }
}

/// 스폰 이유
enum SpawnReason {
  /// 스폰됨
  SpawnReason_SP_ON_SPAWNED = 0  /// 시야에 나타남
,
  SpawnReason_SP_ON_VIEWIN = 1,
  SpawnReason_MIN = SpawnReason_SP_ON_SPAWNED,
  SpawnReason_MAX = SpawnReason_SP_ON_VIEWIN
};

inline const SpawnReason (&EnumValuesSpawnReason())[2] {
  static const SpawnReason values[] = {
    SpawnReason_SP_ON_SPAWNED,
    SpawnReason_SP_ON_VIEWIN
  };
  return values;
}

inline const char * const *EnumNamesSpawnReason() {
  static const char * const names[] = {
    "SP_ON_SPAWNED",
    "SP_ON_VIEWIN",
    nullptr
  };
  return names;
}

inline const char *EnumNameSpawnReason(SpawnReason e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesSpawnReason()[index];
}

/// 디스폰 이유
enum DespawnReason {
  /// 디스폰됨
  DespawnReason_DP_ON_DESPAWNED = 0  /// 시야에서 벗어남
,
  DespawnReason_DP_ON_VIEWOUT = 1,
  DespawnReason_MIN = DespawnReason_DP_ON_DESPAWNED,
  DespawnReason_MAX = DespawnReason_DP_ON_VIEWOUT
};

inline const DespawnReason (&EnumValuesDespawnReason())[2] {
  static const DespawnReason values[] = {
    DespawnReason_DP_ON_DESPAWNED,
    DespawnReason_DP_ON_VIEWOUT
  };
  return values;
}

inline const char * const *EnumNamesDespawnReason() {
  static const char * const names[] = {
    "DP_ON_DESPAWNED",
    "DP_ON_VIEWOUT",
    nullptr
  };
  return names;
}

inline const char *EnumNameDespawnReason(DespawnReason e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesDespawnReason()[index];
}

/// 컨텐츠 타입
enum ContentsType {
  ContentsType_CONTENTS_TYPE_NONE = 0,
  ContentsType_CONTENTS_TYPE_TOWN = 1,
  ContentsType_CONTENTS_TYPE_FIELD = 2,
  ContentsType_CONTENTS_TYPE_MISSION = 3,
  ContentsType_CONTENTS_TYPE_DAILY_DUNGEON = 4,
  ContentsType_CONTENTS_TYPE_SINGLE_EVENT = 5,
  ContentsType_CONTENTS_TYPE_ARENA = 6,
  ContentsType_CONTENTS_TYPE_RAID = 7,
  ContentsType_CONTENTS_TYPE_TUTORIAL = 8,
  ContentsType_CONTENTS_TYPE_BOSS = 9,
  ContentsType_CONTENTS_TYPE_GOLD_DUNGEON = 10,
  ContentsType_CONTENTS_TYPE_ILLIMITABLE_TOWER = 11,
  ContentsType_CONTENTS_TYPE_BATTLE_FIELD = 12,
  ContentsType_CONTENTS_TYPE_GUILD_DUNGEON = 13,
  ContentsType_CONTENTS_TYPE_BRAWL = 14,
  ContentsType_CONTENTS_TYPE_CONFLICT_FIELD = 15,
  ContentsType_CONTENTS_TYPE_MAX = 16,
  ContentsType_MIN = ContentsType_CONTENTS_TYPE_NONE,
  ContentsType_MAX = ContentsType_CONTENTS_TYPE_MAX
};

inline const ContentsType (&EnumValuesContentsType())[17] {
  static const ContentsType values[] = {
    ContentsType_CONTENTS_TYPE_NONE,
    ContentsType_CONTENTS_TYPE_TOWN,
    ContentsType_CONTENTS_TYPE_FIELD,
    ContentsType_CONTENTS_TYPE_MISSION,
    ContentsType_CONTENTS_TYPE_DAILY_DUNGEON,
    ContentsType_CONTENTS_TYPE_SINGLE_EVENT,
    ContentsType_CONTENTS_TYPE_ARENA,
    ContentsType_CONTENTS_TYPE_RAID,
    ContentsType_CONTENTS_TYPE_TUTORIAL,
    ContentsType_CONTENTS_TYPE_BOSS,
    ContentsType_CONTENTS_TYPE_GOLD_DUNGEON,
    ContentsType_CONTENTS_TYPE_ILLIMITABLE_TOWER,
    ContentsType_CONTENTS_TYPE_BATTLE_FIELD,
    ContentsType_CONTENTS_TYPE_GUILD_DUNGEON,
    ContentsType_CONTENTS_TYPE_BRAWL,
    ContentsType_CONTENTS_TYPE_CONFLICT_FIELD,
    ContentsType_CONTENTS_TYPE_MAX
  };
  return values;
}

inline const char * const *EnumNamesContentsType() {
  static const char * const names[] = {
    "CONTENTS_TYPE_NONE",
    "CONTENTS_TYPE_TOWN",
    "CONTENTS_TYPE_FIELD",
    "CONTENTS_TYPE_MISSION",
    "CONTENTS_TYPE_DAILY_DUNGEON",
    "CONTENTS_TYPE_SINGLE_EVENT",
    "CONTENTS_TYPE_ARENA",
    "CONTENTS_TYPE_RAID",
    "CONTENTS_TYPE_TUTORIAL",
    "CONTENTS_TYPE_BOSS",
    "CONTENTS_TYPE_GOLD_DUNGEON",
    "CONTENTS_TYPE_ILLIMITABLE_TOWER",
    "CONTENTS_TYPE_BATTLE_FIELD",
    "CONTENTS_TYPE_GUILD_DUNGEON",
    "CONTENTS_TYPE_BRAWL",
    "CONTENTS_TYPE_CONFLICT_FIELD",
    "CONTENTS_TYPE_MAX",
    nullptr
  };
  return names;
}

inline const char *EnumNameContentsType(ContentsType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesContentsType()[index];
}

enum ArenaSpendType {
  ArenaSpendType_ArenaSpendType_freeTicket = 0,
  ArenaSpendType_ArenaSpendType_paidTicket = 1,
  ArenaSpendType_ArenaSpendType_dia = 2,
  ArenaSpendType_MIN = ArenaSpendType_ArenaSpendType_freeTicket,
  ArenaSpendType_MAX = ArenaSpendType_ArenaSpendType_dia
};

inline const ArenaSpendType (&EnumValuesArenaSpendType())[3] {
  static const ArenaSpendType values[] = {
    ArenaSpendType_ArenaSpendType_freeTicket,
    ArenaSpendType_ArenaSpendType_paidTicket,
    ArenaSpendType_ArenaSpendType_dia
  };
  return values;
}

inline const char * const *EnumNamesArenaSpendType() {
  static const char * const names[] = {
    "ArenaSpendType_freeTicket",
    "ArenaSpendType_paidTicket",
    "ArenaSpendType_dia",
    nullptr
  };
  return names;
}

inline const char *EnumNameArenaSpendType(ArenaSpendType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesArenaSpendType()[index];
}

enum TeamType {
  TeamType_TeamType_None = 0,
  TeamType_TeamType_AreanTeamA = 1,
  TeamType_TeamType_AreanTeamB = 2,
  TeamType_MIN = TeamType_TeamType_None,
  TeamType_MAX = TeamType_TeamType_AreanTeamB
};

inline const TeamType (&EnumValuesTeamType())[3] {
  static const TeamType values[] = {
    TeamType_TeamType_None,
    TeamType_TeamType_AreanTeamA,
    TeamType_TeamType_AreanTeamB
  };
  return values;
}

inline const char * const *EnumNamesTeamType() {
  static const char * const names[] = {
    "TeamType_None",
    "TeamType_AreanTeamA",
    "TeamType_AreanTeamB",
    nullptr
  };
  return names;
}

inline const char *EnumNameTeamType(TeamType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesTeamType()[index];
}

enum AreanPlayInfoType {
  AreanPlayInfoType_AreanPlayInfoType_None = 0,
  AreanPlayInfoType_AreanPlayInfoType_Killed = 1,
  AreanPlayInfoType_MIN = AreanPlayInfoType_AreanPlayInfoType_None,
  AreanPlayInfoType_MAX = AreanPlayInfoType_AreanPlayInfoType_Killed
};

inline const AreanPlayInfoType (&EnumValuesAreanPlayInfoType())[2] {
  static const AreanPlayInfoType values[] = {
    AreanPlayInfoType_AreanPlayInfoType_None,
    AreanPlayInfoType_AreanPlayInfoType_Killed
  };
  return values;
}

inline const char * const *EnumNamesAreanPlayInfoType() {
  static const char * const names[] = {
    "AreanPlayInfoType_None",
    "AreanPlayInfoType_Killed",
    nullptr
  };
  return names;
}

inline const char *EnumNameAreanPlayInfoType(AreanPlayInfoType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesAreanPlayInfoType()[index];
}

enum RedisRankType {
  RedisRankType_COMBAT_POWER = 0,
  RedisRankType_INFLUENCE = 1,
  RedisRankType_DEEDS_OF_ARMS = 2,
  RedisRankType_MONARCH_POINT = 3,
  RedisRankType_PVP_POINT = 4,
  RedisRankType_RANK_TYPE_MAX = 5,
  RedisRankType_MIN = RedisRankType_COMBAT_POWER,
  RedisRankType_MAX = RedisRankType_RANK_TYPE_MAX
};

inline const RedisRankType (&EnumValuesRedisRankType())[6] {
  static const RedisRankType values[] = {
    RedisRankType_COMBAT_POWER,
    RedisRankType_INFLUENCE,
    RedisRankType_DEEDS_OF_ARMS,
    RedisRankType_MONARCH_POINT,
    RedisRankType_PVP_POINT,
    RedisRankType_RANK_TYPE_MAX
  };
  return values;
}

inline const char * const *EnumNamesRedisRankType() {
  static const char * const names[] = {
    "COMBAT_POWER",
    "INFLUENCE",
    "DEEDS_OF_ARMS",
    "MONARCH_POINT",
    "PVP_POINT",
    "RANK_TYPE_MAX",
    nullptr
  };
  return names;
}

inline const char *EnumNameRedisRankType(RedisRankType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesRedisRankType()[index];
}

///-----------------------------------------------------------------------------
/// PROTOCOL
///-----------------------------------------------------------------------------
///- PROTOCOL ----------
enum Protocol {
  Protocol_START = 0,
  Protocol_PING_NOTIFY = 1,
  Protocol_KEEP_ALIVE_NOTIFY = 2  /////////////////////////////////////////
  /// Game Agent <-> Auth
  /////////////////////////////////////////
,
  Protocol_GAME_AGENT_REGISTER_REQUEST = 11,
  Protocol_GAME_AGENT_REGISTER_RESPONSE = 12,
  Protocol_GAME_AGENT_LOGINED_USER_LIST_NOTIFY = 13,
  Protocol_GAME_AGENT_CHANGE_MAX_USER_COUNT_NOTIFY = 14,
  Protocol_GAME_AGENT_INFO_NOTIFY = 15,
  Protocol_CHECK_ACCOUNT_AUTH_REQUEST = 21,
  Protocol_CHECK_ACCOUNT_AUTH_RESPONSE = 22,
  Protocol_DB_UPDATE_REALM_NOTIFY = 30,
  Protocol_DB_UPDATE_PC_COUNT_NOTIFY = 31,
  Protocol_GAME_AGENT_LOGOUT_REQUEST = 32,
  Protocol_GAME_AGENT_PC_RENAME_NOTIFY = 33,
  Protocol_GAME_AGENT_SELECT_RESERVED_CHAR_REQUEST = 34,
  Protocol_GAME_AGENT_SELECT_RESERVED_CHAR_RESPONSE = 35,
  Protocol_GAME_AGENT_GOTO_SERVER_LIST_REQUEST = 40,
  Protocol_GAME_AGENT_GOTO_SERVER_LIST_RESPONSE = 41,
  Protocol_GAME_AGENT_UPDATE_PLAYER_INFO_REQUEST = 42,
  Protocol_GAME_AGENT_CHARACTER_CREATION = 44,
  Protocol_GAME_AGENT_NAME_CHECK_REQUEST = 45,
  Protocol_GAME_AGENT_NAME_CHECK_RESPONSE = 46,
  Protocol_ACCOUNT_CACHE_EXPIRATION_RESERVE_REQUEST = 47,
  Protocol_GAME_AGENT_HIVE_TOP_PC_INFO_REQUEST = 48,
  Protocol_GAME_AGENT_HIVE_TOP_PC_INFO_RESPONSE = 49,
  Protocol_GAME_AGENT_PLAYER_DELETE_NOTIFY = 50,
  Protocol_GAME_AGENT_PLAYER_CANCEL_DELETE_NOTIFY = 51,
  Protocol_GAME_AGENT_GIFTEVENT_MODIFY_NOTIFY = 52,
  Protocol_GAME_AGENT_NOTICE_NOTIFY = 53,
  Protocol_GAME_AGENT_ALL_KICK_NOTIFY = 54,
  Protocol_GAME_AGENT_MAINTENANCE_NOTIFY = 55,
  Protocol_GAME_AGENT_UPDATE_GAME_LANGUAGE_REQUEST = 56  /////////////////////////////////////////
  /// Auth Agent <-> Auth
  /////////////////////////////////////////
,
  Protocol_AUTH_AGENT_SERVER_REGISTER_REQUEST = 60,
  Protocol_AUTH_AGENT_SERVER_REGISTER_RESPONSE = 61,
  Protocol_AUTH_AGENT_AUTH_REQUEST = 62,
  Protocol_AUTH_AGENT_AUTH_RESPONSE = 63,
  Protocol_AUTH_AGENT_LOGOUT_REQUEST = 64,
  Protocol_AUTH_AGENT_APKHASH_UPDATE_NOTIFY = 65,
  Protocol_AUTH_AGENT_AUTH_TICKET_REQUEST = 70,
  Protocol_AUTH_AGENT_AUTH_TICKET_RESPONSE = 71,
  Protocol_AUTH_AGENT_SELECT_RESERVED_NICK_NAME_REQUEST = 72,
  Protocol_AUTH_AGENT_SELECT_RESERVED_NICK_NAME_RESPONSE = 73,
  Protocol_AUTH_AGENT_HIVE_TOP_PC_INFO_REQUEST = 74,
  Protocol_AUTH_AGENT_HIVE_TOP_PC_INFO_RESPONSE = 75,
  Protocol_AUTH_AGENT_BAN_COUNTRY_REGIST_NOTIFY = 76,
  Protocol_AUTH_AGENT_BAN_COUNTRY_UNREGIST_NOTIFY = 77  /////////////////////////////////////////
  /// Client <-> Auth Agent
  /////////////////////////////////////////
,
  Protocol_CHECK_CLIENT_VERSION_REQUEST = 101,
  Protocol_CHECK_CLIENT_VERSION_RESPONSE = 102  /// 일반 인증
,
  Protocol_ACCOUNT_AUTH_REQUEST = 103,
  Protocol_ACCOUNT_AUTH_RESPONSE = 104  /// 서버 선택창으로 이동 인증
,
  Protocol_ACCOUNT_AUTH_AGENT_TICKET_REQUEST = 105,
  Protocol_COLONY_LIST_REQUEST = 111,
  Protocol_COLONY_LIST_RESPONSE = 112,
  Protocol_CHARACTER_LIST_REQUEST = 113,
  Protocol_CHARACTER_LIST_RESPONSE = 114,
  Protocol_HIVE_AUTH_REQUEST = 115,
  Protocol_HIVE_AUTH_RESPONSE = 116,
  Protocol_SELECT_COLONY_REQUEST = 131,
  Protocol_SELECT_COLONY_RESPONSE = 132  /// server -> client
,
  Protocol_SELECT_REALM_REQUEST = 133,
  Protocol_SELECT_REALM_RESPONSE = 134,
  Protocol_SELECT_REALM_BOT_RESPONSE = 135,
  Protocol_SELECT_COLONY_BOT_REQUEST = 136,
  Protocol_COLONY_WAITING_NOTIFY = 137,
  Protocol_INQUIRE_WAITING_REQUEST = 138,
  Protocol_INQUIRE_WAITING_RESPONSE = 139,
  Protocol_CANCEL_WAITING_REQUEST = 140,
  Protocol_CANCEL_WAITING_RESPONSE = 141,
  Protocol_FIND_RESERVED_NICK_NAME_REQUEST = 142,
  Protocol_FIND_RESERVED_NICK_NAME_RESPONSE = 143,
  Protocol_SELECT_RESERVED_NICK_NAME_REQUSET = 144,
  Protocol_SELECT_RESERVED_NICK_NAME_RESPONSE = 145,
  Protocol_FIND_RESERVED_CHAR_REQUEST = 146,
  Protocol_FIND_RESERVED_CHAR_RESPONSE = 147,
  Protocol_SELECT_RESERVED_CHAR_REQUEST = 148,
  Protocol_SELECT_RESERVED_CHAR_RESPONSE = 149,
  Protocol_SHOP_EVENT_DATA_UPDATE_NOTIFY = 150  /// Common Packet
,
  Protocol_STRING_MESSAGE_NOTIFY = 1001,
  Protocol_USER_KICK_NOTIFY = 1002,
  Protocol_CONTENT_CONFIG_UPDATE_NOFITY = 1003  /////////////////////////////////////////
  /// Client <-> Agent
  /////////////////////////////////////////
,
  Protocol_ACCOUNT_LOGIN_REQUEST = 2001,
  Protocol_ACCOUNT_LOGIN_RESPONSE = 2002,
  Protocol_SERVER_LOCAL_TIME_NOTIFY = 2004,
  Protocol_DEVICE_PERFORMANCE_POINT_NOTIFY = 2005  /// 계정당 한번 보내준다
,
  Protocol_SEASON_INFO_NOTIFY = 2006,
  Protocol_SERVER_LOCAL_TIME_REQUEST = 2007,
  Protocol_SERVER_LOCAL_TIME_RESPONSE = 2008,
  Protocol_SLOT_LIST_REQUEST = 2011,
  Protocol_SLOT_LIST_RESPONSE = 2012,
  Protocol_PC_TUTORIAL_SKIP_REQUEST = 2013,
  Protocol_PC_TUTORIAL_SKIP_RESPONSE = 2014,
  Protocol_PC_LOGIN_REQUEST = 2015,
  Protocol_PC_LOGIN_RESPONSE = 2016,
  Protocol_PC_CREATION_REQUEST = 2021,
  Protocol_PC_CREATION_RESPONSE = 2022,
  Protocol_PC_CHECK_NEW_NAME_REQUEST = 2023,
  Protocol_PC_CHECK_NEW_NAME_RESPONSE = 2024,
  Protocol_PC_RENAME_REQUEST = 2025,
  Protocol_PC_RENAME_RESPONSE = 2026,
  Protocol_PC_DELETE_REQUEST = 2031,
  Protocol_PC_DELETE_RESPONSE = 2032,
  Protocol_PC_CANCEL_DELETE_REQUEST = 2033,
  Protocol_PC_CANCEL_DELETE_RESPONSE = 2034,
  Protocol_PC_GOTO_LOBBY_REQUEST = 2101,
  Protocol_PC_GOTO_LOBBY_RESPONSE = 2102,
  Protocol_ACCOUNT_LOGOUT_REQUEST = 2111,
  Protocol_ACCOUNT_LOGOUT_RESPONSE = 2112,
  Protocol_GOTO_SERVER_LIST_REQUEST = 2113,
  Protocol_GOTO_SERVER_LIST_RESPONSE = 2114,
  Protocol_ACCOUNT_RECONNECT_REQUEST = 2130,
  Protocol_ACCOUNT_RECONNECT_RESPONSE = 2131,
  Protocol_HIVE_TOP_PC_INFO_REQUEST = 2140,
  Protocol_HIVE_TOP_PC_INFO_RESPONSE = 2141,
  Protocol_HIVE_COMPANION_COUNT_REQUEST = 2142,
  Protocol_HIVE_COMPANION_COUNT_RESPONSE = 2143,
  Protocol_HIVE_SHOP_PURCHASE_PRODUCT_NOTIFY = 2144,
  Protocol_DELAY_PING_NOTIFY = 2150  /////////////////////////////////////////
  /// Server <-> Server
  /////////////////////////////////////////
,
  Protocol_BYPASS_FROM_CLIENT_NOTIFY = 3001,
  Protocol_BYPASS_TO_CLIENT_NOTIFY = 3002,
  Protocol_BYPASS_BROADCAST_TO_CLIENT_NOTIFY = 3003  /////////////////////////////////////////
  /// Agent <-> Game
  /////////////////////////////////////////
,
  Protocol_GAME_SERVER_REGISTER_REQUEST = 5001,
  Protocol_GAME_SERVER_REGISTER_RESPONSE = 5002,
  Protocol_PC_ENTER_WORLD_READY_REQUEST = 5003,
  Protocol_PC_ENTER_WORLD_READY_RESPONSE = 5004,
  Protocol_PC_START_NOTIFY = 5005,
  Protocol_PC_LEAVE_WORLD_REQUEST = 5007,
  Protocol_PC_LEAVE_WORLD_RESPONSE = 5008,
  Protocol_PC_TRY_TO_LEAVE_WORLD_NOTIFY = 5010,
  Protocol_PC_DISCONNECT_NOTIFY = 5011,
  Protocol_PC_RECONNECT_REQUEST = 5012,
  Protocol_SERVER_GUILD_REQUEST = 5013,
  Protocol_SERVER_GUILD_DATA_LOAD = 5014,
  Protocol_SERVER_GUILD_MEMBER_LOAD = 5015,
  Protocol_SERVER_GUILD_RESPONSE = 5016,
  Protocol_SERVER_GUILD_CREATE = 5017,
  Protocol_SERVER_GUILD_DESTROY = 5018,
  Protocol_SERVER_GUILD_DATA_UPDATE = 5019,
  Protocol_SERVER_GUILD_MEMBER_ADD = 5020,
  Protocol_SERVER_GUILD_MEMBER_REMOVE = 5021,
  Protocol_SERVER_GUILD_MEMBER_UPDATE = 5022,
  Protocol_SERVER_GUILD_BUFF_ADD = 5023,
  Protocol_SERVER_GUILD_BUFF_REMOVE = 5024  /// 군주길드 변경 (치트를 위해 사용됨)
,
  Protocol_SERVER_GUILD_LEADER_GUILD_UPDATE = 5025  /// 길드 가입요청 변경
,
  Protocol_SERVER_GUILD_APPLICANT_UPDATE = 5026,
  Protocol_SERVER_SEASON_INFO_UPDATE = 5030,
  Protocol_SERVER_SEASON_RESET_REQUEST = 5031,
  Protocol_SERVER_SEASON_RESET_RESPONSE = 5032,
  Protocol_PC_NEW_MAIL_NOTIFY = 5040,
  Protocol_PC_SHOP_PURCHASE_PRODUCT_REQUEST = 5041,
  Protocol_PC_LEAVED_BRAWL_NOTIFY = 5042  /////////////////////////////////////////
  /// Client <-> Game
  /////////////////////////////////////////
,
  Protocol_NOTICE_NOTIFY = 6000,
  Protocol_CLIENT_DEBUG_MESSAGE_NOTIFY = 6001,
  Protocol_SMAP_CHANNEL_LIST_REQUEST = 6002,
  Protocol_SMAP_CHANNEL_LIST_RESPONSE = 6003,
  Protocol_SMAP_CHANNEL_MOVE_REQUEST = 6004,
  Protocol_SMAP_CHANNEL_MOVE_RESPONSE = 6005,
  Protocol_JOIN_EVENTSET_CHANNEL_REQUEST = 6013,
  Protocol_JOIN_EVENTSET_CHANNEL_RESPONSE = 6014,
  Protocol_ADMIN_COMMAND_NOTIFY = 6015,
  Protocol_SYSTEM_DEBUG_MESSAGE_NOTIFY = 6016,
  Protocol_PC_SPAWN_COMPLETE_NOTIFY = 6017,
  Protocol_UPC_SPAWN_COMPLETE_NOTIFY = 6018,
  Protocol_BOT_ADMIN_COMMAND_NOTIFY = 6019,
  Protocol_TELEPORT_NOTIFY_OTHER_PC_IN_VIEW = 6020,
  Protocol_TELEPORT_REQUEST = 6021,
  Protocol_TELEPORT_RESPONSE = 6022  /// 이벤트 1
,
  Protocol_ENTER_EVENT_AREA_REQUEST = 6023,
  Protocol_ENTER_EVENT_AREA_RESPONSE = 6024,
  Protocol_EVENT_MESSAGE_NOTIFY = 6025,
  Protocol_SAFE_ZONE_IN_REQUEST = 6026,
  Protocol_SAFE_ZONE_IN_RESPONSE = 6027,
  Protocol_SAFE_ZONE_OUT_REQUEST = 6028,
  Protocol_SAFE_ZONE_OUT_RESPONSE = 6029,
  Protocol_CLIENT_CREATURE_MOVE_NOTIFY = 6030,
  Protocol_SERVER_CREATURE_MOVE_NOTIFY = 6031,
  Protocol_CLIENT_SHORT_TERM_MOVE_NOTIFY = 6032,
  Protocol_CLIENT_LONG_TERM_MOVE_NOTIFY = 6033,
  Protocol_SERVER_SHORT_TERM_MOVE_NOTIFY = 6034,
  Protocol_SERVER_LONG_TERM_MOVE_NOTIFY = 6035,
  Protocol_GAME_PING_REQUEST = 6036,
  Protocol_GAME_PING_RESPONSE = 6037,
  Protocol_GAME_CONTENTS_CONFIG_NOTIFY = 6038,
  Protocol_EVENT_DIRECTION_BEGIN_NOTIFY = 6050,
  Protocol_EVENT_DIRECTION_FINISH_NOTIFY = 6051,
  Protocol_EVENT_BATTLE_REALM_CONTRIBUTION_NOTIFY = 6052,
  Protocol_EVENT_BATTLE_REALM__END_NOTIFY = 6053,
  Protocol_NOTIFY_EVENT_CONTRIBUTION = 6054,
  Protocol_NOTIFY_EVENT_REWARD = 6055,
  Protocol_NOTIFY_EVENT_START = 6056,
  Protocol_NOTIFY_EVENT_END = 6057,
  Protocol_NOTIFY_NEXT_NORMAL_EVENTSET_INFO = 6058,
  Protocol_EVENT_DISAPPEAR_BARRIER_NOTIFY = 6059,
  Protocol_NOTIFY_EVENT_TOTAL_REWARD = 6061,
  Protocol_EVENT_SPEECH_BUBBLE_NOTIFY = 6062,
  Protocol_EVENT_CHANNEL_CLOSE_NOTIFY = 6063,
  Protocol_EVENT_GO_TOWN_REQUEST = 6064,
  Protocol_EVENT_GO_TOWN_RESPONSE = 6065,
  Protocol_NOTIFY_EVENT_PHASE_START = 6067,
  Protocol_NOTIFY_EVENT_COUNTER_INFO = 6068,
  Protocol_NOTIFY_EVENT_COUNTER_PROGRESS_INFO = 6069,
  Protocol_NOTIFY_EVENT_HIDDEN_CONTENTS_START = 6070,
  Protocol_NOTIFY_EVENT_HIDDEN_CONTENTS_END = 6071,
  Protocol_NOTIFY_EVENT_HIDDEN_GATHERING_COLLECTED = 6072,
  Protocol_EVENT_OUT_OF_PLAY_NOTIFY = 6073,
  Protocol_EVENT_MIDDLE_NOTIFY = 6074,
  Protocol_QUEST_REWARD_NOTIFY = 6101,
  Protocol_QUEST_RECEIVE_REWARD_REQUEST = 6109,
  Protocol_QUEST_RECEIVE_REWARD_RESPONSE = 6120,
  Protocol_QUEST_CONTEXT_DATA_SET_NOTIFY = 6121,
  Protocol_QUEST_CONTEXT_DATA_NOTIFY = 6122,
  Protocol_CHAPTER_JOIN_REQUEST = 6123,
  Protocol_CHAPTER_JOIN_RESPONSE = 6124,
  Protocol_CHAPTER_DATA_NOTIFY = 6125,
  Protocol_QUEST_BONUS_REWARD_REQUEST = 6128,
  Protocol_QUEST_BONUS_REWARD_RESPONSE = 6129,
  Protocol_QUEST_BONUS_REWARD_NOTIFY = 6130  ///
  /// 챕터
  ///
,
  Protocol_CHAPTER_NOTIFY = 6140  /// smap clear로 chapterId가 변경될 수 있다
,
  Protocol_CHAPTER_CLEAR_SMAP_REQUEST = 6141,
  Protocol_CHAPTER_CLEAR_SMAP_RESPONSE = 6142,
  Protocol_CHAPTER_JOIN_SMAP_REQUEST = 6143,
  Protocol_CHAPTER_JOIN_SMAP_RESPONSE = 6144,
  Protocol_EXIT_INSTANCE_DUNGEON_REQUEST = 6150,
  Protocol_EXIT_INSTANCE_DUNGEON_RESPONSE = 6151,
  Protocol_EVENT_MOVE_START_LOC_REQUEST = 6152,
  Protocol_EVENT_MOVE_START_LOC_RESPONSE = 6153,
  Protocol_EVENT_RETURN_LAST_LOC_REQUEST = 6154,
  Protocol_EVENT_RETURN_LAST_LOC_RESPONSE = 6155,
  Protocol_MAIN_STREAM_EVENT_JOIN_SWITCH_STATE_NOTIFY = 6157,
  Protocol_MAIN_STREAM_EVENT_JOIN_SWITCH_REQUEST = 6158,
  Protocol_MAIN_STREAM_EVENT_JOIN_SWITCH_RESPONSE = 6159,
  Protocol_MAINSTREAM_STATE_NOTIFY = 6160,
  Protocol_MAIN_STREAM_DATA_NOTIFY = 6161,
  Protocol_MAIN_STREAM_DATA_SET_NOTIFY = 6162,
  Protocol_MAIN_STREAM_DIRECT_NOTIFY = 6163,
  Protocol_MAIN_STREAM_PRE_ACTION_REQUEST = 6164,
  Protocol_MAIN_STREAM_PRE_ACTION_RESPONSE = 6165,
  Protocol_MAIN_STREAM_FINISHED_BACK_NOTIFY = 6166,
  Protocol_MAIN_STREAM_DO_BUTTON_ACTION_REQUEST = 6167,
  Protocol_MAIN_STREAM_DO_BUTTON_ACTION_RESPONSE = 6168,
  Protocol_MAIN_STREAM_ON_REWARD_UI_NOTIFY = 6169,
  Protocol_DAILY_HOMEWORK_DATA_ALL_NOTIFY = 6171,
  Protocol_DAILY_HOMEWORK_DATA_UPDATE_NOTIFY = 6172,
  Protocol_DAILY_HOMEWORK_RESERVED = 6173,
  Protocol_DAILY_HOMEWORK_GET_REWARD_REQUEST = 6174,
  Protocol_DAILY_HOMEWORK_GET_REWARD_RESPONSE = 6175  /// #골드던전
,
  Protocol_GOLD_DUNGEON_INFO_REQUEST = 6180,
  Protocol_GOLD_DUNGEON_INFO_RESPONSE = 6181,
  Protocol_GOLD_DUNGEON_ENTER_FAILED = 6182,
  Protocol_RECOMMEND_GET_PRAISER_REQUEST = 6201,
  Protocol_RECOMMEND_GET_PRAISER_RESPONSE = 6202,
  Protocol_RECOMMEND_CHOICE_PRAISER_REQUEST = 6203,
  Protocol_RECOMMEND_CHOICE_PRAISER_RESPOSE = 6204,
  Protocol_RECOMMEND_PRAISER_RESULT_NOTIFY = 6205,
  Protocol_RECOMMEND_CHOICE_RESULT_NOTIFY = 6206,
  Protocol_NPC_SCENEMAP_INFO_UPDATE_NOTIFY = 6901,
  Protocol_NPC_SCENEMAP_INFO_DESTROY_NOTIFY = 6902,
  Protocol_PC_SCENEMAP_INFO_UPDATE_NOTIFY = 6903,
  Protocol_PC_SCENEMAP_INFO_DESTROY_NOTIFY = 6904,
  Protocol_FIELD_JOIN_REQUEST = 7010,
  Protocol_FIELD_JOIN_RESPONSE = 7011,
  Protocol_DAILY_DUNGEON_CLEAR_NOTIFY = 7017,
  Protocol_DAILY_DUNGEON_JOIN_REQUEST = 7018,
  Protocol_DAILY_DUNGEON_JOIN_RESPONSE = 7019,
  Protocol_DAILY_DUNGEON_INFO_REQUEST = 7021,
  Protocol_DAILY_DUNGEON_INFO_RESPONSE = 7022,
  Protocol_DAILY_DUNGEON_OTHER_JOIN_REQUEST = 7023,
  Protocol_DAILY_DUNGEON_OTHER_JOIN_RESPONSE = 7024,
  Protocol_ARENA_TEAM_REQUEST = 7030,
  Protocol_ARENA_TEAM_RESPONSE = 7031,
  Protocol_ARENA_TEAM_REFRESH_REQUEST = 7032,
  Protocol_ARENA_TEAM_REFRESH_RESPONSE = 7033,
  Protocol_ARENA_JOIN_REQUEST = 7034,
  Protocol_ARENA_JOIN_RESPONSE = 7035,
  Protocol_ARENA_FINISH_REQUEST = 7036,
  Protocol_ARENA_FINISH_NOTIFY = 7037,
  Protocol_ARENA_PLAY_INFO_NOTIFY = 7038,
  Protocol_ARENA_REWARD_REQUEST = 7039,
  Protocol_ARENA_REWARD_RESPONSE = 7040,
  Protocol_ARENA_EXIT_REQUEST = 7041,
  Protocol_UPDATE_ITEM_COOLTIME_NOTIFY = 7042,
  Protocol_ARENA_FINISH_NOTIFY_REQUEST = 7043,
  Protocol_SOLO_DUNGEON_RELOAD_REQUEST = 7098,
  Protocol_SOLO_DUNGEON_RELOAD_RESPONSE = 7099,
  Protocol_SOLO_DUNGEON_LOAD_NOTIFY = 7100,
  Protocol_SOLO_DUNGEON_JOIN_REQUEST = 7101,
  Protocol_SOLO_DUNGEON_JOIN_RESPONSE = 7102,
  Protocol_SOLO_DUNGEON_CLEAR_NOTIFY = 7103,
  Protocol_INFLUENCE_POINT_UP_NOTIFY = 7120,
  Protocol_INFLUENCE_DATA_NOTIFY = 7121,
  Protocol_INFLUENCE_AFTER_REFRESH_NOTIFY = 7122,
  Protocol_ADMIN_UPDATE_REFRESH_INFLUENCE = 7123,
  Protocol_DB_ADMIN_UPDATE_INFLUENCE_TIER_LEVEL_REQUEST = 7124,
  Protocol_DB_ADMIN_UPDATE_INFLUENCE_TIER_LEVEL_RESPONSE = 7125,
  Protocol_MAIL_RECEIVE_NOTIFY = 7220,
  Protocol_MAIL_REWARD_RECEIVE_REQUEST = 7221,
  Protocol_MAIL_REWARD_RECEIVE_RESPONSE = 7222,
  Protocol_MAIL_REMOVE_NOTIFY = 7223,
  Protocol_CHAT_REQUEST = 7250,
  Protocol_CHAT_WHISPER_REQUEST = 7251,
  Protocol_CHAT_ERROR_NOTIFY = 7252,
  Protocol_CHAT_COMMON_NOTIFY = 7253,
  Protocol_CHAT_GUILD_NOTIFY = 7254,
  Protocol_CHAT_WHISPER_NOTIFY = 7255,
  Protocol_CHAT_GUILD_MSG_LIST_REQUEST = 7256,
  Protocol_CHAT_GUILD_MSG_LIST_RESPONSE = 7257,
  Protocol_CHAT_WHISPER_MSG_LIST_REQUEST = 7258,
  Protocol_CHAT_WHISPER_MSG_LIST_RESPONSE = 7259,
  Protocol_CHAT_NEW_MESSAGE_NOTIFY = 7260,
  Protocol_CHAT_WORLD_REQUEST = 7261,
  Protocol_CHAT_LOCAL_REQUEST = 7262,
  Protocol_CHAT_WARFIELD_REQUEST = 7263,
  Protocol_CHAT_CHECK_RECEIVER_REQUEST = 7264,
  Protocol_CHAT_CHECK_RECEIVER_RESPONSE = 7265,
  Protocol_CHAT_READ_WHISPER_NOTIFY = 7266,
  Protocol_CHAT_READ_GUILD_NOTIFY = 7267,
  Protocol_CHAT_DELETE_ROOM = 7268,
  Protocol_NEW_WHISPER_MESSAGE_NOTIFY = 7269,
  Protocol_NEW_GUILD_MESSAGE_NOTIFY = 7270,
  Protocol_TARGET_PC_DETAIL_INFO_REQUEST = 7271,
  Protocol_TARGET_PC_DETAIL_INFO_RESPONSE = 7272,
  Protocol_PLAYER_DENIED_REQUEST = 7273,
  Protocol_PLAYER_DENIED_RESPONSE = 7274,
  Protocol_PLAYER_UNDENIED_REQUEST = 7275,
  Protocol_PLAYER_UNDENIED_RESPONSE = 7276,
  Protocol_PLAYER_DENIED_LIST_NOTIFY = 7277  ///----- 거래소 -----------------
,
  Protocol_TRADE_GET_TRADE_ITEM_LIST_REQUEST = 7301,
  Protocol_TRADE_GET_TRADE_ITEM_LIST_RESPONSE = 7302,
  Protocol_TRADE_SET_TRADE_ITEM_REQUEST = 7303,
  Protocol_TRADE_SET_TRADE_ITEM_RESPONSE = 7304,
  Protocol_TRADE_BUY_TRADE_ITEM_REQUEST = 7305,
  Protocol_TRADE_BUY_TRADE_ITEM_RESPONSE = 7306,
  Protocol_TRADE_MY_SALE_LIST_REQUEST = 7307,
  Protocol_TRADE_MY_SALE_LIST_RESPONSE = 7308,
  Protocol_TRADE_SALE_LOG_LIST_REQUEST = 7309,
  Protocol_TRADE_SALE_LOG_LIST_RESPONSE = 7310,
  Protocol_TRADE_CANCEL_TRADE_ITEM_REQUEST = 7311,
  Protocol_TRADE_CANCEL_TRADE_ITEM_RESPONSE = 7312  ///----- 레이드 -----------------
,
  Protocol_RAID_JOIN_FAILED_NOTIFY = 7401,
  Protocol_RAID_INFO_REQUEST = 7402,
  Protocol_RAID_INFO_RESPONSE = 7403,
  Protocol_RAID_RANDOM_REWARD_PC_NOTIFY = 7404  ///----- 보너스_일일 충전 -----------------
,
  Protocol_BONUS_DAILY_RECHARGE_MANUAL_REQUEST = 7410,
  Protocol_BONUS_DAILY_RECHARGE_MANUAL_RESPONSE = 7411,
  Protocol_BONUS_DAILY_RECHARGE_INFO_REQUEST = 7413,
  Protocol_BONUS_DAILY_RECHARGE_INFO_RESPONSE = 7414  ///----- 무한의 탑 -----------------
,
  Protocol_INFINITE_TOWER_INFO_REQUEST = 7420,
  Protocol_INFINITE_TOWER_INFO_RESPONSE = 7421,
  Protocol_INFINITE_TOWER_JOIN_REQUEST = 7422,
  Protocol_INFINITE_TOWER_JOIN_RESPONSE = 7423,
  Protocol_INFINITE_TOWER_SWEEP_REQUEST = 7424,
  Protocol_INFINITE_TOWER_SWEEP_RESPONSE = 7425,
  Protocol_INFINITE_TOWER_CLEAR_NOTIFY = 7426  ///----- 출석체크 -----------------
,
  Protocol_ATTENDANCE_INFO_REQUEST = 7430,
  Protocol_ATTENDANCE_INFO_RESPONSE = 7431,
  Protocol_ATTENDANCE_STAMP_REQUEST = 7432,
  Protocol_ATTENDANCE_STAMP_RESPONSE = 7433  ///----- 접속보상 -----------------
,
  Protocol_ACCESS_TIME_INFO_REQUEST = 7435,
  Protocol_ACCESS_TIME_INFO_RESPONSE = 7436,
  Protocol_ACCESS_TIME_REWARD_REQUEST = 7437,
  Protocol_ACCESS_TIME_REWARD_RESPONSE = 7438  ///----- 휴식보상 -----------------
,
  Protocol_REST_TIME_INFO_REQUEST = 7440,
  Protocol_REST_TIME_INFO_RESPONSE = 7441,
  Protocol_REST_TIME_REWARD_REQUEST = 7442,
  Protocol_REST_TIME_REWARD_RESPONSE = 7443  ///----- 상점 -----------------
,
  Protocol_SHOP_PURCHASE_PRODUCT_REQUEST = 7500,
  Protocol_SHOP_PURCHASE_PRODUCT_RESPONSE = 7501,
  Protocol_SHOP_PURCHASE_PRODUCT_REWARD_REQUEST = 7502,
  Protocol_SHOP_PURCHASE_PRODUCT_REWARD_RESPONSE = 7503,
  Protocol_SHOP_PURCHASE_PRODUCT_BONUS_REWARD_REQUEST = 7504,
  Protocol_SHOP_PURCHASE_PRODUCT_BONUS_REWARD_RESPONSE = 7505,
  Protocol_SHOP_PURCHASE_PRODUCT_LIST_NOTIFY = 7506,
  Protocol_SHOP_PURCHASE_PRODUCT_EXPIRE_DATE_NOTIFY = 7507,
  Protocol_SHOP_PURCHASE_PRODUCT_MISSION_UPDATE_NOTIFY = 7508,
  Protocol_SHOP_PURCHASE_PRODUCT_BONUS_POINT_UPDATE_NOTIFY = 7509,
  Protocol_SHOP_PURCHASE_PRODUCT_PROMOTION_UPDATE_NOTIFY = 7510,
  Protocol_SHOP_PURCHASE_PRODUCT_PROMOTION_REWARD_REQUEST = 7511,
  Protocol_SHOP_PURCHASE_PRODUCT_PROMOTION_REWARD_RESPONSE = 7512  ///----- #길드던전 --------------
,
  Protocol_GUILD_DUNGEON_INFO_REQUEST = 7601,
  Protocol_GUILD_DUNGEON_INFO_RESPONSE = 7602,
  Protocol_GUILD_DUNGEON_ENTER_FAILED = 7603,
  Protocol_GUILD_DUNGEON_CLEAR_NOTIFY = 7604,
  Protocol_GUILD_DUNGEON_REWARD_REQUEST = 7605,
  Protocol_GUILD_DUNGEON_REWARD_RESPONSE = 7606  /// DB Transaction (Game <-> Agent)
  ///------------------------------
,
  Protocol_DB_USER_DATA_REQUEST = 11001,
  Protocol_DB_USER_DATA_RESPONSE = 11002,
  Protocol_DB_ADD_ITEM_REQUEST = 11003,
  Protocol_DB_ADD_ITEM_RESPONSE = 11004,
  Protocol_DB_DEL_ITEM_REQUEST = 11005,
  Protocol_DB_DEL_ITEM_RESPONSE = 11006,
  Protocol_DB_UPDATE_LEVEL_EXP_REQUEST = 11009,
  Protocol_DB_UPDATE_LEVEL_EXP_RESPONSE = 11010,
  Protocol_DB_DISENCHANT_ITEM_REQUEST = 11011,
  Protocol_DB_DISENCHANT_ITEM_RESPONSE = 11012,
  Protocol_DB_ENCHANT_ITEM_REQUEST = 11013,
  Protocol_DB_ENCHANT_ITEM_RESPONSE = 11014,
  Protocol_DB_UPGRADE_ITEM_REQUEST = 11015,
  Protocol_DB_UPGRADE_ITEM_RESPONSE = 11016,
  Protocol_DB_SALE_ITEM_REQUEST = 11017,
  Protocol_DB_SALE_ITEM_RESPONSE = 11018,
  Protocol_DB_TRANSCEND_ITEM_REQUEST = 11019,
  Protocol_DB_TRANSCEND_ITEM_RESPONSE = 11020,
  Protocol_DB_CHANGE_TRANSCEND_STAT_REQUEST = 11021,
  Protocol_DB_CHANGE_TRANSCEND_STAT_RESPONSE = 11022,
  Protocol_DB_CRAFT_ITEM_REQUEST = 11023,
  Protocol_DB_CRAFT_ITEM_RESPONSE = 11024,
  Protocol_DB_PRESET_INSERT_REQUEST = 11025,
  Protocol_DB_PRESET_INSERT_RESPONSE = 11026,
  Protocol_DB_PRESET_UPDATE_REQUEST = 11027,
  Protocol_DB_PRESET_UPDATE_RESPONSE = 11028,
  Protocol_DB_SKILL_GROWTH_UPDATE_REQUEST = 11029,
  Protocol_DB_SKILL_GROWTH_UPDATE_RESPONSE = 11030,
  Protocol_DB_PURSE_REQUEST = 11033,
  Protocol_DB_PURSE_RESPONSE = 11034,
  Protocol_DB_CHANGE_PRISM_REQUEST = 11035,
  Protocol_DB_CHANGE_PRISM_RESPONSE = 11036,
  Protocol_DB_SET_DIAMOND_CHEAT_REQUEST = 11037,
  Protocol_DB_SET_DIAMOND_CHEAT_RESPONSE = 11038,
  Protocol_DB_TRANSMUTE_CRYSTAL_REQUEST = 11039,
  Protocol_DB_TRANSMUTE_CRYSTAL_RESPONSE = 11040,
  Protocol_DB_CHANGE_CRYSTAL_REQUEST = 11041,
  Protocol_DB_CHANGE_CRYSTAL_RESPONSE = 11042,
  Protocol_DB_UPDATE_SKILL_POINT_REQUEST = 11043,
  Protocol_DB_UPDATE_SKILL_POINT_RESPONSE = 11044,
  Protocol_DB_TOGGLE_SAFE_GUARD_REQUEST = 11045,
  Protocol_DB_TOGGLE_SAFE_GUARD_RESPONSE = 11046,
  Protocol_DB_SKILL_FEATURE_INITIALIZE_REQUEST = 11047,
  Protocol_DB_SKILL_FEATURE_INITIALIZE_RESPONSE = 11048,
  Protocol_DB_DAILY_DUNGEON_COMPLETE_REQUEST = 11055,
  Protocol_DB_DAILY_DUNGEON_COMPLETE_RESPONSE = 11056,
  Protocol_DB_MOVE_ITEM_REQUEST = 11057,
  Protocol_DB_MOVE_ITEM_RESPONSE = 11058,
  Protocol_DB_PRESET_TYPE_UPDATE_REQUEST = 11061,
  Protocol_DB_PRESET_TYPE_UPDATE_RESPONSE = 11062,
  Protocol_DB_QUEST_SET_DATA_MULTI_REQUEST = 11071,
  Protocol_DB_QUEST_SET_DATA_MULTI_RESPONSE = 11072,
  Protocol_DB_CHAPTER_UPDATE_REQUEST = 11075,
  Protocol_DB_CHAPTER_UPDATE_RESPONSE = 11076,
  Protocol_DB_INVEN_REWARD_MAIL_REQUEST = 11077,
  Protocol_DB_INVEN_REWARD_MAIL_RESPONSE = 11078,
  Protocol_DB_RECV_MAIL_REWARD_REQUEST = 11081,
  Protocol_DB_RECV_MAIL_REWARD_RESPONSE = 11082,
  Protocol_DB_SOLO_DUNGEON_SET_DATA_REQUEST = 11087,
  Protocol_DB_SOLO_DUNGEON_SET_DATA_RESPONSE = 11088,
  Protocol_DB_SOLO_DUNGEON_SET_TICKET_REQUEST = 11089,
  Protocol_DB_SOLO_DUNGEON_SET_TICKET_RESPONSE = 11090,
  Protocol_DB_QUEST_BONUS_SET_DATA_REQUEST = 11095,
  Protocol_DB_QUSET_BONUS_SET_DATA_RESPONSE = 11096,
  Protocol_DB_PC_UPDATE_REQUEST = 11120,
  Protocol_DB_PC_UPDATE_RESPONSE = 11121,
  Protocol_DB_USE_ITEM_REQUEST = 11130,
  Protocol_DB_USE_ITEM_RESPONSE = 11131,
  Protocol_DB_USE_ITEM_CONTENTS_EFFECT_REQUEST = 11132,
  Protocol_DB_USE_ITEM_CONTENTS_EFFECT_RESPONSE = 11133,
  Protocol_DB_NEW_MAIL_LOAD_REQUEST = 11134,
  Protocol_DB_NEW_MAIL_LOAD_RESPONSE = 11135,
  Protocol_DB_REWARD_REQUEST = 11160,
  Protocol_DB_REWARD_RESPONSE = 11161,
  Protocol_DB_FOLLOWER_ADD_SOUL_STONE_REQUEST = 11168,
  Protocol_DB_FOLLOWER_ADD_SOUL_STONE_RESPONSE = 11169,
  Protocol_DB_FOLLOWER_ENCHANT_REQUEST = 11170,
  Protocol_DB_FOLLOWER_ENCHANT_RESPONSE = 11171,
  Protocol_DB_FOLLOWER_START_MISSION_REQUEST = 11172,
  Protocol_DB_FOLLOWER_START_MISSION_RESPONSE = 11173,
  Protocol_DB_FOLLOWER_END_MISSION_REQUEST = 11174,
  Protocol_DB_FOLLOWER_END_MISSION_RESPONSE = 11175,
  Protocol_DB_FOLLOWER_MISSION_REWARD_REQUEST = 11182,
  Protocol_DB_FOLLOWER_MISSION_REWARD_RESPONSE = 11183,
  Protocol_DB_QUEST_SET_REWARD_REQUEST = 11184,
  Protocol_DB_QUEST_SET_REWARD_RESPONSE = 11185,
  Protocol_ARENA_STATE_NOTIFY = 11191,
  Protocol_ARENA_MEMBER_LIST_REQUEST = 11192,
  Protocol_ARENA_MEMBER_LIST_RESPONSE = 11193,
  Protocol_DB_ARENA_REWARD_REQUEST = 11194,
  Protocol_DB_ARENA_REWARD_RESPONSE = 11195,
  Protocol_DB_ARENA_FINISH_REQUEST = 11196,
  Protocol_DB_ARENA_FINISH_RESPONSE = 11197,
  Protocol_ARENA_INFO_REQUEST = 11198,
  Protocol_ARENA_INFO_RESPONSE = 11199,
  Protocol_DB_LOAD_UPC_DATA_REQUEST = 11200,
  Protocol_DB_LOAD_UPC_DATA_RESPONSE = 11201,
  Protocol_DB_ITEM_COOL_TIME_SAVE_REQUEST = 11202,
  Protocol_DB_ITEM_COOL_TIME_SAVE_RESPONSE = 11203,
  Protocol_DB_LOAD_ITEM_COOLTIME_RESPONSE = 11204,
  Protocol_DB_ITEM_COOL_TIME_UPDATE_REQUEST = 11205,
  Protocol_DB_ITEM_COOL_TIME_UPDATE_RESPONSE = 11206,
  Protocol_DB_INFLUENCE_REFRESH_REQUEST = 11210,
  Protocol_DB_INFLUENCE_REFRESH_RESPONSE = 11211,
  Protocol_DB_INFLUENCE_POINT_UP_REQUEST = 11212,
  Protocol_DB_INFLUENCE_POINT_UP_RESPONSE = 11213,
  Protocol_DB_TICKET_UPDATE_REQUEST = 11220,
  Protocol_DB_TICKET_UPDATE_RESPONSE = 11221,
  Protocol_DB_TICKET_REFILL_REQUEST = 11222,
  Protocol_DB_TICKET_REFILL_RESPONSE = 11223,
  Protocol_DB_DAILY_HOMEWORK_UPDATE_REQUEST = 11234,
  Protocol_DB_DAILY_HOMEWORK_UPDATE_RESPONSE = 11235,
  Protocol_DB_MAIN_STREAM_UPDATE_REQUEST = 11236,
  Protocol_DB_MAIN_STREAM_UPDATE_RESPONSE = 11237,
  Protocol_DB_MAIN_STREAM_UPDATE_ALL_REQUEST = 11238,
  Protocol_DB_MAIN_STREAM_UPDATE_ALL_RESPONSE = 11239,
  Protocol_DB_DAILY_HOMEWORK_POINT_UPDATE_REQUEST = 11240,
  Protocol_DB_DAILY_HOMEWORK_POINT_UPDATE_RESPONSE = 11241,
  Protocol_DB_DAILY_HOMEWORK_POINT_REWARD_REQUEST = 11242,
  Protocol_DB_DAILY_HOMEWORK_POINT_REWARD_RESPONSE = 11243,
  Protocol_DB_SET_TRADE_ITEM_REQUEST = 11250,
  Protocol_DB_SET_TRADE_ITEM_RESPONSE = 11251,
  Protocol_DB_GET_TRADE_ITEM_LIST_REQUEST = 11252,
  Protocol_DB_GET_TRADE_ITEM_LIST_RESPONSE = 11253,
  Protocol_DB_GET_TRADE_MY_SALE_LIST_REQUEST = 11254,
  Protocol_DB_GET_TRADE_MY_SALE_LIST_RESPONSE = 11255,
  Protocol_DB_BUY_TRADE_ITEM_REQUEST = 11256,
  Protocol_DB_BUY_TRADE_ITEM_RESPONSE = 11257,
  Protocol_DB_CANCEL_TRADE_ITEM_REQUEST = 11258,
  Protocol_DB_CANCEL_TRADE_ITEM_RESPONSE = 11259,
  Protocol_DB_GET_TRADE_SALE_LOG_LIST_REQUEST = 11260,
  Protocol_DB_GET_TRADE_SALE_LOG_LIST_RESPONSE = 11261  /// #일일과제
,
  Protocol_DB_DAILY_HOMEWORK_CHANGE_CHAPTER_REQUEST = 11262,
  Protocol_DB_DAILY_HOMEWORK_CHANGE_CHAPTER_RESPONSE = 11263,
  Protocol_DB_DAILY_HOMEWORK_RESET_REQUEST = 11264,
  Protocol_DB_DAILY_HOMEWORK_RESET_RESPONSE = 11265,
  Protocol_DB_DAILY_HOMEWORK_TEST_RESET_REQUEST = 11266,
  Protocol_DB_DAILY_HOMEWORK_TEST_RESET_RESPONSE = 11267,
  Protocol_DB_BONUS_DAILY_RECHARGE_REQEUST = 11275,
  Protocol_DB_BONUS_DAILY_RECHARGE_RESPONSE = 11276,
  Protocol_DB_INFINITE_TOWER_CLEAR_REQUEST = 11282,
  Protocol_DB_INFINITE_TOWER_CLEAR_RESPONSE = 11283,
  Protocol_DB_INFINITE_TOWER_SWEEP_REQUEST = 11284,
  Protocol_DB_INFINITE_TOWER_SWEEP_RESPONSE = 11285,
  Protocol_DB_ATTENDANCE_STAMP_REQUEST = 11286,
  Protocol_DB_ATTENDANCE_STAMP_RESPONSE = 11287,
  Protocol_DB_DIA_ENTER_COUNT_UPDATE_REQUEST = 11290,
  Protocol_DB_DIA_ENTER_COUNT_UPDATE_RESPONSE = 11291,
  Protocol_DB_ITEM_ENTER_COUNT_UPDATE_REQUEST = 11292,
  Protocol_DB_ITEM_ENTER_COUNT_UPDATE_RESPONSE = 11293,
  Protocol_DB_ENTER_COUNT_UPDATE_REQUEST = 11294,
  Protocol_DB_ENTER_COUNT_UPDATE_RESPONSE = 11295,
  Protocol_DB_ENTER_SET_COUNT_UPDATE_REQUEST = 11296,
  Protocol_DB_ENTER_SET_COUNT_UPDATE_REPONSE = 11297,
  Protocol_DB_ITEM_FUSION_REQUEST = 11298,
  Protocol_DB_ITEM_FUSION_RESPONSE = 11299  ///////////////////////////////////////////////
  ///
  ///			초기 PC 로그인 데이터
  ///
  /// 게임 서버에서 DB_USER_DATA_REQUEST를 보내면 아래 패킷을 쭉 받는다
  ///
  ///////////////////////////////////////////////
,
  Protocol_DB_LOAD_PC_DATA_RESPONSE = 11300,
  Protocol_DB_LOAD_PC_SKILL_DATA_RESPONSE = 11302,
  Protocol_DB_LOAD_PC_PRESET_DATA_RESPONSE = 11303,
  Protocol_DB_LOAD_PC_PC_PURSE_DATA_RESPONSE = 11304,
  Protocol_DB_LOAD_PC_MAIL_DATA_RESPONSE = 11305,
  Protocol_DB_LOAD_PC_DAILY_DUNGEON_DATA_RESPONSE = 11306,
  Protocol_DB_LOAD_PC_SHOP_PURCHASED_DATA_RESPONSE = 11307,
  Protocol_DB_LOAD_PC_STORAGE_DATA_RESPONSE = 11308,
  Protocol_DB_LOAD_PC_ITEM_DATA_RESPONSE = 11309,
  Protocol_DB_LOAD_PC_FOLLOWER_DATA_RESPONSE = 11310,
  Protocol_DB_LOAD_PC_QUEST_DATA_RESPONSE = 11311,
  Protocol_DB_LOAD_PC_CHAPTER_DATA_RESPONSE = 11313,
  Protocol_DB_LOAD_PC_SOLO_DUNGEON_DATA_RESPONSE = 11314,
  Protocol_DB_LOAD_PC_TICKET_DATA_RESPONSE = 11315,
  Protocol_DB_LOAD_PC_ARENA_DATA_RESPONSE = 11316,
  Protocol_DB_LOAD_PC_INFLUENCE_DATA_RESPONSE = 11317,
  Protocol_DB_LOAD_PC_MAIN_STREAM_DATA_RESPONSE = 11319,
  Protocol_DB_LOAD_PC_DAILY_HOMEWORK_DATA_RESPONSE = 11320,
  Protocol_DB_LOAD_PC_INFINITE_TOWER_DATA_RESPONSE = 11322,
  Protocol_DB_LOAD_PC_ENTER_COUNTS_RESPONSE = 11323,
  Protocol_DB_LOAD_PC_ATTENDANCE_RESPONSE = 11324,
  Protocol_DB_LOAD_PC_ACCESS_TIME_RESPONSE = 11325,
  Protocol_DB_LOAD_PC_REST_TIME_RESPONSE = 11326,
  Protocol_DB_LOAD_PC_INFLUENCE_RESPONSE = 11327,
  Protocol_DB_LOAD_PC_SPECIAL_GROWTH_RESPONSE = 11328,
  Protocol_DB_LOAD_PC_BUDDY_RESPONSE = 11329,
  Protocol_DB_LOAD_PC_SHORT_TERM_DATA_RESPONSE = 11330,
  Protocol_DB_LOAD_PC_ACCOUNT_PURSE_DATA_RESPONSE = 11331,
  Protocol_DB_LOAD_PC_ACCOUNT_DEPOT_DATA_RESPONSE = 11332,
  Protocol_DB_LOAD_PC_ACCOUNT_ARTIFACT_DATA_RESPONSE = 11333,
  Protocol_DB_LOAD_PC_ACCOUNT_SHOP_PURCHASE_LIMIT_COUNT_RESPONSE = 11334,
  Protocol_DB_LOAD_PC_ACCOUNT_SHOP_PURCHASE_DATA_RESPONSE = 11335,
  Protocol_DB_LOAD_PC_BUFF_LIST_RESPONSE = 11336,
  Protocol_DB_LOAD_PC_ACCOUNT_MAIL_DATA_RESPONSE = 11337,
  Protocol_DB_LOAD_PC_KILLER_LIST_DATA_RESPONSE = 11338,
  Protocol_DB_LOAD_PC_KILL_ASSIST_COUNT_DATA_RESPONSE = 11339,
  Protocol_DB_LOAD_PC_BATTLE_FIELD_COLLECTION_RESPONSE = 11341,
  Protocol_DB_LOAD_PC_GUILD_DUNGEON_RESPONSE = 11342,
  Protocol_DB_LOAD_PC_COSTUME_PRESET_DATA_RESPONSE = 11343,
  Protocol_DB_LOAD_PC_LIVE_EVENT_TRADE_RESPONSE = 11344,
  Protocol_DB_LOAD_PC_LIVE_EVENT_DIA_BUY_RESPONSE = 11345,
  Protocol_DB_LOAD_PC_LIVE_EVENT_DIA_SPENT_RESPONSE = 11346,
  Protocol_DB_LOAD_PC_LIVE_EVENT_LIMIT_SELL_SHOP_RESPONSE = 11347,
  Protocol_DB_LOAD_PC_ACCOUNT_LIVE_EVENT_LIMIT_SELL_SHOP_RESPONSE = 11348,
  Protocol_DB_LOAD_PC_ACCOUNT_LIVE_EVENT_ATTENTION_RESPONSE = 11349,
  Protocol_DB_LOAD_PC_BRAWL_SHORT_TERM_DATA_RESPONSE = 11350,
  Protocol_DB_LOAD_PC_BRAWL_DAILY_ACQUIRED_DATA_RESPONSE = 11351,
  Protocol_DB_LOAD_PC_BRAWL_ENHANCE_DATA_RESPONSE = 11352,
  Protocol_DB_LOAD_PC_SCROLL_QUEST_DATA_RESPONSE = 11353,
  Protocol_DB_LOAD_PC_BRAWL_LAST_LEAVED_TIME_DATA_RESPONSE = 11354,
  Protocol_DB_LOAD_PC_LIVE_EVENT_LEVELUP_RESPONSE = 11355,
  Protocol_DB_LOAD_PC_ACCOUNT_PET_DATA_RESPONSE = 11356,
  Protocol_DB_LOAD_PC_ACCOUNT_PET_ALTAR_DATA_RESPONSE = 11357,
  Protocol_DB_LOAD_PC_ACCOUNT_PET_HATCHERY_DATA_RESPONSE = 11358,
  Protocol_DB_LOAD_PC_CRYSTAL_CHANGE_COUNT_DATA_RESPONSE = 11359,
  Protocol_DB_LOAD_PC_ACCOUNT_LAST_LOGOUT_BY_MY_PCS_RESPONSE = 11360,
  Protocol_DB_LOAD_PC_PVPCOIN_DAILY_ACQUIRED_DATA_RESPONSE = 11361  ///////////////////////////////////////////////
  ///
  ///			PC 업데이트 데이터
  ///
  ///////////////////////////////////////////////
,
  Protocol_DB_UPDATE_PC_UPDATE_DATA_NOTIFY = 11500,
  Protocol_DB_UPDATE_QUEST_UPDATE_DATA_NOTIFY = 11501,
  Protocol_DB_UPDATE_ACCESS_TIME_DATA_NOTIFY = 11502,
  Protocol_DB_UPDATE_REST_TIME_DATA_NOTIFY = 11503  ///////////////////////////////////////////////
  ///
  /// DB Transaction (Game <-> Agent)
  /// 번호가 부족해서 일단 여기 추가했습니다.
  /// 
  ///////////////////////////////////////////////	
,
  Protocol_DB_ACCESS_TIME_REWARD_REQUEST = 12000,
  Protocol_DB_ACCESS_TIME_REWARD_RESPONSE = 12001,
  Protocol_DB_ACCESS_TIME_SET_REQUEST = 12002,
  Protocol_DB_ACCESS_TIME_SET_RESPONSE = 12003,
  Protocol_DB_REST_TIME_REWARD_REQUEST = 12005,
  Protocol_DB_REST_TIME_REWARD_RESPONSE = 12006,
  Protocol_DB_REST_TIME_SET_REQUEST = 12007,
  Protocol_DB_REST_TIME_SET_RESPONSE = 12008,
  Protocol_DB_UPC_CACHE_DATA_REQUEST = 12010,
  Protocol_DB_UPC_CACHE_DATA_RESPONSE = 12011,
  Protocol_DB_ARENA_SCORE_UPDATE_REQUEST = 12012,
  Protocol_DB_CHANNEL_MOVE_TIME_UPDATE_REQUEST = 12013,
  Protocol_DB_CHANNEL_MOVE_TIME_UPDATE_RESPONSE = 12014,
  Protocol_DB_BATTLE_FIELD_SET_TIME_REQUEST = 12020,
  Protocol_DB_BATTLE_FIELD_SET_TIME_RESPONSE = 12021,
  Protocol_DB_BATTLE_FIELD_DAILY_RESET_REQUEST = 12022,
  Protocol_DB_BATTLE_FIELD_DAILY_RESET_RESPONSE = 12023,
  Protocol_DB_BATTLE_FIELD_SET_SHORT_TERM_REQUEST = 12024,
  Protocol_DB_BATTLE_FIELD_SET_SHORT_TERM_RESPONSE = 12025,
  Protocol_DB_ARENA_TODAY_PLAY_COUNT_UPDATE_REQUEST = 12026,
  Protocol_DB_ARENA_TODAY_PLAY_COUNT_UPDATE_RESPONSE = 12027,
  Protocol_DB_ARENA_TODAY_PLAY_COUNT_RESET_REQUEST = 12028,
  Protocol_DB_ARENA_TODAY_PLAY_COUNT_RESET_RESPONSE = 12029,
  Protocol_DB_BATTLE_FIELD_SET_SHORT_TERM_MAIL_REQUEST = 12030,
  Protocol_DB_BATTLE_FIELD_SET_SHORT_TERM_MAIL_RESPONSE = 12031,
  Protocol_DB_KILLER_INFO_SET_REQUEST = 12041,
  Protocol_DB_KILLER_INFO_SET_RESPONSE = 12042,
  Protocol_DB_KILL_ASSIST_COUNT_SET_REQUEST = 12047,
  Protocol_DB_KILL_ASSIST_COUNT_SET_RESPONSE = 12048,
  Protocol_DB_EVENT_REWARD_REQUEST = 12050,
  Protocol_DB_EVENT_REWARD_RESPONSE = 12051,
  Protocol_DB_PLAYER_STAT_SAVE_REQUEST = 12052,
  Protocol_DB_PLAYER_STAT_SAVE_RESPONSE = 12053,
  Protocol_DB_GUILD_DUNGEON_CLEAR_REQUEST = 12061,
  Protocol_DB_GUILD_DUNGEON_CLEAR_RESPONSE = 12062,
  Protocol_DB_GUILD_DUNGEON_REWARD_REQUEST = 12063,
  Protocol_DB_GUILD_DUNGEON_REWARD_RESPONSE = 12064,
  Protocol_DB_COSTUME_PRESET_TYPE_UPDATE_REQUEST = 12065,
  Protocol_DB_COSTUME_PRESET_TYPE_UPDATE_RESPONSE = 12066,
  Protocol_DB_COSTUME_PRESET_UPDATE_REQUEST = 12067,
  Protocol_DB_COSTUME_PRESET_UPDATE_RESPONSE = 12068,
  Protocol_DB_ENCHANT_COSTUME_REQUEST = 12069,
  Protocol_DB_ENCHANT_COSTUME_RESPONSE = 12070,
  Protocol_DB_UPGRADE_COSTUME_REQUEST = 12071,
  Protocol_DB_UPGRADE_COSTUME_RESPONSE = 12072,
  Protocol_DB_INHERIT_COSTUME_REQUEST = 12073,
  Protocol_DB_INHERIT_COSTUME_RESPONSE = 12074,
  Protocol_DB_LIVE_EVENT_TRADE_PURCHAES_REQUEST = 12100,
  Protocol_DB_LIVE_EVENT_TRADE_PURCHAES_RESPONSE = 12101,
  Protocol_DB_LIVE_EVENT_LIMIT_SELL_SHOP_PURCHAES_REQUEST = 12102,
  Protocol_DB_LIVE_EVENT_LIMIT_SELL_SHOP_PURCHAES_RESPONSE = 12103,
  Protocol_DB_LIVE_EVENT_DIA_BUY_REWARD_REQUEST = 12104,
  Protocol_DB_LIVE_EVENT_DIA_BUY_REWARD_RESPONSE = 12105,
  Protocol_DB_LIVE_EVENT_DIA_BUY_UPDATE_AMOUNT_NOTIFY = 12106,
  Protocol_DB_LIVE_EVENT_DIA_SPENT_REWARD_REQUEST = 12107,
  Protocol_DB_LIVE_EVENT_DIA_SPENT_REWARD_RESPONSE = 12108,
  Protocol_DB_LIVE_EVENT_DIA_SPENT_UPDATE_AMOUNT_NOTIFY = 12109,
  Protocol_DB_LIVE_EVENT_ATTENTION_RECEIVE_STATE_REQUEST = 12110,
  Protocol_DB_LIVE_EVENT_ATTENTION_RECEIVE_STATE_RESPONSE = 12111,
  Protocol_DB_LIVE_EVENT_RETURN_ATTENTION_RECEIVE_STATE_REQUEST = 12112,
  Protocol_DB_LIVE_EVENT_RETURN_ATTENTION_RECEIVE_STATE_RESPONSE = 12113,
  Protocol_DB_LIVE_EVENT_NEWBIE_ATTENTION_RECEIVE_STATE_REQUEST = 12114,
  Protocol_DB_LIVE_EVENT_NEWBIE_ATTENTION_RECEIVE_STATE_RESPONSE = 12115,
  Protocol_DB_LIVE_EVENT_ATTENTION_REWARD_REQUEST = 12116,
  Protocol_DB_LIVE_EVENT_ATTENTION_REWARD_RESPONSE = 12117,
  Protocol_DB_LIVE_EVENT_RETURN_ATTENTION_REWARD_REQUEST = 12118,
  Protocol_DB_LIVE_EVENT_RETURN_ATTENTION_REWARD_RESPONSE = 12119,
  Protocol_DB_LIVE_EVENT_NEWBIE_ATTENTION_REWARD_REQUEST = 12120,
  Protocol_DB_LIVE_EVENT_NEWBIE_ATTENTION_REWARD_RESPONSE = 12121,
  Protocol_DB_LIVE_EVENT_ATTENTION_END_RECEIVE_STATE_REQUEST = 12122,
  Protocol_DB_LIVE_EVENT_ATTENTION_END_RECEIVE_STATE_RESPONSE = 12123,
  Protocol_DB_LIVE_EVENT_RETURN_ATTENTION_END_RECEIVE_STATE_REQUEST = 12124,
  Protocol_DB_LIVE_EVENT_RETURN_ATTENTION_END_RECEIVE_STATE_RESPONSE = 12125,
  Protocol_DB_LIVE_EVENT_NEWBIE_ATTENTION_END_RECEIVE_STATE_REQUEST = 12126,
  Protocol_DB_LIVE_EVENT_NEWBIE_ATTENTION_END_RECEIVE_STATE_RESPONSE = 12127,
  Protocol_DB_LIVE_EVENT_ATTENTION_END_REWARD_REQUEST = 12128,
  Protocol_DB_LIVE_EVENT_ATTENTION_END_REWARD_RESPONSE = 12129,
  Protocol_DB_LIVE_EVENT_RETURN_ATTENTION_END_REWARD_REQUEST = 12130,
  Protocol_DB_LIVE_EVENT_RETURN_ATTENTION_END_REWARD_RESPONSE = 12131,
  Protocol_DB_LIVE_EVENT_NEWBIE_ATTENTION_END_REWARD_REQUEST = 12132,
  Protocol_DB_LIVE_EVENT_NEWBIE_ATTENTION_END_REWARD_RESPONSE = 12133,
  Protocol_DB_LIVE_EVENT_LEVELUP_RECEIVE_STATE_REQUEST = 12134,
  Protocol_DB_LIVE_EVENT_LEVELUP_RECEIVE_STATE_RESPONSE = 12135,
  Protocol_DB_LIVE_EVENT_LEVELUP_REWARD_REQUEST = 12136,
  Protocol_DB_LIVE_EVENT_LEVELUP_REWARD_RESPONSE = 12137,
  Protocol_DB_STORAGE_SLOT_EXPANSION_REQUEST = 12150,
  Protocol_DB_STORAGE_SLOT_EXPANSION_RESPONSE = 12151,
  Protocol_DB_BRAWL_SET_TIME_REQUEST = 12160,
  Protocol_DB_BRAWL_SET_TIME_RESPONSE = 12161,
  Protocol_DB_BRAWL_SET_SHORT_TERM_REQUEST = 12162,
  Protocol_DB_BRAWL_SET_SHORT_TERM_RESPONSE = 12163,
  Protocol_DB_BRAWL_SHORT_TERM_REWARD_REQUEST = 12164,
  Protocol_DB_BRAWL_SHORT_TERM_REWARD_RESPONSE = 12165,
  Protocol_DB_BRAWL_SET_POINT_REQEUST = 12170,
  Protocol_DB_BRAWL_SET_POINT_RESPONSE = 12171,
  Protocol_DB_BRAWL_ENHANCE_LEVEL_UP_REQUEST = 12172,
  Protocol_DB_BRAWL_ENHANCE_LEVEL_UP_RESPONSE = 12173,
  Protocol_DB_BRAWL_SET_DAILY_ACQUIRED_REQEUST = 12174,
  Protocol_DB_BRAWL_SET_DAILY_ACQUIRED_RESPONSE = 12175,
  Protocol_DB_SCROLL_QUEST_USE_SCROLL_GROUP_ITEM_REQUEST = 12178,
  Protocol_DB_SCROLL_QUEST_USE_SCROLL_GROUP_ITEM_RESPONSE = 12179,
  Protocol_DB_SCROLL_QUEST_PROGRESS_SET_REQUEST = 12180,
  Protocol_DB_SCROLL_QUEST_PROGRESS_SET_RESPONSE = 12181,
  Protocol_DB_SCROLL_QUEST_DAILY_SET_REQUEST = 12182,
  Protocol_DB_SCROLL_QUEST_DAILY_SET_RESPONSE = 12183,
  Protocol_DB_SCROLL_QUEST_REWARD_REQUEST = 12184,
  Protocol_DB_SCROLL_QUEST_REWARD_RESPONSE = 12185,
  Protocol_DB_UPDATE_PVP_POINT_REQEUST = 12191,
  Protocol_DB_UPDATE_PVP_POINT_RESPONSE = 12192,
  Protocol_DB_SET_PVP_COIN_DAILY_ACQUIRED_REQEUST = 12193,
  Protocol_DB_SET_PVP_COIN_DAILY_ACQUIRED_RESPONSE = 12194  /////////////////////////////////////////
  /// Client <-> Game
  /////////////////////////////////////////
,
  Protocol_PC_LOGIN_DATA_NOTIFY = 20000,
  Protocol_LOAD_DATA_REQUEST = 20001,
  Protocol_LOAD_DATA_RESPONSE = 20002,
  Protocol_WORLDOBJECT_DESPAWN_NOTIFY = 20003,
  Protocol_PC_SPAWN_NOTIFY = 20004,
  Protocol_NPC_SPAWN_NOTIFY = 20005,
  Protocol_PROJECTILE_SPAWN_NOTIFY = 20006,
  Protocol_INSTANTSHOT_SPAWN_NOTIFY = 20007,
  Protocol_INSTANTSHOT_DESPAWN_NOTIFY = 20008,
  Protocol_PROJECTILE_EFFECT_NOTIFY = 20009,
  Protocol_REACTION_ENTER_NOTIFY = 20010,
  Protocol_REACTION_LEAVE_NOTIFY = 20011,
  Protocol_REACTION_UPDATE_NOTIFY = 20012,
  Protocol_ENTER_STATE_NOTIFY = 20013,
  Protocol_LEAVE_STATE_NOTIFY = 20014,
  Protocol_PLAYER_REVIVE_REQUEST = 20015,
  Protocol_PLAYER_REVIVE_RESPONSE = 20016,
  Protocol_UPC_SPAWN_NOTIFY = 20017,
  Protocol_PLAYER_IMMEDIATELY_DEAD_REQUEST = 20018,
  Protocol_PC_GUILD_INFO_UPDATE_NOTIFY = 20019,
  Protocol_AGGRO_TICKER_INFO_NOTIFY = 20020,
  Protocol_UPC_LOAD_START_NOTIFY = 20021,
  Protocol_UPC_LOAD_FINISH_NOTIFY = 20022,
  Protocol_UPC_HOST_REQUEST = 20023,
  Protocol_UPC_HOST_RESPONSE = 20024,
  Protocol_UPC_UNHOST_NOTIFY = 20025,
  Protocol_PC_STAT_HARDCAP_DATA_NOTIFY = 20026,
  Protocol_STORAGE_DATA_NOTIFY = 20027,
  Protocol_STORAGE_ITEM_DATA_NOTIFY = 20028,
  Protocol_EQUIP_DATA_NOTIFY = 20029,
  Protocol_UPC_LOAD_START_NOTIFY_REQUEST = 20030,
  Protocol_PC_PK_HONOR_INFO_REQUEST = 20034,
  Protocol_PC_PK_HONOR_INFO_RESPONSE = 20035,
  Protocol_KILL_ASSIST_COUNT_NOTIFY = 20036,
  Protocol_PLAYER_DESPAWN_NOTIFY = 20050,
  Protocol_SKILL_USE_NOTIFY = 21000,
  Protocol_SKILL_START_NOTIFY = 21001,
  Protocol_SKILL_END_NOTIFY = 21002,
  Protocol_SKILL_EFFECT_NOTIFY = 21003,
  Protocol_SKILL_EFFECT_RESULT_NOTIFY = 21004,
  Protocol_SKILL_SLOT_NOTIFY = 21005,
  Protocol_SKILL_OPEN_SHIELD_NOTIFY = 21006,
  Protocol_STAT_UPDATE_NOTIFY = 21007,
  Protocol_SKILL_ERROR_NOTIFY = 21008,
  Protocol_SKILL_CLOSED_SHIELD_NOTIFY = 21009  /// Effect Result
,
  Protocol_SKILL_EFFECT_RESULT_DAMAGE_NOTIFY = 21011,
  Protocol_SKILL_EFFECT_RESULT_HEAL_NOTIFY = 21012,
  Protocol_SKILL_SLOT_PLACE_REQUEST = 21013,
  Protocol_SKILL_SLOT_PLACE_RESPONSE = 21014,
  Protocol_SKILL_LEVEL_UP_REQUEST = 21015,
  Protocol_SKILL_LEVEL_UP_RESPONSE = 21016,
  Protocol_CHANGE_IFF_NOTIFY = 21017,
  Protocol_UPDATE_ENERGYPOINT_NOTIFY = 21018,
  Protocol_PRESET_CHANGE_REQUEST = 21019,
  Protocol_PRESET_CHANGE_RESPONSE = 21020,
  Protocol_PRESET_ITEMSLOT_UPDATE_NOTIFY = 21021,
  Protocol_SKILL_FEATURE_INITIALIZE_REQUEST = 21022,
  Protocol_SKILL_FEATURE_INITIALIZE_RESPONSE = 21023,
  Protocol_UPDATE_SKILL_POINT_NOTIFY = 21024,
  Protocol_PLAYER_REVIVE_INFO_NOTIFY = 21025,
  Protocol_SWITCH_SKILL_SLOT_REQUEST = 21026  /// BUFF
,
  Protocol_ADD_BUFF_NOTIFY = 21100,
  Protocol_UPDATE_BUFF_NOTIFY = 21101,
  Protocol_CREATURE_HP_CHANGE_NOTIFY = 21200,
  Protocol_CHANGED_SUPER_ARMOR_GAUGE_NOTIFY = 21201,
  Protocol_PENALTY_SKILL_NOTIFY = 21202,
  Protocol_PENALTY_SKILL_CANCEL_NOTIFY = 21203,
  Protocol_CHANGE_REACTION_IMMUNE_INFO_NOTIFY = 21204  /// 몬스터 관련
  /// 몬스터 어그로 타이머 정보 통지
,
  Protocol_NPC_AGGRO_TIMER_NOTIFY = 21300  /// 어떤 대상이 타겟되었음을 통지
,
  Protocol_CREATURE_TARGETED_NOTIFY = 21301  /// 몬스터 리턴 주의 통지
,
  Protocol_NPC_RETURN_WARNING_NOTIFY = 21302,
  Protocol_AI_ACTION_START_NOTIFY = 21303,
  Protocol_AI_ACTION_END_NOTIFY = 21304,
  Protocol_CREATURE_DETECT_TARGET_NOTIFY = 21305  /// 소셜모션
,
  Protocol_SOCIAL_MOTION_START_REQUEST = 21350,
  Protocol_SOCIAL_MOTION_START_NOTIFY = 21351  /// INVENTORY : Client <-> Game
  ///INSERT_ITEM_REQUEST							= 22000,
,
  Protocol_INSERT_ITEM_RESPONSE = 22001,
  Protocol_DELETE_ITEM_REQUEST = 22002,
  Protocol_DELETE_ITEM_RESPONSE = 22003,
  Protocol_EQUIP_ITEM_OBJECT_REQUEST = 22005,
  Protocol_EQUIP_ITEM_RESPONSE = 22006,
  Protocol_UNEQUIP_ITEM_REQUEST = 22007,
  Protocol_UNEQUIP_ITEM_RESPONSE = 22008,
  Protocol_REFRESH_INVEN_REQUEST = 22009,
  Protocol_REFRESH_INVEN_RESPONSE = 22010,
  Protocol_SERVER_TIME_REQUEST = 22011,
  Protocol_SERVER_TIME_RESPONSE = 22012,
  Protocol_UPDATE_ITEM_NOTIFY = 22013,
  Protocol_TOGGLE_SAFE_GUARD_REQUEST = 22014,
  Protocol_TOGGLE_SAFE_GUARD_RESPONSE = 22015,
  Protocol_USE_ITEM_REQUEST = 22016,
  Protocol_USE_ITEM_RESPONSE = 22017,
  Protocol_ITEM_BOUND_STATE_UPDATE_NOTIFY = 22018,
  Protocol_ADD_ITEM_NOTIFY = 22019,
  Protocol_REMOVE_ITEM_NOTIFY = 22020,
  Protocol_CHANGE_ITEM_STACK_COUNT_NOTIFY = 22021,
  Protocol_UPDATE_ITEM_GRADE_LEVEL_NOTIFY = 22022,
  Protocol_UPDATE_ITEM_OPTION_NOTIFY = 22023,
  Protocol_MOVE_ITEM_NOTIFY = 22024,
  Protocol_UPDATE_ARTIFACT_NOTIFY = 22025,
  Protocol_FOLLOWER_ADD_SOUL_STONE_NOTIFY = 22026,
  Protocol_FOLLOWER_ENCHANT_REQUEST = 22027,
  Protocol_FOLLOWER_ENCHANT_RESPONSE = 22028,
  Protocol_FOLLOWER_START_MISSION_REQUEST = 22029,
  Protocol_FOLLOWER_START_MISSION_NOTIFY = 22030,
  Protocol_FOLLOWER_END_MISSION_REQUEST = 22031,
  Protocol_FOLLOWER_END_MISSION_RESPONSE = 22032,
  Protocol_FOLLOWER_MISSION_REMAIN_TIME_REQUEST = 22033,
  Protocol_FOLLOWER_MISSION_REMAIN_TIME_RESPONSE = 22034,
  Protocol_FOLLOWER_LOAD_INFO_NOTIFY = 22035,
  Protocol_FOLLOWER_MISSION_REWARD_RESPONSE = 22036,
  Protocol_FOLLOWER_MISSION_COMPLETE_REQUEST = 22037,
  Protocol_FOLLOWER_MISSION_COMPLETE_RESPONSE = 22038  /// ENCHANT : Client <-> Game
,
  Protocol_DISENCHANT_ITEM_REQUEST = 22100,
  Protocol_DISENCHANT_ITEM_RESPONSE = 22101,
  Protocol_ENCHANT_ITEM_REQUEST = 22104,
  Protocol_ENCHANT_ITEM_RESPONSE = 22105,
  Protocol_EQUIPMENT_TRANSMUTATION_ITEM_REQUEST = 22106,
  Protocol_EQUIPMENT_TRANSMUTATION_ITEM_RESPONSE = 22107,
  Protocol_UPGRADE_ITEM_REQUEST = 22108,
  Protocol_UPGRADE_ITEM_RESPONSE = 22109  /// CRAFTING
,
  Protocol_CRAFT_ITEM_REQUEST = 22116,
  Protocol_CRAFT_ITEM_RESPONSE = 22117  /// PRISM TRANSMUTATION
,
  Protocol_PRISM_TRANSMUTATION_REQUEST = 22118,
  Protocol_PRISM_TRANSMUTATION_RESPONSE = 22119  /// ITEM MOVE
,
  Protocol_MOVE_ITEM_REQUEST = 22120,
  Protocol_MOVE_ITEM_RESPONSE = 22121,
  Protocol_TRANSMUTE_CRYSTAL_ITEM_REQUEST = 22122,
  Protocol_TRANSMUTE_CRYSTAL_ITEM_RESPONSE = 22123,
  Protocol_CHANGE_CRYSTAL_ITEM_REQUEST = 22124,
  Protocol_CHANGE_CRYSTAL_ITEM_RESPONSE = 22125,
  Protocol_CRYSTAL_ITEM_CHANGE_COUNT_NOTIFY = 22126  /// TICKET
,
  Protocol_TICKET_NOTIFY = 22132,
  Protocol_TICKET_ALL_NOTIFY = 22133,
  Protocol_ACQUIRE_CONTRIBUTION_NOTIFY = 22134,
  Protocol_BUNDLE_BOX_RESULT_NOTIFY = 22135,
  Protocol_ITEM_FUSION_REQUEST = 22136,
  Protocol_ITEM_FUSION_RESPONSE = 22137,
  Protocol_USE_ITEM_CONTENTS_EFFECT_REQUEST = 22138,
  Protocol_USE_ITEM_CONTENTS_EFFECT_RESPONSE = 22139,
  Protocol_TRANSCEND_ITEM_REQUEST = 22140,
  Protocol_TRANSCEND_ITEM_RESPONSE = 22141,
  Protocol_TRANSCEND_CHANGE_STAT_REQUEST = 22142,
  Protocol_TRANSCEND_CHANGE_STAT_RESPONSE = 22143  /// PC PROGRESSION
  /// - level up
  /// - progression(성장)
  ///   (1) promotion(진급)
  ///   (2) advancement(전직)
  /// PC LEVEL UP AND EXP NOTIFY
,
  Protocol_PC_LEVEL_UP_EXP_NOTIFY = 22200,
  Protocol_PC_EXP_UP_NOTIFY = 22201  /// 보상 알림
,
  Protocol_DROP_REWARD_NOTIFY = 22300  /// STORE : Client <-> Game
,
  Protocol_SALE_ITEM_REQUEST = 22500,
  Protocol_SALE_ITEM_RESPONSE = 22501,
  Protocol_UPDATE_PURSE_NOTIFY = 22502  /// 워크 오브젝트 스폰
,
  Protocol_WORKOBJECT_SPAWN_NOTIFY = 23001  /// 워크 오브젝트 정보 업데이트
,
  Protocol_WORKOBJECT_UPDATE_NOTIFY = 23002  /// 인터랙션 상태 통지
,
  Protocol_INTERACTION_STATE_NOTIFY = 23011  /// 인터렉션 시작요청
,
  Protocol_START_INTERACTION_REQUEST = 23021,
  Protocol_START_RESURRECTION_REQUEST = 23022,
  Protocol_START_RESURRECTION_NOTIFY = 23023,
  Protocol_END_RESURRECTION_NOTIFY = 23024,
  Protocol_CANCEL_RESURRECTION_REQUEST = 23025,
  Protocol_CANCEL_RESURRECTION_NOTIFY = 23026  /// 미니게임 인터렉션 시작
,
  Protocol_START_MINIGAME_INTERACTION_NOTIFY = 23031  /// 다이얼로그 인터랙션 시작
,
  Protocol_START_DIALOG_INTERACTION_NOTIFY = 23032  /// 다른 유저 인터렉션 시작 알림
,
  Protocol_OTHER_PC_START_INTERACTION_NOTIFY = 23039  /// MiniGame 결과 통지(Client -> Server)
,
  Protocol_MINIGAME_INTERACTION_RESULT_NOTIFY = 23041  /// 인터렉션 취소 통지(Client -> Server)
,
  Protocol_CANCEL_INTERACTION_NOTIFY = 23051  /// 인터렉션 종료 통지
,
  Protocol_END_INTERACTION_NOTIFY = 23052  /// 다른 유저 인터렉션 종료 알림
,
  Protocol_OTHER_PC_END_INTERACTION_NOTIFY = 23059,
  Protocol_PUSH_CREATE_NOTIFY = 23100,
  Protocol_PUSH_UPDATE_NOTIFY = 23101,
  Protocol_PUSH_ALONE_JOIN_REQUEST = 23103,
  Protocol_PUSH_ALONE_JOIN_RESPONSE = 23104,
  Protocol_PUSH_QUICK_MATCHING_JOIN_REQUEST = 23105,
  Protocol_PUSH_QUICK_MATCHING_JOIN_RESPONSE = 23106,
  Protocol_PUSH_QUICK_MATCHING_LEAVE_REQUEST = 23107,
  Protocol_PUSH_MATCHING_ADDED_NOTIFY = 23110,
  Protocol_PUSH_MATCHING_REMOVED_NOTIFY = 23111,
  Protocol_PUSH_MATCHING_JOINED_PC_CLASS_UPDATE = 23115,
  Protocol_PUSH_MATCHING_FAILED_NOTIFY = 23120,
  Protocol_PUSH_MATCHED_SUCCESS_NOTIFY = 23121  /// 연출 카메라 시작
,
  Protocol_CAMERA_OBJECT_START_NOTIFY = 24200  /// 연출 카메라 종료
,
  Protocol_CAMERA_OBJECT_END_NOTIFY = 24201  /// 연출 카메라 이동
,
  Protocol_CAMERA_OBJECT_MOVE_NOTIFY = 24210,
  Protocol_DIMENSION_CRYSTAL_INSERT_REQUEST = 24250,
  Protocol_DIMENSION_CRYSTAL_INSERT_RESPONSE = 24251,
  Protocol_DB_DIMENSION_CRYSTAL_INSERT_REQUEST = 24252,
  Protocol_DB_DIMENSION_CRYSTAL_INSERT_RESPONSE = 24253,
  Protocol_DIMENSION_CRYSTAL_REMOVE_REQUEST = 24254,
  Protocol_DIMENSION_CRYSTAL_REMOVE_RESPONSE = 24255,
  Protocol_DB_DIMENSION_CRYSTAL_REMOVE_REQUEST = 24256,
  Protocol_DB_DIMENSION_CRYSTAL_REMOVE_RESPONSE = 24257,
  Protocol_DIMENSION_CRYSTAL_LEVELUP_REQUEST = 24258,
  Protocol_DIMENISON_CRYSTAL_LEVELUP_RESPONSE = 24259,
  Protocol_DB_DIMENSION_CRYSTAL_LEVELUP_REQUEST = 24260,
  Protocol_DB_DIMENSION_CRYSTAL_LEVELUP_RESPONSE = 24261,
  Protocol_DIMENSION_CRYSTAL_UPGRADE_REQUEST = 24262,
  Protocol_DIMENSION_CRYSTAL_UPGRADE_RESPONSE = 24363,
  Protocol_DB_DIMENSION_CRYSTAL_UPGRADE_REQUEST = 24364,
  Protocol_DB_DIMENSION_CRYSTAL_UPGRADE_RESPONSE = 24365  /// 재연결
,
  Protocol_GAME_RECONNECT_REQUEST = 25000,
  Protocol_GAME_RECONNECT_RESPONSE = 25001,
  Protocol_RECONNECT_LOAD_DATA_REQUEST = 25002,
  Protocol_RECONNECT_LOAD_DATA_RESPONSE = 25003,
  Protocol_LOAD_DATA_COMPLETE_NOTIFY = 25005,
  Protocol_PC_LOGIN_DATA_COMPLETE_NOTIFY = 25010,
  Protocol_PC_LOGIN_DATA_START_NOTIFY = 25011,
  Protocol_REDIS_GET_RANGE_RANK_INFO_REQUEST = 25021,
  Protocol_REDIS_GET_RANGE_RANK_INFO_RESPONSE = 25022,
  Protocol_REDIS_GET_MY_RANK_REQUEST = 25023,
  Protocol_REDIS_GET_MY_RANK_RESPONSE = 25024,
  Protocol_REDIS_RANK_LOOKUP_REQUEST = 25026,
  Protocol_RANK_GET_PC_DEATIL_INFO_REQUEST = 25028,
  Protocol_REDIS_RANK_LOOKUP_RESPONSE = 25030,
  Protocol_DB_SHOP_PRODUCT_PURCHASE_REQUEST = 25050,
  Protocol_DB_SHOP_PRODUCT_PURCHASE_RESPONSE = 25051,
  Protocol_DB_SHOP_PROUDCT_UPDATE_MISSION_REQUEST = 25052,
  Protocol_DB_SHOP_PROUDCT_UPDATE_MISSION_RESPONSE = 25053,
  Protocol_DB_SHOP_PRODUCT_MISSION_REWARD_REQUEST = 25054,
  Protocol_DB_SHOP_PRODUCT_MISSION_REWARD_RESPONSE = 25055,
  Protocol_DB_SHOP_PRODUCT_PROMOTION_REWARD_REQUEST = 25056,
  Protocol_DB_SHOP_PRODUCT_PROMOTION_REWARD_RESPONSE = 25057,
  Protocol_ELIXIR_LIST_NOTIFY = 25070,
  Protocol_ELIXIR_EHCNAHT_REQUEST = 25071,
  Protocol_ELIXIR_EHCNAHT_RESPONSE = 25072,
  Protocol_DB_ELIXIR_ENCHANT_REQUEST = 25073,
  Protocol_DB_ELIXIR_ENCHANT_RESPONSE = 25074,
  Protocol_TERRASTONE_LIST_NOTIFY = 25080,
  Protocol_TERRASTONE_ENCHANT_REQUEST = 25081,
  Protocol_TERRASTONE_ENCHANT_RESPONSE = 25082,
  Protocol_DB_TERRASTONE_ENCHANT_REQUEST = 25083,
  Protocol_DB_TERRASTONE_ENCHANT_RESPONSE = 25084,
  Protocol_RESEARCH_LIST_NOTIFY = 25090,
  Protocol_RESEARCH_ENCHANT_REQUEST = 25091,
  Protocol_RESEARCH_ENCHANT_RESPONSE = 25092,
  Protocol_DB_RESEARCH_ENCHANT_REQUEST = 25093,
  Protocol_DB_RESEARCH_ENCHANT_RESPONSE = 25094,
  Protocol_GUARDIAN_STAR_LIST_NOTIFY = 25100,
  Protocol_GUARDIAN_STAR_ENCHANT_REQUEST = 25101,
  Protocol_GUARDIAN_STAR_ENCHANT_RESPONSE = 25102,
  Protocol_GUARDIAN_STAR_UPGRADE_REQUEST = 25103,
  Protocol_GUARDIAN_STAR_UPGRADE_RESPONSE = 25104,
  Protocol_DB_GUARDIAN_STAR_ENCHANT_REQUEST = 25105,
  Protocol_DB_GUARDIAN_STAR_ENCHANT_RESPONSE = 25106,
  Protocol_DB_GUARDIAN_STAR_UPGRADE_REQUEST = 25107,
  Protocol_DB_GUARDIAN_STAR_UPGRADE_RESPONSE = 25108,
  Protocol_PASSIVE_SKILL_LIST_NOTIFY = 25109,
  Protocol_PASSIVE_SKILL_ENCHANT_REQUEST = 25110,
  Protocol_PASSIVE_SKILL_ENCHANT_RESPONSE = 25111,
  Protocol_DB_PASSIVE_SKILL_ENCHANT_REQUEST = 25112,
  Protocol_DB_PASSIVE_SKILL_ENCHANT_RESPONSE = 25113,
  Protocol_DB_BUFF_SAVE_REQUEST = 25114,
  Protocol_DB_BUFF_SAVE_RESPONSE = 25115,
  Protocol_DB_BUFF_UPDATE_REQUEST = 25116,
  Protocol_DB_BUFF_UPDATE_RESPONSE = 25117,
  Protocol_DB_BUFF_REMOVE_REQUEST = 25118,
  Protocol_DB_BUFF_REMOVE_RESPONSE = 25119,
  Protocol_POTION_GROWTH_LIST_NOTIFY = 25120,
  Protocol_POTION_GROWTH_UPDATE_NOTIFY = 25121,
  Protocol_POTION_GROWTH_LEVEL_UP_REQUEST = 25122,
  Protocol_POTION_GROWTH_LEVEL_UP_RESPONSE = 25123,
  Protocol_DB_POTION_GROWTH_LEVEL_EXP_CHANGE_REQUEST = 25124,
  Protocol_DB_POTION_GROWTH_LEVEL_EXP_CHANGE_RESPONSE = 25125,
  Protocol_PC_CLIENT_CONFIG_NOTIFY = 25130,
  Protocol_PC_CLIENT_CONFIG_SAVE_REQUEST = 25131,
  Protocol_DB_UPDATE_PC_CLIENT_CONFIG_NOTIFY = 25132,
  Protocol_NOTICE_ITEM_NOTIFY = 25140,
  Protocol_NOTICE_USER_NOTIFY = 25141,
  Protocol_NOTICE_SHOP_PURCHASE_NOTIFY = 25142,
  Protocol_NOTICE_PET_NOTIFY = 25143,
  Protocol_NOTICE_ELITE_MONSTER_KILL_NOTIFY = 25144,
  Protocol_GUILD_INFO_NOTIFY = 25200  /// 미구현을 알리기 위한 패킷
  /// 서버에서 구현 안된 요청이 오면 이 패킷이 갑니다
,
  Protocol_GUILD_NOT_IMPL_NOTIFY = 25201,
  Protocol_GUILD_INFO_REQUEST = 25202,
  Protocol_GUILD_INFO_RESPONSE = 25203  /// 길드 생성
,
  Protocol_GUILD_CREATE_REQUEST = 25204,
  Protocol_GUILD_CREATE_RESPONSE = 25205  /// 생성 전 길드명 체크
,
  Protocol_GUILD_CHECK_NAME_REQUEST = 25206,
  Protocol_GUILD_CHECK_NAME_RESPONSE = 25207  /// 길드 해산
,
  Protocol_GUILD_DESTROY_REQUEST = 25208,
  Protocol_GUILD_DESTROY_RESPONSE = 25209  /// 길드 찾기 (길드명으로)
,
  Protocol_GUILD_FIND_REQUEST = 25210,
  Protocol_GUILD_FIND_RESPONSE = 25211  /// 가입 신청 (request request..)
,
  Protocol_GUILD_JOIN_REQ_REQUEST = 25212,
  Protocol_GUILD_JOIN_REQ_RESPONSE = 25213  /// 가입 신청 변경 알림
,
  Protocol_GUILD_APPLICANT_UPDATE_NOTIFY = 25214  /// 새로운 멤버 들어옴
,
  Protocol_GUILD_NEW_MEMBER_NOTIFY = 25215  /// 멤버 나감
,
  Protocol_GUILD_LEAVE_MEMBER_NOTIFY = 25216  /// 탈퇴 (강퇴는 밑에 따로 있음)
,
  Protocol_GUILD_LEAVE_REQUEST = 25217,
  Protocol_GUILD_LEAVE_RESPONSE = 25218  /// 길드 가입됨
,
  Protocol_GUILD_JOIN_NOTIFY = 25219  /// 길드 탈퇴됨
,
  Protocol_GUILD_LEAVE_NOTIFY = 25220  /// 길드 멤버 조회
,
  Protocol_GUILD_MEMBER_LIST_REQUEST = 25221,
  Protocol_GUILD_MEMBER_LIST_RESPONSE = 25222  /// 길드 출석
,
  Protocol_GUILD_ATTEND_REQUEST = 25223,
  Protocol_GUILD_ATTEND_RESPONSE = 25224  /// 길드 기부
,
  Protocol_GUILD_DONATE_REQUEST = 25225,
  Protocol_GUILD_DONATE_RESPONSE = 25226  /// 길드 랭킹 요청
,
  Protocol_GUILD_RANKING_LIST_REQUEST = 25227,
  Protocol_GUILD_RANKING_LIST_RESPONSE = 25228  /// 길드 목록 요청 (변경될 수 있음. 일단 임시)
,
  Protocol_GUILD_LIST_REQUEST = 25229,
  Protocol_GUILD_LIST_RESPONSE = 25230,
  Protocol_GUILD_DETAIL_INFO_REQUEST = 25231,
  Protocol_GUILD_DETAIL_INFO_RESPONSE = 25232  /// 가입 신청한 목록 요청 (내가 가입신청한 것을 확인)
,
  Protocol_GUILD_MY_JOIN_REQ_LIST_REQUEST = 25233,
  Protocol_GUILD_MY_JOIN_REQ_LIST_RESPONSE = 25234  /// 가입 요청 취소
,
  Protocol_GUILD_REMOVE_JOIN_REQ_REQUEST = 25235,
  Protocol_GUILD_REMOVE_JOIN_REQ_RESPONSE = 25236  ///
  /// #길드 관리 관련
  ///
  /// 가입 요청 목록 요청  (길드 관리자가 확인하는 용도)
,
  Protocol_GUILD_JOIN_REQ_LIST_REQUEST = 25237,
  Protocol_GUILD_JOIN_REQ_LIST_RESPONSE = 25238  /// 가입 수락
,
  Protocol_GUILD_ACCEPT_JOIN_REQ_REQUEST = 25239,
  Protocol_GUILD_ACCEPT_JOIN_REQ_RESPONSE = 25240  /// 가입 요청 거절
,
  Protocol_GUILD_REJECT_JOIN_REQ_REQUEST = 25241,
  Protocol_GUILD_REJECT_JOIN_REQ_RESPONSE = 25242  /// 가입 조건 변경
,
  Protocol_GUILD_CHANGE_JOIN_CONDITION_REQUEST = 25243,
  Protocol_GUILD_CHANGE_JOIN_CONDITION_RESPONSE = 25244  /// 소개글 or 공지글 변경
,
  Protocol_GUILD_CHANGE_MSG_REQUEST = 25245,
  Protocol_GUILD_CHANGE_MSG_RESPONSE = 25246  /// 강퇴처리
,
  Protocol_GUILD_KICK_MEMBER_REQUEST = 25247,
  Protocol_GUILD_KICK_MEMBER_RESPONSE = 25248  /// 레벨업
,
  Protocol_GUILD_LEVEL_UP_NOTIFY = 25249  /// 멤버 등급 변경
,
  Protocol_GUILD_CHANGE_MEMBER_GRADE_REQUEST = 25250,
  Protocol_GUILD_CHANGE_MEMBER_GRADE_RESPONSE = 25251,
  Protocol_GUILD_CHANGE_MEMBER_GRADE_NOTIFY = 25252  /// 길드 히스토리 조회
,
  Protocol_GUILD_HISTORY_REQUEST = 25253,
  Protocol_GUILD_HISTORY_RESPONSE = 25254  /// 길드 버프 구매 (개인 버프)
,
  Protocol_GUILD_BUFF_PURCHASE_REQUEST = 25255,
  Protocol_GUILD_BUFF_PURCHASE_RESPONSE = 25256  /// 길드 전체 적용 버프는
  /// SERVER_GUILD_BUFF_ADD / REMOVE 패킷으로 서버간 동기화 됨
  /// 길드장 위임
,
  Protocol_GUILD_CHANGE_LEADER_REQUEST = 25257,
  Protocol_GUILD_CHANGE_LEADER_RESPONSE = 25258  /// 길드장 후보 목록
,
  Protocol_GUILD_CANDIDATE_LEADER_LIST_REQUEST = 25259,
  Protocol_GUILD_CANDIDATE_LEADER_LIST_RESPONSE = 25260  /// 길드 문장 변경
,
  Protocol_GUILD_CHANGE_CREST_REQUEST = 25261,
  Protocol_GUILD_CHANGE_CREST_RESPONSE = 25262  /// 분배 설정 정보 요청
,
  Protocol_GUILD_SHARE_SETTING_INFO_REQUEST = 25263,
  Protocol_GUILD_SHARE_SETTING_INFO_RESPONSE = 25264  /// 분배 설정 저장 요청
,
  Protocol_GUILD_SAVE_SHARE_SETTING_REQUEST = 25265,
  Protocol_GUILD_SAVE_SHARE_SETTING_RESPONSE = 25266,
  Protocol_GUILD_INVITE_MESSAGE_REQUEST = 25267,
  Protocol_GUILD_INVITE_MESSAGE_RESPONSE = 25268  /// 길드원 상세정보 요청
,
  Protocol_GUILD_MEMBER_DETAIL_INFO_REQUEST = 25269,
  Protocol_GUILD_MEMBER_DETAIL_INFO_RESPONSE = 25270  /// 가입 신청 거절 알림 (거절 당한 사람에게 패킷이 간다)
,
  Protocol_GUILD_REJECT_JOIN_REQ_NOTIFY = 25271  /// 길드이름 변경
,
  Protocol_GUILD_CHANGE_NAME_REQUEST = 25272,
  Protocol_GUILD_CHANGE_NAME_RESPONSE = 25273,
  Protocol_GUILD_CHANGE_NAME_NOTIFY = 25274  /// 길드던전 내 순위  정보 요청
,
  Protocol_GUILD_DUNGEON_SCORE_REQUEST = 25275,
  Protocol_GUILD_DUNGEON_SCORE_RESPONSE = 25276  /// 길드 전체 서버 랭킹 요청
,
  Protocol_GUILD_UNITY_RANKING_LIST_REQUEST = 25277,
  Protocol_GUILD_UNITY_RANKING_LIST_RESPONSE = 25278  ///
  /// #길드 DB관련 패킷
  ///
,
  Protocol_DB_GUILD_CREATE_REQUEST = 25300,
  Protocol_DB_GUILD_CREATE_RESPONSE = 25301,
  Protocol_DB_GUILD_DESTROY_REQUEST = 25302,
  Protocol_DB_GUILD_DESTROY_RESPONSE = 25303  /// 길드 출석
,
  Protocol_DB_GUILD_ATTEND_REQUEST = 25304,
  Protocol_DB_GUILD_ATTEND_RESPONSE = 25305  /// 길드 기부
,
  Protocol_DB_GUILD_DONATE_REQUEST = 25306,
  Protocol_DB_GUILD_DONATE_RESPONSE = 25307  /// 길드 문장 변경
,
  Protocol_DB_GUILD_CHANGE_CREST_REQUEST = 25308,
  Protocol_DB_GUILD_CHANGE_CREST_RESPONSE = 25309  /// 길드 출석 시간 리셋 (테스트용)
,
  Protocol_DB_GUILD_ATTEND_RESET_REQUEST = 25310,
  Protocol_DB_GUILD_ATTEND_RESET_RESPONSE = 25311,
  Protocol_DB_GUILD_CHANGE_NAME_REQUEST = 25312,
  Protocol_DB_GUILD_CHANGE_NAME_RESPONSE = 25313  ///
  /// 시즌
  ///
  /// 현재 시즌 정보 조회 (시즌 UI 첫 정보)
,
  Protocol_SEASON_CURRENT_INFO_REQUEST = 25400,
  Protocol_SEASON_CURRENT_INFO_RESPONSE = 25401  /// 현재 시즌에 누적된 보상 (거래소 수수로) 조회
,
  Protocol_SEASON_REWARD_INFO_REQUEST = 25402,
  Protocol_SEASON_REWARD_INFO_RESPONSE = 25403  /// 길드던전 현재 시즌 정보 조회
,
  Protocol_SEASON_DUNGEON_INFO_REQUEST = 25404,
  Protocol_SEASON_DUNGEON_INFO_RESPONSE = 25405  /// RVR 컨텐츠 처리
,
  Protocol_AGENT_PC_MOVE_SERVER_REQUEST = 30000,
  Protocol_RVR_BATTLE_FIELD_REMAIN_TIME_REQUEST = 30020,
  Protocol_RVR_BATTLE_FIELD_REMAIN_TIME_RESPONSE = 30021,
  Protocol_RVR_BATTLE_FIELD_INFO_REQUEST = 30026,
  Protocol_RVR_BATTLE_FIELD_INFO_RESPONSE = 30027,
  Protocol_RVR_BATTLE_FIELD_ALL_INFOS_REQUEST = 30030,
  Protocol_RVR_BATTLE_FIELD_ALL_INFOS_RESPONSE = 30031,
  Protocol_RVR_PASS_BATTLE_FIELD_CAHNNEL_INFO_SYNC_NOTIFY = 30033,
  Protocol_RVR_RELAY_BATTLE_FIELD_CAHNNEL_INFO_SYNC_NOTIFY = 30034,
  Protocol_RVR_PASS_BATTLE_FIELD_CHANNEL_INFO_NOTIFY = 30035,
  Protocol_RVR_RELAY_BATTLE_FIELD_CHANNEL_INFO_NOTIFY = 30036,
  Protocol_RVR_PASS_BATTLE_FIELD_PLAYER_COUNT_INFO_NOTIFY = 30037,
  Protocol_RVR_RELAY_BATTLE_FIELD_PLAYER_COUNT_INFO_NOTIFY = 30038,
  Protocol_RVR_BATTLE_FIELD_EVENT_START_NOTIFY = 30040,
  Protocol_RVR_BATTLE_FIELD_EVENT_END_NOTIFY = 30041,
  Protocol_RVR_BATTLE_FIELD_CLOSE_NOTIFY = 30042,
  Protocol_RVR_BATTLE_FILED_TIME_INFO_NOTIFY = 30047,
  Protocol_RVR_BATTLE_FILED_TIME_INFO_REQUEST = 30048,
  Protocol_RVR_BATTLE_FILED_TIME_INFO_RESPONSE = 30049,
  Protocol_RVR_BATTLE_FILED_TIME_EXPIRED_NOTIFY = 30050,
  Protocol_RVR_BATTLE_FILED_FREE_TIME_EXPIRED_NOTIFY = 30051,
  Protocol_RVR_BATTLE_FILED_REMAIN_TIME_NOTIFY = 30052,
  Protocol_RVR_BATTLE_FILED_PK_NOTIFY = 30060,
  Protocol_RVR_BATTLE_FIELD_SHORT_TERM_MAX_NOTIFY = 30061,
  Protocol_RVR_BATTLE_FIELD_OTHER_PC_SHORT_TERM_MAX_NOTIFY = 30062,
  Protocol_RVR_STANDBY_ORDER_REQUEST = 30101,
  Protocol_RVR_STANDBY_ORDER_RESPONSE = 30102,
  Protocol_RVR_JOIN_REQUEST = 30103,
  Protocol_RVR_JOIN_RESPONSE = 30104,
  Protocol_RVR_RESERVATION_REQUEST = 30105,
  Protocol_RVR_RESERVATION_RESPONSE = 30106,
  Protocol_RVR_CANCEL_REQUEST = 30107,
  Protocol_RVR_CANCEL_RESPONSE = 30108,
  Protocol_RVR_LEAVE_BATTLE_SERVER_REQUEST = 30109,
  Protocol_RVR_LEAVE_BATTLE_SERVER_RESPONSE = 30110  /// 예약 상태 통지
,
  Protocol_RVR_RESERVATION_STATE_NOTIFY = 30111,
  Protocol_RVR_PASS_CHECK_STANDBY_ORDER_REQUEST = 30501,
  Protocol_RVR_RELAY_CHECK_STANDBY_ORDER_REQUEST = 30502,
  Protocol_RVR_PASS_CHECK_STANDBY_ORDER_RESPONSE = 30503,
  Protocol_RVR_RELAY_CHECK_STANDBY_ORDER_RESPONSE = 30504,
  Protocol_RVR_PERMISSION_TO_JOIN_PASS_REQUEST = 30511,
  Protocol_RVR_PERMISSION_TO_JOIN_RELAY_REQUEST = 30512,
  Protocol_RVR_PERMISSION_TO_JOIN_PASS_RESPONSE = 30513,
  Protocol_RVR_PERMISSION_TO_JOIN_RELAY_RESPONSE = 30514,
  Protocol_RVR_CANCEL_TO_JOIN_PASS_REQUEST = 30521,
  Protocol_RVR_CANCEL_TO_JOIN_RELAY_REQUEST = 30522,
  Protocol_RVR_CANCEL_TO_JOIN_PASS_RESPONSE = 30523,
  Protocol_RVR_CANCEL_TO_JOIN_RELAY_RESPONSE = 30524,
  Protocol_RVR_ASK_TO_STANDBY_PASS_REQUEST = 30525,
  Protocol_RVR_ASK_TO_STANDBY_RELAY_REQUEST = 30526,
  Protocol_RVR_ASK_TO_STANDBY_PASS_RESPONSE = 30527,
  Protocol_RVR_ASK_TO_STANDBY_RELAY_RESPONSE = 30528,
  Protocol_RVR_CONNECTED_GAME_SERVER_NOTIFY = 30529,
  Protocol_RVR_CONNECTED_BATTLE_SERVER_NOTIFY = 30531,
  Protocol_RVR_DISCONNECTED_BATTLE_SERVER_NOTIFY = 30532,
  Protocol_RVR_QA_COMMAND_PASS_NOTIFY = 30533,
  Protocol_RVR_QA_COMMAND_RELAY_NOTIFY = 30534  /// RVR의 클라이언트 퀘스트 위치로 이동
,
  Protocol_RVR_MOVE_CLIENT_QUEST_LOC_REQUEST = 30535,
  Protocol_RVR_MOVE_CLIENT_QUEST_LOC_RESPONSE = 30536  /// RVR의 베이스 캠프 이동
,
  Protocol_RVR_MOVE_BASE_CAMP_REQUEST = 30537,
  Protocol_RVR_MOVE_BASE_CAMP_RESPONSE = 30538,
  Protocol_RVR_MAIN_HUD_INFO_NOTIFY = 30539,
  Protocol_RVR_EVENT_TOTAL_REWARD_NOTIFY = 30541,
  Protocol_RVR_MAIN_HUD_POINT_INFO_NOTIFY = 30550,
  Protocol_RVR_OCCUPYING_GAUGE_APPROXIMATE_INFO_NOTIFY = 30551,
  Protocol_RVR_OCCUPYING_GAUGE_INFO_NOTIFY = 30552  ///------------------------------
  /// 친구시스템(server)		
  /// 친구요청 보냈을 때(보낸 요청 추가)
,
  Protocol_BUDDY_AG_SEND_INVITATION_NOTIFY = 30680  /// 친구요청 받았을 때(받은 요청 추가)
,
  Protocol_BUDDY_AG_RECEIVE_INVITATION_NOTIFY = 30681  /// 친구요청 수락했을 때(받은 요청 삭제, 친구 추가)
,
  Protocol_BUDDY_AG_ACCEPT_RECEIVE_INVITATION_NOTIFY = 30682  /// 친구요청 수락당했을 때(보낸 요청 삭제, 친구 추가)
,
  Protocol_BUDDY_AG_ACCEPTED_SEND_INVITATION_NOTIFY = 30683  /// 친구요청 거절했을 때(받은 요청 삭제)
,
  Protocol_BUDDY_AG_REJECT_RECEIVE_INVITATION_NOTIFY = 30684  /// 친구요청 거절당했을 때(보낸 요청 삭제)
,
  Protocol_BUDDY_AG_REJECTED_SEND_INVITATION_NOTIFY = 30685  /// 친구 삭제했을 때(친구 삭제)
,
  Protocol_BUDDY_AG_DELETE_BUDDY_NOTIFY = 30686  /// 친구 삭제당했을 때(친구 삭제)
,
  Protocol_BUDDY_AG_DELETED_BUDDY_NOTIFY = 30687  ///------------------------------
  /// 친구시스템
,
  Protocol_BUDDY_DATA_ALL_NOTIFY = 30701,
  Protocol_BUDDY_SEND_INVITATION_REQUEST = 30703,
  Protocol_BUDDY_SEND_INVITATION_RESPONSE = 30704,
  Protocol_BUDDY_ACCEPT_INVITATION_REQUEST = 30707,
  Protocol_BUDDY_ACCEPT_INVITATION_RESPONSE = 30708,
  Protocol_BUDDY_REJECT_INVITATION_REQUEST = 30709,
  Protocol_BUDDY_REJECT_INVITATION_RESPONSE = 30710,
  Protocol_BUDDY_DELETE_REQUEST = 30711,
  Protocol_BUDDY_DELETE_RESPONSE = 30712,
  Protocol_BUDDY_RECEIVE_INVITATION_NOTIFY = 30715,
  Protocol_BUDDY_ADDED_NOTIFY = 30716,
  Protocol_BUDDY_DELETED_NOTIFY = 30718,
  Protocol_BUDDY_SEND_INVITATION_REJECTED_NOTIFY = 30723,
  Protocol_BUDDY_SEARCH_REQUEST = 30725,
  Protocol_BUDDY_SEARCH_RESPONSE = 30726,
  Protocol_BUDDY_RECOMMEND_REQUEST = 30730,
  Protocol_BUDDY_RECOMMEND_RESPONSE = 30731,
  Protocol_BUDDY_DETAIL_INFO_REQUEST = 30734,
  Protocol_BUDDY_REFRESH_REQUEST = 30735,
  Protocol_BUDDY_REFRESH_RESPONSE = 30736,
  Protocol_BUDDY_RECEIVE_INVIATION_REFRESH_REQUEST = 30737,
  Protocol_BUDDY_RECEIVE_INVIATION_REFRESH_RESPONSE = 30738,
  Protocol_SUMMON_REQUEST = 30739,
  Protocol_SUMMON_RESPONSE = 30740,
  Protocol_SUMMON_ACCEPT_REQUEST = 30741,
  Protocol_SUMMON_ACCEPT_RESPONSE = 30742,
  Protocol_SUMMON_RECEIVED_NOTIFY = 30744,
  Protocol_SUMMON_ACCEPTED_NOTIFY = 30745,
  Protocol_SUMMON_ABLE_STATE_NOTIFY = 30746,
  Protocol_MOVE_TO_PC_REQUEST = 30748,
  Protocol_MOVE_TO_PC_RESPONSE = 30749,
  Protocol_SHORT_TERM_REWARD_DATA_NOTIFY = 30760,
  Protocol_SHORT_TERM_REWARD_DATA_ALL_NOTIFY = 30761,
  Protocol_SHORT_TERM_REWARD_GIVE_REQUSET = 30762,
  Protocol_SHORT_TERM_REWARD_GIVE_RESPONSE = 30763,
  Protocol_SHORT_TERM_REWARD_DATA_ALL_REQUSET = 30764,
  Protocol_SHORT_TERM_REWARD_DATA_ALL_RESPONSE = 30765,
  Protocol_KILLER_DATA_NOTIFY = 30770,
  Protocol_KILLER_DATA_ALL_NOTIFY = 30771,
  Protocol_REFUND_REDIS_RECORD_ADDED_NOTIFY = 30780,
  Protocol_REFUND_REDIS_RECORD_DATA_REQUEST = 30781,
  Protocol_REFUND_REDIS_RECORD_DATA_RESPONSE = 30782,
  Protocol_REFUND_REDIS_RECORD_REMOVE_REQUEST = 30783,
  Protocol_REFUND_REDIS_RECORD_REMOVE_RESPONSE = 30784,
  Protocol_BATTLE_FIELD_COLLECTION_NOTIFY = 30790,
  Protocol_DB_BATTLE_FIELD_COLLECTION_UPDATE_REQUEST = 30791,
  Protocol_DB_BATTLE_FIELD_COLLECTION_UPDATE_RESPONSE = 30792,
  Protocol_PUSH_PROMOTION_REQUEST = 30800,
  Protocol_PUSH_PROMOTION_RESPONSE = 30801,
  Protocol_GROUP_MATCHING_MAKE_REQEUST = 30805,
  Protocol_GROUP_MATCHING_MAKE_RESPONSE = 30806,
  Protocol_GROUP_MATCHING_LEAVE_REQUEST = 30807,
  Protocol_GROUP_MATCHING_GUILD_MEMBER_LIST_REQUEST = 30812,
  Protocol_GROUP_MATCHING_GUILD_MEMBER_LIST_RESPONSE = 30813,
  Protocol_GROUP_MATCHING_BUDDY_LIST_REQUEST = 30814,
  Protocol_GROUP_MATCHING_BUDDY_LIST_RESPONSE = 30815,
  Protocol_GROUP_MATCHING_INVITE_REQUEST = 30820,
  Protocol_GROUP_MATCHING_INVITE_RESPONSE = 30821,
  Protocol_GROUP_MATCHING_MEMBER_LEAVE_NOTIFY = 30824,
  Protocol_GROUP_MATCHING_INVITATION_ACCEPTED_NOTIFY = 30825,
  Protocol_GROUP_MATCHING_INVITATION_REJECTED_NOTIFY = 30826,
  Protocol_GROUP_MATCHING_INVITATION_ADD_NOTIFY = 30827,
  Protocol_GROUP_MATCHING_INVITATION_REMOVE_NOTIFY = 30828,
  Protocol_GROUP_MATCHING_INVITE_ACCEPT_REQUEST = 30830,
  Protocol_GROUP_MATCHING_INVITE_ACCEPT_RESPONSE = 30831,
  Protocol_GROUP_MATCHING_INVITE_REJECT_REQUEST = 30832,
  Protocol_GROUP_MATCHING_INVITE_REJECT_RESPONSE = 30833,
  Protocol_GROUP_MATCHING_START_REQUEST = 30840,
  Protocol_GROUP_MATCHING_START_RESPONSE = 30841,
  Protocol_GROUP_MATCHING_CONVERT_TO_QUICK_REQUEST = 30842,
  Protocol_GROUP_MATCHING_CONVERT_TO_QUICK_RESPONSE = 30843,
  Protocol_GROUP_MATCHING_REMATCHING_REQUEST = 30844,
  Protocol_GROUP_MATCHING_REMATCHING_RESPONSE = 30845,
  Protocol_EQUIP_COSTUME_REQUEST = 30851,
  Protocol_EQUIP_COSTUME_RESPONSE = 30852,
  Protocol_UNEQUIP_COSTUME_REQUEST = 30853,
  Protocol_UNEQUIP_COSTUME_RESPONSE = 30854,
  Protocol_COSTUME_PRESET_CHANGE_REQUEST = 30855,
  Protocol_COSTUME_PRESET_CHANGE_RESPONSE = 30856,
  Protocol_COSTUME_PRESET_COSTUMESLOT_UPDATE_NOTIFY = 30857,
  Protocol_ENCHANT_COSTUME_REQUEST = 30858,
  Protocol_ENCHANT_COSTUME_RESPONSE = 30859,
  Protocol_UPGRADE_COSTUME_REQUEST = 30860,
  Protocol_UPGRADE_COSTUME_RESPONSE = 30861,
  Protocol_SHOW_COSTUME_REQUEST = 30862,
  Protocol_SHOW_COSTUME_RESPONSE = 30863,
  Protocol_HIDE_COSTUME_REQUEST = 30864,
  Protocol_HIDE_COSTUME_RESPONSE = 30865,
  Protocol_INHERIT_COSTUME_REQUEST = 30866,
  Protocol_INHERIT_COSTUME_RESPONSE = 30867,
  Protocol_LIVE_EVENT_STOP_NOTIFY = 30900,
  Protocol_LIVE_EVENT_DATA_UPDATE_NOTIFY = 30901,
  Protocol_LIVE_EVENT_TRADE_DATA_NOTIFY = 30910,
  Protocol_LIVE_EVENT_BUFF_DATA_NOTIFY = 30911,
  Protocol_LIVE_EVENT_ATTENTION_DATA_NOTIFY = 30912,
  Protocol_LIVE_EVENT_NEWBIE_ATTENTION_DATA_NOTIFY = 30913,
  Protocol_LIVE_EVENT_RETURN_ATTENTION_DATA_NOTIFY = 30914,
  Protocol_LIVE_EVENT_DIA_BUY_DATA_NOTIFY = 30915,
  Protocol_LIVE_EVENT_DIA_SPENT_DATA_NOTIFY = 30916,
  Protocol_LIVE_EVENT_LIMIT_SELL_SHOP_DATA_NOTIFY = 30917,
  Protocol_LIVE_EVENT_LEVEL_BUFF_DATA_NOTIFY = 30918,
  Protocol_LIVE_EVENT_NEWBIE_BUFF_DATA_NOTIFY = 30919,
  Protocol_LIVE_EVENT_ITEM_DROP_DATA_NOTIFY = 30920,
  Protocol_LIVE_EVENT_LEVELUP_EVENT_DATA_NOTIFY = 30921,
  Protocol_LIVE_EVENT_LEVELUP_NEWBIE_DATA_NOTIFY = 30922,
  Protocol_LIVE_EVENT_LEVELUP_RETURN_DATA_NOTIFY = 30923,
  Protocol_LIVE_EVENT_TRADE_INSTANCE_NOTIFY = 30930,
  Protocol_LIVE_EVENT_TRADE_INSTANCE_EXPIRE_NOTIFY = 30931,
  Protocol_LIVE_EVENT_TRADE_PURCHASE_REQUEST = 30932,
  Protocol_LIVE_EVENT_TRADE_PURCHASE_RESPONSE = 30933,
  Protocol_LIVE_EVENT_DIA_BUY_NOTIFY = 30940,
  Protocol_LIVE_EVENT_DIA_BUY_MISSION_UPDATE_NOTIFY = 30941,
  Protocol_LIVE_EVENT_DIA_BUY_AMOUNT_UPDATE_NOTIFY = 30942,
  Protocol_LIVE_EVENT_DIA_BUY_REWARD_REQUEST = 30943,
  Protocol_LIVE_EVENT_DIA_BUY_REWARD_RESPONSE = 30944,
  Protocol_LIVE_EVENT_DIA_SPENT_NOTIFY = 30950,
  Protocol_LIVE_EVENT_DIA_SPENT_MISSION_UPDATE_NOTIFY = 30951,
  Protocol_LIVE_EVENT_DIA_SPENT_AMOUNT_UPDATE_NOTIFY = 30952,
  Protocol_LIVE_EVENT_DIA_SPENT_REWARD_REQUEST = 30953,
  Protocol_LIVE_EVENT_DIA_SPENT_REWARD_RESPONSE = 30954,
  Protocol_LIVE_EVENT_LIMIT_SELL_SHOP_INSTANCE_NOTIFY = 30960,
  Protocol_LIVE_EVENT_LIMIT_SELL_SHOP_INSTANCE_EXPIRE_NOTIFY = 30961,
  Protocol_LIVE_EVENT_LIMIT_SELL_SHOP_PURCHASE_REQUEST = 30962,
  Protocol_LIVE_EVENT_LIMIT_SELL_SHOP_PURCHASE_RESPONSE = 30963,
  Protocol_LIVE_EVENT_ATTENTION_NOTIFY = 30980,
  Protocol_LIVE_EVENT_ATTENTION_RECEIVE_NOTIFY = 30981,
  Protocol_LIVE_EVENT_ATTENTION_END_RECEIVE_NOTIFY = 30982,
  Protocol_LIVE_EVENT_ATTENTION_REWARD_RECEIVE_REQUEST = 30983,
  Protocol_LIVE_EVENT_ATTENTION_REWARD_RECEIVE_RESPONSE = 30984,
  Protocol_LIVE_EVENT_ATTENTION_RETURN_REWARD_RECEIVE_REQUEST = 30985,
  Protocol_LIVE_EVENT_ATTENTION_RETURN_REWARD_RECEIVE_RESPONSE = 30986,
  Protocol_LIVE_EVENT_ATTENTION_NEWBIE_REWARD_RECEIVE_REQUEST = 30987,
  Protocol_LIVE_EVENT_ATTENTION_NEWBIE_REWARD_RECEIVE_RESPONSE = 30988,
  Protocol_LIVE_EVENT_ATTENTION_END_REWARD_RECEIVE_REQUEST = 30989,
  Protocol_LIVE_EVENT_ATTENTION_END_REWARD_RECEIVE_RESPONSE = 30990,
  Protocol_LIVE_EVENT_ATTENTION_END_RETURN_REWARD_RECEIVE_REQUEST = 30991,
  Protocol_LIVE_EVENT_ATTENTION_END_RETURN_REWARD_RECEIVE_RESPONSE = 30992,
  Protocol_LIVE_EVENT_ATTENTION_END_NEWBIE_REWARD_RECEIVE_REQUEST = 30993,
  Protocol_LIVE_EVENT_ATTENTION_END_NEWBIE_REWARD_RECEIVE_RESPONSE = 30994,
  Protocol_LIVE_EVENT_BUFF_INFO_INSTANCE_NOTIFY = 31000,
  Protocol_LIVE_EVENT_LEVELUP_NOTIFY = 31010,
  Protocol_LIVE_EVENT_LEVELUP_RECEIVE_NOTIFY = 31011,
  Protocol_LIVE_EVENT_LEVELUP_REWARD_RECEIVE_REQUEST = 31012,
  Protocol_LIVE_EVENT_LEVELUP_REWARD_RECEIVE_RESPONSE = 31013,
  Protocol_STORAGE_SLOT_EXPANSION_REQUEST = 31100,
  Protocol_STORAGE_SLOT_EXPANSION_RESPONSE = 31101,
  Protocol_BRAWL_TIME_INFO_NOTIFY = 31105,
  Protocol_BRAWL_TIME_INFO_REQUEST = 31106,
  Protocol_BRAWL_TIME_INFO_RESPONSE = 31107,
  Protocol_BRAWL_TIME_EXPIRED_NOTIFY = 31108,
  Protocol_BRAWL_FREE_TIME_EXPIRED_NOTIFY = 31109,
  Protocol_BRAWL_REMAIN_TIME_NOTIFY = 31110,
  Protocol_BRAWL_SHORT_TERM_DATA_NOTIFY = 31111,
  Protocol_BRAWL_SHORT_TERM_REWARD_REQUEST = 31112,
  Protocol_BRAWL_SHORT_TERM_REWARD_RESPONSE = 31113,
  Protocol_BRAWL_SHORT_TERM_DATA_REQUEST = 31114,
  Protocol_BRAWL_SHORT_TERM_DATA_RESPONSE = 31115,
  Protocol_BRAWL_PK_NOTIFY = 31120,
  Protocol_BRAWL_SHORT_TERM_MAX_NOTIFY = 31121,
  Protocol_BRAWL_OTHER_PC_SHORT_TERM_MAX_NOTIFY = 31122,
  Protocol_BRAWL_POINT_NOTIFY = 31124,
  Protocol_BRAWL_ENHANCE_DATA_NOTIFY = 31125,
  Protocol_BRAWL_ENHANCE_LEVEL_UP_REQUEST = 31126,
  Protocol_BRAWL_ENHANCE_LEVEL_UP_RESPONSE = 31127,
  Protocol_ADD_ITEM_FAILED_NOT_ENOUGH_STORAGE_SPACE_NOTIFY = 31128,
  Protocol_SCROLL_QUEST_DAILY_INFO_NOTIFY = 31130,
  Protocol_SCROLL_QUEST_PROGRESS_INFO_NOTIFY = 31131,
  Protocol_SCROLL_QUEST_START_PROGRESS_REQUEST = 31133,
  Protocol_SCROLL_QUEST_START_PROGRESS_RESPONSE = 31134,
  Protocol_SCROLL_QUEST_GIVE_UP_REQUEST = 31135,
  Protocol_SCROLL_QUEST_GIVE_UP_RESPONSE = 31136,
  Protocol_SCROLL_QUEST_REWARD_REQUEST = 31137,
  Protocol_SCROLL_QUEST_REWARD_RESPONSE = 31138,
  Protocol_BRAWL_LAST_LEAVED_TIME_REQUEST = 31140,
  Protocol_BRAWL_LAST_LEAVED_TIME_RESPONSE = 31141,
  Protocol_BRAWL_LAST_LEAVED_TIME_NOTIFY = 31142  /////////////////////////////////////
  /////////////////////////////////////		
,
  Protocol_PET_CREATED_WITH_EFFECT_NOTIFY = 31147,
  Protocol_PET_CREATED_NOTIFY = 31148,
  Protocol_PET_DELETED_NOTIFY = 31149,
  Protocol_PET_DATA_NOTIFY = 31150,
  Protocol_PET_FEED_REQUEST = 31152,
  Protocol_PET_FEED_RESPONSE = 31153,
  Protocol_PET_DIGESTION_COMPLETE_NOTIFY = 31154,
  Protocol_PET_SUMMON_REQUEST = 31155,
  Protocol_PET_SUMMON_RESPONSE = 31156,
  Protocol_PET_SUMMON_CANCEL_REQUEST = 31157,
  Protocol_PET_SUMMON_CANCEL_RESPONSE = 31158,
  Protocol_PET_SUPPORT_REQUEST = 31160,
  Protocol_PET_SUPPORT_RESPONSE = 31161,
  Protocol_PET_SUPPORT_CANCEL_REQUEST = 31162,
  Protocol_PET_SUPPORT_CANCEL_RESPONSE = 31163,
  Protocol_PET_REMAIN_DIGESTION_TIME_REQUEST = 31164,
  Protocol_PET_REMAIN_DIGESTION_TIME_RESPONSE = 31165,
  Protocol_PET_FUSION_REQUEST = 31170,
  Protocol_PET_FUSION_RESPONSE = 31171,
  Protocol_PET_LEVEL_EXP_UP_NOTIFY = 31172,
  Protocol_PET_TOGGLE_SAFE_GUARD_REQUEST = 31173,
  Protocol_PET_TOGGLE_SAFE_GUARD_RESPONSE = 31174  /////////////////////////////////////
  /////////////////////////////////////	
,
  Protocol_PET_ALTAR_DATA_NOTIFY = 31200,
  Protocol_PET_ALTAR_LEVEL_EXP_NOTIFY = 31201,
  Protocol_PET_ALTAR_POINT_NOTIFY = 31202,
  Protocol_PET_ALTAR_DONATE_REQUEST = 31210,
  Protocol_PET_ALTAR_DONATE_RESPONSE = 31211,
  Protocol_PET_ALTAR_ACTIVE_SKILL_LEVEL_UP_REQUEST = 31220,
  Protocol_PET_ALTAR_ACTIVE_SKILL_LEVEL_UP_RESPONSE = 31221  /////////////////////////////////////
  /////////////////////////////////////
,
  Protocol_PET_HATCHERY_DATA_NOTIFY = 31250,
  Protocol_PET_HATCHERY_SPAWN_REQUEST = 31251,
  Protocol_PET_HATCHERY_SPAWN_RESPONSE = 31252,
  Protocol_PET_HATCHERY_HATCH_REQUEST = 31254,
  Protocol_PET_HATCHERY_HATCH_RESPONSE = 31255,
  Protocol_DB_PET_MAKE_REQUEST = 31300,
  Protocol_DB_PET_MAKE_RESPONSE = 31301,
  Protocol_DB_PET_FEED_REQUEST = 31302,
  Protocol_DB_PET_FEED_RESPONSE = 31303,
  Protocol_DB_PET_FUSION_REQUEST = 31304,
  Protocol_DB_PET_FUSION_RESPONSE = 31305,
  Protocol_DB_PET_SET_STATE_REQUEST = 31306,
  Protocol_DB_PET_SET_STATE_RESPONSE = 31307,
  Protocol_DB_PET_LEVEL_UP_REQUEST = 31308,
  Protocol_DB_PET_LEVEL_UP_RESPONSE = 31309,
  Protocol_DB_PET_TOGGLE_SAFE_GUARD_REQUEST = 31310,
  Protocol_DB_PET_TOGGLE_SAFE_GUARD_RESPONSE = 31311,
  Protocol_DB_PET_ALTAR_DONATE_REQUEST = 31320,
  Protocol_DB_PET_ALTAR_DONATE_RESPONSE = 31321,
  Protocol_DB_PET_ALTAR_ACTIVE_SKILL_LEVEL_UP_REQUEST = 31322,
  Protocol_DB_PET_ALTAR_ACTIVE_SKILL_LEVEL_UP_RESPONSE = 31323,
  Protocol_DB_PET_HATCHERY_SUMMON_REQUEST = 31324,
  Protocol_DB_PET_HATCHERY_SUMMON_RESPONSE = 31325,
  Protocol_DB_PET_HATCHERY_HATCH_REQUEST = 31326,
  Protocol_DB_PET_HATCHERY_HATCH_RESPONSE = 31327,
  Protocol_DB_PET_SET_REQUEST = 31328,
  Protocol_DB_PET_SET_RESPONSE = 31329,
  Protocol_DB_PET_DELETE_REQUEST = 31330,
  Protocol_DB_PET_DELETE_RESPONSE = 31331,
  Protocol_DB_PET_ALTAR_SET_REQUEST = 31332,
  Protocol_DB_PET_ALTAR_SET_RESPONSE = 31333,
  Protocol_CONFLICT_FIELD_MOVE_HOME_SERVER_REQUEST = 31400,
  Protocol_CONFLICT_FIELD_MOVE_HOME_SERVER_RESPONSE = 31401,
  Protocol_KINGSROAD_QUERY_MAINSTREAM_QUEST_REQUEST = 31500,
  Protocol_KINGSROAD_QUERY_MAINSTREAM_QUEST_RESPONSE = 31501  /// 암호키 교환
,
  Protocol_PUBLIC_KEY_NOTIFY = 65533,
  Protocol_CRYPT_KEY_NOTIFY = 65534,
  Protocol_MAX = 65535,
  Protocol_MIN = Protocol_START,
};

inline const Protocol (&EnumValuesProtocol())[1395] {
  static const Protocol values[] = {
    Protocol_START,
    Protocol_PING_NOTIFY,
    Protocol_KEEP_ALIVE_NOTIFY,
    Protocol_GAME_AGENT_REGISTER_REQUEST,
    Protocol_GAME_AGENT_REGISTER_RESPONSE,
    Protocol_GAME_AGENT_LOGINED_USER_LIST_NOTIFY,
    Protocol_GAME_AGENT_CHANGE_MAX_USER_COUNT_NOTIFY,
    Protocol_GAME_AGENT_INFO_NOTIFY,
    Protocol_CHECK_ACCOUNT_AUTH_REQUEST,
    Protocol_CHECK_ACCOUNT_AUTH_RESPONSE,
    Protocol_DB_UPDATE_REALM_NOTIFY,
    Protocol_DB_UPDATE_PC_COUNT_NOTIFY,
    Protocol_GAME_AGENT_LOGOUT_REQUEST,
    Protocol_GAME_AGENT_PC_RENAME_NOTIFY,
    Protocol_GAME_AGENT_SELECT_RESERVED_CHAR_REQUEST,
    Protocol_GAME_AGENT_SELECT_RESERVED_CHAR_RESPONSE,
    Protocol_GAME_AGENT_GOTO_SERVER_LIST_REQUEST,
    Protocol_GAME_AGENT_GOTO_SERVER_LIST_RESPONSE,
    Protocol_GAME_AGENT_UPDATE_PLAYER_INFO_REQUEST,
    Protocol_GAME_AGENT_CHARACTER_CREATION,
    Protocol_GAME_AGENT_NAME_CHECK_REQUEST,
    Protocol_GAME_AGENT_NAME_CHECK_RESPONSE,
    Protocol_ACCOUNT_CACHE_EXPIRATION_RESERVE_REQUEST,
    Protocol_GAME_AGENT_HIVE_TOP_PC_INFO_REQUEST,
    Protocol_GAME_AGENT_HIVE_TOP_PC_INFO_RESPONSE,
    Protocol_GAME_AGENT_PLAYER_DELETE_NOTIFY,
    Protocol_GAME_AGENT_PLAYER_CANCEL_DELETE_NOTIFY,
    Protocol_GAME_AGENT_GIFTEVENT_MODIFY_NOTIFY,
    Protocol_GAME_AGENT_NOTICE_NOTIFY,
    Protocol_GAME_AGENT_ALL_KICK_NOTIFY,
    Protocol_GAME_AGENT_MAINTENANCE_NOTIFY,
    Protocol_GAME_AGENT_UPDATE_GAME_LANGUAGE_REQUEST,
    Protocol_AUTH_AGENT_SERVER_REGISTER_REQUEST,
    Protocol_AUTH_AGENT_SERVER_REGISTER_RESPONSE,
    Protocol_AUTH_AGENT_AUTH_REQUEST,
    Protocol_AUTH_AGENT_AUTH_RESPONSE,
    Protocol_AUTH_AGENT_LOGOUT_REQUEST,
    Protocol_AUTH_AGENT_APKHASH_UPDATE_NOTIFY,
    Protocol_AUTH_AGENT_AUTH_TICKET_REQUEST,
    Protocol_AUTH_AGENT_AUTH_TICKET_RESPONSE,
    Protocol_AUTH_AGENT_SELECT_RESERVED_NICK_NAME_REQUEST,
    Protocol_AUTH_AGENT_SELECT_RESERVED_NICK_NAME_RESPONSE,
    Protocol_AUTH_AGENT_HIVE_TOP_PC_INFO_REQUEST,
    Protocol_AUTH_AGENT_HIVE_TOP_PC_INFO_RESPONSE,
    Protocol_AUTH_AGENT_BAN_COUNTRY_REGIST_NOTIFY,
    Protocol_AUTH_AGENT_BAN_COUNTRY_UNREGIST_NOTIFY,
    Protocol_CHECK_CLIENT_VERSION_REQUEST,
    Protocol_CHECK_CLIENT_VERSION_RESPONSE,
    Protocol_ACCOUNT_AUTH_REQUEST,
    Protocol_ACCOUNT_AUTH_RESPONSE,
    Protocol_ACCOUNT_AUTH_AGENT_TICKET_REQUEST,
    Protocol_COLONY_LIST_REQUEST,
    Protocol_COLONY_LIST_RESPONSE,
    Protocol_CHARACTER_LIST_REQUEST,
    Protocol_CHARACTER_LIST_RESPONSE,
    Protocol_HIVE_AUTH_REQUEST,
    Protocol_HIVE_AUTH_RESPONSE,
    Protocol_SELECT_COLONY_REQUEST,
    Protocol_SELECT_COLONY_RESPONSE,
    Protocol_SELECT_REALM_REQUEST,
    Protocol_SELECT_REALM_RESPONSE,
    Protocol_SELECT_REALM_BOT_RESPONSE,
    Protocol_SELECT_COLONY_BOT_REQUEST,
    Protocol_COLONY_WAITING_NOTIFY,
    Protocol_INQUIRE_WAITING_REQUEST,
    Protocol_INQUIRE_WAITING_RESPONSE,
    Protocol_CANCEL_WAITING_REQUEST,
    Protocol_CANCEL_WAITING_RESPONSE,
    Protocol_FIND_RESERVED_NICK_NAME_REQUEST,
    Protocol_FIND_RESERVED_NICK_NAME_RESPONSE,
    Protocol_SELECT_RESERVED_NICK_NAME_REQUSET,
    Protocol_SELECT_RESERVED_NICK_NAME_RESPONSE,
    Protocol_FIND_RESERVED_CHAR_REQUEST,
    Protocol_FIND_RESERVED_CHAR_RESPONSE,
    Protocol_SELECT_RESERVED_CHAR_REQUEST,
    Protocol_SELECT_RESERVED_CHAR_RESPONSE,
    Protocol_SHOP_EVENT_DATA_UPDATE_NOTIFY,
    Protocol_STRING_MESSAGE_NOTIFY,
    Protocol_USER_KICK_NOTIFY,
    Protocol_CONTENT_CONFIG_UPDATE_NOFITY,
    Protocol_ACCOUNT_LOGIN_REQUEST,
    Protocol_ACCOUNT_LOGIN_RESPONSE,
    Protocol_SERVER_LOCAL_TIME_NOTIFY,
    Protocol_DEVICE_PERFORMANCE_POINT_NOTIFY,
    Protocol_SEASON_INFO_NOTIFY,
    Protocol_SERVER_LOCAL_TIME_REQUEST,
    Protocol_SERVER_LOCAL_TIME_RESPONSE,
    Protocol_SLOT_LIST_REQUEST,
    Protocol_SLOT_LIST_RESPONSE,
    Protocol_PC_TUTORIAL_SKIP_REQUEST,
    Protocol_PC_TUTORIAL_SKIP_RESPONSE,
    Protocol_PC_LOGIN_REQUEST,
    Protocol_PC_LOGIN_RESPONSE,
    Protocol_PC_CREATION_REQUEST,
    Protocol_PC_CREATION_RESPONSE,
    Protocol_PC_CHECK_NEW_NAME_REQUEST,
    Protocol_PC_CHECK_NEW_NAME_RESPONSE,
    Protocol_PC_RENAME_REQUEST,
    Protocol_PC_RENAME_RESPONSE,
    Protocol_PC_DELETE_REQUEST,
    Protocol_PC_DELETE_RESPONSE,
    Protocol_PC_CANCEL_DELETE_REQUEST,
    Protocol_PC_CANCEL_DELETE_RESPONSE,
    Protocol_PC_GOTO_LOBBY_REQUEST,
    Protocol_PC_GOTO_LOBBY_RESPONSE,
    Protocol_ACCOUNT_LOGOUT_REQUEST,
    Protocol_ACCOUNT_LOGOUT_RESPONSE,
    Protocol_GOTO_SERVER_LIST_REQUEST,
    Protocol_GOTO_SERVER_LIST_RESPONSE,
    Protocol_ACCOUNT_RECONNECT_REQUEST,
    Protocol_ACCOUNT_RECONNECT_RESPONSE,
    Protocol_HIVE_TOP_PC_INFO_REQUEST,
    Protocol_HIVE_TOP_PC_INFO_RESPONSE,
    Protocol_HIVE_COMPANION_COUNT_REQUEST,
    Protocol_HIVE_COMPANION_COUNT_RESPONSE,
    Protocol_HIVE_SHOP_PURCHASE_PRODUCT_NOTIFY,
    Protocol_DELAY_PING_NOTIFY,
    Protocol_BYPASS_FROM_CLIENT_NOTIFY,
    Protocol_BYPASS_TO_CLIENT_NOTIFY,
    Protocol_BYPASS_BROADCAST_TO_CLIENT_NOTIFY,
    Protocol_GAME_SERVER_REGISTER_REQUEST,
    Protocol_GAME_SERVER_REGISTER_RESPONSE,
    Protocol_PC_ENTER_WORLD_READY_REQUEST,
    Protocol_PC_ENTER_WORLD_READY_RESPONSE,
    Protocol_PC_START_NOTIFY,
    Protocol_PC_LEAVE_WORLD_REQUEST,
    Protocol_PC_LEAVE_WORLD_RESPONSE,
    Protocol_PC_TRY_TO_LEAVE_WORLD_NOTIFY,
    Protocol_PC_DISCONNECT_NOTIFY,
    Protocol_PC_RECONNECT_REQUEST,
    Protocol_SERVER_GUILD_REQUEST,
    Protocol_SERVER_GUILD_DATA_LOAD,
    Protocol_SERVER_GUILD_MEMBER_LOAD,
    Protocol_SERVER_GUILD_RESPONSE,
    Protocol_SERVER_GUILD_CREATE,
    Protocol_SERVER_GUILD_DESTROY,
    Protocol_SERVER_GUILD_DATA_UPDATE,
    Protocol_SERVER_GUILD_MEMBER_ADD,
    Protocol_SERVER_GUILD_MEMBER_REMOVE,
    Protocol_SERVER_GUILD_MEMBER_UPDATE,
    Protocol_SERVER_GUILD_BUFF_ADD,
    Protocol_SERVER_GUILD_BUFF_REMOVE,
    Protocol_SERVER_GUILD_LEADER_GUILD_UPDATE,
    Protocol_SERVER_GUILD_APPLICANT_UPDATE,
    Protocol_SERVER_SEASON_INFO_UPDATE,
    Protocol_SERVER_SEASON_RESET_REQUEST,
    Protocol_SERVER_SEASON_RESET_RESPONSE,
    Protocol_PC_NEW_MAIL_NOTIFY,
    Protocol_PC_SHOP_PURCHASE_PRODUCT_REQUEST,
    Protocol_PC_LEAVED_BRAWL_NOTIFY,
    Protocol_NOTICE_NOTIFY,
    Protocol_CLIENT_DEBUG_MESSAGE_NOTIFY,
    Protocol_SMAP_CHANNEL_LIST_REQUEST,
    Protocol_SMAP_CHANNEL_LIST_RESPONSE,
    Protocol_SMAP_CHANNEL_MOVE_REQUEST,
    Protocol_SMAP_CHANNEL_MOVE_RESPONSE,
    Protocol_JOIN_EVENTSET_CHANNEL_REQUEST,
    Protocol_JOIN_EVENTSET_CHANNEL_RESPONSE,
    Protocol_ADMIN_COMMAND_NOTIFY,
    Protocol_SYSTEM_DEBUG_MESSAGE_NOTIFY,
    Protocol_PC_SPAWN_COMPLETE_NOTIFY,
    Protocol_UPC_SPAWN_COMPLETE_NOTIFY,
    Protocol_BOT_ADMIN_COMMAND_NOTIFY,
    Protocol_TELEPORT_NOTIFY_OTHER_PC_IN_VIEW,
    Protocol_TELEPORT_REQUEST,
    Protocol_TELEPORT_RESPONSE,
    Protocol_ENTER_EVENT_AREA_REQUEST,
    Protocol_ENTER_EVENT_AREA_RESPONSE,
    Protocol_EVENT_MESSAGE_NOTIFY,
    Protocol_SAFE_ZONE_IN_REQUEST,
    Protocol_SAFE_ZONE_IN_RESPONSE,
    Protocol_SAFE_ZONE_OUT_REQUEST,
    Protocol_SAFE_ZONE_OUT_RESPONSE,
    Protocol_CLIENT_CREATURE_MOVE_NOTIFY,
    Protocol_SERVER_CREATURE_MOVE_NOTIFY,
    Protocol_CLIENT_SHORT_TERM_MOVE_NOTIFY,
    Protocol_CLIENT_LONG_TERM_MOVE_NOTIFY,
    Protocol_SERVER_SHORT_TERM_MOVE_NOTIFY,
    Protocol_SERVER_LONG_TERM_MOVE_NOTIFY,
    Protocol_GAME_PING_REQUEST,
    Protocol_GAME_PING_RESPONSE,
    Protocol_GAME_CONTENTS_CONFIG_NOTIFY,
    Protocol_EVENT_DIRECTION_BEGIN_NOTIFY,
    Protocol_EVENT_DIRECTION_FINISH_NOTIFY,
    Protocol_EVENT_BATTLE_REALM_CONTRIBUTION_NOTIFY,
    Protocol_EVENT_BATTLE_REALM__END_NOTIFY,
    Protocol_NOTIFY_EVENT_CONTRIBUTION,
    Protocol_NOTIFY_EVENT_REWARD,
    Protocol_NOTIFY_EVENT_START,
    Protocol_NOTIFY_EVENT_END,
    Protocol_NOTIFY_NEXT_NORMAL_EVENTSET_INFO,
    Protocol_EVENT_DISAPPEAR_BARRIER_NOTIFY,
    Protocol_NOTIFY_EVENT_TOTAL_REWARD,
    Protocol_EVENT_SPEECH_BUBBLE_NOTIFY,
    Protocol_EVENT_CHANNEL_CLOSE_NOTIFY,
    Protocol_EVENT_GO_TOWN_REQUEST,
    Protocol_EVENT_GO_TOWN_RESPONSE,
    Protocol_NOTIFY_EVENT_PHASE_START,
    Protocol_NOTIFY_EVENT_COUNTER_INFO,
    Protocol_NOTIFY_EVENT_COUNTER_PROGRESS_INFO,
    Protocol_NOTIFY_EVENT_HIDDEN_CONTENTS_START,
    Protocol_NOTIFY_EVENT_HIDDEN_CONTENTS_END,
    Protocol_NOTIFY_EVENT_HIDDEN_GATHERING_COLLECTED,
    Protocol_EVENT_OUT_OF_PLAY_NOTIFY,
    Protocol_EVENT_MIDDLE_NOTIFY,
    Protocol_QUEST_REWARD_NOTIFY,
    Protocol_QUEST_RECEIVE_REWARD_REQUEST,
    Protocol_QUEST_RECEIVE_REWARD_RESPONSE,
    Protocol_QUEST_CONTEXT_DATA_SET_NOTIFY,
    Protocol_QUEST_CONTEXT_DATA_NOTIFY,
    Protocol_CHAPTER_JOIN_REQUEST,
    Protocol_CHAPTER_JOIN_RESPONSE,
    Protocol_CHAPTER_DATA_NOTIFY,
    Protocol_QUEST_BONUS_REWARD_REQUEST,
    Protocol_QUEST_BONUS_REWARD_RESPONSE,
    Protocol_QUEST_BONUS_REWARD_NOTIFY,
    Protocol_CHAPTER_NOTIFY,
    Protocol_CHAPTER_CLEAR_SMAP_REQUEST,
    Protocol_CHAPTER_CLEAR_SMAP_RESPONSE,
    Protocol_CHAPTER_JOIN_SMAP_REQUEST,
    Protocol_CHAPTER_JOIN_SMAP_RESPONSE,
    Protocol_EXIT_INSTANCE_DUNGEON_REQUEST,
    Protocol_EXIT_INSTANCE_DUNGEON_RESPONSE,
    Protocol_EVENT_MOVE_START_LOC_REQUEST,
    Protocol_EVENT_MOVE_START_LOC_RESPONSE,
    Protocol_EVENT_RETURN_LAST_LOC_REQUEST,
    Protocol_EVENT_RETURN_LAST_LOC_RESPONSE,
    Protocol_MAIN_STREAM_EVENT_JOIN_SWITCH_STATE_NOTIFY,
    Protocol_MAIN_STREAM_EVENT_JOIN_SWITCH_REQUEST,
    Protocol_MAIN_STREAM_EVENT_JOIN_SWITCH_RESPONSE,
    Protocol_MAINSTREAM_STATE_NOTIFY,
    Protocol_MAIN_STREAM_DATA_NOTIFY,
    Protocol_MAIN_STREAM_DATA_SET_NOTIFY,
    Protocol_MAIN_STREAM_DIRECT_NOTIFY,
    Protocol_MAIN_STREAM_PRE_ACTION_REQUEST,
    Protocol_MAIN_STREAM_PRE_ACTION_RESPONSE,
    Protocol_MAIN_STREAM_FINISHED_BACK_NOTIFY,
    Protocol_MAIN_STREAM_DO_BUTTON_ACTION_REQUEST,
    Protocol_MAIN_STREAM_DO_BUTTON_ACTION_RESPONSE,
    Protocol_MAIN_STREAM_ON_REWARD_UI_NOTIFY,
    Protocol_DAILY_HOMEWORK_DATA_ALL_NOTIFY,
    Protocol_DAILY_HOMEWORK_DATA_UPDATE_NOTIFY,
    Protocol_DAILY_HOMEWORK_RESERVED,
    Protocol_DAILY_HOMEWORK_GET_REWARD_REQUEST,
    Protocol_DAILY_HOMEWORK_GET_REWARD_RESPONSE,
    Protocol_GOLD_DUNGEON_INFO_REQUEST,
    Protocol_GOLD_DUNGEON_INFO_RESPONSE,
    Protocol_GOLD_DUNGEON_ENTER_FAILED,
    Protocol_RECOMMEND_GET_PRAISER_REQUEST,
    Protocol_RECOMMEND_GET_PRAISER_RESPONSE,
    Protocol_RECOMMEND_CHOICE_PRAISER_REQUEST,
    Protocol_RECOMMEND_CHOICE_PRAISER_RESPOSE,
    Protocol_RECOMMEND_PRAISER_RESULT_NOTIFY,
    Protocol_RECOMMEND_CHOICE_RESULT_NOTIFY,
    Protocol_NPC_SCENEMAP_INFO_UPDATE_NOTIFY,
    Protocol_NPC_SCENEMAP_INFO_DESTROY_NOTIFY,
    Protocol_PC_SCENEMAP_INFO_UPDATE_NOTIFY,
    Protocol_PC_SCENEMAP_INFO_DESTROY_NOTIFY,
    Protocol_FIELD_JOIN_REQUEST,
    Protocol_FIELD_JOIN_RESPONSE,
    Protocol_DAILY_DUNGEON_CLEAR_NOTIFY,
    Protocol_DAILY_DUNGEON_JOIN_REQUEST,
    Protocol_DAILY_DUNGEON_JOIN_RESPONSE,
    Protocol_DAILY_DUNGEON_INFO_REQUEST,
    Protocol_DAILY_DUNGEON_INFO_RESPONSE,
    Protocol_DAILY_DUNGEON_OTHER_JOIN_REQUEST,
    Protocol_DAILY_DUNGEON_OTHER_JOIN_RESPONSE,
    Protocol_ARENA_TEAM_REQUEST,
    Protocol_ARENA_TEAM_RESPONSE,
    Protocol_ARENA_TEAM_REFRESH_REQUEST,
    Protocol_ARENA_TEAM_REFRESH_RESPONSE,
    Protocol_ARENA_JOIN_REQUEST,
    Protocol_ARENA_JOIN_RESPONSE,
    Protocol_ARENA_FINISH_REQUEST,
    Protocol_ARENA_FINISH_NOTIFY,
    Protocol_ARENA_PLAY_INFO_NOTIFY,
    Protocol_ARENA_REWARD_REQUEST,
    Protocol_ARENA_REWARD_RESPONSE,
    Protocol_ARENA_EXIT_REQUEST,
    Protocol_UPDATE_ITEM_COOLTIME_NOTIFY,
    Protocol_ARENA_FINISH_NOTIFY_REQUEST,
    Protocol_SOLO_DUNGEON_RELOAD_REQUEST,
    Protocol_SOLO_DUNGEON_RELOAD_RESPONSE,
    Protocol_SOLO_DUNGEON_LOAD_NOTIFY,
    Protocol_SOLO_DUNGEON_JOIN_REQUEST,
    Protocol_SOLO_DUNGEON_JOIN_RESPONSE,
    Protocol_SOLO_DUNGEON_CLEAR_NOTIFY,
    Protocol_INFLUENCE_POINT_UP_NOTIFY,
    Protocol_INFLUENCE_DATA_NOTIFY,
    Protocol_INFLUENCE_AFTER_REFRESH_NOTIFY,
    Protocol_ADMIN_UPDATE_REFRESH_INFLUENCE,
    Protocol_DB_ADMIN_UPDATE_INFLUENCE_TIER_LEVEL_REQUEST,
    Protocol_DB_ADMIN_UPDATE_INFLUENCE_TIER_LEVEL_RESPONSE,
    Protocol_MAIL_RECEIVE_NOTIFY,
    Protocol_MAIL_REWARD_RECEIVE_REQUEST,
    Protocol_MAIL_REWARD_RECEIVE_RESPONSE,
    Protocol_MAIL_REMOVE_NOTIFY,
    Protocol_CHAT_REQUEST,
    Protocol_CHAT_WHISPER_REQUEST,
    Protocol_CHAT_ERROR_NOTIFY,
    Protocol_CHAT_COMMON_NOTIFY,
    Protocol_CHAT_GUILD_NOTIFY,
    Protocol_CHAT_WHISPER_NOTIFY,
    Protocol_CHAT_GUILD_MSG_LIST_REQUEST,
    Protocol_CHAT_GUILD_MSG_LIST_RESPONSE,
    Protocol_CHAT_WHISPER_MSG_LIST_REQUEST,
    Protocol_CHAT_WHISPER_MSG_LIST_RESPONSE,
    Protocol_CHAT_NEW_MESSAGE_NOTIFY,
    Protocol_CHAT_WORLD_REQUEST,
    Protocol_CHAT_LOCAL_REQUEST,
    Protocol_CHAT_WARFIELD_REQUEST,
    Protocol_CHAT_CHECK_RECEIVER_REQUEST,
    Protocol_CHAT_CHECK_RECEIVER_RESPONSE,
    Protocol_CHAT_READ_WHISPER_NOTIFY,
    Protocol_CHAT_READ_GUILD_NOTIFY,
    Protocol_CHAT_DELETE_ROOM,
    Protocol_NEW_WHISPER_MESSAGE_NOTIFY,
    Protocol_NEW_GUILD_MESSAGE_NOTIFY,
    Protocol_TARGET_PC_DETAIL_INFO_REQUEST,
    Protocol_TARGET_PC_DETAIL_INFO_RESPONSE,
    Protocol_PLAYER_DENIED_REQUEST,
    Protocol_PLAYER_DENIED_RESPONSE,
    Protocol_PLAYER_UNDENIED_REQUEST,
    Protocol_PLAYER_UNDENIED_RESPONSE,
    Protocol_PLAYER_DENIED_LIST_NOTIFY,
    Protocol_TRADE_GET_TRADE_ITEM_LIST_REQUEST,
    Protocol_TRADE_GET_TRADE_ITEM_LIST_RESPONSE,
    Protocol_TRADE_SET_TRADE_ITEM_REQUEST,
    Protocol_TRADE_SET_TRADE_ITEM_RESPONSE,
    Protocol_TRADE_BUY_TRADE_ITEM_REQUEST,
    Protocol_TRADE_BUY_TRADE_ITEM_RESPONSE,
    Protocol_TRADE_MY_SALE_LIST_REQUEST,
    Protocol_TRADE_MY_SALE_LIST_RESPONSE,
    Protocol_TRADE_SALE_LOG_LIST_REQUEST,
    Protocol_TRADE_SALE_LOG_LIST_RESPONSE,
    Protocol_TRADE_CANCEL_TRADE_ITEM_REQUEST,
    Protocol_TRADE_CANCEL_TRADE_ITEM_RESPONSE,
    Protocol_RAID_JOIN_FAILED_NOTIFY,
    Protocol_RAID_INFO_REQUEST,
    Protocol_RAID_INFO_RESPONSE,
    Protocol_RAID_RANDOM_REWARD_PC_NOTIFY,
    Protocol_BONUS_DAILY_RECHARGE_MANUAL_REQUEST,
    Protocol_BONUS_DAILY_RECHARGE_MANUAL_RESPONSE,
    Protocol_BONUS_DAILY_RECHARGE_INFO_REQUEST,
    Protocol_BONUS_DAILY_RECHARGE_INFO_RESPONSE,
    Protocol_INFINITE_TOWER_INFO_REQUEST,
    Protocol_INFINITE_TOWER_INFO_RESPONSE,
    Protocol_INFINITE_TOWER_JOIN_REQUEST,
    Protocol_INFINITE_TOWER_JOIN_RESPONSE,
    Protocol_INFINITE_TOWER_SWEEP_REQUEST,
    Protocol_INFINITE_TOWER_SWEEP_RESPONSE,
    Protocol_INFINITE_TOWER_CLEAR_NOTIFY,
    Protocol_ATTENDANCE_INFO_REQUEST,
    Protocol_ATTENDANCE_INFO_RESPONSE,
    Protocol_ATTENDANCE_STAMP_REQUEST,
    Protocol_ATTENDANCE_STAMP_RESPONSE,
    Protocol_ACCESS_TIME_INFO_REQUEST,
    Protocol_ACCESS_TIME_INFO_RESPONSE,
    Protocol_ACCESS_TIME_REWARD_REQUEST,
    Protocol_ACCESS_TIME_REWARD_RESPONSE,
    Protocol_REST_TIME_INFO_REQUEST,
    Protocol_REST_TIME_INFO_RESPONSE,
    Protocol_REST_TIME_REWARD_REQUEST,
    Protocol_REST_TIME_REWARD_RESPONSE,
    Protocol_SHOP_PURCHASE_PRODUCT_REQUEST,
    Protocol_SHOP_PURCHASE_PRODUCT_RESPONSE,
    Protocol_SHOP_PURCHASE_PRODUCT_REWARD_REQUEST,
    Protocol_SHOP_PURCHASE_PRODUCT_REWARD_RESPONSE,
    Protocol_SHOP_PURCHASE_PRODUCT_BONUS_REWARD_REQUEST,
    Protocol_SHOP_PURCHASE_PRODUCT_BONUS_REWARD_RESPONSE,
    Protocol_SHOP_PURCHASE_PRODUCT_LIST_NOTIFY,
    Protocol_SHOP_PURCHASE_PRODUCT_EXPIRE_DATE_NOTIFY,
    Protocol_SHOP_PURCHASE_PRODUCT_MISSION_UPDATE_NOTIFY,
    Protocol_SHOP_PURCHASE_PRODUCT_BONUS_POINT_UPDATE_NOTIFY,
    Protocol_SHOP_PURCHASE_PRODUCT_PROMOTION_UPDATE_NOTIFY,
    Protocol_SHOP_PURCHASE_PRODUCT_PROMOTION_REWARD_REQUEST,
    Protocol_SHOP_PURCHASE_PRODUCT_PROMOTION_REWARD_RESPONSE,
    Protocol_GUILD_DUNGEON_INFO_REQUEST,
    Protocol_GUILD_DUNGEON_INFO_RESPONSE,
    Protocol_GUILD_DUNGEON_ENTER_FAILED,
    Protocol_GUILD_DUNGEON_CLEAR_NOTIFY,
    Protocol_GUILD_DUNGEON_REWARD_REQUEST,
    Protocol_GUILD_DUNGEON_REWARD_RESPONSE,
    Protocol_DB_USER_DATA_REQUEST,
    Protocol_DB_USER_DATA_RESPONSE,
    Protocol_DB_ADD_ITEM_REQUEST,
    Protocol_DB_ADD_ITEM_RESPONSE,
    Protocol_DB_DEL_ITEM_REQUEST,
    Protocol_DB_DEL_ITEM_RESPONSE,
    Protocol_DB_UPDATE_LEVEL_EXP_REQUEST,
    Protocol_DB_UPDATE_LEVEL_EXP_RESPONSE,
    Protocol_DB_DISENCHANT_ITEM_REQUEST,
    Protocol_DB_DISENCHANT_ITEM_RESPONSE,
    Protocol_DB_ENCHANT_ITEM_REQUEST,
    Protocol_DB_ENCHANT_ITEM_RESPONSE,
    Protocol_DB_UPGRADE_ITEM_REQUEST,
    Protocol_DB_UPGRADE_ITEM_RESPONSE,
    Protocol_DB_SALE_ITEM_REQUEST,
    Protocol_DB_SALE_ITEM_RESPONSE,
    Protocol_DB_TRANSCEND_ITEM_REQUEST,
    Protocol_DB_TRANSCEND_ITEM_RESPONSE,
    Protocol_DB_CHANGE_TRANSCEND_STAT_REQUEST,
    Protocol_DB_CHANGE_TRANSCEND_STAT_RESPONSE,
    Protocol_DB_CRAFT_ITEM_REQUEST,
    Protocol_DB_CRAFT_ITEM_RESPONSE,
    Protocol_DB_PRESET_INSERT_REQUEST,
    Protocol_DB_PRESET_INSERT_RESPONSE,
    Protocol_DB_PRESET_UPDATE_REQUEST,
    Protocol_DB_PRESET_UPDATE_RESPONSE,
    Protocol_DB_SKILL_GROWTH_UPDATE_REQUEST,
    Protocol_DB_SKILL_GROWTH_UPDATE_RESPONSE,
    Protocol_DB_PURSE_REQUEST,
    Protocol_DB_PURSE_RESPONSE,
    Protocol_DB_CHANGE_PRISM_REQUEST,
    Protocol_DB_CHANGE_PRISM_RESPONSE,
    Protocol_DB_SET_DIAMOND_CHEAT_REQUEST,
    Protocol_DB_SET_DIAMOND_CHEAT_RESPONSE,
    Protocol_DB_TRANSMUTE_CRYSTAL_REQUEST,
    Protocol_DB_TRANSMUTE_CRYSTAL_RESPONSE,
    Protocol_DB_CHANGE_CRYSTAL_REQUEST,
    Protocol_DB_CHANGE_CRYSTAL_RESPONSE,
    Protocol_DB_UPDATE_SKILL_POINT_REQUEST,
    Protocol_DB_UPDATE_SKILL_POINT_RESPONSE,
    Protocol_DB_TOGGLE_SAFE_GUARD_REQUEST,
    Protocol_DB_TOGGLE_SAFE_GUARD_RESPONSE,
    Protocol_DB_SKILL_FEATURE_INITIALIZE_REQUEST,
    Protocol_DB_SKILL_FEATURE_INITIALIZE_RESPONSE,
    Protocol_DB_DAILY_DUNGEON_COMPLETE_REQUEST,
    Protocol_DB_DAILY_DUNGEON_COMPLETE_RESPONSE,
    Protocol_DB_MOVE_ITEM_REQUEST,
    Protocol_DB_MOVE_ITEM_RESPONSE,
    Protocol_DB_PRESET_TYPE_UPDATE_REQUEST,
    Protocol_DB_PRESET_TYPE_UPDATE_RESPONSE,
    Protocol_DB_QUEST_SET_DATA_MULTI_REQUEST,
    Protocol_DB_QUEST_SET_DATA_MULTI_RESPONSE,
    Protocol_DB_CHAPTER_UPDATE_REQUEST,
    Protocol_DB_CHAPTER_UPDATE_RESPONSE,
    Protocol_DB_INVEN_REWARD_MAIL_REQUEST,
    Protocol_DB_INVEN_REWARD_MAIL_RESPONSE,
    Protocol_DB_RECV_MAIL_REWARD_REQUEST,
    Protocol_DB_RECV_MAIL_REWARD_RESPONSE,
    Protocol_DB_SOLO_DUNGEON_SET_DATA_REQUEST,
    Protocol_DB_SOLO_DUNGEON_SET_DATA_RESPONSE,
    Protocol_DB_SOLO_DUNGEON_SET_TICKET_REQUEST,
    Protocol_DB_SOLO_DUNGEON_SET_TICKET_RESPONSE,
    Protocol_DB_QUEST_BONUS_SET_DATA_REQUEST,
    Protocol_DB_QUSET_BONUS_SET_DATA_RESPONSE,
    Protocol_DB_PC_UPDATE_REQUEST,
    Protocol_DB_PC_UPDATE_RESPONSE,
    Protocol_DB_USE_ITEM_REQUEST,
    Protocol_DB_USE_ITEM_RESPONSE,
    Protocol_DB_USE_ITEM_CONTENTS_EFFECT_REQUEST,
    Protocol_DB_USE_ITEM_CONTENTS_EFFECT_RESPONSE,
    Protocol_DB_NEW_MAIL_LOAD_REQUEST,
    Protocol_DB_NEW_MAIL_LOAD_RESPONSE,
    Protocol_DB_REWARD_REQUEST,
    Protocol_DB_REWARD_RESPONSE,
    Protocol_DB_FOLLOWER_ADD_SOUL_STONE_REQUEST,
    Protocol_DB_FOLLOWER_ADD_SOUL_STONE_RESPONSE,
    Protocol_DB_FOLLOWER_ENCHANT_REQUEST,
    Protocol_DB_FOLLOWER_ENCHANT_RESPONSE,
    Protocol_DB_FOLLOWER_START_MISSION_REQUEST,
    Protocol_DB_FOLLOWER_START_MISSION_RESPONSE,
    Protocol_DB_FOLLOWER_END_MISSION_REQUEST,
    Protocol_DB_FOLLOWER_END_MISSION_RESPONSE,
    Protocol_DB_FOLLOWER_MISSION_REWARD_REQUEST,
    Protocol_DB_FOLLOWER_MISSION_REWARD_RESPONSE,
    Protocol_DB_QUEST_SET_REWARD_REQUEST,
    Protocol_DB_QUEST_SET_REWARD_RESPONSE,
    Protocol_ARENA_STATE_NOTIFY,
    Protocol_ARENA_MEMBER_LIST_REQUEST,
    Protocol_ARENA_MEMBER_LIST_RESPONSE,
    Protocol_DB_ARENA_REWARD_REQUEST,
    Protocol_DB_ARENA_REWARD_RESPONSE,
    Protocol_DB_ARENA_FINISH_REQUEST,
    Protocol_DB_ARENA_FINISH_RESPONSE,
    Protocol_ARENA_INFO_REQUEST,
    Protocol_ARENA_INFO_RESPONSE,
    Protocol_DB_LOAD_UPC_DATA_REQUEST,
    Protocol_DB_LOAD_UPC_DATA_RESPONSE,
    Protocol_DB_ITEM_COOL_TIME_SAVE_REQUEST,
    Protocol_DB_ITEM_COOL_TIME_SAVE_RESPONSE,
    Protocol_DB_LOAD_ITEM_COOLTIME_RESPONSE,
    Protocol_DB_ITEM_COOL_TIME_UPDATE_REQUEST,
    Protocol_DB_ITEM_COOL_TIME_UPDATE_RESPONSE,
    Protocol_DB_INFLUENCE_REFRESH_REQUEST,
    Protocol_DB_INFLUENCE_REFRESH_RESPONSE,
    Protocol_DB_INFLUENCE_POINT_UP_REQUEST,
    Protocol_DB_INFLUENCE_POINT_UP_RESPONSE,
    Protocol_DB_TICKET_UPDATE_REQUEST,
    Protocol_DB_TICKET_UPDATE_RESPONSE,
    Protocol_DB_TICKET_REFILL_REQUEST,
    Protocol_DB_TICKET_REFILL_RESPONSE,
    Protocol_DB_DAILY_HOMEWORK_UPDATE_REQUEST,
    Protocol_DB_DAILY_HOMEWORK_UPDATE_RESPONSE,
    Protocol_DB_MAIN_STREAM_UPDATE_REQUEST,
    Protocol_DB_MAIN_STREAM_UPDATE_RESPONSE,
    Protocol_DB_MAIN_STREAM_UPDATE_ALL_REQUEST,
    Protocol_DB_MAIN_STREAM_UPDATE_ALL_RESPONSE,
    Protocol_DB_DAILY_HOMEWORK_POINT_UPDATE_REQUEST,
    Protocol_DB_DAILY_HOMEWORK_POINT_UPDATE_RESPONSE,
    Protocol_DB_DAILY_HOMEWORK_POINT_REWARD_REQUEST,
    Protocol_DB_DAILY_HOMEWORK_POINT_REWARD_RESPONSE,
    Protocol_DB_SET_TRADE_ITEM_REQUEST,
    Protocol_DB_SET_TRADE_ITEM_RESPONSE,
    Protocol_DB_GET_TRADE_ITEM_LIST_REQUEST,
    Protocol_DB_GET_TRADE_ITEM_LIST_RESPONSE,
    Protocol_DB_GET_TRADE_MY_SALE_LIST_REQUEST,
    Protocol_DB_GET_TRADE_MY_SALE_LIST_RESPONSE,
    Protocol_DB_BUY_TRADE_ITEM_REQUEST,
    Protocol_DB_BUY_TRADE_ITEM_RESPONSE,
    Protocol_DB_CANCEL_TRADE_ITEM_REQUEST,
    Protocol_DB_CANCEL_TRADE_ITEM_RESPONSE,
    Protocol_DB_GET_TRADE_SALE_LOG_LIST_REQUEST,
    Protocol_DB_GET_TRADE_SALE_LOG_LIST_RESPONSE,
    Protocol_DB_DAILY_HOMEWORK_CHANGE_CHAPTER_REQUEST,
    Protocol_DB_DAILY_HOMEWORK_CHANGE_CHAPTER_RESPONSE,
    Protocol_DB_DAILY_HOMEWORK_RESET_REQUEST,
    Protocol_DB_DAILY_HOMEWORK_RESET_RESPONSE,
    Protocol_DB_DAILY_HOMEWORK_TEST_RESET_REQUEST,
    Protocol_DB_DAILY_HOMEWORK_TEST_RESET_RESPONSE,
    Protocol_DB_BONUS_DAILY_RECHARGE_REQEUST,
    Protocol_DB_BONUS_DAILY_RECHARGE_RESPONSE,
    Protocol_DB_INFINITE_TOWER_CLEAR_REQUEST,
    Protocol_DB_INFINITE_TOWER_CLEAR_RESPONSE,
    Protocol_DB_INFINITE_TOWER_SWEEP_REQUEST,
    Protocol_DB_INFINITE_TOWER_SWEEP_RESPONSE,
    Protocol_DB_ATTENDANCE_STAMP_REQUEST,
    Protocol_DB_ATTENDANCE_STAMP_RESPONSE,
    Protocol_DB_DIA_ENTER_COUNT_UPDATE_REQUEST,
    Protocol_DB_DIA_ENTER_COUNT_UPDATE_RESPONSE,
    Protocol_DB_ITEM_ENTER_COUNT_UPDATE_REQUEST,
    Protocol_DB_ITEM_ENTER_COUNT_UPDATE_RESPONSE,
    Protocol_DB_ENTER_COUNT_UPDATE_REQUEST,
    Protocol_DB_ENTER_COUNT_UPDATE_RESPONSE,
    Protocol_DB_ENTER_SET_COUNT_UPDATE_REQUEST,
    Protocol_DB_ENTER_SET_COUNT_UPDATE_REPONSE,
    Protocol_DB_ITEM_FUSION_REQUEST,
    Protocol_DB_ITEM_FUSION_RESPONSE,
    Protocol_DB_LOAD_PC_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_SKILL_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_PRESET_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_PC_PURSE_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_MAIL_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_DAILY_DUNGEON_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_SHOP_PURCHASED_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_STORAGE_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_ITEM_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_FOLLOWER_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_QUEST_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_CHAPTER_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_SOLO_DUNGEON_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_TICKET_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_ARENA_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_INFLUENCE_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_MAIN_STREAM_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_DAILY_HOMEWORK_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_INFINITE_TOWER_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_ENTER_COUNTS_RESPONSE,
    Protocol_DB_LOAD_PC_ATTENDANCE_RESPONSE,
    Protocol_DB_LOAD_PC_ACCESS_TIME_RESPONSE,
    Protocol_DB_LOAD_PC_REST_TIME_RESPONSE,
    Protocol_DB_LOAD_PC_INFLUENCE_RESPONSE,
    Protocol_DB_LOAD_PC_SPECIAL_GROWTH_RESPONSE,
    Protocol_DB_LOAD_PC_BUDDY_RESPONSE,
    Protocol_DB_LOAD_PC_SHORT_TERM_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_ACCOUNT_PURSE_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_ACCOUNT_DEPOT_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_ACCOUNT_ARTIFACT_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_ACCOUNT_SHOP_PURCHASE_LIMIT_COUNT_RESPONSE,
    Protocol_DB_LOAD_PC_ACCOUNT_SHOP_PURCHASE_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_BUFF_LIST_RESPONSE,
    Protocol_DB_LOAD_PC_ACCOUNT_MAIL_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_KILLER_LIST_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_KILL_ASSIST_COUNT_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_BATTLE_FIELD_COLLECTION_RESPONSE,
    Protocol_DB_LOAD_PC_GUILD_DUNGEON_RESPONSE,
    Protocol_DB_LOAD_PC_COSTUME_PRESET_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_LIVE_EVENT_TRADE_RESPONSE,
    Protocol_DB_LOAD_PC_LIVE_EVENT_DIA_BUY_RESPONSE,
    Protocol_DB_LOAD_PC_LIVE_EVENT_DIA_SPENT_RESPONSE,
    Protocol_DB_LOAD_PC_LIVE_EVENT_LIMIT_SELL_SHOP_RESPONSE,
    Protocol_DB_LOAD_PC_ACCOUNT_LIVE_EVENT_LIMIT_SELL_SHOP_RESPONSE,
    Protocol_DB_LOAD_PC_ACCOUNT_LIVE_EVENT_ATTENTION_RESPONSE,
    Protocol_DB_LOAD_PC_BRAWL_SHORT_TERM_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_BRAWL_DAILY_ACQUIRED_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_BRAWL_ENHANCE_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_SCROLL_QUEST_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_BRAWL_LAST_LEAVED_TIME_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_LIVE_EVENT_LEVELUP_RESPONSE,
    Protocol_DB_LOAD_PC_ACCOUNT_PET_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_ACCOUNT_PET_ALTAR_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_ACCOUNT_PET_HATCHERY_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_CRYSTAL_CHANGE_COUNT_DATA_RESPONSE,
    Protocol_DB_LOAD_PC_ACCOUNT_LAST_LOGOUT_BY_MY_PCS_RESPONSE,
    Protocol_DB_LOAD_PC_PVPCOIN_DAILY_ACQUIRED_DATA_RESPONSE,
    Protocol_DB_UPDATE_PC_UPDATE_DATA_NOTIFY,
    Protocol_DB_UPDATE_QUEST_UPDATE_DATA_NOTIFY,
    Protocol_DB_UPDATE_ACCESS_TIME_DATA_NOTIFY,
    Protocol_DB_UPDATE_REST_TIME_DATA_NOTIFY,
    Protocol_DB_ACCESS_TIME_REWARD_REQUEST,
    Protocol_DB_ACCESS_TIME_REWARD_RESPONSE,
    Protocol_DB_ACCESS_TIME_SET_REQUEST,
    Protocol_DB_ACCESS_TIME_SET_RESPONSE,
    Protocol_DB_REST_TIME_REWARD_REQUEST,
    Protocol_DB_REST_TIME_REWARD_RESPONSE,
    Protocol_DB_REST_TIME_SET_REQUEST,
    Protocol_DB_REST_TIME_SET_RESPONSE,
    Protocol_DB_UPC_CACHE_DATA_REQUEST,
    Protocol_DB_UPC_CACHE_DATA_RESPONSE,
    Protocol_DB_ARENA_SCORE_UPDATE_REQUEST,
    Protocol_DB_CHANNEL_MOVE_TIME_UPDATE_REQUEST,
    Protocol_DB_CHANNEL_MOVE_TIME_UPDATE_RESPONSE,
    Protocol_DB_BATTLE_FIELD_SET_TIME_REQUEST,
    Protocol_DB_BATTLE_FIELD_SET_TIME_RESPONSE,
    Protocol_DB_BATTLE_FIELD_DAILY_RESET_REQUEST,
    Protocol_DB_BATTLE_FIELD_DAILY_RESET_RESPONSE,
    Protocol_DB_BATTLE_FIELD_SET_SHORT_TERM_REQUEST,
    Protocol_DB_BATTLE_FIELD_SET_SHORT_TERM_RESPONSE,
    Protocol_DB_ARENA_TODAY_PLAY_COUNT_UPDATE_REQUEST,
    Protocol_DB_ARENA_TODAY_PLAY_COUNT_UPDATE_RESPONSE,
    Protocol_DB_ARENA_TODAY_PLAY_COUNT_RESET_REQUEST,
    Protocol_DB_ARENA_TODAY_PLAY_COUNT_RESET_RESPONSE,
    Protocol_DB_BATTLE_FIELD_SET_SHORT_TERM_MAIL_REQUEST,
    Protocol_DB_BATTLE_FIELD_SET_SHORT_TERM_MAIL_RESPONSE,
    Protocol_DB_KILLER_INFO_SET_REQUEST,
    Protocol_DB_KILLER_INFO_SET_RESPONSE,
    Protocol_DB_KILL_ASSIST_COUNT_SET_REQUEST,
    Protocol_DB_KILL_ASSIST_COUNT_SET_RESPONSE,
    Protocol_DB_EVENT_REWARD_REQUEST,
    Protocol_DB_EVENT_REWARD_RESPONSE,
    Protocol_DB_PLAYER_STAT_SAVE_REQUEST,
    Protocol_DB_PLAYER_STAT_SAVE_RESPONSE,
    Protocol_DB_GUILD_DUNGEON_CLEAR_REQUEST,
    Protocol_DB_GUILD_DUNGEON_CLEAR_RESPONSE,
    Protocol_DB_GUILD_DUNGEON_REWARD_REQUEST,
    Protocol_DB_GUILD_DUNGEON_REWARD_RESPONSE,
    Protocol_DB_COSTUME_PRESET_TYPE_UPDATE_REQUEST,
    Protocol_DB_COSTUME_PRESET_TYPE_UPDATE_RESPONSE,
    Protocol_DB_COSTUME_PRESET_UPDATE_REQUEST,
    Protocol_DB_COSTUME_PRESET_UPDATE_RESPONSE,
    Protocol_DB_ENCHANT_COSTUME_REQUEST,
    Protocol_DB_ENCHANT_COSTUME_RESPONSE,
    Protocol_DB_UPGRADE_COSTUME_REQUEST,
    Protocol_DB_UPGRADE_COSTUME_RESPONSE,
    Protocol_DB_INHERIT_COSTUME_REQUEST,
    Protocol_DB_INHERIT_COSTUME_RESPONSE,
    Protocol_DB_LIVE_EVENT_TRADE_PURCHAES_REQUEST,
    Protocol_DB_LIVE_EVENT_TRADE_PURCHAES_RESPONSE,
    Protocol_DB_LIVE_EVENT_LIMIT_SELL_SHOP_PURCHAES_REQUEST,
    Protocol_DB_LIVE_EVENT_LIMIT_SELL_SHOP_PURCHAES_RESPONSE,
    Protocol_DB_LIVE_EVENT_DIA_BUY_REWARD_REQUEST,
    Protocol_DB_LIVE_EVENT_DIA_BUY_REWARD_RESPONSE,
    Protocol_DB_LIVE_EVENT_DIA_BUY_UPDATE_AMOUNT_NOTIFY,
    Protocol_DB_LIVE_EVENT_DIA_SPENT_REWARD_REQUEST,
    Protocol_DB_LIVE_EVENT_DIA_SPENT_REWARD_RESPONSE,
    Protocol_DB_LIVE_EVENT_DIA_SPENT_UPDATE_AMOUNT_NOTIFY,
    Protocol_DB_LIVE_EVENT_ATTENTION_RECEIVE_STATE_REQUEST,
    Protocol_DB_LIVE_EVENT_ATTENTION_RECEIVE_STATE_RESPONSE,
    Protocol_DB_LIVE_EVENT_RETURN_ATTENTION_RECEIVE_STATE_REQUEST,
    Protocol_DB_LIVE_EVENT_RETURN_ATTENTION_RECEIVE_STATE_RESPONSE,
    Protocol_DB_LIVE_EVENT_NEWBIE_ATTENTION_RECEIVE_STATE_REQUEST,
    Protocol_DB_LIVE_EVENT_NEWBIE_ATTENTION_RECEIVE_STATE_RESPONSE,
    Protocol_DB_LIVE_EVENT_ATTENTION_REWARD_REQUEST,
    Protocol_DB_LIVE_EVENT_ATTENTION_REWARD_RESPONSE,
    Protocol_DB_LIVE_EVENT_RETURN_ATTENTION_REWARD_REQUEST,
    Protocol_DB_LIVE_EVENT_RETURN_ATTENTION_REWARD_RESPONSE,
    Protocol_DB_LIVE_EVENT_NEWBIE_ATTENTION_REWARD_REQUEST,
    Protocol_DB_LIVE_EVENT_NEWBIE_ATTENTION_REWARD_RESPONSE,
    Protocol_DB_LIVE_EVENT_ATTENTION_END_RECEIVE_STATE_REQUEST,
    Protocol_DB_LIVE_EVENT_ATTENTION_END_RECEIVE_STATE_RESPONSE,
    Protocol_DB_LIVE_EVENT_RETURN_ATTENTION_END_RECEIVE_STATE_REQUEST,
    Protocol_DB_LIVE_EVENT_RETURN_ATTENTION_END_RECEIVE_STATE_RESPONSE,
    Protocol_DB_LIVE_EVENT_NEWBIE_ATTENTION_END_RECEIVE_STATE_REQUEST,
    Protocol_DB_LIVE_EVENT_NEWBIE_ATTENTION_END_RECEIVE_STATE_RESPONSE,
    Protocol_DB_LIVE_EVENT_ATTENTION_END_REWARD_REQUEST,
    Protocol_DB_LIVE_EVENT_ATTENTION_END_REWARD_RESPONSE,
    Protocol_DB_LIVE_EVENT_RETURN_ATTENTION_END_REWARD_REQUEST,
    Protocol_DB_LIVE_EVENT_RETURN_ATTENTION_END_REWARD_RESPONSE,
    Protocol_DB_LIVE_EVENT_NEWBIE_ATTENTION_END_REWARD_REQUEST,
    Protocol_DB_LIVE_EVENT_NEWBIE_ATTENTION_END_REWARD_RESPONSE,
    Protocol_DB_LIVE_EVENT_LEVELUP_RECEIVE_STATE_REQUEST,
    Protocol_DB_LIVE_EVENT_LEVELUP_RECEIVE_STATE_RESPONSE,
    Protocol_DB_LIVE_EVENT_LEVELUP_REWARD_REQUEST,
    Protocol_DB_LIVE_EVENT_LEVELUP_REWARD_RESPONSE,
    Protocol_DB_STORAGE_SLOT_EXPANSION_REQUEST,
    Protocol_DB_STORAGE_SLOT_EXPANSION_RESPONSE,
    Protocol_DB_BRAWL_SET_TIME_REQUEST,
    Protocol_DB_BRAWL_SET_TIME_RESPONSE,
    Protocol_DB_BRAWL_SET_SHORT_TERM_REQUEST,
    Protocol_DB_BRAWL_SET_SHORT_TERM_RESPONSE,
    Protocol_DB_BRAWL_SHORT_TERM_REWARD_REQUEST,
    Protocol_DB_BRAWL_SHORT_TERM_REWARD_RESPONSE,
    Protocol_DB_BRAWL_SET_POINT_REQEUST,
    Protocol_DB_BRAWL_SET_POINT_RESPONSE,
    Protocol_DB_BRAWL_ENHANCE_LEVEL_UP_REQUEST,
    Protocol_DB_BRAWL_ENHANCE_LEVEL_UP_RESPONSE,
    Protocol_DB_BRAWL_SET_DAILY_ACQUIRED_REQEUST,
    Protocol_DB_BRAWL_SET_DAILY_ACQUIRED_RESPONSE,
    Protocol_DB_SCROLL_QUEST_USE_SCROLL_GROUP_ITEM_REQUEST,
    Protocol_DB_SCROLL_QUEST_USE_SCROLL_GROUP_ITEM_RESPONSE,
    Protocol_DB_SCROLL_QUEST_PROGRESS_SET_REQUEST,
    Protocol_DB_SCROLL_QUEST_PROGRESS_SET_RESPONSE,
    Protocol_DB_SCROLL_QUEST_DAILY_SET_REQUEST,
    Protocol_DB_SCROLL_QUEST_DAILY_SET_RESPONSE,
    Protocol_DB_SCROLL_QUEST_REWARD_REQUEST,
    Protocol_DB_SCROLL_QUEST_REWARD_RESPONSE,
    Protocol_DB_UPDATE_PVP_POINT_REQEUST,
    Protocol_DB_UPDATE_PVP_POINT_RESPONSE,
    Protocol_DB_SET_PVP_COIN_DAILY_ACQUIRED_REQEUST,
    Protocol_DB_SET_PVP_COIN_DAILY_ACQUIRED_RESPONSE,
    Protocol_PC_LOGIN_DATA_NOTIFY,
    Protocol_LOAD_DATA_REQUEST,
    Protocol_LOAD_DATA_RESPONSE,
    Protocol_WORLDOBJECT_DESPAWN_NOTIFY,
    Protocol_PC_SPAWN_NOTIFY,
    Protocol_NPC_SPAWN_NOTIFY,
    Protocol_PROJECTILE_SPAWN_NOTIFY,
    Protocol_INSTANTSHOT_SPAWN_NOTIFY,
    Protocol_INSTANTSHOT_DESPAWN_NOTIFY,
    Protocol_PROJECTILE_EFFECT_NOTIFY,
    Protocol_REACTION_ENTER_NOTIFY,
    Protocol_REACTION_LEAVE_NOTIFY,
    Protocol_REACTION_UPDATE_NOTIFY,
    Protocol_ENTER_STATE_NOTIFY,
    Protocol_LEAVE_STATE_NOTIFY,
    Protocol_PLAYER_REVIVE_REQUEST,
    Protocol_PLAYER_REVIVE_RESPONSE,
    Protocol_UPC_SPAWN_NOTIFY,
    Protocol_PLAYER_IMMEDIATELY_DEAD_REQUEST,
    Protocol_PC_GUILD_INFO_UPDATE_NOTIFY,
    Protocol_AGGRO_TICKER_INFO_NOTIFY,
    Protocol_UPC_LOAD_START_NOTIFY,
    Protocol_UPC_LOAD_FINISH_NOTIFY,
    Protocol_UPC_HOST_REQUEST,
    Protocol_UPC_HOST_RESPONSE,
    Protocol_UPC_UNHOST_NOTIFY,
    Protocol_PC_STAT_HARDCAP_DATA_NOTIFY,
    Protocol_STORAGE_DATA_NOTIFY,
    Protocol_STORAGE_ITEM_DATA_NOTIFY,
    Protocol_EQUIP_DATA_NOTIFY,
    Protocol_UPC_LOAD_START_NOTIFY_REQUEST,
    Protocol_PC_PK_HONOR_INFO_REQUEST,
    Protocol_PC_PK_HONOR_INFO_RESPONSE,
    Protocol_KILL_ASSIST_COUNT_NOTIFY,
    Protocol_PLAYER_DESPAWN_NOTIFY,
    Protocol_SKILL_USE_NOTIFY,
    Protocol_SKILL_START_NOTIFY,
    Protocol_SKILL_END_NOTIFY,
    Protocol_SKILL_EFFECT_NOTIFY,
    Protocol_SKILL_EFFECT_RESULT_NOTIFY,
    Protocol_SKILL_SLOT_NOTIFY,
    Protocol_SKILL_OPEN_SHIELD_NOTIFY,
    Protocol_STAT_UPDATE_NOTIFY,
    Protocol_SKILL_ERROR_NOTIFY,
    Protocol_SKILL_CLOSED_SHIELD_NOTIFY,
    Protocol_SKILL_EFFECT_RESULT_DAMAGE_NOTIFY,
    Protocol_SKILL_EFFECT_RESULT_HEAL_NOTIFY,
    Protocol_SKILL_SLOT_PLACE_REQUEST,
    Protocol_SKILL_SLOT_PLACE_RESPONSE,
    Protocol_SKILL_LEVEL_UP_REQUEST,
    Protocol_SKILL_LEVEL_UP_RESPONSE,
    Protocol_CHANGE_IFF_NOTIFY,
    Protocol_UPDATE_ENERGYPOINT_NOTIFY,
    Protocol_PRESET_CHANGE_REQUEST,
    Protocol_PRESET_CHANGE_RESPONSE,
    Protocol_PRESET_ITEMSLOT_UPDATE_NOTIFY,
    Protocol_SKILL_FEATURE_INITIALIZE_REQUEST,
    Protocol_SKILL_FEATURE_INITIALIZE_RESPONSE,
    Protocol_UPDATE_SKILL_POINT_NOTIFY,
    Protocol_PLAYER_REVIVE_INFO_NOTIFY,
    Protocol_SWITCH_SKILL_SLOT_REQUEST,
    Protocol_ADD_BUFF_NOTIFY,
    Protocol_UPDATE_BUFF_NOTIFY,
    Protocol_CREATURE_HP_CHANGE_NOTIFY,
    Protocol_CHANGED_SUPER_ARMOR_GAUGE_NOTIFY,
    Protocol_PENALTY_SKILL_NOTIFY,
    Protocol_PENALTY_SKILL_CANCEL_NOTIFY,
    Protocol_CHANGE_REACTION_IMMUNE_INFO_NOTIFY,
    Protocol_NPC_AGGRO_TIMER_NOTIFY,
    Protocol_CREATURE_TARGETED_NOTIFY,
    Protocol_NPC_RETURN_WARNING_NOTIFY,
    Protocol_AI_ACTION_START_NOTIFY,
    Protocol_AI_ACTION_END_NOTIFY,
    Protocol_CREATURE_DETECT_TARGET_NOTIFY,
    Protocol_SOCIAL_MOTION_START_REQUEST,
    Protocol_SOCIAL_MOTION_START_NOTIFY,
    Protocol_INSERT_ITEM_RESPONSE,
    Protocol_DELETE_ITEM_REQUEST,
    Protocol_DELETE_ITEM_RESPONSE,
    Protocol_EQUIP_ITEM_OBJECT_REQUEST,
    Protocol_EQUIP_ITEM_RESPONSE,
    Protocol_UNEQUIP_ITEM_REQUEST,
    Protocol_UNEQUIP_ITEM_RESPONSE,
    Protocol_REFRESH_INVEN_REQUEST,
    Protocol_REFRESH_INVEN_RESPONSE,
    Protocol_SERVER_TIME_REQUEST,
    Protocol_SERVER_TIME_RESPONSE,
    Protocol_UPDATE_ITEM_NOTIFY,
    Protocol_TOGGLE_SAFE_GUARD_REQUEST,
    Protocol_TOGGLE_SAFE_GUARD_RESPONSE,
    Protocol_USE_ITEM_REQUEST,
    Protocol_USE_ITEM_RESPONSE,
    Protocol_ITEM_BOUND_STATE_UPDATE_NOTIFY,
    Protocol_ADD_ITEM_NOTIFY,
    Protocol_REMOVE_ITEM_NOTIFY,
    Protocol_CHANGE_ITEM_STACK_COUNT_NOTIFY,
    Protocol_UPDATE_ITEM_GRADE_LEVEL_NOTIFY,
    Protocol_UPDATE_ITEM_OPTION_NOTIFY,
    Protocol_MOVE_ITEM_NOTIFY,
    Protocol_UPDATE_ARTIFACT_NOTIFY,
    Protocol_FOLLOWER_ADD_SOUL_STONE_NOTIFY,
    Protocol_FOLLOWER_ENCHANT_REQUEST,
    Protocol_FOLLOWER_ENCHANT_RESPONSE,
    Protocol_FOLLOWER_START_MISSION_REQUEST,
    Protocol_FOLLOWER_START_MISSION_NOTIFY,
    Protocol_FOLLOWER_END_MISSION_REQUEST,
    Protocol_FOLLOWER_END_MISSION_RESPONSE,
    Protocol_FOLLOWER_MISSION_REMAIN_TIME_REQUEST,
    Protocol_FOLLOWER_MISSION_REMAIN_TIME_RESPONSE,
    Protocol_FOLLOWER_LOAD_INFO_NOTIFY,
    Protocol_FOLLOWER_MISSION_REWARD_RESPONSE,
    Protocol_FOLLOWER_MISSION_COMPLETE_REQUEST,
    Protocol_FOLLOWER_MISSION_COMPLETE_RESPONSE,
    Protocol_DISENCHANT_ITEM_REQUEST,
    Protocol_DISENCHANT_ITEM_RESPONSE,
    Protocol_ENCHANT_ITEM_REQUEST,
    Protocol_ENCHANT_ITEM_RESPONSE,
    Protocol_EQUIPMENT_TRANSMUTATION_ITEM_REQUEST,
    Protocol_EQUIPMENT_TRANSMUTATION_ITEM_RESPONSE,
    Protocol_UPGRADE_ITEM_REQUEST,
    Protocol_UPGRADE_ITEM_RESPONSE,
    Protocol_CRAFT_ITEM_REQUEST,
    Protocol_CRAFT_ITEM_RESPONSE,
    Protocol_PRISM_TRANSMUTATION_REQUEST,
    Protocol_PRISM_TRANSMUTATION_RESPONSE,
    Protocol_MOVE_ITEM_REQUEST,
    Protocol_MOVE_ITEM_RESPONSE,
    Protocol_TRANSMUTE_CRYSTAL_ITEM_REQUEST,
    Protocol_TRANSMUTE_CRYSTAL_ITEM_RESPONSE,
    Protocol_CHANGE_CRYSTAL_ITEM_REQUEST,
    Protocol_CHANGE_CRYSTAL_ITEM_RESPONSE,
    Protocol_CRYSTAL_ITEM_CHANGE_COUNT_NOTIFY,
    Protocol_TICKET_NOTIFY,
    Protocol_TICKET_ALL_NOTIFY,
    Protocol_ACQUIRE_CONTRIBUTION_NOTIFY,
    Protocol_BUNDLE_BOX_RESULT_NOTIFY,
    Protocol_ITEM_FUSION_REQUEST,
    Protocol_ITEM_FUSION_RESPONSE,
    Protocol_USE_ITEM_CONTENTS_EFFECT_REQUEST,
    Protocol_USE_ITEM_CONTENTS_EFFECT_RESPONSE,
    Protocol_TRANSCEND_ITEM_REQUEST,
    Protocol_TRANSCEND_ITEM_RESPONSE,
    Protocol_TRANSCEND_CHANGE_STAT_REQUEST,
    Protocol_TRANSCEND_CHANGE_STAT_RESPONSE,
    Protocol_PC_LEVEL_UP_EXP_NOTIFY,
    Protocol_PC_EXP_UP_NOTIFY,
    Protocol_DROP_REWARD_NOTIFY,
    Protocol_SALE_ITEM_REQUEST,
    Protocol_SALE_ITEM_RESPONSE,
    Protocol_UPDATE_PURSE_NOTIFY,
    Protocol_WORKOBJECT_SPAWN_NOTIFY,
    Protocol_WORKOBJECT_UPDATE_NOTIFY,
    Protocol_INTERACTION_STATE_NOTIFY,
    Protocol_START_INTERACTION_REQUEST,
    Protocol_START_RESURRECTION_REQUEST,
    Protocol_START_RESURRECTION_NOTIFY,
    Protocol_END_RESURRECTION_NOTIFY,
    Protocol_CANCEL_RESURRECTION_REQUEST,
    Protocol_CANCEL_RESURRECTION_NOTIFY,
    Protocol_START_MINIGAME_INTERACTION_NOTIFY,
    Protocol_START_DIALOG_INTERACTION_NOTIFY,
    Protocol_OTHER_PC_START_INTERACTION_NOTIFY,
    Protocol_MINIGAME_INTERACTION_RESULT_NOTIFY,
    Protocol_CANCEL_INTERACTION_NOTIFY,
    Protocol_END_INTERACTION_NOTIFY,
    Protocol_OTHER_PC_END_INTERACTION_NOTIFY,
    Protocol_PUSH_CREATE_NOTIFY,
    Protocol_PUSH_UPDATE_NOTIFY,
    Protocol_PUSH_ALONE_JOIN_REQUEST,
    Protocol_PUSH_ALONE_JOIN_RESPONSE,
    Protocol_PUSH_QUICK_MATCHING_JOIN_REQUEST,
    Protocol_PUSH_QUICK_MATCHING_JOIN_RESPONSE,
    Protocol_PUSH_QUICK_MATCHING_LEAVE_REQUEST,
    Protocol_PUSH_MATCHING_ADDED_NOTIFY,
    Protocol_PUSH_MATCHING_REMOVED_NOTIFY,
    Protocol_PUSH_MATCHING_JOINED_PC_CLASS_UPDATE,
    Protocol_PUSH_MATCHING_FAILED_NOTIFY,
    Protocol_PUSH_MATCHED_SUCCESS_NOTIFY,
    Protocol_CAMERA_OBJECT_START_NOTIFY,
    Protocol_CAMERA_OBJECT_END_NOTIFY,
    Protocol_CAMERA_OBJECT_MOVE_NOTIFY,
    Protocol_DIMENSION_CRYSTAL_INSERT_REQUEST,
    Protocol_DIMENSION_CRYSTAL_INSERT_RESPONSE,
    Protocol_DB_DIMENSION_CRYSTAL_INSERT_REQUEST,
    Protocol_DB_DIMENSION_CRYSTAL_INSERT_RESPONSE,
    Protocol_DIMENSION_CRYSTAL_REMOVE_REQUEST,
    Protocol_DIMENSION_CRYSTAL_REMOVE_RESPONSE,
    Protocol_DB_DIMENSION_CRYSTAL_REMOVE_REQUEST,
    Protocol_DB_DIMENSION_CRYSTAL_REMOVE_RESPONSE,
    Protocol_DIMENSION_CRYSTAL_LEVELUP_REQUEST,
    Protocol_DIMENISON_CRYSTAL_LEVELUP_RESPONSE,
    Protocol_DB_DIMENSION_CRYSTAL_LEVELUP_REQUEST,
    Protocol_DB_DIMENSION_CRYSTAL_LEVELUP_RESPONSE,
    Protocol_DIMENSION_CRYSTAL_UPGRADE_REQUEST,
    Protocol_DIMENSION_CRYSTAL_UPGRADE_RESPONSE,
    Protocol_DB_DIMENSION_CRYSTAL_UPGRADE_REQUEST,
    Protocol_DB_DIMENSION_CRYSTAL_UPGRADE_RESPONSE,
    Protocol_GAME_RECONNECT_REQUEST,
    Protocol_GAME_RECONNECT_RESPONSE,
    Protocol_RECONNECT_LOAD_DATA_REQUEST,
    Protocol_RECONNECT_LOAD_DATA_RESPONSE,
    Protocol_LOAD_DATA_COMPLETE_NOTIFY,
    Protocol_PC_LOGIN_DATA_COMPLETE_NOTIFY,
    Protocol_PC_LOGIN_DATA_START_NOTIFY,
    Protocol_REDIS_GET_RANGE_RANK_INFO_REQUEST,
    Protocol_REDIS_GET_RANGE_RANK_INFO_RESPONSE,
    Protocol_REDIS_GET_MY_RANK_REQUEST,
    Protocol_REDIS_GET_MY_RANK_RESPONSE,
    Protocol_REDIS_RANK_LOOKUP_REQUEST,
    Protocol_RANK_GET_PC_DEATIL_INFO_REQUEST,
    Protocol_REDIS_RANK_LOOKUP_RESPONSE,
    Protocol_DB_SHOP_PRODUCT_PURCHASE_REQUEST,
    Protocol_DB_SHOP_PRODUCT_PURCHASE_RESPONSE,
    Protocol_DB_SHOP_PROUDCT_UPDATE_MISSION_REQUEST,
    Protocol_DB_SHOP_PROUDCT_UPDATE_MISSION_RESPONSE,
    Protocol_DB_SHOP_PRODUCT_MISSION_REWARD_REQUEST,
    Protocol_DB_SHOP_PRODUCT_MISSION_REWARD_RESPONSE,
    Protocol_DB_SHOP_PRODUCT_PROMOTION_REWARD_REQUEST,
    Protocol_DB_SHOP_PRODUCT_PROMOTION_REWARD_RESPONSE,
    Protocol_ELIXIR_LIST_NOTIFY,
    Protocol_ELIXIR_EHCNAHT_REQUEST,
    Protocol_ELIXIR_EHCNAHT_RESPONSE,
    Protocol_DB_ELIXIR_ENCHANT_REQUEST,
    Protocol_DB_ELIXIR_ENCHANT_RESPONSE,
    Protocol_TERRASTONE_LIST_NOTIFY,
    Protocol_TERRASTONE_ENCHANT_REQUEST,
    Protocol_TERRASTONE_ENCHANT_RESPONSE,
    Protocol_DB_TERRASTONE_ENCHANT_REQUEST,
    Protocol_DB_TERRASTONE_ENCHANT_RESPONSE,
    Protocol_RESEARCH_LIST_NOTIFY,
    Protocol_RESEARCH_ENCHANT_REQUEST,
    Protocol_RESEARCH_ENCHANT_RESPONSE,
    Protocol_DB_RESEARCH_ENCHANT_REQUEST,
    Protocol_DB_RESEARCH_ENCHANT_RESPONSE,
    Protocol_GUARDIAN_STAR_LIST_NOTIFY,
    Protocol_GUARDIAN_STAR_ENCHANT_REQUEST,
    Protocol_GUARDIAN_STAR_ENCHANT_RESPONSE,
    Protocol_GUARDIAN_STAR_UPGRADE_REQUEST,
    Protocol_GUARDIAN_STAR_UPGRADE_RESPONSE,
    Protocol_DB_GUARDIAN_STAR_ENCHANT_REQUEST,
    Protocol_DB_GUARDIAN_STAR_ENCHANT_RESPONSE,
    Protocol_DB_GUARDIAN_STAR_UPGRADE_REQUEST,
    Protocol_DB_GUARDIAN_STAR_UPGRADE_RESPONSE,
    Protocol_PASSIVE_SKILL_LIST_NOTIFY,
    Protocol_PASSIVE_SKILL_ENCHANT_REQUEST,
    Protocol_PASSIVE_SKILL_ENCHANT_RESPONSE,
    Protocol_DB_PASSIVE_SKILL_ENCHANT_REQUEST,
    Protocol_DB_PASSIVE_SKILL_ENCHANT_RESPONSE,
    Protocol_DB_BUFF_SAVE_REQUEST,
    Protocol_DB_BUFF_SAVE_RESPONSE,
    Protocol_DB_BUFF_UPDATE_REQUEST,
    Protocol_DB_BUFF_UPDATE_RESPONSE,
    Protocol_DB_BUFF_REMOVE_REQUEST,
    Protocol_DB_BUFF_REMOVE_RESPONSE,
    Protocol_POTION_GROWTH_LIST_NOTIFY,
    Protocol_POTION_GROWTH_UPDATE_NOTIFY,
    Protocol_POTION_GROWTH_LEVEL_UP_REQUEST,
    Protocol_POTION_GROWTH_LEVEL_UP_RESPONSE,
    Protocol_DB_POTION_GROWTH_LEVEL_EXP_CHANGE_REQUEST,
    Protocol_DB_POTION_GROWTH_LEVEL_EXP_CHANGE_RESPONSE,
    Protocol_PC_CLIENT_CONFIG_NOTIFY,
    Protocol_PC_CLIENT_CONFIG_SAVE_REQUEST,
    Protocol_DB_UPDATE_PC_CLIENT_CONFIG_NOTIFY,
    Protocol_NOTICE_ITEM_NOTIFY,
    Protocol_NOTICE_USER_NOTIFY,
    Protocol_NOTICE_SHOP_PURCHASE_NOTIFY,
    Protocol_NOTICE_PET_NOTIFY,
    Protocol_NOTICE_ELITE_MONSTER_KILL_NOTIFY,
    Protocol_GUILD_INFO_NOTIFY,
    Protocol_GUILD_NOT_IMPL_NOTIFY,
    Protocol_GUILD_INFO_REQUEST,
    Protocol_GUILD_INFO_RESPONSE,
    Protocol_GUILD_CREATE_REQUEST,
    Protocol_GUILD_CREATE_RESPONSE,
    Protocol_GUILD_CHECK_NAME_REQUEST,
    Protocol_GUILD_CHECK_NAME_RESPONSE,
    Protocol_GUILD_DESTROY_REQUEST,
    Protocol_GUILD_DESTROY_RESPONSE,
    Protocol_GUILD_FIND_REQUEST,
    Protocol_GUILD_FIND_RESPONSE,
    Protocol_GUILD_JOIN_REQ_REQUEST,
    Protocol_GUILD_JOIN_REQ_RESPONSE,
    Protocol_GUILD_APPLICANT_UPDATE_NOTIFY,
    Protocol_GUILD_NEW_MEMBER_NOTIFY,
    Protocol_GUILD_LEAVE_MEMBER_NOTIFY,
    Protocol_GUILD_LEAVE_REQUEST,
    Protocol_GUILD_LEAVE_RESPONSE,
    Protocol_GUILD_JOIN_NOTIFY,
    Protocol_GUILD_LEAVE_NOTIFY,
    Protocol_GUILD_MEMBER_LIST_REQUEST,
    Protocol_GUILD_MEMBER_LIST_RESPONSE,
    Protocol_GUILD_ATTEND_REQUEST,
    Protocol_GUILD_ATTEND_RESPONSE,
    Protocol_GUILD_DONATE_REQUEST,
    Protocol_GUILD_DONATE_RESPONSE,
    Protocol_GUILD_RANKING_LIST_REQUEST,
    Protocol_GUILD_RANKING_LIST_RESPONSE,
    Protocol_GUILD_LIST_REQUEST,
    Protocol_GUILD_LIST_RESPONSE,
    Protocol_GUILD_DETAIL_INFO_REQUEST,
    Protocol_GUILD_DETAIL_INFO_RESPONSE,
    Protocol_GUILD_MY_JOIN_REQ_LIST_REQUEST,
    Protocol_GUILD_MY_JOIN_REQ_LIST_RESPONSE,
    Protocol_GUILD_REMOVE_JOIN_REQ_REQUEST,
    Protocol_GUILD_REMOVE_JOIN_REQ_RESPONSE,
    Protocol_GUILD_JOIN_REQ_LIST_REQUEST,
    Protocol_GUILD_JOIN_REQ_LIST_RESPONSE,
    Protocol_GUILD_ACCEPT_JOIN_REQ_REQUEST,
    Protocol_GUILD_ACCEPT_JOIN_REQ_RESPONSE,
    Protocol_GUILD_REJECT_JOIN_REQ_REQUEST,
    Protocol_GUILD_REJECT_JOIN_REQ_RESPONSE,
    Protocol_GUILD_CHANGE_JOIN_CONDITION_REQUEST,
    Protocol_GUILD_CHANGE_JOIN_CONDITION_RESPONSE,
    Protocol_GUILD_CHANGE_MSG_REQUEST,
    Protocol_GUILD_CHANGE_MSG_RESPONSE,
    Protocol_GUILD_KICK_MEMBER_REQUEST,
    Protocol_GUILD_KICK_MEMBER_RESPONSE,
    Protocol_GUILD_LEVEL_UP_NOTIFY,
    Protocol_GUILD_CHANGE_MEMBER_GRADE_REQUEST,
    Protocol_GUILD_CHANGE_MEMBER_GRADE_RESPONSE,
    Protocol_GUILD_CHANGE_MEMBER_GRADE_NOTIFY,
    Protocol_GUILD_HISTORY_REQUEST,
    Protocol_GUILD_HISTORY_RESPONSE,
    Protocol_GUILD_BUFF_PURCHASE_REQUEST,
    Protocol_GUILD_BUFF_PURCHASE_RESPONSE,
    Protocol_GUILD_CHANGE_LEADER_REQUEST,
    Protocol_GUILD_CHANGE_LEADER_RESPONSE,
    Protocol_GUILD_CANDIDATE_LEADER_LIST_REQUEST,
    Protocol_GUILD_CANDIDATE_LEADER_LIST_RESPONSE,
    Protocol_GUILD_CHANGE_CREST_REQUEST,
    Protocol_GUILD_CHANGE_CREST_RESPONSE,
    Protocol_GUILD_SHARE_SETTING_INFO_REQUEST,
    Protocol_GUILD_SHARE_SETTING_INFO_RESPONSE,
    Protocol_GUILD_SAVE_SHARE_SETTING_REQUEST,
    Protocol_GUILD_SAVE_SHARE_SETTING_RESPONSE,
    Protocol_GUILD_INVITE_MESSAGE_REQUEST,
    Protocol_GUILD_INVITE_MESSAGE_RESPONSE,
    Protocol_GUILD_MEMBER_DETAIL_INFO_REQUEST,
    Protocol_GUILD_MEMBER_DETAIL_INFO_RESPONSE,
    Protocol_GUILD_REJECT_JOIN_REQ_NOTIFY,
    Protocol_GUILD_CHANGE_NAME_REQUEST,
    Protocol_GUILD_CHANGE_NAME_RESPONSE,
    Protocol_GUILD_CHANGE_NAME_NOTIFY,
    Protocol_GUILD_DUNGEON_SCORE_REQUEST,
    Protocol_GUILD_DUNGEON_SCORE_RESPONSE,
    Protocol_GUILD_UNITY_RANKING_LIST_REQUEST,
    Protocol_GUILD_UNITY_RANKING_LIST_RESPONSE,
    Protocol_DB_GUILD_CREATE_REQUEST,
    Protocol_DB_GUILD_CREATE_RESPONSE,
    Protocol_DB_GUILD_DESTROY_REQUEST,
    Protocol_DB_GUILD_DESTROY_RESPONSE,
    Protocol_DB_GUILD_ATTEND_REQUEST,
    Protocol_DB_GUILD_ATTEND_RESPONSE,
    Protocol_DB_GUILD_DONATE_REQUEST,
    Protocol_DB_GUILD_DONATE_RESPONSE,
    Protocol_DB_GUILD_CHANGE_CREST_REQUEST,
    Protocol_DB_GUILD_CHANGE_CREST_RESPONSE,
    Protocol_DB_GUILD_ATTEND_RESET_REQUEST,
    Protocol_DB_GUILD_ATTEND_RESET_RESPONSE,
    Protocol_DB_GUILD_CHANGE_NAME_REQUEST,
    Protocol_DB_GUILD_CHANGE_NAME_RESPONSE,
    Protocol_SEASON_CURRENT_INFO_REQUEST,
    Protocol_SEASON_CURRENT_INFO_RESPONSE,
    Protocol_SEASON_REWARD_INFO_REQUEST,
    Protocol_SEASON_REWARD_INFO_RESPONSE,
    Protocol_SEASON_DUNGEON_INFO_REQUEST,
    Protocol_SEASON_DUNGEON_INFO_RESPONSE,
    Protocol_AGENT_PC_MOVE_SERVER_REQUEST,
    Protocol_RVR_BATTLE_FIELD_REMAIN_TIME_REQUEST,
    Protocol_RVR_BATTLE_FIELD_REMAIN_TIME_RESPONSE,
    Protocol_RVR_BATTLE_FIELD_INFO_REQUEST,
    Protocol_RVR_BATTLE_FIELD_INFO_RESPONSE,
    Protocol_RVR_BATTLE_FIELD_ALL_INFOS_REQUEST,
    Protocol_RVR_BATTLE_FIELD_ALL_INFOS_RESPONSE,
    Protocol_RVR_PASS_BATTLE_FIELD_CAHNNEL_INFO_SYNC_NOTIFY,
    Protocol_RVR_RELAY_BATTLE_FIELD_CAHNNEL_INFO_SYNC_NOTIFY,
    Protocol_RVR_PASS_BATTLE_FIELD_CHANNEL_INFO_NOTIFY,
    Protocol_RVR_RELAY_BATTLE_FIELD_CHANNEL_INFO_NOTIFY,
    Protocol_RVR_PASS_BATTLE_FIELD_PLAYER_COUNT_INFO_NOTIFY,
    Protocol_RVR_RELAY_BATTLE_FIELD_PLAYER_COUNT_INFO_NOTIFY,
    Protocol_RVR_BATTLE_FIELD_EVENT_START_NOTIFY,
    Protocol_RVR_BATTLE_FIELD_EVENT_END_NOTIFY,
    Protocol_RVR_BATTLE_FIELD_CLOSE_NOTIFY,
    Protocol_RVR_BATTLE_FILED_TIME_INFO_NOTIFY,
    Protocol_RVR_BATTLE_FILED_TIME_INFO_REQUEST,
    Protocol_RVR_BATTLE_FILED_TIME_INFO_RESPONSE,
    Protocol_RVR_BATTLE_FILED_TIME_EXPIRED_NOTIFY,
    Protocol_RVR_BATTLE_FILED_FREE_TIME_EXPIRED_NOTIFY,
    Protocol_RVR_BATTLE_FILED_REMAIN_TIME_NOTIFY,
    Protocol_RVR_BATTLE_FILED_PK_NOTIFY,
    Protocol_RVR_BATTLE_FIELD_SHORT_TERM_MAX_NOTIFY,
    Protocol_RVR_BATTLE_FIELD_OTHER_PC_SHORT_TERM_MAX_NOTIFY,
    Protocol_RVR_STANDBY_ORDER_REQUEST,
    Protocol_RVR_STANDBY_ORDER_RESPONSE,
    Protocol_RVR_JOIN_REQUEST,
    Protocol_RVR_JOIN_RESPONSE,
    Protocol_RVR_RESERVATION_REQUEST,
    Protocol_RVR_RESERVATION_RESPONSE,
    Protocol_RVR_CANCEL_REQUEST,
    Protocol_RVR_CANCEL_RESPONSE,
    Protocol_RVR_LEAVE_BATTLE_SERVER_REQUEST,
    Protocol_RVR_LEAVE_BATTLE_SERVER_RESPONSE,
    Protocol_RVR_RESERVATION_STATE_NOTIFY,
    Protocol_RVR_PASS_CHECK_STANDBY_ORDER_REQUEST,
    Protocol_RVR_RELAY_CHECK_STANDBY_ORDER_REQUEST,
    Protocol_RVR_PASS_CHECK_STANDBY_ORDER_RESPONSE,
    Protocol_RVR_RELAY_CHECK_STANDBY_ORDER_RESPONSE,
    Protocol_RVR_PERMISSION_TO_JOIN_PASS_REQUEST,
    Protocol_RVR_PERMISSION_TO_JOIN_RELAY_REQUEST,
    Protocol_RVR_PERMISSION_TO_JOIN_PASS_RESPONSE,
    Protocol_RVR_PERMISSION_TO_JOIN_RELAY_RESPONSE,
    Protocol_RVR_CANCEL_TO_JOIN_PASS_REQUEST,
    Protocol_RVR_CANCEL_TO_JOIN_RELAY_REQUEST,
    Protocol_RVR_CANCEL_TO_JOIN_PASS_RESPONSE,
    Protocol_RVR_CANCEL_TO_JOIN_RELAY_RESPONSE,
    Protocol_RVR_ASK_TO_STANDBY_PASS_REQUEST,
    Protocol_RVR_ASK_TO_STANDBY_RELAY_REQUEST,
    Protocol_RVR_ASK_TO_STANDBY_PASS_RESPONSE,
    Protocol_RVR_ASK_TO_STANDBY_RELAY_RESPONSE,
    Protocol_RVR_CONNECTED_GAME_SERVER_NOTIFY,
    Protocol_RVR_CONNECTED_BATTLE_SERVER_NOTIFY,
    Protocol_RVR_DISCONNECTED_BATTLE_SERVER_NOTIFY,
    Protocol_RVR_QA_COMMAND_PASS_NOTIFY,
    Protocol_RVR_QA_COMMAND_RELAY_NOTIFY,
    Protocol_RVR_MOVE_CLIENT_QUEST_LOC_REQUEST,
    Protocol_RVR_MOVE_CLIENT_QUEST_LOC_RESPONSE,
    Protocol_RVR_MOVE_BASE_CAMP_REQUEST,
    Protocol_RVR_MOVE_BASE_CAMP_RESPONSE,
    Protocol_RVR_MAIN_HUD_INFO_NOTIFY,
    Protocol_RVR_EVENT_TOTAL_REWARD_NOTIFY,
    Protocol_RVR_MAIN_HUD_POINT_INFO_NOTIFY,
    Protocol_RVR_OCCUPYING_GAUGE_APPROXIMATE_INFO_NOTIFY,
    Protocol_RVR_OCCUPYING_GAUGE_INFO_NOTIFY,
    Protocol_BUDDY_AG_SEND_INVITATION_NOTIFY,
    Protocol_BUDDY_AG_RECEIVE_INVITATION_NOTIFY,
    Protocol_BUDDY_AG_ACCEPT_RECEIVE_INVITATION_NOTIFY,
    Protocol_BUDDY_AG_ACCEPTED_SEND_INVITATION_NOTIFY,
    Protocol_BUDDY_AG_REJECT_RECEIVE_INVITATION_NOTIFY,
    Protocol_BUDDY_AG_REJECTED_SEND_INVITATION_NOTIFY,
    Protocol_BUDDY_AG_DELETE_BUDDY_NOTIFY,
    Protocol_BUDDY_AG_DELETED_BUDDY_NOTIFY,
    Protocol_BUDDY_DATA_ALL_NOTIFY,
    Protocol_BUDDY_SEND_INVITATION_REQUEST,
    Protocol_BUDDY_SEND_INVITATION_RESPONSE,
    Protocol_BUDDY_ACCEPT_INVITATION_REQUEST,
    Protocol_BUDDY_ACCEPT_INVITATION_RESPONSE,
    Protocol_BUDDY_REJECT_INVITATION_REQUEST,
    Protocol_BUDDY_REJECT_INVITATION_RESPONSE,
    Protocol_BUDDY_DELETE_REQUEST,
    Protocol_BUDDY_DELETE_RESPONSE,
    Protocol_BUDDY_RECEIVE_INVITATION_NOTIFY,
    Protocol_BUDDY_ADDED_NOTIFY,
    Protocol_BUDDY_DELETED_NOTIFY,
    Protocol_BUDDY_SEND_INVITATION_REJECTED_NOTIFY,
    Protocol_BUDDY_SEARCH_REQUEST,
    Protocol_BUDDY_SEARCH_RESPONSE,
    Protocol_BUDDY_RECOMMEND_REQUEST,
    Protocol_BUDDY_RECOMMEND_RESPONSE,
    Protocol_BUDDY_DETAIL_INFO_REQUEST,
    Protocol_BUDDY_REFRESH_REQUEST,
    Protocol_BUDDY_REFRESH_RESPONSE,
    Protocol_BUDDY_RECEIVE_INVIATION_REFRESH_REQUEST,
    Protocol_BUDDY_RECEIVE_INVIATION_REFRESH_RESPONSE,
    Protocol_SUMMON_REQUEST,
    Protocol_SUMMON_RESPONSE,
    Protocol_SUMMON_ACCEPT_REQUEST,
    Protocol_SUMMON_ACCEPT_RESPONSE,
    Protocol_SUMMON_RECEIVED_NOTIFY,
    Protocol_SUMMON_ACCEPTED_NOTIFY,
    Protocol_SUMMON_ABLE_STATE_NOTIFY,
    Protocol_MOVE_TO_PC_REQUEST,
    Protocol_MOVE_TO_PC_RESPONSE,
    Protocol_SHORT_TERM_REWARD_DATA_NOTIFY,
    Protocol_SHORT_TERM_REWARD_DATA_ALL_NOTIFY,
    Protocol_SHORT_TERM_REWARD_GIVE_REQUSET,
    Protocol_SHORT_TERM_REWARD_GIVE_RESPONSE,
    Protocol_SHORT_TERM_REWARD_DATA_ALL_REQUSET,
    Protocol_SHORT_TERM_REWARD_DATA_ALL_RESPONSE,
    Protocol_KILLER_DATA_NOTIFY,
    Protocol_KILLER_DATA_ALL_NOTIFY,
    Protocol_REFUND_REDIS_RECORD_ADDED_NOTIFY,
    Protocol_REFUND_REDIS_RECORD_DATA_REQUEST,
    Protocol_REFUND_REDIS_RECORD_DATA_RESPONSE,
    Protocol_REFUND_REDIS_RECORD_REMOVE_REQUEST,
    Protocol_REFUND_REDIS_RECORD_REMOVE_RESPONSE,
    Protocol_BATTLE_FIELD_COLLECTION_NOTIFY,
    Protocol_DB_BATTLE_FIELD_COLLECTION_UPDATE_REQUEST,
    Protocol_DB_BATTLE_FIELD_COLLECTION_UPDATE_RESPONSE,
    Protocol_PUSH_PROMOTION_REQUEST,
    Protocol_PUSH_PROMOTION_RESPONSE,
    Protocol_GROUP_MATCHING_MAKE_REQEUST,
    Protocol_GROUP_MATCHING_MAKE_RESPONSE,
    Protocol_GROUP_MATCHING_LEAVE_REQUEST,
    Protocol_GROUP_MATCHING_GUILD_MEMBER_LIST_REQUEST,
    Protocol_GROUP_MATCHING_GUILD_MEMBER_LIST_RESPONSE,
    Protocol_GROUP_MATCHING_BUDDY_LIST_REQUEST,
    Protocol_GROUP_MATCHING_BUDDY_LIST_RESPONSE,
    Protocol_GROUP_MATCHING_INVITE_REQUEST,
    Protocol_GROUP_MATCHING_INVITE_RESPONSE,
    Protocol_GROUP_MATCHING_MEMBER_LEAVE_NOTIFY,
    Protocol_GROUP_MATCHING_INVITATION_ACCEPTED_NOTIFY,
    Protocol_GROUP_MATCHING_INVITATION_REJECTED_NOTIFY,
    Protocol_GROUP_MATCHING_INVITATION_ADD_NOTIFY,
    Protocol_GROUP_MATCHING_INVITATION_REMOVE_NOTIFY,
    Protocol_GROUP_MATCHING_INVITE_ACCEPT_REQUEST,
    Protocol_GROUP_MATCHING_INVITE_ACCEPT_RESPONSE,
    Protocol_GROUP_MATCHING_INVITE_REJECT_REQUEST,
    Protocol_GROUP_MATCHING_INVITE_REJECT_RESPONSE,
    Protocol_GROUP_MATCHING_START_REQUEST,
    Protocol_GROUP_MATCHING_START_RESPONSE,
    Protocol_GROUP_MATCHING_CONVERT_TO_QUICK_REQUEST,
    Protocol_GROUP_MATCHING_CONVERT_TO_QUICK_RESPONSE,
    Protocol_GROUP_MATCHING_REMATCHING_REQUEST,
    Protocol_GROUP_MATCHING_REMATCHING_RESPONSE,
    Protocol_EQUIP_COSTUME_REQUEST,
    Protocol_EQUIP_COSTUME_RESPONSE,
    Protocol_UNEQUIP_COSTUME_REQUEST,
    Protocol_UNEQUIP_COSTUME_RESPONSE,
    Protocol_COSTUME_PRESET_CHANGE_REQUEST,
    Protocol_COSTUME_PRESET_CHANGE_RESPONSE,
    Protocol_COSTUME_PRESET_COSTUMESLOT_UPDATE_NOTIFY,
    Protocol_ENCHANT_COSTUME_REQUEST,
    Protocol_ENCHANT_COSTUME_RESPONSE,
    Protocol_UPGRADE_COSTUME_REQUEST,
    Protocol_UPGRADE_COSTUME_RESPONSE,
    Protocol_SHOW_COSTUME_REQUEST,
    Protocol_SHOW_COSTUME_RESPONSE,
    Protocol_HIDE_COSTUME_REQUEST,
    Protocol_HIDE_COSTUME_RESPONSE,
    Protocol_INHERIT_COSTUME_REQUEST,
    Protocol_INHERIT_COSTUME_RESPONSE,
    Protocol_LIVE_EVENT_STOP_NOTIFY,
    Protocol_LIVE_EVENT_DATA_UPDATE_NOTIFY,
    Protocol_LIVE_EVENT_TRADE_DATA_NOTIFY,
    Protocol_LIVE_EVENT_BUFF_DATA_NOTIFY,
    Protocol_LIVE_EVENT_ATTENTION_DATA_NOTIFY,
    Protocol_LIVE_EVENT_NEWBIE_ATTENTION_DATA_NOTIFY,
    Protocol_LIVE_EVENT_RETURN_ATTENTION_DATA_NOTIFY,
    Protocol_LIVE_EVENT_DIA_BUY_DATA_NOTIFY,
    Protocol_LIVE_EVENT_DIA_SPENT_DATA_NOTIFY,
    Protocol_LIVE_EVENT_LIMIT_SELL_SHOP_DATA_NOTIFY,
    Protocol_LIVE_EVENT_LEVEL_BUFF_DATA_NOTIFY,
    Protocol_LIVE_EVENT_NEWBIE_BUFF_DATA_NOTIFY,
    Protocol_LIVE_EVENT_ITEM_DROP_DATA_NOTIFY,
    Protocol_LIVE_EVENT_LEVELUP_EVENT_DATA_NOTIFY,
    Protocol_LIVE_EVENT_LEVELUP_NEWBIE_DATA_NOTIFY,
    Protocol_LIVE_EVENT_LEVELUP_RETURN_DATA_NOTIFY,
    Protocol_LIVE_EVENT_TRADE_INSTANCE_NOTIFY,
    Protocol_LIVE_EVENT_TRADE_INSTANCE_EXPIRE_NOTIFY,
    Protocol_LIVE_EVENT_TRADE_PURCHASE_REQUEST,
    Protocol_LIVE_EVENT_TRADE_PURCHASE_RESPONSE,
    Protocol_LIVE_EVENT_DIA_BUY_NOTIFY,
    Protocol_LIVE_EVENT_DIA_BUY_MISSION_UPDATE_NOTIFY,
    Protocol_LIVE_EVENT_DIA_BUY_AMOUNT_UPDATE_NOTIFY,
    Protocol_LIVE_EVENT_DIA_BUY_REWARD_REQUEST,
    Protocol_LIVE_EVENT_DIA_BUY_REWARD_RESPONSE,
    Protocol_LIVE_EVENT_DIA_SPENT_NOTIFY,
    Protocol_LIVE_EVENT_DIA_SPENT_MISSION_UPDATE_NOTIFY,
    Protocol_LIVE_EVENT_DIA_SPENT_AMOUNT_UPDATE_NOTIFY,
    Protocol_LIVE_EVENT_DIA_SPENT_REWARD_REQUEST,
    Protocol_LIVE_EVENT_DIA_SPENT_REWARD_RESPONSE,
    Protocol_LIVE_EVENT_LIMIT_SELL_SHOP_INSTANCE_NOTIFY,
    Protocol_LIVE_EVENT_LIMIT_SELL_SHOP_INSTANCE_EXPIRE_NOTIFY,
    Protocol_LIVE_EVENT_LIMIT_SELL_SHOP_PURCHASE_REQUEST,
    Protocol_LIVE_EVENT_LIMIT_SELL_SHOP_PURCHASE_RESPONSE,
    Protocol_LIVE_EVENT_ATTENTION_NOTIFY,
    Protocol_LIVE_EVENT_ATTENTION_RECEIVE_NOTIFY,
    Protocol_LIVE_EVENT_ATTENTION_END_RECEIVE_NOTIFY,
    Protocol_LIVE_EVENT_ATTENTION_REWARD_RECEIVE_REQUEST,
    Protocol_LIVE_EVENT_ATTENTION_REWARD_RECEIVE_RESPONSE,
    Protocol_LIVE_EVENT_ATTENTION_RETURN_REWARD_RECEIVE_REQUEST,
    Protocol_LIVE_EVENT_ATTENTION_RETURN_REWARD_RECEIVE_RESPONSE,
    Protocol_LIVE_EVENT_ATTENTION_NEWBIE_REWARD_RECEIVE_REQUEST,
    Protocol_LIVE_EVENT_ATTENTION_NEWBIE_REWARD_RECEIVE_RESPONSE,
    Protocol_LIVE_EVENT_ATTENTION_END_REWARD_RECEIVE_REQUEST,
    Protocol_LIVE_EVENT_ATTENTION_END_REWARD_RECEIVE_RESPONSE,
    Protocol_LIVE_EVENT_ATTENTION_END_RETURN_REWARD_RECEIVE_REQUEST,
    Protocol_LIVE_EVENT_ATTENTION_END_RETURN_REWARD_RECEIVE_RESPONSE,
    Protocol_LIVE_EVENT_ATTENTION_END_NEWBIE_REWARD_RECEIVE_REQUEST,
    Protocol_LIVE_EVENT_ATTENTION_END_NEWBIE_REWARD_RECEIVE_RESPONSE,
    Protocol_LIVE_EVENT_BUFF_INFO_INSTANCE_NOTIFY,
    Protocol_LIVE_EVENT_LEVELUP_NOTIFY,
    Protocol_LIVE_EVENT_LEVELUP_RECEIVE_NOTIFY,
    Protocol_LIVE_EVENT_LEVELUP_REWARD_RECEIVE_REQUEST,
    Protocol_LIVE_EVENT_LEVELUP_REWARD_RECEIVE_RESPONSE,
    Protocol_STORAGE_SLOT_EXPANSION_REQUEST,
    Protocol_STORAGE_SLOT_EXPANSION_RESPONSE,
    Protocol_BRAWL_TIME_INFO_NOTIFY,
    Protocol_BRAWL_TIME_INFO_REQUEST,
    Protocol_BRAWL_TIME_INFO_RESPONSE,
    Protocol_BRAWL_TIME_EXPIRED_NOTIFY,
    Protocol_BRAWL_FREE_TIME_EXPIRED_NOTIFY,
    Protocol_BRAWL_REMAIN_TIME_NOTIFY,
    Protocol_BRAWL_SHORT_TERM_DATA_NOTIFY,
    Protocol_BRAWL_SHORT_TERM_REWARD_REQUEST,
    Protocol_BRAWL_SHORT_TERM_REWARD_RESPONSE,
    Protocol_BRAWL_SHORT_TERM_DATA_REQUEST,
    Protocol_BRAWL_SHORT_TERM_DATA_RESPONSE,
    Protocol_BRAWL_PK_NOTIFY,
    Protocol_BRAWL_SHORT_TERM_MAX_NOTIFY,
    Protocol_BRAWL_OTHER_PC_SHORT_TERM_MAX_NOTIFY,
    Protocol_BRAWL_POINT_NOTIFY,
    Protocol_BRAWL_ENHANCE_DATA_NOTIFY,
    Protocol_BRAWL_ENHANCE_LEVEL_UP_REQUEST,
    Protocol_BRAWL_ENHANCE_LEVEL_UP_RESPONSE,
    Protocol_ADD_ITEM_FAILED_NOT_ENOUGH_STORAGE_SPACE_NOTIFY,
    Protocol_SCROLL_QUEST_DAILY_INFO_NOTIFY,
    Protocol_SCROLL_QUEST_PROGRESS_INFO_NOTIFY,
    Protocol_SCROLL_QUEST_START_PROGRESS_REQUEST,
    Protocol_SCROLL_QUEST_START_PROGRESS_RESPONSE,
    Protocol_SCROLL_QUEST_GIVE_UP_REQUEST,
    Protocol_SCROLL_QUEST_GIVE_UP_RESPONSE,
    Protocol_SCROLL_QUEST_REWARD_REQUEST,
    Protocol_SCROLL_QUEST_REWARD_RESPONSE,
    Protocol_BRAWL_LAST_LEAVED_TIME_REQUEST,
    Protocol_BRAWL_LAST_LEAVED_TIME_RESPONSE,
    Protocol_BRAWL_LAST_LEAVED_TIME_NOTIFY,
    Protocol_PET_CREATED_WITH_EFFECT_NOTIFY,
    Protocol_PET_CREATED_NOTIFY,
    Protocol_PET_DELETED_NOTIFY,
    Protocol_PET_DATA_NOTIFY,
    Protocol_PET_FEED_REQUEST,
    Protocol_PET_FEED_RESPONSE,
    Protocol_PET_DIGESTION_COMPLETE_NOTIFY,
    Protocol_PET_SUMMON_REQUEST,
    Protocol_PET_SUMMON_RESPONSE,
    Protocol_PET_SUMMON_CANCEL_REQUEST,
    Protocol_PET_SUMMON_CANCEL_RESPONSE,
    Protocol_PET_SUPPORT_REQUEST,
    Protocol_PET_SUPPORT_RESPONSE,
    Protocol_PET_SUPPORT_CANCEL_REQUEST,
    Protocol_PET_SUPPORT_CANCEL_RESPONSE,
    Protocol_PET_REMAIN_DIGESTION_TIME_REQUEST,
    Protocol_PET_REMAIN_DIGESTION_TIME_RESPONSE,
    Protocol_PET_FUSION_REQUEST,
    Protocol_PET_FUSION_RESPONSE,
    Protocol_PET_LEVEL_EXP_UP_NOTIFY,
    Protocol_PET_TOGGLE_SAFE_GUARD_REQUEST,
    Protocol_PET_TOGGLE_SAFE_GUARD_RESPONSE,
    Protocol_PET_ALTAR_DATA_NOTIFY,
    Protocol_PET_ALTAR_LEVEL_EXP_NOTIFY,
    Protocol_PET_ALTAR_POINT_NOTIFY,
    Protocol_PET_ALTAR_DONATE_REQUEST,
    Protocol_PET_ALTAR_DONATE_RESPONSE,
    Protocol_PET_ALTAR_ACTIVE_SKILL_LEVEL_UP_REQUEST,
    Protocol_PET_ALTAR_ACTIVE_SKILL_LEVEL_UP_RESPONSE,
    Protocol_PET_HATCHERY_DATA_NOTIFY,
    Protocol_PET_HATCHERY_SPAWN_REQUEST,
    Protocol_PET_HATCHERY_SPAWN_RESPONSE,
    Protocol_PET_HATCHERY_HATCH_REQUEST,
    Protocol_PET_HATCHERY_HATCH_RESPONSE,
    Protocol_DB_PET_MAKE_REQUEST,
    Protocol_DB_PET_MAKE_RESPONSE,
    Protocol_DB_PET_FEED_REQUEST,
    Protocol_DB_PET_FEED_RESPONSE,
    Protocol_DB_PET_FUSION_REQUEST,
    Protocol_DB_PET_FUSION_RESPONSE,
    Protocol_DB_PET_SET_STATE_REQUEST,
    Protocol_DB_PET_SET_STATE_RESPONSE,
    Protocol_DB_PET_LEVEL_UP_REQUEST,
    Protocol_DB_PET_LEVEL_UP_RESPONSE,
    Protocol_DB_PET_TOGGLE_SAFE_GUARD_REQUEST,
    Protocol_DB_PET_TOGGLE_SAFE_GUARD_RESPONSE,
    Protocol_DB_PET_ALTAR_DONATE_REQUEST,
    Protocol_DB_PET_ALTAR_DONATE_RESPONSE,
    Protocol_DB_PET_ALTAR_ACTIVE_SKILL_LEVEL_UP_REQUEST,
    Protocol_DB_PET_ALTAR_ACTIVE_SKILL_LEVEL_UP_RESPONSE,
    Protocol_DB_PET_HATCHERY_SUMMON_REQUEST,
    Protocol_DB_PET_HATCHERY_SUMMON_RESPONSE,
    Protocol_DB_PET_HATCHERY_HATCH_REQUEST,
    Protocol_DB_PET_HATCHERY_HATCH_RESPONSE,
    Protocol_DB_PET_SET_REQUEST,
    Protocol_DB_PET_SET_RESPONSE,
    Protocol_DB_PET_DELETE_REQUEST,
    Protocol_DB_PET_DELETE_RESPONSE,
    Protocol_DB_PET_ALTAR_SET_REQUEST,
    Protocol_DB_PET_ALTAR_SET_RESPONSE,
    Protocol_CONFLICT_FIELD_MOVE_HOME_SERVER_REQUEST,
    Protocol_CONFLICT_FIELD_MOVE_HOME_SERVER_RESPONSE,
    Protocol_KINGSROAD_QUERY_MAINSTREAM_QUEST_REQUEST,
    Protocol_KINGSROAD_QUERY_MAINSTREAM_QUEST_RESPONSE,
    Protocol_PUBLIC_KEY_NOTIFY,
    Protocol_CRYPT_KEY_NOTIFY,
    Protocol_MAX
  };
  return values;
}

inline const char *EnumNameProtocol(Protocol e) {
  switch (e) {
    case Protocol_START: return "START";
    case Protocol_PING_NOTIFY: return "PING_NOTIFY";
    case Protocol_KEEP_ALIVE_NOTIFY: return "KEEP_ALIVE_NOTIFY";
    case Protocol_GAME_AGENT_REGISTER_REQUEST: return "GAME_AGENT_REGISTER_REQUEST";
    case Protocol_GAME_AGENT_REGISTER_RESPONSE: return "GAME_AGENT_REGISTER_RESPONSE";
    case Protocol_GAME_AGENT_LOGINED_USER_LIST_NOTIFY: return "GAME_AGENT_LOGINED_USER_LIST_NOTIFY";
    case Protocol_GAME_AGENT_CHANGE_MAX_USER_COUNT_NOTIFY: return "GAME_AGENT_CHANGE_MAX_USER_COUNT_NOTIFY";
    case Protocol_GAME_AGENT_INFO_NOTIFY: return "GAME_AGENT_INFO_NOTIFY";
    case Protocol_CHECK_ACCOUNT_AUTH_REQUEST: return "CHECK_ACCOUNT_AUTH_REQUEST";
    case Protocol_CHECK_ACCOUNT_AUTH_RESPONSE: return "CHECK_ACCOUNT_AUTH_RESPONSE";
    case Protocol_DB_UPDATE_REALM_NOTIFY: return "DB_UPDATE_REALM_NOTIFY";
    case Protocol_DB_UPDATE_PC_COUNT_NOTIFY: return "DB_UPDATE_PC_COUNT_NOTIFY";
    case Protocol_GAME_AGENT_LOGOUT_REQUEST: return "GAME_AGENT_LOGOUT_REQUEST";
    case Protocol_GAME_AGENT_PC_RENAME_NOTIFY: return "GAME_AGENT_PC_RENAME_NOTIFY";
    case Protocol_GAME_AGENT_SELECT_RESERVED_CHAR_REQUEST: return "GAME_AGENT_SELECT_RESERVED_CHAR_REQUEST";
    case Protocol_GAME_AGENT_SELECT_RESERVED_CHAR_RESPONSE: return "GAME_AGENT_SELECT_RESERVED_CHAR_RESPONSE";
    case Protocol_GAME_AGENT_GOTO_SERVER_LIST_REQUEST: return "GAME_AGENT_GOTO_SERVER_LIST_REQUEST";
    case Protocol_GAME_AGENT_GOTO_SERVER_LIST_RESPONSE: return "GAME_AGENT_GOTO_SERVER_LIST_RESPONSE";
    case Protocol_GAME_AGENT_UPDATE_PLAYER_INFO_REQUEST: return "GAME_AGENT_UPDATE_PLAYER_INFO_REQUEST";
    case Protocol_GAME_AGENT_CHARACTER_CREATION: return "GAME_AGENT_CHARACTER_CREATION";
    case Protocol_GAME_AGENT_NAME_CHECK_REQUEST: return "GAME_AGENT_NAME_CHECK_REQUEST";
    case Protocol_GAME_AGENT_NAME_CHECK_RESPONSE: return "GAME_AGENT_NAME_CHECK_RESPONSE";
    case Protocol_ACCOUNT_CACHE_EXPIRATION_RESERVE_REQUEST: return "ACCOUNT_CACHE_EXPIRATION_RESERVE_REQUEST";
    case Protocol_GAME_AGENT_HIVE_TOP_PC_INFO_REQUEST: return "GAME_AGENT_HIVE_TOP_PC_INFO_REQUEST";
    case Protocol_GAME_AGENT_HIVE_TOP_PC_INFO_RESPONSE: return "GAME_AGENT_HIVE_TOP_PC_INFO_RESPONSE";
    case Protocol_GAME_AGENT_PLAYER_DELETE_NOTIFY: return "GAME_AGENT_PLAYER_DELETE_NOTIFY";
    case Protocol_GAME_AGENT_PLAYER_CANCEL_DELETE_NOTIFY: return "GAME_AGENT_PLAYER_CANCEL_DELETE_NOTIFY";
    case Protocol_GAME_AGENT_GIFTEVENT_MODIFY_NOTIFY: return "GAME_AGENT_GIFTEVENT_MODIFY_NOTIFY";
    case Protocol_GAME_AGENT_NOTICE_NOTIFY: return "GAME_AGENT_NOTICE_NOTIFY";
    case Protocol_GAME_AGENT_ALL_KICK_NOTIFY: return "GAME_AGENT_ALL_KICK_NOTIFY";
    case Protocol_GAME_AGENT_MAINTENANCE_NOTIFY: return "GAME_AGENT_MAINTENANCE_NOTIFY";
    case Protocol_GAME_AGENT_UPDATE_GAME_LANGUAGE_REQUEST: return "GAME_AGENT_UPDATE_GAME_LANGUAGE_REQUEST";
    case Protocol_AUTH_AGENT_SERVER_REGISTER_REQUEST: return "AUTH_AGENT_SERVER_REGISTER_REQUEST";
    case Protocol_AUTH_AGENT_SERVER_REGISTER_RESPONSE: return "AUTH_AGENT_SERVER_REGISTER_RESPONSE";
    case Protocol_AUTH_AGENT_AUTH_REQUEST: return "AUTH_AGENT_AUTH_REQUEST";
    case Protocol_AUTH_AGENT_AUTH_RESPONSE: return "AUTH_AGENT_AUTH_RESPONSE";
    case Protocol_AUTH_AGENT_LOGOUT_REQUEST: return "AUTH_AGENT_LOGOUT_REQUEST";
    case Protocol_AUTH_AGENT_APKHASH_UPDATE_NOTIFY: return "AUTH_AGENT_APKHASH_UPDATE_NOTIFY";
    case Protocol_AUTH_AGENT_AUTH_TICKET_REQUEST: return "AUTH_AGENT_AUTH_TICKET_REQUEST";
    case Protocol_AUTH_AGENT_AUTH_TICKET_RESPONSE: return "AUTH_AGENT_AUTH_TICKET_RESPONSE";
    case Protocol_AUTH_AGENT_SELECT_RESERVED_NICK_NAME_REQUEST: return "AUTH_AGENT_SELECT_RESERVED_NICK_NAME_REQUEST";
    case Protocol_AUTH_AGENT_SELECT_RESERVED_NICK_NAME_RESPONSE: return "AUTH_AGENT_SELECT_RESERVED_NICK_NAME_RESPONSE";
    case Protocol_AUTH_AGENT_HIVE_TOP_PC_INFO_REQUEST: return "AUTH_AGENT_HIVE_TOP_PC_INFO_REQUEST";
    case Protocol_AUTH_AGENT_HIVE_TOP_PC_INFO_RESPONSE: return "AUTH_AGENT_HIVE_TOP_PC_INFO_RESPONSE";
    case Protocol_AUTH_AGENT_BAN_COUNTRY_REGIST_NOTIFY: return "AUTH_AGENT_BAN_COUNTRY_REGIST_NOTIFY";
    case Protocol_AUTH_AGENT_BAN_COUNTRY_UNREGIST_NOTIFY: return "AUTH_AGENT_BAN_COUNTRY_UNREGIST_NOTIFY";
    case Protocol_CHECK_CLIENT_VERSION_REQUEST: return "CHECK_CLIENT_VERSION_REQUEST";
    case Protocol_CHECK_CLIENT_VERSION_RESPONSE: return "CHECK_CLIENT_VERSION_RESPONSE";
    case Protocol_ACCOUNT_AUTH_REQUEST: return "ACCOUNT_AUTH_REQUEST";
    case Protocol_ACCOUNT_AUTH_RESPONSE: return "ACCOUNT_AUTH_RESPONSE";
    case Protocol_ACCOUNT_AUTH_AGENT_TICKET_REQUEST: return "ACCOUNT_AUTH_AGENT_TICKET_REQUEST";
    case Protocol_COLONY_LIST_REQUEST: return "COLONY_LIST_REQUEST";
    case Protocol_COLONY_LIST_RESPONSE: return "COLONY_LIST_RESPONSE";
    case Protocol_CHARACTER_LIST_REQUEST: return "CHARACTER_LIST_REQUEST";
    case Protocol_CHARACTER_LIST_RESPONSE: return "CHARACTER_LIST_RESPONSE";
    case Protocol_HIVE_AUTH_REQUEST: return "HIVE_AUTH_REQUEST";
    case Protocol_HIVE_AUTH_RESPONSE: return "HIVE_AUTH_RESPONSE";
    case Protocol_SELECT_COLONY_REQUEST: return "SELECT_COLONY_REQUEST";
    case Protocol_SELECT_COLONY_RESPONSE: return "SELECT_COLONY_RESPONSE";
    case Protocol_SELECT_REALM_REQUEST: return "SELECT_REALM_REQUEST";
    case Protocol_SELECT_REALM_RESPONSE: return "SELECT_REALM_RESPONSE";
    case Protocol_SELECT_REALM_BOT_RESPONSE: return "SELECT_REALM_BOT_RESPONSE";
    case Protocol_SELECT_COLONY_BOT_REQUEST: return "SELECT_COLONY_BOT_REQUEST";
    case Protocol_COLONY_WAITING_NOTIFY: return "COLONY_WAITING_NOTIFY";
    case Protocol_INQUIRE_WAITING_REQUEST: return "INQUIRE_WAITING_REQUEST";
    case Protocol_INQUIRE_WAITING_RESPONSE: return "INQUIRE_WAITING_RESPONSE";
    case Protocol_CANCEL_WAITING_REQUEST: return "CANCEL_WAITING_REQUEST";
    case Protocol_CANCEL_WAITING_RESPONSE: return "CANCEL_WAITING_RESPONSE";
    case Protocol_FIND_RESERVED_NICK_NAME_REQUEST: return "FIND_RESERVED_NICK_NAME_REQUEST";
    case Protocol_FIND_RESERVED_NICK_NAME_RESPONSE: return "FIND_RESERVED_NICK_NAME_RESPONSE";
    case Protocol_SELECT_RESERVED_NICK_NAME_REQUSET: return "SELECT_RESERVED_NICK_NAME_REQUSET";
    case Protocol_SELECT_RESERVED_NICK_NAME_RESPONSE: return "SELECT_RESERVED_NICK_NAME_RESPONSE";
    case Protocol_FIND_RESERVED_CHAR_REQUEST: return "FIND_RESERVED_CHAR_REQUEST";
    case Protocol_FIND_RESERVED_CHAR_RESPONSE: return "FIND_RESERVED_CHAR_RESPONSE";
    case Protocol_SELECT_RESERVED_CHAR_REQUEST: return "SELECT_RESERVED_CHAR_REQUEST";
    case Protocol_SELECT_RESERVED_CHAR_RESPONSE: return "SELECT_RESERVED_CHAR_RESPONSE";
    case Protocol_SHOP_EVENT_DATA_UPDATE_NOTIFY: return "SHOP_EVENT_DATA_UPDATE_NOTIFY";
    case Protocol_STRING_MESSAGE_NOTIFY: return "STRING_MESSAGE_NOTIFY";
    case Protocol_USER_KICK_NOTIFY: return "USER_KICK_NOTIFY";
    case Protocol_CONTENT_CONFIG_UPDATE_NOFITY: return "CONTENT_CONFIG_UPDATE_NOFITY";
    case Protocol_ACCOUNT_LOGIN_REQUEST: return "ACCOUNT_LOGIN_REQUEST";
    case Protocol_ACCOUNT_LOGIN_RESPONSE: return "ACCOUNT_LOGIN_RESPONSE";
    case Protocol_SERVER_LOCAL_TIME_NOTIFY: return "SERVER_LOCAL_TIME_NOTIFY";
    case Protocol_DEVICE_PERFORMANCE_POINT_NOTIFY: return "DEVICE_PERFORMANCE_POINT_NOTIFY";
    case Protocol_SEASON_INFO_NOTIFY: return "SEASON_INFO_NOTIFY";
    case Protocol_SERVER_LOCAL_TIME_REQUEST: return "SERVER_LOCAL_TIME_REQUEST";
    case Protocol_SERVER_LOCAL_TIME_RESPONSE: return "SERVER_LOCAL_TIME_RESPONSE";
    case Protocol_SLOT_LIST_REQUEST: return "SLOT_LIST_REQUEST";
    case Protocol_SLOT_LIST_RESPONSE: return "SLOT_LIST_RESPONSE";
    case Protocol_PC_TUTORIAL_SKIP_REQUEST: return "PC_TUTORIAL_SKIP_REQUEST";
    case Protocol_PC_TUTORIAL_SKIP_RESPONSE: return "PC_TUTORIAL_SKIP_RESPONSE";
    case Protocol_PC_LOGIN_REQUEST: return "PC_LOGIN_REQUEST";
    case Protocol_PC_LOGIN_RESPONSE: return "PC_LOGIN_RESPONSE";
    case Protocol_PC_CREATION_REQUEST: return "PC_CREATION_REQUEST";
    case Protocol_PC_CREATION_RESPONSE: return "PC_CREATION_RESPONSE";
    case Protocol_PC_CHECK_NEW_NAME_REQUEST: return "PC_CHECK_NEW_NAME_REQUEST";
    case Protocol_PC_CHECK_NEW_NAME_RESPONSE: return "PC_CHECK_NEW_NAME_RESPONSE";
    case Protocol_PC_RENAME_REQUEST: return "PC_RENAME_REQUEST";
    case Protocol_PC_RENAME_RESPONSE: return "PC_RENAME_RESPONSE";
    case Protocol_PC_DELETE_REQUEST: return "PC_DELETE_REQUEST";
    case Protocol_PC_DELETE_RESPONSE: return "PC_DELETE_RESPONSE";
    case Protocol_PC_CANCEL_DELETE_REQUEST: return "PC_CANCEL_DELETE_REQUEST";
    case Protocol_PC_CANCEL_DELETE_RESPONSE: return "PC_CANCEL_DELETE_RESPONSE";
    case Protocol_PC_GOTO_LOBBY_REQUEST: return "PC_GOTO_LOBBY_REQUEST";
    case Protocol_PC_GOTO_LOBBY_RESPONSE: return "PC_GOTO_LOBBY_RESPONSE";
    case Protocol_ACCOUNT_LOGOUT_REQUEST: return "ACCOUNT_LOGOUT_REQUEST";
    case Protocol_ACCOUNT_LOGOUT_RESPONSE: return "ACCOUNT_LOGOUT_RESPONSE";
    case Protocol_GOTO_SERVER_LIST_REQUEST: return "GOTO_SERVER_LIST_REQUEST";
    case Protocol_GOTO_SERVER_LIST_RESPONSE: return "GOTO_SERVER_LIST_RESPONSE";
    case Protocol_ACCOUNT_RECONNECT_REQUEST: return "ACCOUNT_RECONNECT_REQUEST";
    case Protocol_ACCOUNT_RECONNECT_RESPONSE: return "ACCOUNT_RECONNECT_RESPONSE";
    case Protocol_HIVE_TOP_PC_INFO_REQUEST: return "HIVE_TOP_PC_INFO_REQUEST";
    case Protocol_HIVE_TOP_PC_INFO_RESPONSE: return "HIVE_TOP_PC_INFO_RESPONSE";
    case Protocol_HIVE_COMPANION_COUNT_REQUEST: return "HIVE_COMPANION_COUNT_REQUEST";
    case Protocol_HIVE_COMPANION_COUNT_RESPONSE: return "HIVE_COMPANION_COUNT_RESPONSE";
    case Protocol_HIVE_SHOP_PURCHASE_PRODUCT_NOTIFY: return "HIVE_SHOP_PURCHASE_PRODUCT_NOTIFY";
    case Protocol_DELAY_PING_NOTIFY: return "DELAY_PING_NOTIFY";
    case Protocol_BYPASS_FROM_CLIENT_NOTIFY: return "BYPASS_FROM_CLIENT_NOTIFY";
    case Protocol_BYPASS_TO_CLIENT_NOTIFY: return "BYPASS_TO_CLIENT_NOTIFY";
    case Protocol_BYPASS_BROADCAST_TO_CLIENT_NOTIFY: return "BYPASS_BROADCAST_TO_CLIENT_NOTIFY";
    case Protocol_GAME_SERVER_REGISTER_REQUEST: return "GAME_SERVER_REGISTER_REQUEST";
    case Protocol_GAME_SERVER_REGISTER_RESPONSE: return "GAME_SERVER_REGISTER_RESPONSE";
    case Protocol_PC_ENTER_WORLD_READY_REQUEST: return "PC_ENTER_WORLD_READY_REQUEST";
    case Protocol_PC_ENTER_WORLD_READY_RESPONSE: return "PC_ENTER_WORLD_READY_RESPONSE";
    case Protocol_PC_START_NOTIFY: return "PC_START_NOTIFY";
    case Protocol_PC_LEAVE_WORLD_REQUEST: return "PC_LEAVE_WORLD_REQUEST";
    case Protocol_PC_LEAVE_WORLD_RESPONSE: return "PC_LEAVE_WORLD_RESPONSE";
    case Protocol_PC_TRY_TO_LEAVE_WORLD_NOTIFY: return "PC_TRY_TO_LEAVE_WORLD_NOTIFY";
    case Protocol_PC_DISCONNECT_NOTIFY: return "PC_DISCONNECT_NOTIFY";
    case Protocol_PC_RECONNECT_REQUEST: return "PC_RECONNECT_REQUEST";
    case Protocol_SERVER_GUILD_REQUEST: return "SERVER_GUILD_REQUEST";
    case Protocol_SERVER_GUILD_DATA_LOAD: return "SERVER_GUILD_DATA_LOAD";
    case Protocol_SERVER_GUILD_MEMBER_LOAD: return "SERVER_GUILD_MEMBER_LOAD";
    case Protocol_SERVER_GUILD_RESPONSE: return "SERVER_GUILD_RESPONSE";
    case Protocol_SERVER_GUILD_CREATE: return "SERVER_GUILD_CREATE";
    case Protocol_SERVER_GUILD_DESTROY: return "SERVER_GUILD_DESTROY";
    case Protocol_SERVER_GUILD_DATA_UPDATE: return "SERVER_GUILD_DATA_UPDATE";
    case Protocol_SERVER_GUILD_MEMBER_ADD: return "SERVER_GUILD_MEMBER_ADD";
    case Protocol_SERVER_GUILD_MEMBER_REMOVE: return "SERVER_GUILD_MEMBER_REMOVE";
    case Protocol_SERVER_GUILD_MEMBER_UPDATE: return "SERVER_GUILD_MEMBER_UPDATE";
    case Protocol_SERVER_GUILD_BUFF_ADD: return "SERVER_GUILD_BUFF_ADD";
    case Protocol_SERVER_GUILD_BUFF_REMOVE: return "SERVER_GUILD_BUFF_REMOVE";
    case Protocol_SERVER_GUILD_LEADER_GUILD_UPDATE: return "SERVER_GUILD_LEADER_GUILD_UPDATE";
    case Protocol_SERVER_GUILD_APPLICANT_UPDATE: return "SERVER_GUILD_APPLICANT_UPDATE";
    case Protocol_SERVER_SEASON_INFO_UPDATE: return "SERVER_SEASON_INFO_UPDATE";
    case Protocol_SERVER_SEASON_RESET_REQUEST: return "SERVER_SEASON_RESET_REQUEST";
    case Protocol_SERVER_SEASON_RESET_RESPONSE: return "SERVER_SEASON_RESET_RESPONSE";
    case Protocol_PC_NEW_MAIL_NOTIFY: return "PC_NEW_MAIL_NOTIFY";
    case Protocol_PC_SHOP_PURCHASE_PRODUCT_REQUEST: return "PC_SHOP_PURCHASE_PRODUCT_REQUEST";
    case Protocol_PC_LEAVED_BRAWL_NOTIFY: return "PC_LEAVED_BRAWL_NOTIFY";
    case Protocol_NOTICE_NOTIFY: return "NOTICE_NOTIFY";
    case Protocol_CLIENT_DEBUG_MESSAGE_NOTIFY: return "CLIENT_DEBUG_MESSAGE_NOTIFY";
    case Protocol_SMAP_CHANNEL_LIST_REQUEST: return "SMAP_CHANNEL_LIST_REQUEST";
    case Protocol_SMAP_CHANNEL_LIST_RESPONSE: return "SMAP_CHANNEL_LIST_RESPONSE";
    case Protocol_SMAP_CHANNEL_MOVE_REQUEST: return "SMAP_CHANNEL_MOVE_REQUEST";
    case Protocol_SMAP_CHANNEL_MOVE_RESPONSE: return "SMAP_CHANNEL_MOVE_RESPONSE";
    case Protocol_JOIN_EVENTSET_CHANNEL_REQUEST: return "JOIN_EVENTSET_CHANNEL_REQUEST";
    case Protocol_JOIN_EVENTSET_CHANNEL_RESPONSE: return "JOIN_EVENTSET_CHANNEL_RESPONSE";
    case Protocol_ADMIN_COMMAND_NOTIFY: return "ADMIN_COMMAND_NOTIFY";
    case Protocol_SYSTEM_DEBUG_MESSAGE_NOTIFY: return "SYSTEM_DEBUG_MESSAGE_NOTIFY";
    case Protocol_PC_SPAWN_COMPLETE_NOTIFY: return "PC_SPAWN_COMPLETE_NOTIFY";
    case Protocol_UPC_SPAWN_COMPLETE_NOTIFY: return "UPC_SPAWN_COMPLETE_NOTIFY";
    case Protocol_BOT_ADMIN_COMMAND_NOTIFY: return "BOT_ADMIN_COMMAND_NOTIFY";
    case Protocol_TELEPORT_NOTIFY_OTHER_PC_IN_VIEW: return "TELEPORT_NOTIFY_OTHER_PC_IN_VIEW";
    case Protocol_TELEPORT_REQUEST: return "TELEPORT_REQUEST";
    case Protocol_TELEPORT_RESPONSE: return "TELEPORT_RESPONSE";
    case Protocol_ENTER_EVENT_AREA_REQUEST: return "ENTER_EVENT_AREA_REQUEST";
    case Protocol_ENTER_EVENT_AREA_RESPONSE: return "ENTER_EVENT_AREA_RESPONSE";
    case Protocol_EVENT_MESSAGE_NOTIFY: return "EVENT_MESSAGE_NOTIFY";
    case Protocol_SAFE_ZONE_IN_REQUEST: return "SAFE_ZONE_IN_REQUEST";
    case Protocol_SAFE_ZONE_IN_RESPONSE: return "SAFE_ZONE_IN_RESPONSE";
    case Protocol_SAFE_ZONE_OUT_REQUEST: return "SAFE_ZONE_OUT_REQUEST";
    case Protocol_SAFE_ZONE_OUT_RESPONSE: return "SAFE_ZONE_OUT_RESPONSE";
    case Protocol_CLIENT_CREATURE_MOVE_NOTIFY: return "CLIENT_CREATURE_MOVE_NOTIFY";
    case Protocol_SERVER_CREATURE_MOVE_NOTIFY: return "SERVER_CREATURE_MOVE_NOTIFY";
    case Protocol_CLIENT_SHORT_TERM_MOVE_NOTIFY: return "CLIENT_SHORT_TERM_MOVE_NOTIFY";
    case Protocol_CLIENT_LONG_TERM_MOVE_NOTIFY: return "CLIENT_LONG_TERM_MOVE_NOTIFY";
    case Protocol_SERVER_SHORT_TERM_MOVE_NOTIFY: return "SERVER_SHORT_TERM_MOVE_NOTIFY";
    case Protocol_SERVER_LONG_TERM_MOVE_NOTIFY: return "SERVER_LONG_TERM_MOVE_NOTIFY";
    case Protocol_GAME_PING_REQUEST: return "GAME_PING_REQUEST";
    case Protocol_GAME_PING_RESPONSE: return "GAME_PING_RESPONSE";
    case Protocol_GAME_CONTENTS_CONFIG_NOTIFY: return "GAME_CONTENTS_CONFIG_NOTIFY";
    case Protocol_EVENT_DIRECTION_BEGIN_NOTIFY: return "EVENT_DIRECTION_BEGIN_NOTIFY";
    case Protocol_EVENT_DIRECTION_FINISH_NOTIFY: return "EVENT_DIRECTION_FINISH_NOTIFY";
    case Protocol_EVENT_BATTLE_REALM_CONTRIBUTION_NOTIFY: return "EVENT_BATTLE_REALM_CONTRIBUTION_NOTIFY";
    case Protocol_EVENT_BATTLE_REALM__END_NOTIFY: return "EVENT_BATTLE_REALM__END_NOTIFY";
    case Protocol_NOTIFY_EVENT_CONTRIBUTION: return "NOTIFY_EVENT_CONTRIBUTION";
    case Protocol_NOTIFY_EVENT_REWARD: return "NOTIFY_EVENT_REWARD";
    case Protocol_NOTIFY_EVENT_START: return "NOTIFY_EVENT_START";
    case Protocol_NOTIFY_EVENT_END: return "NOTIFY_EVENT_END";
    case Protocol_NOTIFY_NEXT_NORMAL_EVENTSET_INFO: return "NOTIFY_NEXT_NORMAL_EVENTSET_INFO";
    case Protocol_EVENT_DISAPPEAR_BARRIER_NOTIFY: return "EVENT_DISAPPEAR_BARRIER_NOTIFY";
    case Protocol_NOTIFY_EVENT_TOTAL_REWARD: return "NOTIFY_EVENT_TOTAL_REWARD";
    case Protocol_EVENT_SPEECH_BUBBLE_NOTIFY: return "EVENT_SPEECH_BUBBLE_NOTIFY";
    case Protocol_EVENT_CHANNEL_CLOSE_NOTIFY: return "EVENT_CHANNEL_CLOSE_NOTIFY";
    case Protocol_EVENT_GO_TOWN_REQUEST: return "EVENT_GO_TOWN_REQUEST";
    case Protocol_EVENT_GO_TOWN_RESPONSE: return "EVENT_GO_TOWN_RESPONSE";
    case Protocol_NOTIFY_EVENT_PHASE_START: return "NOTIFY_EVENT_PHASE_START";
    case Protocol_NOTIFY_EVENT_COUNTER_INFO: return "NOTIFY_EVENT_COUNTER_INFO";
    case Protocol_NOTIFY_EVENT_COUNTER_PROGRESS_INFO: return "NOTIFY_EVENT_COUNTER_PROGRESS_INFO";
    case Protocol_NOTIFY_EVENT_HIDDEN_CONTENTS_START: return "NOTIFY_EVENT_HIDDEN_CONTENTS_START";
    case Protocol_NOTIFY_EVENT_HIDDEN_CONTENTS_END: return "NOTIFY_EVENT_HIDDEN_CONTENTS_END";
    case Protocol_NOTIFY_EVENT_HIDDEN_GATHERING_COLLECTED: return "NOTIFY_EVENT_HIDDEN_GATHERING_COLLECTED";
    case Protocol_EVENT_OUT_OF_PLAY_NOTIFY: return "EVENT_OUT_OF_PLAY_NOTIFY";
    case Protocol_EVENT_MIDDLE_NOTIFY: return "EVENT_MIDDLE_NOTIFY";
    case Protocol_QUEST_REWARD_NOTIFY: return "QUEST_REWARD_NOTIFY";
    case Protocol_QUEST_RECEIVE_REWARD_REQUEST: return "QUEST_RECEIVE_REWARD_REQUEST";
    case Protocol_QUEST_RECEIVE_REWARD_RESPONSE: return "QUEST_RECEIVE_REWARD_RESPONSE";
    case Protocol_QUEST_CONTEXT_DATA_SET_NOTIFY: return "QUEST_CONTEXT_DATA_SET_NOTIFY";
    case Protocol_QUEST_CONTEXT_DATA_NOTIFY: return "QUEST_CONTEXT_DATA_NOTIFY";
    case Protocol_CHAPTER_JOIN_REQUEST: return "CHAPTER_JOIN_REQUEST";
    case Protocol_CHAPTER_JOIN_RESPONSE: return "CHAPTER_JOIN_RESPONSE";
    case Protocol_CHAPTER_DATA_NOTIFY: return "CHAPTER_DATA_NOTIFY";
    case Protocol_QUEST_BONUS_REWARD_REQUEST: return "QUEST_BONUS_REWARD_REQUEST";
    case Protocol_QUEST_BONUS_REWARD_RESPONSE: return "QUEST_BONUS_REWARD_RESPONSE";
    case Protocol_QUEST_BONUS_REWARD_NOTIFY: return "QUEST_BONUS_REWARD_NOTIFY";
    case Protocol_CHAPTER_NOTIFY: return "CHAPTER_NOTIFY";
    case Protocol_CHAPTER_CLEAR_SMAP_REQUEST: return "CHAPTER_CLEAR_SMAP_REQUEST";
    case Protocol_CHAPTER_CLEAR_SMAP_RESPONSE: return "CHAPTER_CLEAR_SMAP_RESPONSE";
    case Protocol_CHAPTER_JOIN_SMAP_REQUEST: return "CHAPTER_JOIN_SMAP_REQUEST";
    case Protocol_CHAPTER_JOIN_SMAP_RESPONSE: return "CHAPTER_JOIN_SMAP_RESPONSE";
    case Protocol_EXIT_INSTANCE_DUNGEON_REQUEST: return "EXIT_INSTANCE_DUNGEON_REQUEST";
    case Protocol_EXIT_INSTANCE_DUNGEON_RESPONSE: return "EXIT_INSTANCE_DUNGEON_RESPONSE";
    case Protocol_EVENT_MOVE_START_LOC_REQUEST: return "EVENT_MOVE_START_LOC_REQUEST";
    case Protocol_EVENT_MOVE_START_LOC_RESPONSE: return "EVENT_MOVE_START_LOC_RESPONSE";
    case Protocol_EVENT_RETURN_LAST_LOC_REQUEST: return "EVENT_RETURN_LAST_LOC_REQUEST";
    case Protocol_EVENT_RETURN_LAST_LOC_RESPONSE: return "EVENT_RETURN_LAST_LOC_RESPONSE";
    case Protocol_MAIN_STREAM_EVENT_JOIN_SWITCH_STATE_NOTIFY: return "MAIN_STREAM_EVENT_JOIN_SWITCH_STATE_NOTIFY";
    case Protocol_MAIN_STREAM_EVENT_JOIN_SWITCH_REQUEST: return "MAIN_STREAM_EVENT_JOIN_SWITCH_REQUEST";
    case Protocol_MAIN_STREAM_EVENT_JOIN_SWITCH_RESPONSE: return "MAIN_STREAM_EVENT_JOIN_SWITCH_RESPONSE";
    case Protocol_MAINSTREAM_STATE_NOTIFY: return "MAINSTREAM_STATE_NOTIFY";
    case Protocol_MAIN_STREAM_DATA_NOTIFY: return "MAIN_STREAM_DATA_NOTIFY";
    case Protocol_MAIN_STREAM_DATA_SET_NOTIFY: return "MAIN_STREAM_DATA_SET_NOTIFY";
    case Protocol_MAIN_STREAM_DIRECT_NOTIFY: return "MAIN_STREAM_DIRECT_NOTIFY";
    case Protocol_MAIN_STREAM_PRE_ACTION_REQUEST: return "MAIN_STREAM_PRE_ACTION_REQUEST";
    case Protocol_MAIN_STREAM_PRE_ACTION_RESPONSE: return "MAIN_STREAM_PRE_ACTION_RESPONSE";
    case Protocol_MAIN_STREAM_FINISHED_BACK_NOTIFY: return "MAIN_STREAM_FINISHED_BACK_NOTIFY";
    case Protocol_MAIN_STREAM_DO_BUTTON_ACTION_REQUEST: return "MAIN_STREAM_DO_BUTTON_ACTION_REQUEST";
    case Protocol_MAIN_STREAM_DO_BUTTON_ACTION_RESPONSE: return "MAIN_STREAM_DO_BUTTON_ACTION_RESPONSE";
    case Protocol_MAIN_STREAM_ON_REWARD_UI_NOTIFY: return "MAIN_STREAM_ON_REWARD_UI_NOTIFY";
    case Protocol_DAILY_HOMEWORK_DATA_ALL_NOTIFY: return "DAILY_HOMEWORK_DATA_ALL_NOTIFY";
    case Protocol_DAILY_HOMEWORK_DATA_UPDATE_NOTIFY: return "DAILY_HOMEWORK_DATA_UPDATE_NOTIFY";
    case Protocol_DAILY_HOMEWORK_RESERVED: return "DAILY_HOMEWORK_RESERVED";
    case Protocol_DAILY_HOMEWORK_GET_REWARD_REQUEST: return "DAILY_HOMEWORK_GET_REWARD_REQUEST";
    case Protocol_DAILY_HOMEWORK_GET_REWARD_RESPONSE: return "DAILY_HOMEWORK_GET_REWARD_RESPONSE";
    case Protocol_GOLD_DUNGEON_INFO_REQUEST: return "GOLD_DUNGEON_INFO_REQUEST";
    case Protocol_GOLD_DUNGEON_INFO_RESPONSE: return "GOLD_DUNGEON_INFO_RESPONSE";
    case Protocol_GOLD_DUNGEON_ENTER_FAILED: return "GOLD_DUNGEON_ENTER_FAILED";
    case Protocol_RECOMMEND_GET_PRAISER_REQUEST: return "RECOMMEND_GET_PRAISER_REQUEST";
    case Protocol_RECOMMEND_GET_PRAISER_RESPONSE: return "RECOMMEND_GET_PRAISER_RESPONSE";
    case Protocol_RECOMMEND_CHOICE_PRAISER_REQUEST: return "RECOMMEND_CHOICE_PRAISER_REQUEST";
    case Protocol_RECOMMEND_CHOICE_PRAISER_RESPOSE: return "RECOMMEND_CHOICE_PRAISER_RESPOSE";
    case Protocol_RECOMMEND_PRAISER_RESULT_NOTIFY: return "RECOMMEND_PRAISER_RESULT_NOTIFY";
    case Protocol_RECOMMEND_CHOICE_RESULT_NOTIFY: return "RECOMMEND_CHOICE_RESULT_NOTIFY";
    case Protocol_NPC_SCENEMAP_INFO_UPDATE_NOTIFY: return "NPC_SCENEMAP_INFO_UPDATE_NOTIFY";
    case Protocol_NPC_SCENEMAP_INFO_DESTROY_NOTIFY: return "NPC_SCENEMAP_INFO_DESTROY_NOTIFY";
    case Protocol_PC_SCENEMAP_INFO_UPDATE_NOTIFY: return "PC_SCENEMAP_INFO_UPDATE_NOTIFY";
    case Protocol_PC_SCENEMAP_INFO_DESTROY_NOTIFY: return "PC_SCENEMAP_INFO_DESTROY_NOTIFY";
    case Protocol_FIELD_JOIN_REQUEST: return "FIELD_JOIN_REQUEST";
    case Protocol_FIELD_JOIN_RESPONSE: return "FIELD_JOIN_RESPONSE";
    case Protocol_DAILY_DUNGEON_CLEAR_NOTIFY: return "DAILY_DUNGEON_CLEAR_NOTIFY";
    case Protocol_DAILY_DUNGEON_JOIN_REQUEST: return "DAILY_DUNGEON_JOIN_REQUEST";
    case Protocol_DAILY_DUNGEON_JOIN_RESPONSE: return "DAILY_DUNGEON_JOIN_RESPONSE";
    case Protocol_DAILY_DUNGEON_INFO_REQUEST: return "DAILY_DUNGEON_INFO_REQUEST";
    case Protocol_DAILY_DUNGEON_INFO_RESPONSE: return "DAILY_DUNGEON_INFO_RESPONSE";
    case Protocol_DAILY_DUNGEON_OTHER_JOIN_REQUEST: return "DAILY_DUNGEON_OTHER_JOIN_REQUEST";
    case Protocol_DAILY_DUNGEON_OTHER_JOIN_RESPONSE: return "DAILY_DUNGEON_OTHER_JOIN_RESPONSE";
    case Protocol_ARENA_TEAM_REQUEST: return "ARENA_TEAM_REQUEST";
    case Protocol_ARENA_TEAM_RESPONSE: return "ARENA_TEAM_RESPONSE";
    case Protocol_ARENA_TEAM_REFRESH_REQUEST: return "ARENA_TEAM_REFRESH_REQUEST";
    case Protocol_ARENA_TEAM_REFRESH_RESPONSE: return "ARENA_TEAM_REFRESH_RESPONSE";
    case Protocol_ARENA_JOIN_REQUEST: return "ARENA_JOIN_REQUEST";
    case Protocol_ARENA_JOIN_RESPONSE: return "ARENA_JOIN_RESPONSE";
    case Protocol_ARENA_FINISH_REQUEST: return "ARENA_FINISH_REQUEST";
    case Protocol_ARENA_FINISH_NOTIFY: return "ARENA_FINISH_NOTIFY";
    case Protocol_ARENA_PLAY_INFO_NOTIFY: return "ARENA_PLAY_INFO_NOTIFY";
    case Protocol_ARENA_REWARD_REQUEST: return "ARENA_REWARD_REQUEST";
    case Protocol_ARENA_REWARD_RESPONSE: return "ARENA_REWARD_RESPONSE";
    case Protocol_ARENA_EXIT_REQUEST: return "ARENA_EXIT_REQUEST";
    case Protocol_UPDATE_ITEM_COOLTIME_NOTIFY: return "UPDATE_ITEM_COOLTIME_NOTIFY";
    case Protocol_ARENA_FINISH_NOTIFY_REQUEST: return "ARENA_FINISH_NOTIFY_REQUEST";
    case Protocol_SOLO_DUNGEON_RELOAD_REQUEST: return "SOLO_DUNGEON_RELOAD_REQUEST";
    case Protocol_SOLO_DUNGEON_RELOAD_RESPONSE: return "SOLO_DUNGEON_RELOAD_RESPONSE";
    case Protocol_SOLO_DUNGEON_LOAD_NOTIFY: return "SOLO_DUNGEON_LOAD_NOTIFY";
    case Protocol_SOLO_DUNGEON_JOIN_REQUEST: return "SOLO_DUNGEON_JOIN_REQUEST";
    case Protocol_SOLO_DUNGEON_JOIN_RESPONSE: return "SOLO_DUNGEON_JOIN_RESPONSE";
    case Protocol_SOLO_DUNGEON_CLEAR_NOTIFY: return "SOLO_DUNGEON_CLEAR_NOTIFY";
    case Protocol_INFLUENCE_POINT_UP_NOTIFY: return "INFLUENCE_POINT_UP_NOTIFY";
    case Protocol_INFLUENCE_DATA_NOTIFY: return "INFLUENCE_DATA_NOTIFY";
    case Protocol_INFLUENCE_AFTER_REFRESH_NOTIFY: return "INFLUENCE_AFTER_REFRESH_NOTIFY";
    case Protocol_ADMIN_UPDATE_REFRESH_INFLUENCE: return "ADMIN_UPDATE_REFRESH_INFLUENCE";
    case Protocol_DB_ADMIN_UPDATE_INFLUENCE_TIER_LEVEL_REQUEST: return "DB_ADMIN_UPDATE_INFLUENCE_TIER_LEVEL_REQUEST";
    case Protocol_DB_ADMIN_UPDATE_INFLUENCE_TIER_LEVEL_RESPONSE: return "DB_ADMIN_UPDATE_INFLUENCE_TIER_LEVEL_RESPONSE";
    case Protocol_MAIL_RECEIVE_NOTIFY: return "MAIL_RECEIVE_NOTIFY";
    case Protocol_MAIL_REWARD_RECEIVE_REQUEST: return "MAIL_REWARD_RECEIVE_REQUEST";
    case Protocol_MAIL_REWARD_RECEIVE_RESPONSE: return "MAIL_REWARD_RECEIVE_RESPONSE";
    case Protocol_MAIL_REMOVE_NOTIFY: return "MAIL_REMOVE_NOTIFY";
    case Protocol_CHAT_REQUEST: return "CHAT_REQUEST";
    case Protocol_CHAT_WHISPER_REQUEST: return "CHAT_WHISPER_REQUEST";
    case Protocol_CHAT_ERROR_NOTIFY: return "CHAT_ERROR_NOTIFY";
    case Protocol_CHAT_COMMON_NOTIFY: return "CHAT_COMMON_NOTIFY";
    case Protocol_CHAT_GUILD_NOTIFY: return "CHAT_GUILD_NOTIFY";
    case Protocol_CHAT_WHISPER_NOTIFY: return "CHAT_WHISPER_NOTIFY";
    case Protocol_CHAT_GUILD_MSG_LIST_REQUEST: return "CHAT_GUILD_MSG_LIST_REQUEST";
    case Protocol_CHAT_GUILD_MSG_LIST_RESPONSE: return "CHAT_GUILD_MSG_LIST_RESPONSE";
    case Protocol_CHAT_WHISPER_MSG_LIST_REQUEST: return "CHAT_WHISPER_MSG_LIST_REQUEST";
    case Protocol_CHAT_WHISPER_MSG_LIST_RESPONSE: return "CHAT_WHISPER_MSG_LIST_RESPONSE";
    case Protocol_CHAT_NEW_MESSAGE_NOTIFY: return "CHAT_NEW_MESSAGE_NOTIFY";
    case Protocol_CHAT_WORLD_REQUEST: return "CHAT_WORLD_REQUEST";
    case Protocol_CHAT_LOCAL_REQUEST: return "CHAT_LOCAL_REQUEST";
    case Protocol_CHAT_WARFIELD_REQUEST: return "CHAT_WARFIELD_REQUEST";
    case Protocol_CHAT_CHECK_RECEIVER_REQUEST: return "CHAT_CHECK_RECEIVER_REQUEST";
    case Protocol_CHAT_CHECK_RECEIVER_RESPONSE: return "CHAT_CHECK_RECEIVER_RESPONSE";
    case Protocol_CHAT_READ_WHISPER_NOTIFY: return "CHAT_READ_WHISPER_NOTIFY";
    case Protocol_CHAT_READ_GUILD_NOTIFY: return "CHAT_READ_GUILD_NOTIFY";
    case Protocol_CHAT_DELETE_ROOM: return "CHAT_DELETE_ROOM";
    case Protocol_NEW_WHISPER_MESSAGE_NOTIFY: return "NEW_WHISPER_MESSAGE_NOTIFY";
    case Protocol_NEW_GUILD_MESSAGE_NOTIFY: return "NEW_GUILD_MESSAGE_NOTIFY";
    case Protocol_TARGET_PC_DETAIL_INFO_REQUEST: return "TARGET_PC_DETAIL_INFO_REQUEST";
    case Protocol_TARGET_PC_DETAIL_INFO_RESPONSE: return "TARGET_PC_DETAIL_INFO_RESPONSE";
    case Protocol_PLAYER_DENIED_REQUEST: return "PLAYER_DENIED_REQUEST";
    case Protocol_PLAYER_DENIED_RESPONSE: return "PLAYER_DENIED_RESPONSE";
    case Protocol_PLAYER_UNDENIED_REQUEST: return "PLAYER_UNDENIED_REQUEST";
    case Protocol_PLAYER_UNDENIED_RESPONSE: return "PLAYER_UNDENIED_RESPONSE";
    case Protocol_PLAYER_DENIED_LIST_NOTIFY: return "PLAYER_DENIED_LIST_NOTIFY";
    case Protocol_TRADE_GET_TRADE_ITEM_LIST_REQUEST: return "TRADE_GET_TRADE_ITEM_LIST_REQUEST";
    case Protocol_TRADE_GET_TRADE_ITEM_LIST_RESPONSE: return "TRADE_GET_TRADE_ITEM_LIST_RESPONSE";
    case Protocol_TRADE_SET_TRADE_ITEM_REQUEST: return "TRADE_SET_TRADE_ITEM_REQUEST";
    case Protocol_TRADE_SET_TRADE_ITEM_RESPONSE: return "TRADE_SET_TRADE_ITEM_RESPONSE";
    case Protocol_TRADE_BUY_TRADE_ITEM_REQUEST: return "TRADE_BUY_TRADE_ITEM_REQUEST";
    case Protocol_TRADE_BUY_TRADE_ITEM_RESPONSE: return "TRADE_BUY_TRADE_ITEM_RESPONSE";
    case Protocol_TRADE_MY_SALE_LIST_REQUEST: return "TRADE_MY_SALE_LIST_REQUEST";
    case Protocol_TRADE_MY_SALE_LIST_RESPONSE: return "TRADE_MY_SALE_LIST_RESPONSE";
    case Protocol_TRADE_SALE_LOG_LIST_REQUEST: return "TRADE_SALE_LOG_LIST_REQUEST";
    case Protocol_TRADE_SALE_LOG_LIST_RESPONSE: return "TRADE_SALE_LOG_LIST_RESPONSE";
    case Protocol_TRADE_CANCEL_TRADE_ITEM_REQUEST: return "TRADE_CANCEL_TRADE_ITEM_REQUEST";
    case Protocol_TRADE_CANCEL_TRADE_ITEM_RESPONSE: return "TRADE_CANCEL_TRADE_ITEM_RESPONSE";
    case Protocol_RAID_JOIN_FAILED_NOTIFY: return "RAID_JOIN_FAILED_NOTIFY";
    case Protocol_RAID_INFO_REQUEST: return "RAID_INFO_REQUEST";
    case Protocol_RAID_INFO_RESPONSE: return "RAID_INFO_RESPONSE";
    case Protocol_RAID_RANDOM_REWARD_PC_NOTIFY: return "RAID_RANDOM_REWARD_PC_NOTIFY";
    case Protocol_BONUS_DAILY_RECHARGE_MANUAL_REQUEST: return "BONUS_DAILY_RECHARGE_MANUAL_REQUEST";
    case Protocol_BONUS_DAILY_RECHARGE_MANUAL_RESPONSE: return "BONUS_DAILY_RECHARGE_MANUAL_RESPONSE";
    case Protocol_BONUS_DAILY_RECHARGE_INFO_REQUEST: return "BONUS_DAILY_RECHARGE_INFO_REQUEST";
    case Protocol_BONUS_DAILY_RECHARGE_INFO_RESPONSE: return "BONUS_DAILY_RECHARGE_INFO_RESPONSE";
    case Protocol_INFINITE_TOWER_INFO_REQUEST: return "INFINITE_TOWER_INFO_REQUEST";
    case Protocol_INFINITE_TOWER_INFO_RESPONSE: return "INFINITE_TOWER_INFO_RESPONSE";
    case Protocol_INFINITE_TOWER_JOIN_REQUEST: return "INFINITE_TOWER_JOIN_REQUEST";
    case Protocol_INFINITE_TOWER_JOIN_RESPONSE: return "INFINITE_TOWER_JOIN_RESPONSE";
    case Protocol_INFINITE_TOWER_SWEEP_REQUEST: return "INFINITE_TOWER_SWEEP_REQUEST";
    case Protocol_INFINITE_TOWER_SWEEP_RESPONSE: return "INFINITE_TOWER_SWEEP_RESPONSE";
    case Protocol_INFINITE_TOWER_CLEAR_NOTIFY: return "INFINITE_TOWER_CLEAR_NOTIFY";
    case Protocol_ATTENDANCE_INFO_REQUEST: return "ATTENDANCE_INFO_REQUEST";
    case Protocol_ATTENDANCE_INFO_RESPONSE: return "ATTENDANCE_INFO_RESPONSE";
    case Protocol_ATTENDANCE_STAMP_REQUEST: return "ATTENDANCE_STAMP_REQUEST";
    case Protocol_ATTENDANCE_STAMP_RESPONSE: return "ATTENDANCE_STAMP_RESPONSE";
    case Protocol_ACCESS_TIME_INFO_REQUEST: return "ACCESS_TIME_INFO_REQUEST";
    case Protocol_ACCESS_TIME_INFO_RESPONSE: return "ACCESS_TIME_INFO_RESPONSE";
    case Protocol_ACCESS_TIME_REWARD_REQUEST: return "ACCESS_TIME_REWARD_REQUEST";
    case Protocol_ACCESS_TIME_REWARD_RESPONSE: return "ACCESS_TIME_REWARD_RESPONSE";
    case Protocol_REST_TIME_INFO_REQUEST: return "REST_TIME_INFO_REQUEST";
    case Protocol_REST_TIME_INFO_RESPONSE: return "REST_TIME_INFO_RESPONSE";
    case Protocol_REST_TIME_REWARD_REQUEST: return "REST_TIME_REWARD_REQUEST";
    case Protocol_REST_TIME_REWARD_RESPONSE: return "REST_TIME_REWARD_RESPONSE";
    case Protocol_SHOP_PURCHASE_PRODUCT_REQUEST: return "SHOP_PURCHASE_PRODUCT_REQUEST";
    case Protocol_SHOP_PURCHASE_PRODUCT_RESPONSE: return "SHOP_PURCHASE_PRODUCT_RESPONSE";
    case Protocol_SHOP_PURCHASE_PRODUCT_REWARD_REQUEST: return "SHOP_PURCHASE_PRODUCT_REWARD_REQUEST";
    case Protocol_SHOP_PURCHASE_PRODUCT_REWARD_RESPONSE: return "SHOP_PURCHASE_PRODUCT_REWARD_RESPONSE";
    case Protocol_SHOP_PURCHASE_PRODUCT_BONUS_REWARD_REQUEST: return "SHOP_PURCHASE_PRODUCT_BONUS_REWARD_REQUEST";
    case Protocol_SHOP_PURCHASE_PRODUCT_BONUS_REWARD_RESPONSE: return "SHOP_PURCHASE_PRODUCT_BONUS_REWARD_RESPONSE";
    case Protocol_SHOP_PURCHASE_PRODUCT_LIST_NOTIFY: return "SHOP_PURCHASE_PRODUCT_LIST_NOTIFY";
    case Protocol_SHOP_PURCHASE_PRODUCT_EXPIRE_DATE_NOTIFY: return "SHOP_PURCHASE_PRODUCT_EXPIRE_DATE_NOTIFY";
    case Protocol_SHOP_PURCHASE_PRODUCT_MISSION_UPDATE_NOTIFY: return "SHOP_PURCHASE_PRODUCT_MISSION_UPDATE_NOTIFY";
    case Protocol_SHOP_PURCHASE_PRODUCT_BONUS_POINT_UPDATE_NOTIFY: return "SHOP_PURCHASE_PRODUCT_BONUS_POINT_UPDATE_NOTIFY";
    case Protocol_SHOP_PURCHASE_PRODUCT_PROMOTION_UPDATE_NOTIFY: return "SHOP_PURCHASE_PRODUCT_PROMOTION_UPDATE_NOTIFY";
    case Protocol_SHOP_PURCHASE_PRODUCT_PROMOTION_REWARD_REQUEST: return "SHOP_PURCHASE_PRODUCT_PROMOTION_REWARD_REQUEST";
    case Protocol_SHOP_PURCHASE_PRODUCT_PROMOTION_REWARD_RESPONSE: return "SHOP_PURCHASE_PRODUCT_PROMOTION_REWARD_RESPONSE";
    case Protocol_GUILD_DUNGEON_INFO_REQUEST: return "GUILD_DUNGEON_INFO_REQUEST";
    case Protocol_GUILD_DUNGEON_INFO_RESPONSE: return "GUILD_DUNGEON_INFO_RESPONSE";
    case Protocol_GUILD_DUNGEON_ENTER_FAILED: return "GUILD_DUNGEON_ENTER_FAILED";
    case Protocol_GUILD_DUNGEON_CLEAR_NOTIFY: return "GUILD_DUNGEON_CLEAR_NOTIFY";
    case Protocol_GUILD_DUNGEON_REWARD_REQUEST: return "GUILD_DUNGEON_REWARD_REQUEST";
    case Protocol_GUILD_DUNGEON_REWARD_RESPONSE: return "GUILD_DUNGEON_REWARD_RESPONSE";
    case Protocol_DB_USER_DATA_REQUEST: return "DB_USER_DATA_REQUEST";
    case Protocol_DB_USER_DATA_RESPONSE: return "DB_USER_DATA_RESPONSE";
    case Protocol_DB_ADD_ITEM_REQUEST: return "DB_ADD_ITEM_REQUEST";
    case Protocol_DB_ADD_ITEM_RESPONSE: return "DB_ADD_ITEM_RESPONSE";
    case Protocol_DB_DEL_ITEM_REQUEST: return "DB_DEL_ITEM_REQUEST";
    case Protocol_DB_DEL_ITEM_RESPONSE: return "DB_DEL_ITEM_RESPONSE";
    case Protocol_DB_UPDATE_LEVEL_EXP_REQUEST: return "DB_UPDATE_LEVEL_EXP_REQUEST";
    case Protocol_DB_UPDATE_LEVEL_EXP_RESPONSE: return "DB_UPDATE_LEVEL_EXP_RESPONSE";
    case Protocol_DB_DISENCHANT_ITEM_REQUEST: return "DB_DISENCHANT_ITEM_REQUEST";
    case Protocol_DB_DISENCHANT_ITEM_RESPONSE: return "DB_DISENCHANT_ITEM_RESPONSE";
    case Protocol_DB_ENCHANT_ITEM_REQUEST: return "DB_ENCHANT_ITEM_REQUEST";
    case Protocol_DB_ENCHANT_ITEM_RESPONSE: return "DB_ENCHANT_ITEM_RESPONSE";
    case Protocol_DB_UPGRADE_ITEM_REQUEST: return "DB_UPGRADE_ITEM_REQUEST";
    case Protocol_DB_UPGRADE_ITEM_RESPONSE: return "DB_UPGRADE_ITEM_RESPONSE";
    case Protocol_DB_SALE_ITEM_REQUEST: return "DB_SALE_ITEM_REQUEST";
    case Protocol_DB_SALE_ITEM_RESPONSE: return "DB_SALE_ITEM_RESPONSE";
    case Protocol_DB_TRANSCEND_ITEM_REQUEST: return "DB_TRANSCEND_ITEM_REQUEST";
    case Protocol_DB_TRANSCEND_ITEM_RESPONSE: return "DB_TRANSCEND_ITEM_RESPONSE";
    case Protocol_DB_CHANGE_TRANSCEND_STAT_REQUEST: return "DB_CHANGE_TRANSCEND_STAT_REQUEST";
    case Protocol_DB_CHANGE_TRANSCEND_STAT_RESPONSE: return "DB_CHANGE_TRANSCEND_STAT_RESPONSE";
    case Protocol_DB_CRAFT_ITEM_REQUEST: return "DB_CRAFT_ITEM_REQUEST";
    case Protocol_DB_CRAFT_ITEM_RESPONSE: return "DB_CRAFT_ITEM_RESPONSE";
    case Protocol_DB_PRESET_INSERT_REQUEST: return "DB_PRESET_INSERT_REQUEST";
    case Protocol_DB_PRESET_INSERT_RESPONSE: return "DB_PRESET_INSERT_RESPONSE";
    case Protocol_DB_PRESET_UPDATE_REQUEST: return "DB_PRESET_UPDATE_REQUEST";
    case Protocol_DB_PRESET_UPDATE_RESPONSE: return "DB_PRESET_UPDATE_RESPONSE";
    case Protocol_DB_SKILL_GROWTH_UPDATE_REQUEST: return "DB_SKILL_GROWTH_UPDATE_REQUEST";
    case Protocol_DB_SKILL_GROWTH_UPDATE_RESPONSE: return "DB_SKILL_GROWTH_UPDATE_RESPONSE";
    case Protocol_DB_PURSE_REQUEST: return "DB_PURSE_REQUEST";
    case Protocol_DB_PURSE_RESPONSE: return "DB_PURSE_RESPONSE";
    case Protocol_DB_CHANGE_PRISM_REQUEST: return "DB_CHANGE_PRISM_REQUEST";
    case Protocol_DB_CHANGE_PRISM_RESPONSE: return "DB_CHANGE_PRISM_RESPONSE";
    case Protocol_DB_SET_DIAMOND_CHEAT_REQUEST: return "DB_SET_DIAMOND_CHEAT_REQUEST";
    case Protocol_DB_SET_DIAMOND_CHEAT_RESPONSE: return "DB_SET_DIAMOND_CHEAT_RESPONSE";
    case Protocol_DB_TRANSMUTE_CRYSTAL_REQUEST: return "DB_TRANSMUTE_CRYSTAL_REQUEST";
    case Protocol_DB_TRANSMUTE_CRYSTAL_RESPONSE: return "DB_TRANSMUTE_CRYSTAL_RESPONSE";
    case Protocol_DB_CHANGE_CRYSTAL_REQUEST: return "DB_CHANGE_CRYSTAL_REQUEST";
    case Protocol_DB_CHANGE_CRYSTAL_RESPONSE: return "DB_CHANGE_CRYSTAL_RESPONSE";
    case Protocol_DB_UPDATE_SKILL_POINT_REQUEST: return "DB_UPDATE_SKILL_POINT_REQUEST";
    case Protocol_DB_UPDATE_SKILL_POINT_RESPONSE: return "DB_UPDATE_SKILL_POINT_RESPONSE";
    case Protocol_DB_TOGGLE_SAFE_GUARD_REQUEST: return "DB_TOGGLE_SAFE_GUARD_REQUEST";
    case Protocol_DB_TOGGLE_SAFE_GUARD_RESPONSE: return "DB_TOGGLE_SAFE_GUARD_RESPONSE";
    case Protocol_DB_SKILL_FEATURE_INITIALIZE_REQUEST: return "DB_SKILL_FEATURE_INITIALIZE_REQUEST";
    case Protocol_DB_SKILL_FEATURE_INITIALIZE_RESPONSE: return "DB_SKILL_FEATURE_INITIALIZE_RESPONSE";
    case Protocol_DB_DAILY_DUNGEON_COMPLETE_REQUEST: return "DB_DAILY_DUNGEON_COMPLETE_REQUEST";
    case Protocol_DB_DAILY_DUNGEON_COMPLETE_RESPONSE: return "DB_DAILY_DUNGEON_COMPLETE_RESPONSE";
    case Protocol_DB_MOVE_ITEM_REQUEST: return "DB_MOVE_ITEM_REQUEST";
    case Protocol_DB_MOVE_ITEM_RESPONSE: return "DB_MOVE_ITEM_RESPONSE";
    case Protocol_DB_PRESET_TYPE_UPDATE_REQUEST: return "DB_PRESET_TYPE_UPDATE_REQUEST";
    case Protocol_DB_PRESET_TYPE_UPDATE_RESPONSE: return "DB_PRESET_TYPE_UPDATE_RESPONSE";
    case Protocol_DB_QUEST_SET_DATA_MULTI_REQUEST: return "DB_QUEST_SET_DATA_MULTI_REQUEST";
    case Protocol_DB_QUEST_SET_DATA_MULTI_RESPONSE: return "DB_QUEST_SET_DATA_MULTI_RESPONSE";
    case Protocol_DB_CHAPTER_UPDATE_REQUEST: return "DB_CHAPTER_UPDATE_REQUEST";
    case Protocol_DB_CHAPTER_UPDATE_RESPONSE: return "DB_CHAPTER_UPDATE_RESPONSE";
    case Protocol_DB_INVEN_REWARD_MAIL_REQUEST: return "DB_INVEN_REWARD_MAIL_REQUEST";
    case Protocol_DB_INVEN_REWARD_MAIL_RESPONSE: return "DB_INVEN_REWARD_MAIL_RESPONSE";
    case Protocol_DB_RECV_MAIL_REWARD_REQUEST: return "DB_RECV_MAIL_REWARD_REQUEST";
    case Protocol_DB_RECV_MAIL_REWARD_RESPONSE: return "DB_RECV_MAIL_REWARD_RESPONSE";
    case Protocol_DB_SOLO_DUNGEON_SET_DATA_REQUEST: return "DB_SOLO_DUNGEON_SET_DATA_REQUEST";
    case Protocol_DB_SOLO_DUNGEON_SET_DATA_RESPONSE: return "DB_SOLO_DUNGEON_SET_DATA_RESPONSE";
    case Protocol_DB_SOLO_DUNGEON_SET_TICKET_REQUEST: return "DB_SOLO_DUNGEON_SET_TICKET_REQUEST";
    case Protocol_DB_SOLO_DUNGEON_SET_TICKET_RESPONSE: return "DB_SOLO_DUNGEON_SET_TICKET_RESPONSE";
    case Protocol_DB_QUEST_BONUS_SET_DATA_REQUEST: return "DB_QUEST_BONUS_SET_DATA_REQUEST";
    case Protocol_DB_QUSET_BONUS_SET_DATA_RESPONSE: return "DB_QUSET_BONUS_SET_DATA_RESPONSE";
    case Protocol_DB_PC_UPDATE_REQUEST: return "DB_PC_UPDATE_REQUEST";
    case Protocol_DB_PC_UPDATE_RESPONSE: return "DB_PC_UPDATE_RESPONSE";
    case Protocol_DB_USE_ITEM_REQUEST: return "DB_USE_ITEM_REQUEST";
    case Protocol_DB_USE_ITEM_RESPONSE: return "DB_USE_ITEM_RESPONSE";
    case Protocol_DB_USE_ITEM_CONTENTS_EFFECT_REQUEST: return "DB_USE_ITEM_CONTENTS_EFFECT_REQUEST";
    case Protocol_DB_USE_ITEM_CONTENTS_EFFECT_RESPONSE: return "DB_USE_ITEM_CONTENTS_EFFECT_RESPONSE";
    case Protocol_DB_NEW_MAIL_LOAD_REQUEST: return "DB_NEW_MAIL_LOAD_REQUEST";
    case Protocol_DB_NEW_MAIL_LOAD_RESPONSE: return "DB_NEW_MAIL_LOAD_RESPONSE";
    case Protocol_DB_REWARD_REQUEST: return "DB_REWARD_REQUEST";
    case Protocol_DB_REWARD_RESPONSE: return "DB_REWARD_RESPONSE";
    case Protocol_DB_FOLLOWER_ADD_SOUL_STONE_REQUEST: return "DB_FOLLOWER_ADD_SOUL_STONE_REQUEST";
    case Protocol_DB_FOLLOWER_ADD_SOUL_STONE_RESPONSE: return "DB_FOLLOWER_ADD_SOUL_STONE_RESPONSE";
    case Protocol_DB_FOLLOWER_ENCHANT_REQUEST: return "DB_FOLLOWER_ENCHANT_REQUEST";
    case Protocol_DB_FOLLOWER_ENCHANT_RESPONSE: return "DB_FOLLOWER_ENCHANT_RESPONSE";
    case Protocol_DB_FOLLOWER_START_MISSION_REQUEST: return "DB_FOLLOWER_START_MISSION_REQUEST";
    case Protocol_DB_FOLLOWER_START_MISSION_RESPONSE: return "DB_FOLLOWER_START_MISSION_RESPONSE";
    case Protocol_DB_FOLLOWER_END_MISSION_REQUEST: return "DB_FOLLOWER_END_MISSION_REQUEST";
    case Protocol_DB_FOLLOWER_END_MISSION_RESPONSE: return "DB_FOLLOWER_END_MISSION_RESPONSE";
    case Protocol_DB_FOLLOWER_MISSION_REWARD_REQUEST: return "DB_FOLLOWER_MISSION_REWARD_REQUEST";
    case Protocol_DB_FOLLOWER_MISSION_REWARD_RESPONSE: return "DB_FOLLOWER_MISSION_REWARD_RESPONSE";
    case Protocol_DB_QUEST_SET_REWARD_REQUEST: return "DB_QUEST_SET_REWARD_REQUEST";
    case Protocol_DB_QUEST_SET_REWARD_RESPONSE: return "DB_QUEST_SET_REWARD_RESPONSE";
    case Protocol_ARENA_STATE_NOTIFY: return "ARENA_STATE_NOTIFY";
    case Protocol_ARENA_MEMBER_LIST_REQUEST: return "ARENA_MEMBER_LIST_REQUEST";
    case Protocol_ARENA_MEMBER_LIST_RESPONSE: return "ARENA_MEMBER_LIST_RESPONSE";
    case Protocol_DB_ARENA_REWARD_REQUEST: return "DB_ARENA_REWARD_REQUEST";
    case Protocol_DB_ARENA_REWARD_RESPONSE: return "DB_ARENA_REWARD_RESPONSE";
    case Protocol_DB_ARENA_FINISH_REQUEST: return "DB_ARENA_FINISH_REQUEST";
    case Protocol_DB_ARENA_FINISH_RESPONSE: return "DB_ARENA_FINISH_RESPONSE";
    case Protocol_ARENA_INFO_REQUEST: return "ARENA_INFO_REQUEST";
    case Protocol_ARENA_INFO_RESPONSE: return "ARENA_INFO_RESPONSE";
    case Protocol_DB_LOAD_UPC_DATA_REQUEST: return "DB_LOAD_UPC_DATA_REQUEST";
    case Protocol_DB_LOAD_UPC_DATA_RESPONSE: return "DB_LOAD_UPC_DATA_RESPONSE";
    case Protocol_DB_ITEM_COOL_TIME_SAVE_REQUEST: return "DB_ITEM_COOL_TIME_SAVE_REQUEST";
    case Protocol_DB_ITEM_COOL_TIME_SAVE_RESPONSE: return "DB_ITEM_COOL_TIME_SAVE_RESPONSE";
    case Protocol_DB_LOAD_ITEM_COOLTIME_RESPONSE: return "DB_LOAD_ITEM_COOLTIME_RESPONSE";
    case Protocol_DB_ITEM_COOL_TIME_UPDATE_REQUEST: return "DB_ITEM_COOL_TIME_UPDATE_REQUEST";
    case Protocol_DB_ITEM_COOL_TIME_UPDATE_RESPONSE: return "DB_ITEM_COOL_TIME_UPDATE_RESPONSE";
    case Protocol_DB_INFLUENCE_REFRESH_REQUEST: return "DB_INFLUENCE_REFRESH_REQUEST";
    case Protocol_DB_INFLUENCE_REFRESH_RESPONSE: return "DB_INFLUENCE_REFRESH_RESPONSE";
    case Protocol_DB_INFLUENCE_POINT_UP_REQUEST: return "DB_INFLUENCE_POINT_UP_REQUEST";
    case Protocol_DB_INFLUENCE_POINT_UP_RESPONSE: return "DB_INFLUENCE_POINT_UP_RESPONSE";
    case Protocol_DB_TICKET_UPDATE_REQUEST: return "DB_TICKET_UPDATE_REQUEST";
    case Protocol_DB_TICKET_UPDATE_RESPONSE: return "DB_TICKET_UPDATE_RESPONSE";
    case Protocol_DB_TICKET_REFILL_REQUEST: return "DB_TICKET_REFILL_REQUEST";
    case Protocol_DB_TICKET_REFILL_RESPONSE: return "DB_TICKET_REFILL_RESPONSE";
    case Protocol_DB_DAILY_HOMEWORK_UPDATE_REQUEST: return "DB_DAILY_HOMEWORK_UPDATE_REQUEST";
    case Protocol_DB_DAILY_HOMEWORK_UPDATE_RESPONSE: return "DB_DAILY_HOMEWORK_UPDATE_RESPONSE";
    case Protocol_DB_MAIN_STREAM_UPDATE_REQUEST: return "DB_MAIN_STREAM_UPDATE_REQUEST";
    case Protocol_DB_MAIN_STREAM_UPDATE_RESPONSE: return "DB_MAIN_STREAM_UPDATE_RESPONSE";
    case Protocol_DB_MAIN_STREAM_UPDATE_ALL_REQUEST: return "DB_MAIN_STREAM_UPDATE_ALL_REQUEST";
    case Protocol_DB_MAIN_STREAM_UPDATE_ALL_RESPONSE: return "DB_MAIN_STREAM_UPDATE_ALL_RESPONSE";
    case Protocol_DB_DAILY_HOMEWORK_POINT_UPDATE_REQUEST: return "DB_DAILY_HOMEWORK_POINT_UPDATE_REQUEST";
    case Protocol_DB_DAILY_HOMEWORK_POINT_UPDATE_RESPONSE: return "DB_DAILY_HOMEWORK_POINT_UPDATE_RESPONSE";
    case Protocol_DB_DAILY_HOMEWORK_POINT_REWARD_REQUEST: return "DB_DAILY_HOMEWORK_POINT_REWARD_REQUEST";
    case Protocol_DB_DAILY_HOMEWORK_POINT_REWARD_RESPONSE: return "DB_DAILY_HOMEWORK_POINT_REWARD_RESPONSE";
    case Protocol_DB_SET_TRADE_ITEM_REQUEST: return "DB_SET_TRADE_ITEM_REQUEST";
    case Protocol_DB_SET_TRADE_ITEM_RESPONSE: return "DB_SET_TRADE_ITEM_RESPONSE";
    case Protocol_DB_GET_TRADE_ITEM_LIST_REQUEST: return "DB_GET_TRADE_ITEM_LIST_REQUEST";
    case Protocol_DB_GET_TRADE_ITEM_LIST_RESPONSE: return "DB_GET_TRADE_ITEM_LIST_RESPONSE";
    case Protocol_DB_GET_TRADE_MY_SALE_LIST_REQUEST: return "DB_GET_TRADE_MY_SALE_LIST_REQUEST";
    case Protocol_DB_GET_TRADE_MY_SALE_LIST_RESPONSE: return "DB_GET_TRADE_MY_SALE_LIST_RESPONSE";
    case Protocol_DB_BUY_TRADE_ITEM_REQUEST: return "DB_BUY_TRADE_ITEM_REQUEST";
    case Protocol_DB_BUY_TRADE_ITEM_RESPONSE: return "DB_BUY_TRADE_ITEM_RESPONSE";
    case Protocol_DB_CANCEL_TRADE_ITEM_REQUEST: return "DB_CANCEL_TRADE_ITEM_REQUEST";
    case Protocol_DB_CANCEL_TRADE_ITEM_RESPONSE: return "DB_CANCEL_TRADE_ITEM_RESPONSE";
    case Protocol_DB_GET_TRADE_SALE_LOG_LIST_REQUEST: return "DB_GET_TRADE_SALE_LOG_LIST_REQUEST";
    case Protocol_DB_GET_TRADE_SALE_LOG_LIST_RESPONSE: return "DB_GET_TRADE_SALE_LOG_LIST_RESPONSE";
    case Protocol_DB_DAILY_HOMEWORK_CHANGE_CHAPTER_REQUEST: return "DB_DAILY_HOMEWORK_CHANGE_CHAPTER_REQUEST";
    case Protocol_DB_DAILY_HOMEWORK_CHANGE_CHAPTER_RESPONSE: return "DB_DAILY_HOMEWORK_CHANGE_CHAPTER_RESPONSE";
    case Protocol_DB_DAILY_HOMEWORK_RESET_REQUEST: return "DB_DAILY_HOMEWORK_RESET_REQUEST";
    case Protocol_DB_DAILY_HOMEWORK_RESET_RESPONSE: return "DB_DAILY_HOMEWORK_RESET_RESPONSE";
    case Protocol_DB_DAILY_HOMEWORK_TEST_RESET_REQUEST: return "DB_DAILY_HOMEWORK_TEST_RESET_REQUEST";
    case Protocol_DB_DAILY_HOMEWORK_TEST_RESET_RESPONSE: return "DB_DAILY_HOMEWORK_TEST_RESET_RESPONSE";
    case Protocol_DB_BONUS_DAILY_RECHARGE_REQEUST: return "DB_BONUS_DAILY_RECHARGE_REQEUST";
    case Protocol_DB_BONUS_DAILY_RECHARGE_RESPONSE: return "DB_BONUS_DAILY_RECHARGE_RESPONSE";
    case Protocol_DB_INFINITE_TOWER_CLEAR_REQUEST: return "DB_INFINITE_TOWER_CLEAR_REQUEST";
    case Protocol_DB_INFINITE_TOWER_CLEAR_RESPONSE: return "DB_INFINITE_TOWER_CLEAR_RESPONSE";
    case Protocol_DB_INFINITE_TOWER_SWEEP_REQUEST: return "DB_INFINITE_TOWER_SWEEP_REQUEST";
    case Protocol_DB_INFINITE_TOWER_SWEEP_RESPONSE: return "DB_INFINITE_TOWER_SWEEP_RESPONSE";
    case Protocol_DB_ATTENDANCE_STAMP_REQUEST: return "DB_ATTENDANCE_STAMP_REQUEST";
    case Protocol_DB_ATTENDANCE_STAMP_RESPONSE: return "DB_ATTENDANCE_STAMP_RESPONSE";
    case Protocol_DB_DIA_ENTER_COUNT_UPDATE_REQUEST: return "DB_DIA_ENTER_COUNT_UPDATE_REQUEST";
    case Protocol_DB_DIA_ENTER_COUNT_UPDATE_RESPONSE: return "DB_DIA_ENTER_COUNT_UPDATE_RESPONSE";
    case Protocol_DB_ITEM_ENTER_COUNT_UPDATE_REQUEST: return "DB_ITEM_ENTER_COUNT_UPDATE_REQUEST";
    case Protocol_DB_ITEM_ENTER_COUNT_UPDATE_RESPONSE: return "DB_ITEM_ENTER_COUNT_UPDATE_RESPONSE";
    case Protocol_DB_ENTER_COUNT_UPDATE_REQUEST: return "DB_ENTER_COUNT_UPDATE_REQUEST";
    case Protocol_DB_ENTER_COUNT_UPDATE_RESPONSE: return "DB_ENTER_COUNT_UPDATE_RESPONSE";
    case Protocol_DB_ENTER_SET_COUNT_UPDATE_REQUEST: return "DB_ENTER_SET_COUNT_UPDATE_REQUEST";
    case Protocol_DB_ENTER_SET_COUNT_UPDATE_REPONSE: return "DB_ENTER_SET_COUNT_UPDATE_REPONSE";
    case Protocol_DB_ITEM_FUSION_REQUEST: return "DB_ITEM_FUSION_REQUEST";
    case Protocol_DB_ITEM_FUSION_RESPONSE: return "DB_ITEM_FUSION_RESPONSE";
    case Protocol_DB_LOAD_PC_DATA_RESPONSE: return "DB_LOAD_PC_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_SKILL_DATA_RESPONSE: return "DB_LOAD_PC_SKILL_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_PRESET_DATA_RESPONSE: return "DB_LOAD_PC_PRESET_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_PC_PURSE_DATA_RESPONSE: return "DB_LOAD_PC_PC_PURSE_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_MAIL_DATA_RESPONSE: return "DB_LOAD_PC_MAIL_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_DAILY_DUNGEON_DATA_RESPONSE: return "DB_LOAD_PC_DAILY_DUNGEON_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_SHOP_PURCHASED_DATA_RESPONSE: return "DB_LOAD_PC_SHOP_PURCHASED_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_STORAGE_DATA_RESPONSE: return "DB_LOAD_PC_STORAGE_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_ITEM_DATA_RESPONSE: return "DB_LOAD_PC_ITEM_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_FOLLOWER_DATA_RESPONSE: return "DB_LOAD_PC_FOLLOWER_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_QUEST_DATA_RESPONSE: return "DB_LOAD_PC_QUEST_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_CHAPTER_DATA_RESPONSE: return "DB_LOAD_PC_CHAPTER_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_SOLO_DUNGEON_DATA_RESPONSE: return "DB_LOAD_PC_SOLO_DUNGEON_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_TICKET_DATA_RESPONSE: return "DB_LOAD_PC_TICKET_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_ARENA_DATA_RESPONSE: return "DB_LOAD_PC_ARENA_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_INFLUENCE_DATA_RESPONSE: return "DB_LOAD_PC_INFLUENCE_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_MAIN_STREAM_DATA_RESPONSE: return "DB_LOAD_PC_MAIN_STREAM_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_DAILY_HOMEWORK_DATA_RESPONSE: return "DB_LOAD_PC_DAILY_HOMEWORK_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_INFINITE_TOWER_DATA_RESPONSE: return "DB_LOAD_PC_INFINITE_TOWER_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_ENTER_COUNTS_RESPONSE: return "DB_LOAD_PC_ENTER_COUNTS_RESPONSE";
    case Protocol_DB_LOAD_PC_ATTENDANCE_RESPONSE: return "DB_LOAD_PC_ATTENDANCE_RESPONSE";
    case Protocol_DB_LOAD_PC_ACCESS_TIME_RESPONSE: return "DB_LOAD_PC_ACCESS_TIME_RESPONSE";
    case Protocol_DB_LOAD_PC_REST_TIME_RESPONSE: return "DB_LOAD_PC_REST_TIME_RESPONSE";
    case Protocol_DB_LOAD_PC_INFLUENCE_RESPONSE: return "DB_LOAD_PC_INFLUENCE_RESPONSE";
    case Protocol_DB_LOAD_PC_SPECIAL_GROWTH_RESPONSE: return "DB_LOAD_PC_SPECIAL_GROWTH_RESPONSE";
    case Protocol_DB_LOAD_PC_BUDDY_RESPONSE: return "DB_LOAD_PC_BUDDY_RESPONSE";
    case Protocol_DB_LOAD_PC_SHORT_TERM_DATA_RESPONSE: return "DB_LOAD_PC_SHORT_TERM_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_ACCOUNT_PURSE_DATA_RESPONSE: return "DB_LOAD_PC_ACCOUNT_PURSE_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_ACCOUNT_DEPOT_DATA_RESPONSE: return "DB_LOAD_PC_ACCOUNT_DEPOT_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_ACCOUNT_ARTIFACT_DATA_RESPONSE: return "DB_LOAD_PC_ACCOUNT_ARTIFACT_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_ACCOUNT_SHOP_PURCHASE_LIMIT_COUNT_RESPONSE: return "DB_LOAD_PC_ACCOUNT_SHOP_PURCHASE_LIMIT_COUNT_RESPONSE";
    case Protocol_DB_LOAD_PC_ACCOUNT_SHOP_PURCHASE_DATA_RESPONSE: return "DB_LOAD_PC_ACCOUNT_SHOP_PURCHASE_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_BUFF_LIST_RESPONSE: return "DB_LOAD_PC_BUFF_LIST_RESPONSE";
    case Protocol_DB_LOAD_PC_ACCOUNT_MAIL_DATA_RESPONSE: return "DB_LOAD_PC_ACCOUNT_MAIL_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_KILLER_LIST_DATA_RESPONSE: return "DB_LOAD_PC_KILLER_LIST_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_KILL_ASSIST_COUNT_DATA_RESPONSE: return "DB_LOAD_PC_KILL_ASSIST_COUNT_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_BATTLE_FIELD_COLLECTION_RESPONSE: return "DB_LOAD_PC_BATTLE_FIELD_COLLECTION_RESPONSE";
    case Protocol_DB_LOAD_PC_GUILD_DUNGEON_RESPONSE: return "DB_LOAD_PC_GUILD_DUNGEON_RESPONSE";
    case Protocol_DB_LOAD_PC_COSTUME_PRESET_DATA_RESPONSE: return "DB_LOAD_PC_COSTUME_PRESET_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_LIVE_EVENT_TRADE_RESPONSE: return "DB_LOAD_PC_LIVE_EVENT_TRADE_RESPONSE";
    case Protocol_DB_LOAD_PC_LIVE_EVENT_DIA_BUY_RESPONSE: return "DB_LOAD_PC_LIVE_EVENT_DIA_BUY_RESPONSE";
    case Protocol_DB_LOAD_PC_LIVE_EVENT_DIA_SPENT_RESPONSE: return "DB_LOAD_PC_LIVE_EVENT_DIA_SPENT_RESPONSE";
    case Protocol_DB_LOAD_PC_LIVE_EVENT_LIMIT_SELL_SHOP_RESPONSE: return "DB_LOAD_PC_LIVE_EVENT_LIMIT_SELL_SHOP_RESPONSE";
    case Protocol_DB_LOAD_PC_ACCOUNT_LIVE_EVENT_LIMIT_SELL_SHOP_RESPONSE: return "DB_LOAD_PC_ACCOUNT_LIVE_EVENT_LIMIT_SELL_SHOP_RESPONSE";
    case Protocol_DB_LOAD_PC_ACCOUNT_LIVE_EVENT_ATTENTION_RESPONSE: return "DB_LOAD_PC_ACCOUNT_LIVE_EVENT_ATTENTION_RESPONSE";
    case Protocol_DB_LOAD_PC_BRAWL_SHORT_TERM_DATA_RESPONSE: return "DB_LOAD_PC_BRAWL_SHORT_TERM_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_BRAWL_DAILY_ACQUIRED_DATA_RESPONSE: return "DB_LOAD_PC_BRAWL_DAILY_ACQUIRED_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_BRAWL_ENHANCE_DATA_RESPONSE: return "DB_LOAD_PC_BRAWL_ENHANCE_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_SCROLL_QUEST_DATA_RESPONSE: return "DB_LOAD_PC_SCROLL_QUEST_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_BRAWL_LAST_LEAVED_TIME_DATA_RESPONSE: return "DB_LOAD_PC_BRAWL_LAST_LEAVED_TIME_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_LIVE_EVENT_LEVELUP_RESPONSE: return "DB_LOAD_PC_LIVE_EVENT_LEVELUP_RESPONSE";
    case Protocol_DB_LOAD_PC_ACCOUNT_PET_DATA_RESPONSE: return "DB_LOAD_PC_ACCOUNT_PET_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_ACCOUNT_PET_ALTAR_DATA_RESPONSE: return "DB_LOAD_PC_ACCOUNT_PET_ALTAR_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_ACCOUNT_PET_HATCHERY_DATA_RESPONSE: return "DB_LOAD_PC_ACCOUNT_PET_HATCHERY_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_CRYSTAL_CHANGE_COUNT_DATA_RESPONSE: return "DB_LOAD_PC_CRYSTAL_CHANGE_COUNT_DATA_RESPONSE";
    case Protocol_DB_LOAD_PC_ACCOUNT_LAST_LOGOUT_BY_MY_PCS_RESPONSE: return "DB_LOAD_PC_ACCOUNT_LAST_LOGOUT_BY_MY_PCS_RESPONSE";
    case Protocol_DB_LOAD_PC_PVPCOIN_DAILY_ACQUIRED_DATA_RESPONSE: return "DB_LOAD_PC_PVPCOIN_DAILY_ACQUIRED_DATA_RESPONSE";
    case Protocol_DB_UPDATE_PC_UPDATE_DATA_NOTIFY: return "DB_UPDATE_PC_UPDATE_DATA_NOTIFY";
    case Protocol_DB_UPDATE_QUEST_UPDATE_DATA_NOTIFY: return "DB_UPDATE_QUEST_UPDATE_DATA_NOTIFY";
    case Protocol_DB_UPDATE_ACCESS_TIME_DATA_NOTIFY: return "DB_UPDATE_ACCESS_TIME_DATA_NOTIFY";
    case Protocol_DB_UPDATE_REST_TIME_DATA_NOTIFY: return "DB_UPDATE_REST_TIME_DATA_NOTIFY";
    case Protocol_DB_ACCESS_TIME_REWARD_REQUEST: return "DB_ACCESS_TIME_REWARD_REQUEST";
    case Protocol_DB_ACCESS_TIME_REWARD_RESPONSE: return "DB_ACCESS_TIME_REWARD_RESPONSE";
    case Protocol_DB_ACCESS_TIME_SET_REQUEST: return "DB_ACCESS_TIME_SET_REQUEST";
    case Protocol_DB_ACCESS_TIME_SET_RESPONSE: return "DB_ACCESS_TIME_SET_RESPONSE";
    case Protocol_DB_REST_TIME_REWARD_REQUEST: return "DB_REST_TIME_REWARD_REQUEST";
    case Protocol_DB_REST_TIME_REWARD_RESPONSE: return "DB_REST_TIME_REWARD_RESPONSE";
    case Protocol_DB_REST_TIME_SET_REQUEST: return "DB_REST_TIME_SET_REQUEST";
    case Protocol_DB_REST_TIME_SET_RESPONSE: return "DB_REST_TIME_SET_RESPONSE";
    case Protocol_DB_UPC_CACHE_DATA_REQUEST: return "DB_UPC_CACHE_DATA_REQUEST";
    case Protocol_DB_UPC_CACHE_DATA_RESPONSE: return "DB_UPC_CACHE_DATA_RESPONSE";
    case Protocol_DB_ARENA_SCORE_UPDATE_REQUEST: return "DB_ARENA_SCORE_UPDATE_REQUEST";
    case Protocol_DB_CHANNEL_MOVE_TIME_UPDATE_REQUEST: return "DB_CHANNEL_MOVE_TIME_UPDATE_REQUEST";
    case Protocol_DB_CHANNEL_MOVE_TIME_UPDATE_RESPONSE: return "DB_CHANNEL_MOVE_TIME_UPDATE_RESPONSE";
    case Protocol_DB_BATTLE_FIELD_SET_TIME_REQUEST: return "DB_BATTLE_FIELD_SET_TIME_REQUEST";
    case Protocol_DB_BATTLE_FIELD_SET_TIME_RESPONSE: return "DB_BATTLE_FIELD_SET_TIME_RESPONSE";
    case Protocol_DB_BATTLE_FIELD_DAILY_RESET_REQUEST: return "DB_BATTLE_FIELD_DAILY_RESET_REQUEST";
    case Protocol_DB_BATTLE_FIELD_DAILY_RESET_RESPONSE: return "DB_BATTLE_FIELD_DAILY_RESET_RESPONSE";
    case Protocol_DB_BATTLE_FIELD_SET_SHORT_TERM_REQUEST: return "DB_BATTLE_FIELD_SET_SHORT_TERM_REQUEST";
    case Protocol_DB_BATTLE_FIELD_SET_SHORT_TERM_RESPONSE: return "DB_BATTLE_FIELD_SET_SHORT_TERM_RESPONSE";
    case Protocol_DB_ARENA_TODAY_PLAY_COUNT_UPDATE_REQUEST: return "DB_ARENA_TODAY_PLAY_COUNT_UPDATE_REQUEST";
    case Protocol_DB_ARENA_TODAY_PLAY_COUNT_UPDATE_RESPONSE: return "DB_ARENA_TODAY_PLAY_COUNT_UPDATE_RESPONSE";
    case Protocol_DB_ARENA_TODAY_PLAY_COUNT_RESET_REQUEST: return "DB_ARENA_TODAY_PLAY_COUNT_RESET_REQUEST";
    case Protocol_DB_ARENA_TODAY_PLAY_COUNT_RESET_RESPONSE: return "DB_ARENA_TODAY_PLAY_COUNT_RESET_RESPONSE";
    case Protocol_DB_BATTLE_FIELD_SET_SHORT_TERM_MAIL_REQUEST: return "DB_BATTLE_FIELD_SET_SHORT_TERM_MAIL_REQUEST";
    case Protocol_DB_BATTLE_FIELD_SET_SHORT_TERM_MAIL_RESPONSE: return "DB_BATTLE_FIELD_SET_SHORT_TERM_MAIL_RESPONSE";
    case Protocol_DB_KILLER_INFO_SET_REQUEST: return "DB_KILLER_INFO_SET_REQUEST";
    case Protocol_DB_KILLER_INFO_SET_RESPONSE: return "DB_KILLER_INFO_SET_RESPONSE";
    case Protocol_DB_KILL_ASSIST_COUNT_SET_REQUEST: return "DB_KILL_ASSIST_COUNT_SET_REQUEST";
    case Protocol_DB_KILL_ASSIST_COUNT_SET_RESPONSE: return "DB_KILL_ASSIST_COUNT_SET_RESPONSE";
    case Protocol_DB_EVENT_REWARD_REQUEST: return "DB_EVENT_REWARD_REQUEST";
    case Protocol_DB_EVENT_REWARD_RESPONSE: return "DB_EVENT_REWARD_RESPONSE";
    case Protocol_DB_PLAYER_STAT_SAVE_REQUEST: return "DB_PLAYER_STAT_SAVE_REQUEST";
    case Protocol_DB_PLAYER_STAT_SAVE_RESPONSE: return "DB_PLAYER_STAT_SAVE_RESPONSE";
    case Protocol_DB_GUILD_DUNGEON_CLEAR_REQUEST: return "DB_GUILD_DUNGEON_CLEAR_REQUEST";
    case Protocol_DB_GUILD_DUNGEON_CLEAR_RESPONSE: return "DB_GUILD_DUNGEON_CLEAR_RESPONSE";
    case Protocol_DB_GUILD_DUNGEON_REWARD_REQUEST: return "DB_GUILD_DUNGEON_REWARD_REQUEST";
    case Protocol_DB_GUILD_DUNGEON_REWARD_RESPONSE: return "DB_GUILD_DUNGEON_REWARD_RESPONSE";
    case Protocol_DB_COSTUME_PRESET_TYPE_UPDATE_REQUEST: return "DB_COSTUME_PRESET_TYPE_UPDATE_REQUEST";
    case Protocol_DB_COSTUME_PRESET_TYPE_UPDATE_RESPONSE: return "DB_COSTUME_PRESET_TYPE_UPDATE_RESPONSE";
    case Protocol_DB_COSTUME_PRESET_UPDATE_REQUEST: return "DB_COSTUME_PRESET_UPDATE_REQUEST";
    case Protocol_DB_COSTUME_PRESET_UPDATE_RESPONSE: return "DB_COSTUME_PRESET_UPDATE_RESPONSE";
    case Protocol_DB_ENCHANT_COSTUME_REQUEST: return "DB_ENCHANT_COSTUME_REQUEST";
    case Protocol_DB_ENCHANT_COSTUME_RESPONSE: return "DB_ENCHANT_COSTUME_RESPONSE";
    case Protocol_DB_UPGRADE_COSTUME_REQUEST: return "DB_UPGRADE_COSTUME_REQUEST";
    case Protocol_DB_UPGRADE_COSTUME_RESPONSE: return "DB_UPGRADE_COSTUME_RESPONSE";
    case Protocol_DB_INHERIT_COSTUME_REQUEST: return "DB_INHERIT_COSTUME_REQUEST";
    case Protocol_DB_INHERIT_COSTUME_RESPONSE: return "DB_INHERIT_COSTUME_RESPONSE";
    case Protocol_DB_LIVE_EVENT_TRADE_PURCHAES_REQUEST: return "DB_LIVE_EVENT_TRADE_PURCHAES_REQUEST";
    case Protocol_DB_LIVE_EVENT_TRADE_PURCHAES_RESPONSE: return "DB_LIVE_EVENT_TRADE_PURCHAES_RESPONSE";
    case Protocol_DB_LIVE_EVENT_LIMIT_SELL_SHOP_PURCHAES_REQUEST: return "DB_LIVE_EVENT_LIMIT_SELL_SHOP_PURCHAES_REQUEST";
    case Protocol_DB_LIVE_EVENT_LIMIT_SELL_SHOP_PURCHAES_RESPONSE: return "DB_LIVE_EVENT_LIMIT_SELL_SHOP_PURCHAES_RESPONSE";
    case Protocol_DB_LIVE_EVENT_DIA_BUY_REWARD_REQUEST: return "DB_LIVE_EVENT_DIA_BUY_REWARD_REQUEST";
    case Protocol_DB_LIVE_EVENT_DIA_BUY_REWARD_RESPONSE: return "DB_LIVE_EVENT_DIA_BUY_REWARD_RESPONSE";
    case Protocol_DB_LIVE_EVENT_DIA_BUY_UPDATE_AMOUNT_NOTIFY: return "DB_LIVE_EVENT_DIA_BUY_UPDATE_AMOUNT_NOTIFY";
    case Protocol_DB_LIVE_EVENT_DIA_SPENT_REWARD_REQUEST: return "DB_LIVE_EVENT_DIA_SPENT_REWARD_REQUEST";
    case Protocol_DB_LIVE_EVENT_DIA_SPENT_REWARD_RESPONSE: return "DB_LIVE_EVENT_DIA_SPENT_REWARD_RESPONSE";
    case Protocol_DB_LIVE_EVENT_DIA_SPENT_UPDATE_AMOUNT_NOTIFY: return "DB_LIVE_EVENT_DIA_SPENT_UPDATE_AMOUNT_NOTIFY";
    case Protocol_DB_LIVE_EVENT_ATTENTION_RECEIVE_STATE_REQUEST: return "DB_LIVE_EVENT_ATTENTION_RECEIVE_STATE_REQUEST";
    case Protocol_DB_LIVE_EVENT_ATTENTION_RECEIVE_STATE_RESPONSE: return "DB_LIVE_EVENT_ATTENTION_RECEIVE_STATE_RESPONSE";
    case Protocol_DB_LIVE_EVENT_RETURN_ATTENTION_RECEIVE_STATE_REQUEST: return "DB_LIVE_EVENT_RETURN_ATTENTION_RECEIVE_STATE_REQUEST";
    case Protocol_DB_LIVE_EVENT_RETURN_ATTENTION_RECEIVE_STATE_RESPONSE: return "DB_LIVE_EVENT_RETURN_ATTENTION_RECEIVE_STATE_RESPONSE";
    case Protocol_DB_LIVE_EVENT_NEWBIE_ATTENTION_RECEIVE_STATE_REQUEST: return "DB_LIVE_EVENT_NEWBIE_ATTENTION_RECEIVE_STATE_REQUEST";
    case Protocol_DB_LIVE_EVENT_NEWBIE_ATTENTION_RECEIVE_STATE_RESPONSE: return "DB_LIVE_EVENT_NEWBIE_ATTENTION_RECEIVE_STATE_RESPONSE";
    case Protocol_DB_LIVE_EVENT_ATTENTION_REWARD_REQUEST: return "DB_LIVE_EVENT_ATTENTION_REWARD_REQUEST";
    case Protocol_DB_LIVE_EVENT_ATTENTION_REWARD_RESPONSE: return "DB_LIVE_EVENT_ATTENTION_REWARD_RESPONSE";
    case Protocol_DB_LIVE_EVENT_RETURN_ATTENTION_REWARD_REQUEST: return "DB_LIVE_EVENT_RETURN_ATTENTION_REWARD_REQUEST";
    case Protocol_DB_LIVE_EVENT_RETURN_ATTENTION_REWARD_RESPONSE: return "DB_LIVE_EVENT_RETURN_ATTENTION_REWARD_RESPONSE";
    case Protocol_DB_LIVE_EVENT_NEWBIE_ATTENTION_REWARD_REQUEST: return "DB_LIVE_EVENT_NEWBIE_ATTENTION_REWARD_REQUEST";
    case Protocol_DB_LIVE_EVENT_NEWBIE_ATTENTION_REWARD_RESPONSE: return "DB_LIVE_EVENT_NEWBIE_ATTENTION_REWARD_RESPONSE";
    case Protocol_DB_LIVE_EVENT_ATTENTION_END_RECEIVE_STATE_REQUEST: return "DB_LIVE_EVENT_ATTENTION_END_RECEIVE_STATE_REQUEST";
    case Protocol_DB_LIVE_EVENT_ATTENTION_END_RECEIVE_STATE_RESPONSE: return "DB_LIVE_EVENT_ATTENTION_END_RECEIVE_STATE_RESPONSE";
    case Protocol_DB_LIVE_EVENT_RETURN_ATTENTION_END_RECEIVE_STATE_REQUEST: return "DB_LIVE_EVENT_RETURN_ATTENTION_END_RECEIVE_STATE_REQUEST";
    case Protocol_DB_LIVE_EVENT_RETURN_ATTENTION_END_RECEIVE_STATE_RESPONSE: return "DB_LIVE_EVENT_RETURN_ATTENTION_END_RECEIVE_STATE_RESPONSE";
    case Protocol_DB_LIVE_EVENT_NEWBIE_ATTENTION_END_RECEIVE_STATE_REQUEST: return "DB_LIVE_EVENT_NEWBIE_ATTENTION_END_RECEIVE_STATE_REQUEST";
    case Protocol_DB_LIVE_EVENT_NEWBIE_ATTENTION_END_RECEIVE_STATE_RESPONSE: return "DB_LIVE_EVENT_NEWBIE_ATTENTION_END_RECEIVE_STATE_RESPONSE";
    case Protocol_DB_LIVE_EVENT_ATTENTION_END_REWARD_REQUEST: return "DB_LIVE_EVENT_ATTENTION_END_REWARD_REQUEST";
    case Protocol_DB_LIVE_EVENT_ATTENTION_END_REWARD_RESPONSE: return "DB_LIVE_EVENT_ATTENTION_END_REWARD_RESPONSE";
    case Protocol_DB_LIVE_EVENT_RETURN_ATTENTION_END_REWARD_REQUEST: return "DB_LIVE_EVENT_RETURN_ATTENTION_END_REWARD_REQUEST";
    case Protocol_DB_LIVE_EVENT_RETURN_ATTENTION_END_REWARD_RESPONSE: return "DB_LIVE_EVENT_RETURN_ATTENTION_END_REWARD_RESPONSE";
    case Protocol_DB_LIVE_EVENT_NEWBIE_ATTENTION_END_REWARD_REQUEST: return "DB_LIVE_EVENT_NEWBIE_ATTENTION_END_REWARD_REQUEST";
    case Protocol_DB_LIVE_EVENT_NEWBIE_ATTENTION_END_REWARD_RESPONSE: return "DB_LIVE_EVENT_NEWBIE_ATTENTION_END_REWARD_RESPONSE";
    case Protocol_DB_LIVE_EVENT_LEVELUP_RECEIVE_STATE_REQUEST: return "DB_LIVE_EVENT_LEVELUP_RECEIVE_STATE_REQUEST";
    case Protocol_DB_LIVE_EVENT_LEVELUP_RECEIVE_STATE_RESPONSE: return "DB_LIVE_EVENT_LEVELUP_RECEIVE_STATE_RESPONSE";
    case Protocol_DB_LIVE_EVENT_LEVELUP_REWARD_REQUEST: return "DB_LIVE_EVENT_LEVELUP_REWARD_REQUEST";
    case Protocol_DB_LIVE_EVENT_LEVELUP_REWARD_RESPONSE: return "DB_LIVE_EVENT_LEVELUP_REWARD_RESPONSE";
    case Protocol_DB_STORAGE_SLOT_EXPANSION_REQUEST: return "DB_STORAGE_SLOT_EXPANSION_REQUEST";
    case Protocol_DB_STORAGE_SLOT_EXPANSION_RESPONSE: return "DB_STORAGE_SLOT_EXPANSION_RESPONSE";
    case Protocol_DB_BRAWL_SET_TIME_REQUEST: return "DB_BRAWL_SET_TIME_REQUEST";
    case Protocol_DB_BRAWL_SET_TIME_RESPONSE: return "DB_BRAWL_SET_TIME_RESPONSE";
    case Protocol_DB_BRAWL_SET_SHORT_TERM_REQUEST: return "DB_BRAWL_SET_SHORT_TERM_REQUEST";
    case Protocol_DB_BRAWL_SET_SHORT_TERM_RESPONSE: return "DB_BRAWL_SET_SHORT_TERM_RESPONSE";
    case Protocol_DB_BRAWL_SHORT_TERM_REWARD_REQUEST: return "DB_BRAWL_SHORT_TERM_REWARD_REQUEST";
    case Protocol_DB_BRAWL_SHORT_TERM_REWARD_RESPONSE: return "DB_BRAWL_SHORT_TERM_REWARD_RESPONSE";
    case Protocol_DB_BRAWL_SET_POINT_REQEUST: return "DB_BRAWL_SET_POINT_REQEUST";
    case Protocol_DB_BRAWL_SET_POINT_RESPONSE: return "DB_BRAWL_SET_POINT_RESPONSE";
    case Protocol_DB_BRAWL_ENHANCE_LEVEL_UP_REQUEST: return "DB_BRAWL_ENHANCE_LEVEL_UP_REQUEST";
    case Protocol_DB_BRAWL_ENHANCE_LEVEL_UP_RESPONSE: return "DB_BRAWL_ENHANCE_LEVEL_UP_RESPONSE";
    case Protocol_DB_BRAWL_SET_DAILY_ACQUIRED_REQEUST: return "DB_BRAWL_SET_DAILY_ACQUIRED_REQEUST";
    case Protocol_DB_BRAWL_SET_DAILY_ACQUIRED_RESPONSE: return "DB_BRAWL_SET_DAILY_ACQUIRED_RESPONSE";
    case Protocol_DB_SCROLL_QUEST_USE_SCROLL_GROUP_ITEM_REQUEST: return "DB_SCROLL_QUEST_USE_SCROLL_GROUP_ITEM_REQUEST";
    case Protocol_DB_SCROLL_QUEST_USE_SCROLL_GROUP_ITEM_RESPONSE: return "DB_SCROLL_QUEST_USE_SCROLL_GROUP_ITEM_RESPONSE";
    case Protocol_DB_SCROLL_QUEST_PROGRESS_SET_REQUEST: return "DB_SCROLL_QUEST_PROGRESS_SET_REQUEST";
    case Protocol_DB_SCROLL_QUEST_PROGRESS_SET_RESPONSE: return "DB_SCROLL_QUEST_PROGRESS_SET_RESPONSE";
    case Protocol_DB_SCROLL_QUEST_DAILY_SET_REQUEST: return "DB_SCROLL_QUEST_DAILY_SET_REQUEST";
    case Protocol_DB_SCROLL_QUEST_DAILY_SET_RESPONSE: return "DB_SCROLL_QUEST_DAILY_SET_RESPONSE";
    case Protocol_DB_SCROLL_QUEST_REWARD_REQUEST: return "DB_SCROLL_QUEST_REWARD_REQUEST";
    case Protocol_DB_SCROLL_QUEST_REWARD_RESPONSE: return "DB_SCROLL_QUEST_REWARD_RESPONSE";
    case Protocol_DB_UPDATE_PVP_POINT_REQEUST: return "DB_UPDATE_PVP_POINT_REQEUST";
    case Protocol_DB_UPDATE_PVP_POINT_RESPONSE: return "DB_UPDATE_PVP_POINT_RESPONSE";
    case Protocol_DB_SET_PVP_COIN_DAILY_ACQUIRED_REQEUST: return "DB_SET_PVP_COIN_DAILY_ACQUIRED_REQEUST";
    case Protocol_DB_SET_PVP_COIN_DAILY_ACQUIRED_RESPONSE: return "DB_SET_PVP_COIN_DAILY_ACQUIRED_RESPONSE";
    case Protocol_PC_LOGIN_DATA_NOTIFY: return "PC_LOGIN_DATA_NOTIFY";
    case Protocol_LOAD_DATA_REQUEST: return "LOAD_DATA_REQUEST";
    case Protocol_LOAD_DATA_RESPONSE: return "LOAD_DATA_RESPONSE";
    case Protocol_WORLDOBJECT_DESPAWN_NOTIFY: return "WORLDOBJECT_DESPAWN_NOTIFY";
    case Protocol_PC_SPAWN_NOTIFY: return "PC_SPAWN_NOTIFY";
    case Protocol_NPC_SPAWN_NOTIFY: return "NPC_SPAWN_NOTIFY";
    case Protocol_PROJECTILE_SPAWN_NOTIFY: return "PROJECTILE_SPAWN_NOTIFY";
    case Protocol_INSTANTSHOT_SPAWN_NOTIFY: return "INSTANTSHOT_SPAWN_NOTIFY";
    case Protocol_INSTANTSHOT_DESPAWN_NOTIFY: return "INSTANTSHOT_DESPAWN_NOTIFY";
    case Protocol_PROJECTILE_EFFECT_NOTIFY: return "PROJECTILE_EFFECT_NOTIFY";
    case Protocol_REACTION_ENTER_NOTIFY: return "REACTION_ENTER_NOTIFY";
    case Protocol_REACTION_LEAVE_NOTIFY: return "REACTION_LEAVE_NOTIFY";
    case Protocol_REACTION_UPDATE_NOTIFY: return "REACTION_UPDATE_NOTIFY";
    case Protocol_ENTER_STATE_NOTIFY: return "ENTER_STATE_NOTIFY";
    case Protocol_LEAVE_STATE_NOTIFY: return "LEAVE_STATE_NOTIFY";
    case Protocol_PLAYER_REVIVE_REQUEST: return "PLAYER_REVIVE_REQUEST";
    case Protocol_PLAYER_REVIVE_RESPONSE: return "PLAYER_REVIVE_RESPONSE";
    case Protocol_UPC_SPAWN_NOTIFY: return "UPC_SPAWN_NOTIFY";
    case Protocol_PLAYER_IMMEDIATELY_DEAD_REQUEST: return "PLAYER_IMMEDIATELY_DEAD_REQUEST";
    case Protocol_PC_GUILD_INFO_UPDATE_NOTIFY: return "PC_GUILD_INFO_UPDATE_NOTIFY";
    case Protocol_AGGRO_TICKER_INFO_NOTIFY: return "AGGRO_TICKER_INFO_NOTIFY";
    case Protocol_UPC_LOAD_START_NOTIFY: return "UPC_LOAD_START_NOTIFY";
    case Protocol_UPC_LOAD_FINISH_NOTIFY: return "UPC_LOAD_FINISH_NOTIFY";
    case Protocol_UPC_HOST_REQUEST: return "UPC_HOST_REQUEST";
    case Protocol_UPC_HOST_RESPONSE: return "UPC_HOST_RESPONSE";
    case Protocol_UPC_UNHOST_NOTIFY: return "UPC_UNHOST_NOTIFY";
    case Protocol_PC_STAT_HARDCAP_DATA_NOTIFY: return "PC_STAT_HARDCAP_DATA_NOTIFY";
    case Protocol_STORAGE_DATA_NOTIFY: return "STORAGE_DATA_NOTIFY";
    case Protocol_STORAGE_ITEM_DATA_NOTIFY: return "STORAGE_ITEM_DATA_NOTIFY";
    case Protocol_EQUIP_DATA_NOTIFY: return "EQUIP_DATA_NOTIFY";
    case Protocol_UPC_LOAD_START_NOTIFY_REQUEST: return "UPC_LOAD_START_NOTIFY_REQUEST";
    case Protocol_PC_PK_HONOR_INFO_REQUEST: return "PC_PK_HONOR_INFO_REQUEST";
    case Protocol_PC_PK_HONOR_INFO_RESPONSE: return "PC_PK_HONOR_INFO_RESPONSE";
    case Protocol_KILL_ASSIST_COUNT_NOTIFY: return "KILL_ASSIST_COUNT_NOTIFY";
    case Protocol_PLAYER_DESPAWN_NOTIFY: return "PLAYER_DESPAWN_NOTIFY";
    case Protocol_SKILL_USE_NOTIFY: return "SKILL_USE_NOTIFY";
    case Protocol_SKILL_START_NOTIFY: return "SKILL_START_NOTIFY";
    case Protocol_SKILL_END_NOTIFY: return "SKILL_END_NOTIFY";
    case Protocol_SKILL_EFFECT_NOTIFY: return "SKILL_EFFECT_NOTIFY";
    case Protocol_SKILL_EFFECT_RESULT_NOTIFY: return "SKILL_EFFECT_RESULT_NOTIFY";
    case Protocol_SKILL_SLOT_NOTIFY: return "SKILL_SLOT_NOTIFY";
    case Protocol_SKILL_OPEN_SHIELD_NOTIFY: return "SKILL_OPEN_SHIELD_NOTIFY";
    case Protocol_STAT_UPDATE_NOTIFY: return "STAT_UPDATE_NOTIFY";
    case Protocol_SKILL_ERROR_NOTIFY: return "SKILL_ERROR_NOTIFY";
    case Protocol_SKILL_CLOSED_SHIELD_NOTIFY: return "SKILL_CLOSED_SHIELD_NOTIFY";
    case Protocol_SKILL_EFFECT_RESULT_DAMAGE_NOTIFY: return "SKILL_EFFECT_RESULT_DAMAGE_NOTIFY";
    case Protocol_SKILL_EFFECT_RESULT_HEAL_NOTIFY: return "SKILL_EFFECT_RESULT_HEAL_NOTIFY";
    case Protocol_SKILL_SLOT_PLACE_REQUEST: return "SKILL_SLOT_PLACE_REQUEST";
    case Protocol_SKILL_SLOT_PLACE_RESPONSE: return "SKILL_SLOT_PLACE_RESPONSE";
    case Protocol_SKILL_LEVEL_UP_REQUEST: return "SKILL_LEVEL_UP_REQUEST";
    case Protocol_SKILL_LEVEL_UP_RESPONSE: return "SKILL_LEVEL_UP_RESPONSE";
    case Protocol_CHANGE_IFF_NOTIFY: return "CHANGE_IFF_NOTIFY";
    case Protocol_UPDATE_ENERGYPOINT_NOTIFY: return "UPDATE_ENERGYPOINT_NOTIFY";
    case Protocol_PRESET_CHANGE_REQUEST: return "PRESET_CHANGE_REQUEST";
    case Protocol_PRESET_CHANGE_RESPONSE: return "PRESET_CHANGE_RESPONSE";
    case Protocol_PRESET_ITEMSLOT_UPDATE_NOTIFY: return "PRESET_ITEMSLOT_UPDATE_NOTIFY";
    case Protocol_SKILL_FEATURE_INITIALIZE_REQUEST: return "SKILL_FEATURE_INITIALIZE_REQUEST";
    case Protocol_SKILL_FEATURE_INITIALIZE_RESPONSE: return "SKILL_FEATURE_INITIALIZE_RESPONSE";
    case Protocol_UPDATE_SKILL_POINT_NOTIFY: return "UPDATE_SKILL_POINT_NOTIFY";
    case Protocol_PLAYER_REVIVE_INFO_NOTIFY: return "PLAYER_REVIVE_INFO_NOTIFY";
    case Protocol_SWITCH_SKILL_SLOT_REQUEST: return "SWITCH_SKILL_SLOT_REQUEST";
    case Protocol_ADD_BUFF_NOTIFY: return "ADD_BUFF_NOTIFY";
    case Protocol_UPDATE_BUFF_NOTIFY: return "UPDATE_BUFF_NOTIFY";
    case Protocol_CREATURE_HP_CHANGE_NOTIFY: return "CREATURE_HP_CHANGE_NOTIFY";
    case Protocol_CHANGED_SUPER_ARMOR_GAUGE_NOTIFY: return "CHANGED_SUPER_ARMOR_GAUGE_NOTIFY";
    case Protocol_PENALTY_SKILL_NOTIFY: return "PENALTY_SKILL_NOTIFY";
    case Protocol_PENALTY_SKILL_CANCEL_NOTIFY: return "PENALTY_SKILL_CANCEL_NOTIFY";
    case Protocol_CHANGE_REACTION_IMMUNE_INFO_NOTIFY: return "CHANGE_REACTION_IMMUNE_INFO_NOTIFY";
    case Protocol_NPC_AGGRO_TIMER_NOTIFY: return "NPC_AGGRO_TIMER_NOTIFY";
    case Protocol_CREATURE_TARGETED_NOTIFY: return "CREATURE_TARGETED_NOTIFY";
    case Protocol_NPC_RETURN_WARNING_NOTIFY: return "NPC_RETURN_WARNING_NOTIFY";
    case Protocol_AI_ACTION_START_NOTIFY: return "AI_ACTION_START_NOTIFY";
    case Protocol_AI_ACTION_END_NOTIFY: return "AI_ACTION_END_NOTIFY";
    case Protocol_CREATURE_DETECT_TARGET_NOTIFY: return "CREATURE_DETECT_TARGET_NOTIFY";
    case Protocol_SOCIAL_MOTION_START_REQUEST: return "SOCIAL_MOTION_START_REQUEST";
    case Protocol_SOCIAL_MOTION_START_NOTIFY: return "SOCIAL_MOTION_START_NOTIFY";
    case Protocol_INSERT_ITEM_RESPONSE: return "INSERT_ITEM_RESPONSE";
    case Protocol_DELETE_ITEM_REQUEST: return "DELETE_ITEM_REQUEST";
    case Protocol_DELETE_ITEM_RESPONSE: return "DELETE_ITEM_RESPONSE";
    case Protocol_EQUIP_ITEM_OBJECT_REQUEST: return "EQUIP_ITEM_OBJECT_REQUEST";
    case Protocol_EQUIP_ITEM_RESPONSE: return "EQUIP_ITEM_RESPONSE";
    case Protocol_UNEQUIP_ITEM_REQUEST: return "UNEQUIP_ITEM_REQUEST";
    case Protocol_UNEQUIP_ITEM_RESPONSE: return "UNEQUIP_ITEM_RESPONSE";
    case Protocol_REFRESH_INVEN_REQUEST: return "REFRESH_INVEN_REQUEST";
    case Protocol_REFRESH_INVEN_RESPONSE: return "REFRESH_INVEN_RESPONSE";
    case Protocol_SERVER_TIME_REQUEST: return "SERVER_TIME_REQUEST";
    case Protocol_SERVER_TIME_RESPONSE: return "SERVER_TIME_RESPONSE";
    case Protocol_UPDATE_ITEM_NOTIFY: return "UPDATE_ITEM_NOTIFY";
    case Protocol_TOGGLE_SAFE_GUARD_REQUEST: return "TOGGLE_SAFE_GUARD_REQUEST";
    case Protocol_TOGGLE_SAFE_GUARD_RESPONSE: return "TOGGLE_SAFE_GUARD_RESPONSE";
    case Protocol_USE_ITEM_REQUEST: return "USE_ITEM_REQUEST";
    case Protocol_USE_ITEM_RESPONSE: return "USE_ITEM_RESPONSE";
    case Protocol_ITEM_BOUND_STATE_UPDATE_NOTIFY: return "ITEM_BOUND_STATE_UPDATE_NOTIFY";
    case Protocol_ADD_ITEM_NOTIFY: return "ADD_ITEM_NOTIFY";
    case Protocol_REMOVE_ITEM_NOTIFY: return "REMOVE_ITEM_NOTIFY";
    case Protocol_CHANGE_ITEM_STACK_COUNT_NOTIFY: return "CHANGE_ITEM_STACK_COUNT_NOTIFY";
    case Protocol_UPDATE_ITEM_GRADE_LEVEL_NOTIFY: return "UPDATE_ITEM_GRADE_LEVEL_NOTIFY";
    case Protocol_UPDATE_ITEM_OPTION_NOTIFY: return "UPDATE_ITEM_OPTION_NOTIFY";
    case Protocol_MOVE_ITEM_NOTIFY: return "MOVE_ITEM_NOTIFY";
    case Protocol_UPDATE_ARTIFACT_NOTIFY: return "UPDATE_ARTIFACT_NOTIFY";
    case Protocol_FOLLOWER_ADD_SOUL_STONE_NOTIFY: return "FOLLOWER_ADD_SOUL_STONE_NOTIFY";
    case Protocol_FOLLOWER_ENCHANT_REQUEST: return "FOLLOWER_ENCHANT_REQUEST";
    case Protocol_FOLLOWER_ENCHANT_RESPONSE: return "FOLLOWER_ENCHANT_RESPONSE";
    case Protocol_FOLLOWER_START_MISSION_REQUEST: return "FOLLOWER_START_MISSION_REQUEST";
    case Protocol_FOLLOWER_START_MISSION_NOTIFY: return "FOLLOWER_START_MISSION_NOTIFY";
    case Protocol_FOLLOWER_END_MISSION_REQUEST: return "FOLLOWER_END_MISSION_REQUEST";
    case Protocol_FOLLOWER_END_MISSION_RESPONSE: return "FOLLOWER_END_MISSION_RESPONSE";
    case Protocol_FOLLOWER_MISSION_REMAIN_TIME_REQUEST: return "FOLLOWER_MISSION_REMAIN_TIME_REQUEST";
    case Protocol_FOLLOWER_MISSION_REMAIN_TIME_RESPONSE: return "FOLLOWER_MISSION_REMAIN_TIME_RESPONSE";
    case Protocol_FOLLOWER_LOAD_INFO_NOTIFY: return "FOLLOWER_LOAD_INFO_NOTIFY";
    case Protocol_FOLLOWER_MISSION_REWARD_RESPONSE: return "FOLLOWER_MISSION_REWARD_RESPONSE";
    case Protocol_FOLLOWER_MISSION_COMPLETE_REQUEST: return "FOLLOWER_MISSION_COMPLETE_REQUEST";
    case Protocol_FOLLOWER_MISSION_COMPLETE_RESPONSE: return "FOLLOWER_MISSION_COMPLETE_RESPONSE";
    case Protocol_DISENCHANT_ITEM_REQUEST: return "DISENCHANT_ITEM_REQUEST";
    case Protocol_DISENCHANT_ITEM_RESPONSE: return "DISENCHANT_ITEM_RESPONSE";
    case Protocol_ENCHANT_ITEM_REQUEST: return "ENCHANT_ITEM_REQUEST";
    case Protocol_ENCHANT_ITEM_RESPONSE: return "ENCHANT_ITEM_RESPONSE";
    case Protocol_EQUIPMENT_TRANSMUTATION_ITEM_REQUEST: return "EQUIPMENT_TRANSMUTATION_ITEM_REQUEST";
    case Protocol_EQUIPMENT_TRANSMUTATION_ITEM_RESPONSE: return "EQUIPMENT_TRANSMUTATION_ITEM_RESPONSE";
    case Protocol_UPGRADE_ITEM_REQUEST: return "UPGRADE_ITEM_REQUEST";
    case Protocol_UPGRADE_ITEM_RESPONSE: return "UPGRADE_ITEM_RESPONSE";
    case Protocol_CRAFT_ITEM_REQUEST: return "CRAFT_ITEM_REQUEST";
    case Protocol_CRAFT_ITEM_RESPONSE: return "CRAFT_ITEM_RESPONSE";
    case Protocol_PRISM_TRANSMUTATION_REQUEST: return "PRISM_TRANSMUTATION_REQUEST";
    case Protocol_PRISM_TRANSMUTATION_RESPONSE: return "PRISM_TRANSMUTATION_RESPONSE";
    case Protocol_MOVE_ITEM_REQUEST: return "MOVE_ITEM_REQUEST";
    case Protocol_MOVE_ITEM_RESPONSE: return "MOVE_ITEM_RESPONSE";
    case Protocol_TRANSMUTE_CRYSTAL_ITEM_REQUEST: return "TRANSMUTE_CRYSTAL_ITEM_REQUEST";
    case Protocol_TRANSMUTE_CRYSTAL_ITEM_RESPONSE: return "TRANSMUTE_CRYSTAL_ITEM_RESPONSE";
    case Protocol_CHANGE_CRYSTAL_ITEM_REQUEST: return "CHANGE_CRYSTAL_ITEM_REQUEST";
    case Protocol_CHANGE_CRYSTAL_ITEM_RESPONSE: return "CHANGE_CRYSTAL_ITEM_RESPONSE";
    case Protocol_CRYSTAL_ITEM_CHANGE_COUNT_NOTIFY: return "CRYSTAL_ITEM_CHANGE_COUNT_NOTIFY";
    case Protocol_TICKET_NOTIFY: return "TICKET_NOTIFY";
    case Protocol_TICKET_ALL_NOTIFY: return "TICKET_ALL_NOTIFY";
    case Protocol_ACQUIRE_CONTRIBUTION_NOTIFY: return "ACQUIRE_CONTRIBUTION_NOTIFY";
    case Protocol_BUNDLE_BOX_RESULT_NOTIFY: return "BUNDLE_BOX_RESULT_NOTIFY";
    case Protocol_ITEM_FUSION_REQUEST: return "ITEM_FUSION_REQUEST";
    case Protocol_ITEM_FUSION_RESPONSE: return "ITEM_FUSION_RESPONSE";
    case Protocol_USE_ITEM_CONTENTS_EFFECT_REQUEST: return "USE_ITEM_CONTENTS_EFFECT_REQUEST";
    case Protocol_USE_ITEM_CONTENTS_EFFECT_RESPONSE: return "USE_ITEM_CONTENTS_EFFECT_RESPONSE";
    case Protocol_TRANSCEND_ITEM_REQUEST: return "TRANSCEND_ITEM_REQUEST";
    case Protocol_TRANSCEND_ITEM_RESPONSE: return "TRANSCEND_ITEM_RESPONSE";
    case Protocol_TRANSCEND_CHANGE_STAT_REQUEST: return "TRANSCEND_CHANGE_STAT_REQUEST";
    case Protocol_TRANSCEND_CHANGE_STAT_RESPONSE: return "TRANSCEND_CHANGE_STAT_RESPONSE";
    case Protocol_PC_LEVEL_UP_EXP_NOTIFY: return "PC_LEVEL_UP_EXP_NOTIFY";
    case Protocol_PC_EXP_UP_NOTIFY: return "PC_EXP_UP_NOTIFY";
    case Protocol_DROP_REWARD_NOTIFY: return "DROP_REWARD_NOTIFY";
    case Protocol_SALE_ITEM_REQUEST: return "SALE_ITEM_REQUEST";
    case Protocol_SALE_ITEM_RESPONSE: return "SALE_ITEM_RESPONSE";
    case Protocol_UPDATE_PURSE_NOTIFY: return "UPDATE_PURSE_NOTIFY";
    case Protocol_WORKOBJECT_SPAWN_NOTIFY: return "WORKOBJECT_SPAWN_NOTIFY";
    case Protocol_WORKOBJECT_UPDATE_NOTIFY: return "WORKOBJECT_UPDATE_NOTIFY";
    case Protocol_INTERACTION_STATE_NOTIFY: return "INTERACTION_STATE_NOTIFY";
    case Protocol_START_INTERACTION_REQUEST: return "START_INTERACTION_REQUEST";
    case Protocol_START_RESURRECTION_REQUEST: return "START_RESURRECTION_REQUEST";
    case Protocol_START_RESURRECTION_NOTIFY: return "START_RESURRECTION_NOTIFY";
    case Protocol_END_RESURRECTION_NOTIFY: return "END_RESURRECTION_NOTIFY";
    case Protocol_CANCEL_RESURRECTION_REQUEST: return "CANCEL_RESURRECTION_REQUEST";
    case Protocol_CANCEL_RESURRECTION_NOTIFY: return "CANCEL_RESURRECTION_NOTIFY";
    case Protocol_START_MINIGAME_INTERACTION_NOTIFY: return "START_MINIGAME_INTERACTION_NOTIFY";
    case Protocol_START_DIALOG_INTERACTION_NOTIFY: return "START_DIALOG_INTERACTION_NOTIFY";
    case Protocol_OTHER_PC_START_INTERACTION_NOTIFY: return "OTHER_PC_START_INTERACTION_NOTIFY";
    case Protocol_MINIGAME_INTERACTION_RESULT_NOTIFY: return "MINIGAME_INTERACTION_RESULT_NOTIFY";
    case Protocol_CANCEL_INTERACTION_NOTIFY: return "CANCEL_INTERACTION_NOTIFY";
    case Protocol_END_INTERACTION_NOTIFY: return "END_INTERACTION_NOTIFY";
    case Protocol_OTHER_PC_END_INTERACTION_NOTIFY: return "OTHER_PC_END_INTERACTION_NOTIFY";
    case Protocol_PUSH_CREATE_NOTIFY: return "PUSH_CREATE_NOTIFY";
    case Protocol_PUSH_UPDATE_NOTIFY: return "PUSH_UPDATE_NOTIFY";
    case Protocol_PUSH_ALONE_JOIN_REQUEST: return "PUSH_ALONE_JOIN_REQUEST";
    case Protocol_PUSH_ALONE_JOIN_RESPONSE: return "PUSH_ALONE_JOIN_RESPONSE";
    case Protocol_PUSH_QUICK_MATCHING_JOIN_REQUEST: return "PUSH_QUICK_MATCHING_JOIN_REQUEST";
    case Protocol_PUSH_QUICK_MATCHING_JOIN_RESPONSE: return "PUSH_QUICK_MATCHING_JOIN_RESPONSE";
    case Protocol_PUSH_QUICK_MATCHING_LEAVE_REQUEST: return "PUSH_QUICK_MATCHING_LEAVE_REQUEST";
    case Protocol_PUSH_MATCHING_ADDED_NOTIFY: return "PUSH_MATCHING_ADDED_NOTIFY";
    case Protocol_PUSH_MATCHING_REMOVED_NOTIFY: return "PUSH_MATCHING_REMOVED_NOTIFY";
    case Protocol_PUSH_MATCHING_JOINED_PC_CLASS_UPDATE: return "PUSH_MATCHING_JOINED_PC_CLASS_UPDATE";
    case Protocol_PUSH_MATCHING_FAILED_NOTIFY: return "PUSH_MATCHING_FAILED_NOTIFY";
    case Protocol_PUSH_MATCHED_SUCCESS_NOTIFY: return "PUSH_MATCHED_SUCCESS_NOTIFY";
    case Protocol_CAMERA_OBJECT_START_NOTIFY: return "CAMERA_OBJECT_START_NOTIFY";
    case Protocol_CAMERA_OBJECT_END_NOTIFY: return "CAMERA_OBJECT_END_NOTIFY";
    case Protocol_CAMERA_OBJECT_MOVE_NOTIFY: return "CAMERA_OBJECT_MOVE_NOTIFY";
    case Protocol_DIMENSION_CRYSTAL_INSERT_REQUEST: return "DIMENSION_CRYSTAL_INSERT_REQUEST";
    case Protocol_DIMENSION_CRYSTAL_INSERT_RESPONSE: return "DIMENSION_CRYSTAL_INSERT_RESPONSE";
    case Protocol_DB_DIMENSION_CRYSTAL_INSERT_REQUEST: return "DB_DIMENSION_CRYSTAL_INSERT_REQUEST";
    case Protocol_DB_DIMENSION_CRYSTAL_INSERT_RESPONSE: return "DB_DIMENSION_CRYSTAL_INSERT_RESPONSE";
    case Protocol_DIMENSION_CRYSTAL_REMOVE_REQUEST: return "DIMENSION_CRYSTAL_REMOVE_REQUEST";
    case Protocol_DIMENSION_CRYSTAL_REMOVE_RESPONSE: return "DIMENSION_CRYSTAL_REMOVE_RESPONSE";
    case Protocol_DB_DIMENSION_CRYSTAL_REMOVE_REQUEST: return "DB_DIMENSION_CRYSTAL_REMOVE_REQUEST";
    case Protocol_DB_DIMENSION_CRYSTAL_REMOVE_RESPONSE: return "DB_DIMENSION_CRYSTAL_REMOVE_RESPONSE";
    case Protocol_DIMENSION_CRYSTAL_LEVELUP_REQUEST: return "DIMENSION_CRYSTAL_LEVELUP_REQUEST";
    case Protocol_DIMENISON_CRYSTAL_LEVELUP_RESPONSE: return "DIMENISON_CRYSTAL_LEVELUP_RESPONSE";
    case Protocol_DB_DIMENSION_CRYSTAL_LEVELUP_REQUEST: return "DB_DIMENSION_CRYSTAL_LEVELUP_REQUEST";
    case Protocol_DB_DIMENSION_CRYSTAL_LEVELUP_RESPONSE: return "DB_DIMENSION_CRYSTAL_LEVELUP_RESPONSE";
    case Protocol_DIMENSION_CRYSTAL_UPGRADE_REQUEST: return "DIMENSION_CRYSTAL_UPGRADE_REQUEST";
    case Protocol_DIMENSION_CRYSTAL_UPGRADE_RESPONSE: return "DIMENSION_CRYSTAL_UPGRADE_RESPONSE";
    case Protocol_DB_DIMENSION_CRYSTAL_UPGRADE_REQUEST: return "DB_DIMENSION_CRYSTAL_UPGRADE_REQUEST";
    case Protocol_DB_DIMENSION_CRYSTAL_UPGRADE_RESPONSE: return "DB_DIMENSION_CRYSTAL_UPGRADE_RESPONSE";
    case Protocol_GAME_RECONNECT_REQUEST: return "GAME_RECONNECT_REQUEST";
    case Protocol_GAME_RECONNECT_RESPONSE: return "GAME_RECONNECT_RESPONSE";
    case Protocol_RECONNECT_LOAD_DATA_REQUEST: return "RECONNECT_LOAD_DATA_REQUEST";
    case Protocol_RECONNECT_LOAD_DATA_RESPONSE: return "RECONNECT_LOAD_DATA_RESPONSE";
    case Protocol_LOAD_DATA_COMPLETE_NOTIFY: return "LOAD_DATA_COMPLETE_NOTIFY";
    case Protocol_PC_LOGIN_DATA_COMPLETE_NOTIFY: return "PC_LOGIN_DATA_COMPLETE_NOTIFY";
    case Protocol_PC_LOGIN_DATA_START_NOTIFY: return "PC_LOGIN_DATA_START_NOTIFY";
    case Protocol_REDIS_GET_RANGE_RANK_INFO_REQUEST: return "REDIS_GET_RANGE_RANK_INFO_REQUEST";
    case Protocol_REDIS_GET_RANGE_RANK_INFO_RESPONSE: return "REDIS_GET_RANGE_RANK_INFO_RESPONSE";
    case Protocol_REDIS_GET_MY_RANK_REQUEST: return "REDIS_GET_MY_RANK_REQUEST";
    case Protocol_REDIS_GET_MY_RANK_RESPONSE: return "REDIS_GET_MY_RANK_RESPONSE";
    case Protocol_REDIS_RANK_LOOKUP_REQUEST: return "REDIS_RANK_LOOKUP_REQUEST";
    case Protocol_RANK_GET_PC_DEATIL_INFO_REQUEST: return "RANK_GET_PC_DEATIL_INFO_REQUEST";
    case Protocol_REDIS_RANK_LOOKUP_RESPONSE: return "REDIS_RANK_LOOKUP_RESPONSE";
    case Protocol_DB_SHOP_PRODUCT_PURCHASE_REQUEST: return "DB_SHOP_PRODUCT_PURCHASE_REQUEST";
    case Protocol_DB_SHOP_PRODUCT_PURCHASE_RESPONSE: return "DB_SHOP_PRODUCT_PURCHASE_RESPONSE";
    case Protocol_DB_SHOP_PROUDCT_UPDATE_MISSION_REQUEST: return "DB_SHOP_PROUDCT_UPDATE_MISSION_REQUEST";
    case Protocol_DB_SHOP_PROUDCT_UPDATE_MISSION_RESPONSE: return "DB_SHOP_PROUDCT_UPDATE_MISSION_RESPONSE";
    case Protocol_DB_SHOP_PRODUCT_MISSION_REWARD_REQUEST: return "DB_SHOP_PRODUCT_MISSION_REWARD_REQUEST";
    case Protocol_DB_SHOP_PRODUCT_MISSION_REWARD_RESPONSE: return "DB_SHOP_PRODUCT_MISSION_REWARD_RESPONSE";
    case Protocol_DB_SHOP_PRODUCT_PROMOTION_REWARD_REQUEST: return "DB_SHOP_PRODUCT_PROMOTION_REWARD_REQUEST";
    case Protocol_DB_SHOP_PRODUCT_PROMOTION_REWARD_RESPONSE: return "DB_SHOP_PRODUCT_PROMOTION_REWARD_RESPONSE";
    case Protocol_ELIXIR_LIST_NOTIFY: return "ELIXIR_LIST_NOTIFY";
    case Protocol_ELIXIR_EHCNAHT_REQUEST: return "ELIXIR_EHCNAHT_REQUEST";
    case Protocol_ELIXIR_EHCNAHT_RESPONSE: return "ELIXIR_EHCNAHT_RESPONSE";
    case Protocol_DB_ELIXIR_ENCHANT_REQUEST: return "DB_ELIXIR_ENCHANT_REQUEST";
    case Protocol_DB_ELIXIR_ENCHANT_RESPONSE: return "DB_ELIXIR_ENCHANT_RESPONSE";
    case Protocol_TERRASTONE_LIST_NOTIFY: return "TERRASTONE_LIST_NOTIFY";
    case Protocol_TERRASTONE_ENCHANT_REQUEST: return "TERRASTONE_ENCHANT_REQUEST";
    case Protocol_TERRASTONE_ENCHANT_RESPONSE: return "TERRASTONE_ENCHANT_RESPONSE";
    case Protocol_DB_TERRASTONE_ENCHANT_REQUEST: return "DB_TERRASTONE_ENCHANT_REQUEST";
    case Protocol_DB_TERRASTONE_ENCHANT_RESPONSE: return "DB_TERRASTONE_ENCHANT_RESPONSE";
    case Protocol_RESEARCH_LIST_NOTIFY: return "RESEARCH_LIST_NOTIFY";
    case Protocol_RESEARCH_ENCHANT_REQUEST: return "RESEARCH_ENCHANT_REQUEST";
    case Protocol_RESEARCH_ENCHANT_RESPONSE: return "RESEARCH_ENCHANT_RESPONSE";
    case Protocol_DB_RESEARCH_ENCHANT_REQUEST: return "DB_RESEARCH_ENCHANT_REQUEST";
    case Protocol_DB_RESEARCH_ENCHANT_RESPONSE: return "DB_RESEARCH_ENCHANT_RESPONSE";
    case Protocol_GUARDIAN_STAR_LIST_NOTIFY: return "GUARDIAN_STAR_LIST_NOTIFY";
    case Protocol_GUARDIAN_STAR_ENCHANT_REQUEST: return "GUARDIAN_STAR_ENCHANT_REQUEST";
    case Protocol_GUARDIAN_STAR_ENCHANT_RESPONSE: return "GUARDIAN_STAR_ENCHANT_RESPONSE";
    case Protocol_GUARDIAN_STAR_UPGRADE_REQUEST: return "GUARDIAN_STAR_UPGRADE_REQUEST";
    case Protocol_GUARDIAN_STAR_UPGRADE_RESPONSE: return "GUARDIAN_STAR_UPGRADE_RESPONSE";
    case Protocol_DB_GUARDIAN_STAR_ENCHANT_REQUEST: return "DB_GUARDIAN_STAR_ENCHANT_REQUEST";
    case Protocol_DB_GUARDIAN_STAR_ENCHANT_RESPONSE: return "DB_GUARDIAN_STAR_ENCHANT_RESPONSE";
    case Protocol_DB_GUARDIAN_STAR_UPGRADE_REQUEST: return "DB_GUARDIAN_STAR_UPGRADE_REQUEST";
    case Protocol_DB_GUARDIAN_STAR_UPGRADE_RESPONSE: return "DB_GUARDIAN_STAR_UPGRADE_RESPONSE";
    case Protocol_PASSIVE_SKILL_LIST_NOTIFY: return "PASSIVE_SKILL_LIST_NOTIFY";
    case Protocol_PASSIVE_SKILL_ENCHANT_REQUEST: return "PASSIVE_SKILL_ENCHANT_REQUEST";
    case Protocol_PASSIVE_SKILL_ENCHANT_RESPONSE: return "PASSIVE_SKILL_ENCHANT_RESPONSE";
    case Protocol_DB_PASSIVE_SKILL_ENCHANT_REQUEST: return "DB_PASSIVE_SKILL_ENCHANT_REQUEST";
    case Protocol_DB_PASSIVE_SKILL_ENCHANT_RESPONSE: return "DB_PASSIVE_SKILL_ENCHANT_RESPONSE";
    case Protocol_DB_BUFF_SAVE_REQUEST: return "DB_BUFF_SAVE_REQUEST";
    case Protocol_DB_BUFF_SAVE_RESPONSE: return "DB_BUFF_SAVE_RESPONSE";
    case Protocol_DB_BUFF_UPDATE_REQUEST: return "DB_BUFF_UPDATE_REQUEST";
    case Protocol_DB_BUFF_UPDATE_RESPONSE: return "DB_BUFF_UPDATE_RESPONSE";
    case Protocol_DB_BUFF_REMOVE_REQUEST: return "DB_BUFF_REMOVE_REQUEST";
    case Protocol_DB_BUFF_REMOVE_RESPONSE: return "DB_BUFF_REMOVE_RESPONSE";
    case Protocol_POTION_GROWTH_LIST_NOTIFY: return "POTION_GROWTH_LIST_NOTIFY";
    case Protocol_POTION_GROWTH_UPDATE_NOTIFY: return "POTION_GROWTH_UPDATE_NOTIFY";
    case Protocol_POTION_GROWTH_LEVEL_UP_REQUEST: return "POTION_GROWTH_LEVEL_UP_REQUEST";
    case Protocol_POTION_GROWTH_LEVEL_UP_RESPONSE: return "POTION_GROWTH_LEVEL_UP_RESPONSE";
    case Protocol_DB_POTION_GROWTH_LEVEL_EXP_CHANGE_REQUEST: return "DB_POTION_GROWTH_LEVEL_EXP_CHANGE_REQUEST";
    case Protocol_DB_POTION_GROWTH_LEVEL_EXP_CHANGE_RESPONSE: return "DB_POTION_GROWTH_LEVEL_EXP_CHANGE_RESPONSE";
    case Protocol_PC_CLIENT_CONFIG_NOTIFY: return "PC_CLIENT_CONFIG_NOTIFY";
    case Protocol_PC_CLIENT_CONFIG_SAVE_REQUEST: return "PC_CLIENT_CONFIG_SAVE_REQUEST";
    case Protocol_DB_UPDATE_PC_CLIENT_CONFIG_NOTIFY: return "DB_UPDATE_PC_CLIENT_CONFIG_NOTIFY";
    case Protocol_NOTICE_ITEM_NOTIFY: return "NOTICE_ITEM_NOTIFY";
    case Protocol_NOTICE_USER_NOTIFY: return "NOTICE_USER_NOTIFY";
    case Protocol_NOTICE_SHOP_PURCHASE_NOTIFY: return "NOTICE_SHOP_PURCHASE_NOTIFY";
    case Protocol_NOTICE_PET_NOTIFY: return "NOTICE_PET_NOTIFY";
    case Protocol_NOTICE_ELITE_MONSTER_KILL_NOTIFY: return "NOTICE_ELITE_MONSTER_KILL_NOTIFY";
    case Protocol_GUILD_INFO_NOTIFY: return "GUILD_INFO_NOTIFY";
    case Protocol_GUILD_NOT_IMPL_NOTIFY: return "GUILD_NOT_IMPL_NOTIFY";
    case Protocol_GUILD_INFO_REQUEST: return "GUILD_INFO_REQUEST";
    case Protocol_GUILD_INFO_RESPONSE: return "GUILD_INFO_RESPONSE";
    case Protocol_GUILD_CREATE_REQUEST: return "GUILD_CREATE_REQUEST";
    case Protocol_GUILD_CREATE_RESPONSE: return "GUILD_CREATE_RESPONSE";
    case Protocol_GUILD_CHECK_NAME_REQUEST: return "GUILD_CHECK_NAME_REQUEST";
    case Protocol_GUILD_CHECK_NAME_RESPONSE: return "GUILD_CHECK_NAME_RESPONSE";
    case Protocol_GUILD_DESTROY_REQUEST: return "GUILD_DESTROY_REQUEST";
    case Protocol_GUILD_DESTROY_RESPONSE: return "GUILD_DESTROY_RESPONSE";
    case Protocol_GUILD_FIND_REQUEST: return "GUILD_FIND_REQUEST";
    case Protocol_GUILD_FIND_RESPONSE: return "GUILD_FIND_RESPONSE";
    case Protocol_GUILD_JOIN_REQ_REQUEST: return "GUILD_JOIN_REQ_REQUEST";
    case Protocol_GUILD_JOIN_REQ_RESPONSE: return "GUILD_JOIN_REQ_RESPONSE";
    case Protocol_GUILD_APPLICANT_UPDATE_NOTIFY: return "GUILD_APPLICANT_UPDATE_NOTIFY";
    case Protocol_GUILD_NEW_MEMBER_NOTIFY: return "GUILD_NEW_MEMBER_NOTIFY";
    case Protocol_GUILD_LEAVE_MEMBER_NOTIFY: return "GUILD_LEAVE_MEMBER_NOTIFY";
    case Protocol_GUILD_LEAVE_REQUEST: return "GUILD_LEAVE_REQUEST";
    case Protocol_GUILD_LEAVE_RESPONSE: return "GUILD_LEAVE_RESPONSE";
    case Protocol_GUILD_JOIN_NOTIFY: return "GUILD_JOIN_NOTIFY";
    case Protocol_GUILD_LEAVE_NOTIFY: return "GUILD_LEAVE_NOTIFY";
    case Protocol_GUILD_MEMBER_LIST_REQUEST: return "GUILD_MEMBER_LIST_REQUEST";
    case Protocol_GUILD_MEMBER_LIST_RESPONSE: return "GUILD_MEMBER_LIST_RESPONSE";
    case Protocol_GUILD_ATTEND_REQUEST: return "GUILD_ATTEND_REQUEST";
    case Protocol_GUILD_ATTEND_RESPONSE: return "GUILD_ATTEND_RESPONSE";
    case Protocol_GUILD_DONATE_REQUEST: return "GUILD_DONATE_REQUEST";
    case Protocol_GUILD_DONATE_RESPONSE: return "GUILD_DONATE_RESPONSE";
    case Protocol_GUILD_RANKING_LIST_REQUEST: return "GUILD_RANKING_LIST_REQUEST";
    case Protocol_GUILD_RANKING_LIST_RESPONSE: return "GUILD_RANKING_LIST_RESPONSE";
    case Protocol_GUILD_LIST_REQUEST: return "GUILD_LIST_REQUEST";
    case Protocol_GUILD_LIST_RESPONSE: return "GUILD_LIST_RESPONSE";
    case Protocol_GUILD_DETAIL_INFO_REQUEST: return "GUILD_DETAIL_INFO_REQUEST";
    case Protocol_GUILD_DETAIL_INFO_RESPONSE: return "GUILD_DETAIL_INFO_RESPONSE";
    case Protocol_GUILD_MY_JOIN_REQ_LIST_REQUEST: return "GUILD_MY_JOIN_REQ_LIST_REQUEST";
    case Protocol_GUILD_MY_JOIN_REQ_LIST_RESPONSE: return "GUILD_MY_JOIN_REQ_LIST_RESPONSE";
    case Protocol_GUILD_REMOVE_JOIN_REQ_REQUEST: return "GUILD_REMOVE_JOIN_REQ_REQUEST";
    case Protocol_GUILD_REMOVE_JOIN_REQ_RESPONSE: return "GUILD_REMOVE_JOIN_REQ_RESPONSE";
    case Protocol_GUILD_JOIN_REQ_LIST_REQUEST: return "GUILD_JOIN_REQ_LIST_REQUEST";
    case Protocol_GUILD_JOIN_REQ_LIST_RESPONSE: return "GUILD_JOIN_REQ_LIST_RESPONSE";
    case Protocol_GUILD_ACCEPT_JOIN_REQ_REQUEST: return "GUILD_ACCEPT_JOIN_REQ_REQUEST";
    case Protocol_GUILD_ACCEPT_JOIN_REQ_RESPONSE: return "GUILD_ACCEPT_JOIN_REQ_RESPONSE";
    case Protocol_GUILD_REJECT_JOIN_REQ_REQUEST: return "GUILD_REJECT_JOIN_REQ_REQUEST";
    case Protocol_GUILD_REJECT_JOIN_REQ_RESPONSE: return "GUILD_REJECT_JOIN_REQ_RESPONSE";
    case Protocol_GUILD_CHANGE_JOIN_CONDITION_REQUEST: return "GUILD_CHANGE_JOIN_CONDITION_REQUEST";
    case Protocol_GUILD_CHANGE_JOIN_CONDITION_RESPONSE: return "GUILD_CHANGE_JOIN_CONDITION_RESPONSE";
    case Protocol_GUILD_CHANGE_MSG_REQUEST: return "GUILD_CHANGE_MSG_REQUEST";
    case Protocol_GUILD_CHANGE_MSG_RESPONSE: return "GUILD_CHANGE_MSG_RESPONSE";
    case Protocol_GUILD_KICK_MEMBER_REQUEST: return "GUILD_KICK_MEMBER_REQUEST";
    case Protocol_GUILD_KICK_MEMBER_RESPONSE: return "GUILD_KICK_MEMBER_RESPONSE";
    case Protocol_GUILD_LEVEL_UP_NOTIFY: return "GUILD_LEVEL_UP_NOTIFY";
    case Protocol_GUILD_CHANGE_MEMBER_GRADE_REQUEST: return "GUILD_CHANGE_MEMBER_GRADE_REQUEST";
    case Protocol_GUILD_CHANGE_MEMBER_GRADE_RESPONSE: return "GUILD_CHANGE_MEMBER_GRADE_RESPONSE";
    case Protocol_GUILD_CHANGE_MEMBER_GRADE_NOTIFY: return "GUILD_CHANGE_MEMBER_GRADE_NOTIFY";
    case Protocol_GUILD_HISTORY_REQUEST: return "GUILD_HISTORY_REQUEST";
    case Protocol_GUILD_HISTORY_RESPONSE: return "GUILD_HISTORY_RESPONSE";
    case Protocol_GUILD_BUFF_PURCHASE_REQUEST: return "GUILD_BUFF_PURCHASE_REQUEST";
    case Protocol_GUILD_BUFF_PURCHASE_RESPONSE: return "GUILD_BUFF_PURCHASE_RESPONSE";
    case Protocol_GUILD_CHANGE_LEADER_REQUEST: return "GUILD_CHANGE_LEADER_REQUEST";
    case Protocol_GUILD_CHANGE_LEADER_RESPONSE: return "GUILD_CHANGE_LEADER_RESPONSE";
    case Protocol_GUILD_CANDIDATE_LEADER_LIST_REQUEST: return "GUILD_CANDIDATE_LEADER_LIST_REQUEST";
    case Protocol_GUILD_CANDIDATE_LEADER_LIST_RESPONSE: return "GUILD_CANDIDATE_LEADER_LIST_RESPONSE";
    case Protocol_GUILD_CHANGE_CREST_REQUEST: return "GUILD_CHANGE_CREST_REQUEST";
    case Protocol_GUILD_CHANGE_CREST_RESPONSE: return "GUILD_CHANGE_CREST_RESPONSE";
    case Protocol_GUILD_SHARE_SETTING_INFO_REQUEST: return "GUILD_SHARE_SETTING_INFO_REQUEST";
    case Protocol_GUILD_SHARE_SETTING_INFO_RESPONSE: return "GUILD_SHARE_SETTING_INFO_RESPONSE";
    case Protocol_GUILD_SAVE_SHARE_SETTING_REQUEST: return "GUILD_SAVE_SHARE_SETTING_REQUEST";
    case Protocol_GUILD_SAVE_SHARE_SETTING_RESPONSE: return "GUILD_SAVE_SHARE_SETTING_RESPONSE";
    case Protocol_GUILD_INVITE_MESSAGE_REQUEST: return "GUILD_INVITE_MESSAGE_REQUEST";
    case Protocol_GUILD_INVITE_MESSAGE_RESPONSE: return "GUILD_INVITE_MESSAGE_RESPONSE";
    case Protocol_GUILD_MEMBER_DETAIL_INFO_REQUEST: return "GUILD_MEMBER_DETAIL_INFO_REQUEST";
    case Protocol_GUILD_MEMBER_DETAIL_INFO_RESPONSE: return "GUILD_MEMBER_DETAIL_INFO_RESPONSE";
    case Protocol_GUILD_REJECT_JOIN_REQ_NOTIFY: return "GUILD_REJECT_JOIN_REQ_NOTIFY";
    case Protocol_GUILD_CHANGE_NAME_REQUEST: return "GUILD_CHANGE_NAME_REQUEST";
    case Protocol_GUILD_CHANGE_NAME_RESPONSE: return "GUILD_CHANGE_NAME_RESPONSE";
    case Protocol_GUILD_CHANGE_NAME_NOTIFY: return "GUILD_CHANGE_NAME_NOTIFY";
    case Protocol_GUILD_DUNGEON_SCORE_REQUEST: return "GUILD_DUNGEON_SCORE_REQUEST";
    case Protocol_GUILD_DUNGEON_SCORE_RESPONSE: return "GUILD_DUNGEON_SCORE_RESPONSE";
    case Protocol_GUILD_UNITY_RANKING_LIST_REQUEST: return "GUILD_UNITY_RANKING_LIST_REQUEST";
    case Protocol_GUILD_UNITY_RANKING_LIST_RESPONSE: return "GUILD_UNITY_RANKING_LIST_RESPONSE";
    case Protocol_DB_GUILD_CREATE_REQUEST: return "DB_GUILD_CREATE_REQUEST";
    case Protocol_DB_GUILD_CREATE_RESPONSE: return "DB_GUILD_CREATE_RESPONSE";
    case Protocol_DB_GUILD_DESTROY_REQUEST: return "DB_GUILD_DESTROY_REQUEST";
    case Protocol_DB_GUILD_DESTROY_RESPONSE: return "DB_GUILD_DESTROY_RESPONSE";
    case Protocol_DB_GUILD_ATTEND_REQUEST: return "DB_GUILD_ATTEND_REQUEST";
    case Protocol_DB_GUILD_ATTEND_RESPONSE: return "DB_GUILD_ATTEND_RESPONSE";
    case Protocol_DB_GUILD_DONATE_REQUEST: return "DB_GUILD_DONATE_REQUEST";
    case Protocol_DB_GUILD_DONATE_RESPONSE: return "DB_GUILD_DONATE_RESPONSE";
    case Protocol_DB_GUILD_CHANGE_CREST_REQUEST: return "DB_GUILD_CHANGE_CREST_REQUEST";
    case Protocol_DB_GUILD_CHANGE_CREST_RESPONSE: return "DB_GUILD_CHANGE_CREST_RESPONSE";
    case Protocol_DB_GUILD_ATTEND_RESET_REQUEST: return "DB_GUILD_ATTEND_RESET_REQUEST";
    case Protocol_DB_GUILD_ATTEND_RESET_RESPONSE: return "DB_GUILD_ATTEND_RESET_RESPONSE";
    case Protocol_DB_GUILD_CHANGE_NAME_REQUEST: return "DB_GUILD_CHANGE_NAME_REQUEST";
    case Protocol_DB_GUILD_CHANGE_NAME_RESPONSE: return "DB_GUILD_CHANGE_NAME_RESPONSE";
    case Protocol_SEASON_CURRENT_INFO_REQUEST: return "SEASON_CURRENT_INFO_REQUEST";
    case Protocol_SEASON_CURRENT_INFO_RESPONSE: return "SEASON_CURRENT_INFO_RESPONSE";
    case Protocol_SEASON_REWARD_INFO_REQUEST: return "SEASON_REWARD_INFO_REQUEST";
    case Protocol_SEASON_REWARD_INFO_RESPONSE: return "SEASON_REWARD_INFO_RESPONSE";
    case Protocol_SEASON_DUNGEON_INFO_REQUEST: return "SEASON_DUNGEON_INFO_REQUEST";
    case Protocol_SEASON_DUNGEON_INFO_RESPONSE: return "SEASON_DUNGEON_INFO_RESPONSE";
    case Protocol_AGENT_PC_MOVE_SERVER_REQUEST: return "AGENT_PC_MOVE_SERVER_REQUEST";
    case Protocol_RVR_BATTLE_FIELD_REMAIN_TIME_REQUEST: return "RVR_BATTLE_FIELD_REMAIN_TIME_REQUEST";
    case Protocol_RVR_BATTLE_FIELD_REMAIN_TIME_RESPONSE: return "RVR_BATTLE_FIELD_REMAIN_TIME_RESPONSE";
    case Protocol_RVR_BATTLE_FIELD_INFO_REQUEST: return "RVR_BATTLE_FIELD_INFO_REQUEST";
    case Protocol_RVR_BATTLE_FIELD_INFO_RESPONSE: return "RVR_BATTLE_FIELD_INFO_RESPONSE";
    case Protocol_RVR_BATTLE_FIELD_ALL_INFOS_REQUEST: return "RVR_BATTLE_FIELD_ALL_INFOS_REQUEST";
    case Protocol_RVR_BATTLE_FIELD_ALL_INFOS_RESPONSE: return "RVR_BATTLE_FIELD_ALL_INFOS_RESPONSE";
    case Protocol_RVR_PASS_BATTLE_FIELD_CAHNNEL_INFO_SYNC_NOTIFY: return "RVR_PASS_BATTLE_FIELD_CAHNNEL_INFO_SYNC_NOTIFY";
    case Protocol_RVR_RELAY_BATTLE_FIELD_CAHNNEL_INFO_SYNC_NOTIFY: return "RVR_RELAY_BATTLE_FIELD_CAHNNEL_INFO_SYNC_NOTIFY";
    case Protocol_RVR_PASS_BATTLE_FIELD_CHANNEL_INFO_NOTIFY: return "RVR_PASS_BATTLE_FIELD_CHANNEL_INFO_NOTIFY";
    case Protocol_RVR_RELAY_BATTLE_FIELD_CHANNEL_INFO_NOTIFY: return "RVR_RELAY_BATTLE_FIELD_CHANNEL_INFO_NOTIFY";
    case Protocol_RVR_PASS_BATTLE_FIELD_PLAYER_COUNT_INFO_NOTIFY: return "RVR_PASS_BATTLE_FIELD_PLAYER_COUNT_INFO_NOTIFY";
    case Protocol_RVR_RELAY_BATTLE_FIELD_PLAYER_COUNT_INFO_NOTIFY: return "RVR_RELAY_BATTLE_FIELD_PLAYER_COUNT_INFO_NOTIFY";
    case Protocol_RVR_BATTLE_FIELD_EVENT_START_NOTIFY: return "RVR_BATTLE_FIELD_EVENT_START_NOTIFY";
    case Protocol_RVR_BATTLE_FIELD_EVENT_END_NOTIFY: return "RVR_BATTLE_FIELD_EVENT_END_NOTIFY";
    case Protocol_RVR_BATTLE_FIELD_CLOSE_NOTIFY: return "RVR_BATTLE_FIELD_CLOSE_NOTIFY";
    case Protocol_RVR_BATTLE_FILED_TIME_INFO_NOTIFY: return "RVR_BATTLE_FILED_TIME_INFO_NOTIFY";
    case Protocol_RVR_BATTLE_FILED_TIME_INFO_REQUEST: return "RVR_BATTLE_FILED_TIME_INFO_REQUEST";
    case Protocol_RVR_BATTLE_FILED_TIME_INFO_RESPONSE: return "RVR_BATTLE_FILED_TIME_INFO_RESPONSE";
    case Protocol_RVR_BATTLE_FILED_TIME_EXPIRED_NOTIFY: return "RVR_BATTLE_FILED_TIME_EXPIRED_NOTIFY";
    case Protocol_RVR_BATTLE_FILED_FREE_TIME_EXPIRED_NOTIFY: return "RVR_BATTLE_FILED_FREE_TIME_EXPIRED_NOTIFY";
    case Protocol_RVR_BATTLE_FILED_REMAIN_TIME_NOTIFY: return "RVR_BATTLE_FILED_REMAIN_TIME_NOTIFY";
    case Protocol_RVR_BATTLE_FILED_PK_NOTIFY: return "RVR_BATTLE_FILED_PK_NOTIFY";
    case Protocol_RVR_BATTLE_FIELD_SHORT_TERM_MAX_NOTIFY: return "RVR_BATTLE_FIELD_SHORT_TERM_MAX_NOTIFY";
    case Protocol_RVR_BATTLE_FIELD_OTHER_PC_SHORT_TERM_MAX_NOTIFY: return "RVR_BATTLE_FIELD_OTHER_PC_SHORT_TERM_MAX_NOTIFY";
    case Protocol_RVR_STANDBY_ORDER_REQUEST: return "RVR_STANDBY_ORDER_REQUEST";
    case Protocol_RVR_STANDBY_ORDER_RESPONSE: return "RVR_STANDBY_ORDER_RESPONSE";
    case Protocol_RVR_JOIN_REQUEST: return "RVR_JOIN_REQUEST";
    case Protocol_RVR_JOIN_RESPONSE: return "RVR_JOIN_RESPONSE";
    case Protocol_RVR_RESERVATION_REQUEST: return "RVR_RESERVATION_REQUEST";
    case Protocol_RVR_RESERVATION_RESPONSE: return "RVR_RESERVATION_RESPONSE";
    case Protocol_RVR_CANCEL_REQUEST: return "RVR_CANCEL_REQUEST";
    case Protocol_RVR_CANCEL_RESPONSE: return "RVR_CANCEL_RESPONSE";
    case Protocol_RVR_LEAVE_BATTLE_SERVER_REQUEST: return "RVR_LEAVE_BATTLE_SERVER_REQUEST";
    case Protocol_RVR_LEAVE_BATTLE_SERVER_RESPONSE: return "RVR_LEAVE_BATTLE_SERVER_RESPONSE";
    case Protocol_RVR_RESERVATION_STATE_NOTIFY: return "RVR_RESERVATION_STATE_NOTIFY";
    case Protocol_RVR_PASS_CHECK_STANDBY_ORDER_REQUEST: return "RVR_PASS_CHECK_STANDBY_ORDER_REQUEST";
    case Protocol_RVR_RELAY_CHECK_STANDBY_ORDER_REQUEST: return "RVR_RELAY_CHECK_STANDBY_ORDER_REQUEST";
    case Protocol_RVR_PASS_CHECK_STANDBY_ORDER_RESPONSE: return "RVR_PASS_CHECK_STANDBY_ORDER_RESPONSE";
    case Protocol_RVR_RELAY_CHECK_STANDBY_ORDER_RESPONSE: return "RVR_RELAY_CHECK_STANDBY_ORDER_RESPONSE";
    case Protocol_RVR_PERMISSION_TO_JOIN_PASS_REQUEST: return "RVR_PERMISSION_TO_JOIN_PASS_REQUEST";
    case Protocol_RVR_PERMISSION_TO_JOIN_RELAY_REQUEST: return "RVR_PERMISSION_TO_JOIN_RELAY_REQUEST";
    case Protocol_RVR_PERMISSION_TO_JOIN_PASS_RESPONSE: return "RVR_PERMISSION_TO_JOIN_PASS_RESPONSE";
    case Protocol_RVR_PERMISSION_TO_JOIN_RELAY_RESPONSE: return "RVR_PERMISSION_TO_JOIN_RELAY_RESPONSE";
    case Protocol_RVR_CANCEL_TO_JOIN_PASS_REQUEST: return "RVR_CANCEL_TO_JOIN_PASS_REQUEST";
    case Protocol_RVR_CANCEL_TO_JOIN_RELAY_REQUEST: return "RVR_CANCEL_TO_JOIN_RELAY_REQUEST";
    case Protocol_RVR_CANCEL_TO_JOIN_PASS_RESPONSE: return "RVR_CANCEL_TO_JOIN_PASS_RESPONSE";
    case Protocol_RVR_CANCEL_TO_JOIN_RELAY_RESPONSE: return "RVR_CANCEL_TO_JOIN_RELAY_RESPONSE";
    case Protocol_RVR_ASK_TO_STANDBY_PASS_REQUEST: return "RVR_ASK_TO_STANDBY_PASS_REQUEST";
    case Protocol_RVR_ASK_TO_STANDBY_RELAY_REQUEST: return "RVR_ASK_TO_STANDBY_RELAY_REQUEST";
    case Protocol_RVR_ASK_TO_STANDBY_PASS_RESPONSE: return "RVR_ASK_TO_STANDBY_PASS_RESPONSE";
    case Protocol_RVR_ASK_TO_STANDBY_RELAY_RESPONSE: return "RVR_ASK_TO_STANDBY_RELAY_RESPONSE";
    case Protocol_RVR_CONNECTED_GAME_SERVER_NOTIFY: return "RVR_CONNECTED_GAME_SERVER_NOTIFY";
    case Protocol_RVR_CONNECTED_BATTLE_SERVER_NOTIFY: return "RVR_CONNECTED_BATTLE_SERVER_NOTIFY";
    case Protocol_RVR_DISCONNECTED_BATTLE_SERVER_NOTIFY: return "RVR_DISCONNECTED_BATTLE_SERVER_NOTIFY";
    case Protocol_RVR_QA_COMMAND_PASS_NOTIFY: return "RVR_QA_COMMAND_PASS_NOTIFY";
    case Protocol_RVR_QA_COMMAND_RELAY_NOTIFY: return "RVR_QA_COMMAND_RELAY_NOTIFY";
    case Protocol_RVR_MOVE_CLIENT_QUEST_LOC_REQUEST: return "RVR_MOVE_CLIENT_QUEST_LOC_REQUEST";
    case Protocol_RVR_MOVE_CLIENT_QUEST_LOC_RESPONSE: return "RVR_MOVE_CLIENT_QUEST_LOC_RESPONSE";
    case Protocol_RVR_MOVE_BASE_CAMP_REQUEST: return "RVR_MOVE_BASE_CAMP_REQUEST";
    case Protocol_RVR_MOVE_BASE_CAMP_RESPONSE: return "RVR_MOVE_BASE_CAMP_RESPONSE";
    case Protocol_RVR_MAIN_HUD_INFO_NOTIFY: return "RVR_MAIN_HUD_INFO_NOTIFY";
    case Protocol_RVR_EVENT_TOTAL_REWARD_NOTIFY: return "RVR_EVENT_TOTAL_REWARD_NOTIFY";
    case Protocol_RVR_MAIN_HUD_POINT_INFO_NOTIFY: return "RVR_MAIN_HUD_POINT_INFO_NOTIFY";
    case Protocol_RVR_OCCUPYING_GAUGE_APPROXIMATE_INFO_NOTIFY: return "RVR_OCCUPYING_GAUGE_APPROXIMATE_INFO_NOTIFY";
    case Protocol_RVR_OCCUPYING_GAUGE_INFO_NOTIFY: return "RVR_OCCUPYING_GAUGE_INFO_NOTIFY";
    case Protocol_BUDDY_AG_SEND_INVITATION_NOTIFY: return "BUDDY_AG_SEND_INVITATION_NOTIFY";
    case Protocol_BUDDY_AG_RECEIVE_INVITATION_NOTIFY: return "BUDDY_AG_RECEIVE_INVITATION_NOTIFY";
    case Protocol_BUDDY_AG_ACCEPT_RECEIVE_INVITATION_NOTIFY: return "BUDDY_AG_ACCEPT_RECEIVE_INVITATION_NOTIFY";
    case Protocol_BUDDY_AG_ACCEPTED_SEND_INVITATION_NOTIFY: return "BUDDY_AG_ACCEPTED_SEND_INVITATION_NOTIFY";
    case Protocol_BUDDY_AG_REJECT_RECEIVE_INVITATION_NOTIFY: return "BUDDY_AG_REJECT_RECEIVE_INVITATION_NOTIFY";
    case Protocol_BUDDY_AG_REJECTED_SEND_INVITATION_NOTIFY: return "BUDDY_AG_REJECTED_SEND_INVITATION_NOTIFY";
    case Protocol_BUDDY_AG_DELETE_BUDDY_NOTIFY: return "BUDDY_AG_DELETE_BUDDY_NOTIFY";
    case Protocol_BUDDY_AG_DELETED_BUDDY_NOTIFY: return "BUDDY_AG_DELETED_BUDDY_NOTIFY";
    case Protocol_BUDDY_DATA_ALL_NOTIFY: return "BUDDY_DATA_ALL_NOTIFY";
    case Protocol_BUDDY_SEND_INVITATION_REQUEST: return "BUDDY_SEND_INVITATION_REQUEST";
    case Protocol_BUDDY_SEND_INVITATION_RESPONSE: return "BUDDY_SEND_INVITATION_RESPONSE";
    case Protocol_BUDDY_ACCEPT_INVITATION_REQUEST: return "BUDDY_ACCEPT_INVITATION_REQUEST";
    case Protocol_BUDDY_ACCEPT_INVITATION_RESPONSE: return "BUDDY_ACCEPT_INVITATION_RESPONSE";
    case Protocol_BUDDY_REJECT_INVITATION_REQUEST: return "BUDDY_REJECT_INVITATION_REQUEST";
    case Protocol_BUDDY_REJECT_INVITATION_RESPONSE: return "BUDDY_REJECT_INVITATION_RESPONSE";
    case Protocol_BUDDY_DELETE_REQUEST: return "BUDDY_DELETE_REQUEST";
    case Protocol_BUDDY_DELETE_RESPONSE: return "BUDDY_DELETE_RESPONSE";
    case Protocol_BUDDY_RECEIVE_INVITATION_NOTIFY: return "BUDDY_RECEIVE_INVITATION_NOTIFY";
    case Protocol_BUDDY_ADDED_NOTIFY: return "BUDDY_ADDED_NOTIFY";
    case Protocol_BUDDY_DELETED_NOTIFY: return "BUDDY_DELETED_NOTIFY";
    case Protocol_BUDDY_SEND_INVITATION_REJECTED_NOTIFY: return "BUDDY_SEND_INVITATION_REJECTED_NOTIFY";
    case Protocol_BUDDY_SEARCH_REQUEST: return "BUDDY_SEARCH_REQUEST";
    case Protocol_BUDDY_SEARCH_RESPONSE: return "BUDDY_SEARCH_RESPONSE";
    case Protocol_BUDDY_RECOMMEND_REQUEST: return "BUDDY_RECOMMEND_REQUEST";
    case Protocol_BUDDY_RECOMMEND_RESPONSE: return "BUDDY_RECOMMEND_RESPONSE";
    case Protocol_BUDDY_DETAIL_INFO_REQUEST: return "BUDDY_DETAIL_INFO_REQUEST";
    case Protocol_BUDDY_REFRESH_REQUEST: return "BUDDY_REFRESH_REQUEST";
    case Protocol_BUDDY_REFRESH_RESPONSE: return "BUDDY_REFRESH_RESPONSE";
    case Protocol_BUDDY_RECEIVE_INVIATION_REFRESH_REQUEST: return "BUDDY_RECEIVE_INVIATION_REFRESH_REQUEST";
    case Protocol_BUDDY_RECEIVE_INVIATION_REFRESH_RESPONSE: return "BUDDY_RECEIVE_INVIATION_REFRESH_RESPONSE";
    case Protocol_SUMMON_REQUEST: return "SUMMON_REQUEST";
    case Protocol_SUMMON_RESPONSE: return "SUMMON_RESPONSE";
    case Protocol_SUMMON_ACCEPT_REQUEST: return "SUMMON_ACCEPT_REQUEST";
    case Protocol_SUMMON_ACCEPT_RESPONSE: return "SUMMON_ACCEPT_RESPONSE";
    case Protocol_SUMMON_RECEIVED_NOTIFY: return "SUMMON_RECEIVED_NOTIFY";
    case Protocol_SUMMON_ACCEPTED_NOTIFY: return "SUMMON_ACCEPTED_NOTIFY";
    case Protocol_SUMMON_ABLE_STATE_NOTIFY: return "SUMMON_ABLE_STATE_NOTIFY";
    case Protocol_MOVE_TO_PC_REQUEST: return "MOVE_TO_PC_REQUEST";
    case Protocol_MOVE_TO_PC_RESPONSE: return "MOVE_TO_PC_RESPONSE";
    case Protocol_SHORT_TERM_REWARD_DATA_NOTIFY: return "SHORT_TERM_REWARD_DATA_NOTIFY";
    case Protocol_SHORT_TERM_REWARD_DATA_ALL_NOTIFY: return "SHORT_TERM_REWARD_DATA_ALL_NOTIFY";
    case Protocol_SHORT_TERM_REWARD_GIVE_REQUSET: return "SHORT_TERM_REWARD_GIVE_REQUSET";
    case Protocol_SHORT_TERM_REWARD_GIVE_RESPONSE: return "SHORT_TERM_REWARD_GIVE_RESPONSE";
    case Protocol_SHORT_TERM_REWARD_DATA_ALL_REQUSET: return "SHORT_TERM_REWARD_DATA_ALL_REQUSET";
    case Protocol_SHORT_TERM_REWARD_DATA_ALL_RESPONSE: return "SHORT_TERM_REWARD_DATA_ALL_RESPONSE";
    case Protocol_KILLER_DATA_NOTIFY: return "KILLER_DATA_NOTIFY";
    case Protocol_KILLER_DATA_ALL_NOTIFY: return "KILLER_DATA_ALL_NOTIFY";
    case Protocol_REFUND_REDIS_RECORD_ADDED_NOTIFY: return "REFUND_REDIS_RECORD_ADDED_NOTIFY";
    case Protocol_REFUND_REDIS_RECORD_DATA_REQUEST: return "REFUND_REDIS_RECORD_DATA_REQUEST";
    case Protocol_REFUND_REDIS_RECORD_DATA_RESPONSE: return "REFUND_REDIS_RECORD_DATA_RESPONSE";
    case Protocol_REFUND_REDIS_RECORD_REMOVE_REQUEST: return "REFUND_REDIS_RECORD_REMOVE_REQUEST";
    case Protocol_REFUND_REDIS_RECORD_REMOVE_RESPONSE: return "REFUND_REDIS_RECORD_REMOVE_RESPONSE";
    case Protocol_BATTLE_FIELD_COLLECTION_NOTIFY: return "BATTLE_FIELD_COLLECTION_NOTIFY";
    case Protocol_DB_BATTLE_FIELD_COLLECTION_UPDATE_REQUEST: return "DB_BATTLE_FIELD_COLLECTION_UPDATE_REQUEST";
    case Protocol_DB_BATTLE_FIELD_COLLECTION_UPDATE_RESPONSE: return "DB_BATTLE_FIELD_COLLECTION_UPDATE_RESPONSE";
    case Protocol_PUSH_PROMOTION_REQUEST: return "PUSH_PROMOTION_REQUEST";
    case Protocol_PUSH_PROMOTION_RESPONSE: return "PUSH_PROMOTION_RESPONSE";
    case Protocol_GROUP_MATCHING_MAKE_REQEUST: return "GROUP_MATCHING_MAKE_REQEUST";
    case Protocol_GROUP_MATCHING_MAKE_RESPONSE: return "GROUP_MATCHING_MAKE_RESPONSE";
    case Protocol_GROUP_MATCHING_LEAVE_REQUEST: return "GROUP_MATCHING_LEAVE_REQUEST";
    case Protocol_GROUP_MATCHING_GUILD_MEMBER_LIST_REQUEST: return "GROUP_MATCHING_GUILD_MEMBER_LIST_REQUEST";
    case Protocol_GROUP_MATCHING_GUILD_MEMBER_LIST_RESPONSE: return "GROUP_MATCHING_GUILD_MEMBER_LIST_RESPONSE";
    case Protocol_GROUP_MATCHING_BUDDY_LIST_REQUEST: return "GROUP_MATCHING_BUDDY_LIST_REQUEST";
    case Protocol_GROUP_MATCHING_BUDDY_LIST_RESPONSE: return "GROUP_MATCHING_BUDDY_LIST_RESPONSE";
    case Protocol_GROUP_MATCHING_INVITE_REQUEST: return "GROUP_MATCHING_INVITE_REQUEST";
    case Protocol_GROUP_MATCHING_INVITE_RESPONSE: return "GROUP_MATCHING_INVITE_RESPONSE";
    case Protocol_GROUP_MATCHING_MEMBER_LEAVE_NOTIFY: return "GROUP_MATCHING_MEMBER_LEAVE_NOTIFY";
    case Protocol_GROUP_MATCHING_INVITATION_ACCEPTED_NOTIFY: return "GROUP_MATCHING_INVITATION_ACCEPTED_NOTIFY";
    case Protocol_GROUP_MATCHING_INVITATION_REJECTED_NOTIFY: return "GROUP_MATCHING_INVITATION_REJECTED_NOTIFY";
    case Protocol_GROUP_MATCHING_INVITATION_ADD_NOTIFY: return "GROUP_MATCHING_INVITATION_ADD_NOTIFY";
    case Protocol_GROUP_MATCHING_INVITATION_REMOVE_NOTIFY: return "GROUP_MATCHING_INVITATION_REMOVE_NOTIFY";
    case Protocol_GROUP_MATCHING_INVITE_ACCEPT_REQUEST: return "GROUP_MATCHING_INVITE_ACCEPT_REQUEST";
    case Protocol_GROUP_MATCHING_INVITE_ACCEPT_RESPONSE: return "GROUP_MATCHING_INVITE_ACCEPT_RESPONSE";
    case Protocol_GROUP_MATCHING_INVITE_REJECT_REQUEST: return "GROUP_MATCHING_INVITE_REJECT_REQUEST";
    case Protocol_GROUP_MATCHING_INVITE_REJECT_RESPONSE: return "GROUP_MATCHING_INVITE_REJECT_RESPONSE";
    case Protocol_GROUP_MATCHING_START_REQUEST: return "GROUP_MATCHING_START_REQUEST";
    case Protocol_GROUP_MATCHING_START_RESPONSE: return "GROUP_MATCHING_START_RESPONSE";
    case Protocol_GROUP_MATCHING_CONVERT_TO_QUICK_REQUEST: return "GROUP_MATCHING_CONVERT_TO_QUICK_REQUEST";
    case Protocol_GROUP_MATCHING_CONVERT_TO_QUICK_RESPONSE: return "GROUP_MATCHING_CONVERT_TO_QUICK_RESPONSE";
    case Protocol_GROUP_MATCHING_REMATCHING_REQUEST: return "GROUP_MATCHING_REMATCHING_REQUEST";
    case Protocol_GROUP_MATCHING_REMATCHING_RESPONSE: return "GROUP_MATCHING_REMATCHING_RESPONSE";
    case Protocol_EQUIP_COSTUME_REQUEST: return "EQUIP_COSTUME_REQUEST";
    case Protocol_EQUIP_COSTUME_RESPONSE: return "EQUIP_COSTUME_RESPONSE";
    case Protocol_UNEQUIP_COSTUME_REQUEST: return "UNEQUIP_COSTUME_REQUEST";
    case Protocol_UNEQUIP_COSTUME_RESPONSE: return "UNEQUIP_COSTUME_RESPONSE";
    case Protocol_COSTUME_PRESET_CHANGE_REQUEST: return "COSTUME_PRESET_CHANGE_REQUEST";
    case Protocol_COSTUME_PRESET_CHANGE_RESPONSE: return "COSTUME_PRESET_CHANGE_RESPONSE";
    case Protocol_COSTUME_PRESET_COSTUMESLOT_UPDATE_NOTIFY: return "COSTUME_PRESET_COSTUMESLOT_UPDATE_NOTIFY";
    case Protocol_ENCHANT_COSTUME_REQUEST: return "ENCHANT_COSTUME_REQUEST";
    case Protocol_ENCHANT_COSTUME_RESPONSE: return "ENCHANT_COSTUME_RESPONSE";
    case Protocol_UPGRADE_COSTUME_REQUEST: return "UPGRADE_COSTUME_REQUEST";
    case Protocol_UPGRADE_COSTUME_RESPONSE: return "UPGRADE_COSTUME_RESPONSE";
    case Protocol_SHOW_COSTUME_REQUEST: return "SHOW_COSTUME_REQUEST";
    case Protocol_SHOW_COSTUME_RESPONSE: return "SHOW_COSTUME_RESPONSE";
    case Protocol_HIDE_COSTUME_REQUEST: return "HIDE_COSTUME_REQUEST";
    case Protocol_HIDE_COSTUME_RESPONSE: return "HIDE_COSTUME_RESPONSE";
    case Protocol_INHERIT_COSTUME_REQUEST: return "INHERIT_COSTUME_REQUEST";
    case Protocol_INHERIT_COSTUME_RESPONSE: return "INHERIT_COSTUME_RESPONSE";
    case Protocol_LIVE_EVENT_STOP_NOTIFY: return "LIVE_EVENT_STOP_NOTIFY";
    case Protocol_LIVE_EVENT_DATA_UPDATE_NOTIFY: return "LIVE_EVENT_DATA_UPDATE_NOTIFY";
    case Protocol_LIVE_EVENT_TRADE_DATA_NOTIFY: return "LIVE_EVENT_TRADE_DATA_NOTIFY";
    case Protocol_LIVE_EVENT_BUFF_DATA_NOTIFY: return "LIVE_EVENT_BUFF_DATA_NOTIFY";
    case Protocol_LIVE_EVENT_ATTENTION_DATA_NOTIFY: return "LIVE_EVENT_ATTENTION_DATA_NOTIFY";
    case Protocol_LIVE_EVENT_NEWBIE_ATTENTION_DATA_NOTIFY: return "LIVE_EVENT_NEWBIE_ATTENTION_DATA_NOTIFY";
    case Protocol_LIVE_EVENT_RETURN_ATTENTION_DATA_NOTIFY: return "LIVE_EVENT_RETURN_ATTENTION_DATA_NOTIFY";
    case Protocol_LIVE_EVENT_DIA_BUY_DATA_NOTIFY: return "LIVE_EVENT_DIA_BUY_DATA_NOTIFY";
    case Protocol_LIVE_EVENT_DIA_SPENT_DATA_NOTIFY: return "LIVE_EVENT_DIA_SPENT_DATA_NOTIFY";
    case Protocol_LIVE_EVENT_LIMIT_SELL_SHOP_DATA_NOTIFY: return "LIVE_EVENT_LIMIT_SELL_SHOP_DATA_NOTIFY";
    case Protocol_LIVE_EVENT_LEVEL_BUFF_DATA_NOTIFY: return "LIVE_EVENT_LEVEL_BUFF_DATA_NOTIFY";
    case Protocol_LIVE_EVENT_NEWBIE_BUFF_DATA_NOTIFY: return "LIVE_EVENT_NEWBIE_BUFF_DATA_NOTIFY";
    case Protocol_LIVE_EVENT_ITEM_DROP_DATA_NOTIFY: return "LIVE_EVENT_ITEM_DROP_DATA_NOTIFY";
    case Protocol_LIVE_EVENT_LEVELUP_EVENT_DATA_NOTIFY: return "LIVE_EVENT_LEVELUP_EVENT_DATA_NOTIFY";
    case Protocol_LIVE_EVENT_LEVELUP_NEWBIE_DATA_NOTIFY: return "LIVE_EVENT_LEVELUP_NEWBIE_DATA_NOTIFY";
    case Protocol_LIVE_EVENT_LEVELUP_RETURN_DATA_NOTIFY: return "LIVE_EVENT_LEVELUP_RETURN_DATA_NOTIFY";
    case Protocol_LIVE_EVENT_TRADE_INSTANCE_NOTIFY: return "LIVE_EVENT_TRADE_INSTANCE_NOTIFY";
    case Protocol_LIVE_EVENT_TRADE_INSTANCE_EXPIRE_NOTIFY: return "LIVE_EVENT_TRADE_INSTANCE_EXPIRE_NOTIFY";
    case Protocol_LIVE_EVENT_TRADE_PURCHASE_REQUEST: return "LIVE_EVENT_TRADE_PURCHASE_REQUEST";
    case Protocol_LIVE_EVENT_TRADE_PURCHASE_RESPONSE: return "LIVE_EVENT_TRADE_PURCHASE_RESPONSE";
    case Protocol_LIVE_EVENT_DIA_BUY_NOTIFY: return "LIVE_EVENT_DIA_BUY_NOTIFY";
    case Protocol_LIVE_EVENT_DIA_BUY_MISSION_UPDATE_NOTIFY: return "LIVE_EVENT_DIA_BUY_MISSION_UPDATE_NOTIFY";
    case Protocol_LIVE_EVENT_DIA_BUY_AMOUNT_UPDATE_NOTIFY: return "LIVE_EVENT_DIA_BUY_AMOUNT_UPDATE_NOTIFY";
    case Protocol_LIVE_EVENT_DIA_BUY_REWARD_REQUEST: return "LIVE_EVENT_DIA_BUY_REWARD_REQUEST";
    case Protocol_LIVE_EVENT_DIA_BUY_REWARD_RESPONSE: return "LIVE_EVENT_DIA_BUY_REWARD_RESPONSE";
    case Protocol_LIVE_EVENT_DIA_SPENT_NOTIFY: return "LIVE_EVENT_DIA_SPENT_NOTIFY";
    case Protocol_LIVE_EVENT_DIA_SPENT_MISSION_UPDATE_NOTIFY: return "LIVE_EVENT_DIA_SPENT_MISSION_UPDATE_NOTIFY";
    case Protocol_LIVE_EVENT_DIA_SPENT_AMOUNT_UPDATE_NOTIFY: return "LIVE_EVENT_DIA_SPENT_AMOUNT_UPDATE_NOTIFY";
    case Protocol_LIVE_EVENT_DIA_SPENT_REWARD_REQUEST: return "LIVE_EVENT_DIA_SPENT_REWARD_REQUEST";
    case Protocol_LIVE_EVENT_DIA_SPENT_REWARD_RESPONSE: return "LIVE_EVENT_DIA_SPENT_REWARD_RESPONSE";
    case Protocol_LIVE_EVENT_LIMIT_SELL_SHOP_INSTANCE_NOTIFY: return "LIVE_EVENT_LIMIT_SELL_SHOP_INSTANCE_NOTIFY";
    case Protocol_LIVE_EVENT_LIMIT_SELL_SHOP_INSTANCE_EXPIRE_NOTIFY: return "LIVE_EVENT_LIMIT_SELL_SHOP_INSTANCE_EXPIRE_NOTIFY";
    case Protocol_LIVE_EVENT_LIMIT_SELL_SHOP_PURCHASE_REQUEST: return "LIVE_EVENT_LIMIT_SELL_SHOP_PURCHASE_REQUEST";
    case Protocol_LIVE_EVENT_LIMIT_SELL_SHOP_PURCHASE_RESPONSE: return "LIVE_EVENT_LIMIT_SELL_SHOP_PURCHASE_RESPONSE";
    case Protocol_LIVE_EVENT_ATTENTION_NOTIFY: return "LIVE_EVENT_ATTENTION_NOTIFY";
    case Protocol_LIVE_EVENT_ATTENTION_RECEIVE_NOTIFY: return "LIVE_EVENT_ATTENTION_RECEIVE_NOTIFY";
    case Protocol_LIVE_EVENT_ATTENTION_END_RECEIVE_NOTIFY: return "LIVE_EVENT_ATTENTION_END_RECEIVE_NOTIFY";
    case Protocol_LIVE_EVENT_ATTENTION_REWARD_RECEIVE_REQUEST: return "LIVE_EVENT_ATTENTION_REWARD_RECEIVE_REQUEST";
    case Protocol_LIVE_EVENT_ATTENTION_REWARD_RECEIVE_RESPONSE: return "LIVE_EVENT_ATTENTION_REWARD_RECEIVE_RESPONSE";
    case Protocol_LIVE_EVENT_ATTENTION_RETURN_REWARD_RECEIVE_REQUEST: return "LIVE_EVENT_ATTENTION_RETURN_REWARD_RECEIVE_REQUEST";
    case Protocol_LIVE_EVENT_ATTENTION_RETURN_REWARD_RECEIVE_RESPONSE: return "LIVE_EVENT_ATTENTION_RETURN_REWARD_RECEIVE_RESPONSE";
    case Protocol_LIVE_EVENT_ATTENTION_NEWBIE_REWARD_RECEIVE_REQUEST: return "LIVE_EVENT_ATTENTION_NEWBIE_REWARD_RECEIVE_REQUEST";
    case Protocol_LIVE_EVENT_ATTENTION_NEWBIE_REWARD_RECEIVE_RESPONSE: return "LIVE_EVENT_ATTENTION_NEWBIE_REWARD_RECEIVE_RESPONSE";
    case Protocol_LIVE_EVENT_ATTENTION_END_REWARD_RECEIVE_REQUEST: return "LIVE_EVENT_ATTENTION_END_REWARD_RECEIVE_REQUEST";
    case Protocol_LIVE_EVENT_ATTENTION_END_REWARD_RECEIVE_RESPONSE: return "LIVE_EVENT_ATTENTION_END_REWARD_RECEIVE_RESPONSE";
    case Protocol_LIVE_EVENT_ATTENTION_END_RETURN_REWARD_RECEIVE_REQUEST: return "LIVE_EVENT_ATTENTION_END_RETURN_REWARD_RECEIVE_REQUEST";
    case Protocol_LIVE_EVENT_ATTENTION_END_RETURN_REWARD_RECEIVE_RESPONSE: return "LIVE_EVENT_ATTENTION_END_RETURN_REWARD_RECEIVE_RESPONSE";
    case Protocol_LIVE_EVENT_ATTENTION_END_NEWBIE_REWARD_RECEIVE_REQUEST: return "LIVE_EVENT_ATTENTION_END_NEWBIE_REWARD_RECEIVE_REQUEST";
    case Protocol_LIVE_EVENT_ATTENTION_END_NEWBIE_REWARD_RECEIVE_RESPONSE: return "LIVE_EVENT_ATTENTION_END_NEWBIE_REWARD_RECEIVE_RESPONSE";
    case Protocol_LIVE_EVENT_BUFF_INFO_INSTANCE_NOTIFY: return "LIVE_EVENT_BUFF_INFO_INSTANCE_NOTIFY";
    case Protocol_LIVE_EVENT_LEVELUP_NOTIFY: return "LIVE_EVENT_LEVELUP_NOTIFY";
    case Protocol_LIVE_EVENT_LEVELUP_RECEIVE_NOTIFY: return "LIVE_EVENT_LEVELUP_RECEIVE_NOTIFY";
    case Protocol_LIVE_EVENT_LEVELUP_REWARD_RECEIVE_REQUEST: return "LIVE_EVENT_LEVELUP_REWARD_RECEIVE_REQUEST";
    case Protocol_LIVE_EVENT_LEVELUP_REWARD_RECEIVE_RESPONSE: return "LIVE_EVENT_LEVELUP_REWARD_RECEIVE_RESPONSE";
    case Protocol_STORAGE_SLOT_EXPANSION_REQUEST: return "STORAGE_SLOT_EXPANSION_REQUEST";
    case Protocol_STORAGE_SLOT_EXPANSION_RESPONSE: return "STORAGE_SLOT_EXPANSION_RESPONSE";
    case Protocol_BRAWL_TIME_INFO_NOTIFY: return "BRAWL_TIME_INFO_NOTIFY";
    case Protocol_BRAWL_TIME_INFO_REQUEST: return "BRAWL_TIME_INFO_REQUEST";
    case Protocol_BRAWL_TIME_INFO_RESPONSE: return "BRAWL_TIME_INFO_RESPONSE";
    case Protocol_BRAWL_TIME_EXPIRED_NOTIFY: return "BRAWL_TIME_EXPIRED_NOTIFY";
    case Protocol_BRAWL_FREE_TIME_EXPIRED_NOTIFY: return "BRAWL_FREE_TIME_EXPIRED_NOTIFY";
    case Protocol_BRAWL_REMAIN_TIME_NOTIFY: return "BRAWL_REMAIN_TIME_NOTIFY";
    case Protocol_BRAWL_SHORT_TERM_DATA_NOTIFY: return "BRAWL_SHORT_TERM_DATA_NOTIFY";
    case Protocol_BRAWL_SHORT_TERM_REWARD_REQUEST: return "BRAWL_SHORT_TERM_REWARD_REQUEST";
    case Protocol_BRAWL_SHORT_TERM_REWARD_RESPONSE: return "BRAWL_SHORT_TERM_REWARD_RESPONSE";
    case Protocol_BRAWL_SHORT_TERM_DATA_REQUEST: return "BRAWL_SHORT_TERM_DATA_REQUEST";
    case Protocol_BRAWL_SHORT_TERM_DATA_RESPONSE: return "BRAWL_SHORT_TERM_DATA_RESPONSE";
    case Protocol_BRAWL_PK_NOTIFY: return "BRAWL_PK_NOTIFY";
    case Protocol_BRAWL_SHORT_TERM_MAX_NOTIFY: return "BRAWL_SHORT_TERM_MAX_NOTIFY";
    case Protocol_BRAWL_OTHER_PC_SHORT_TERM_MAX_NOTIFY: return "BRAWL_OTHER_PC_SHORT_TERM_MAX_NOTIFY";
    case Protocol_BRAWL_POINT_NOTIFY: return "BRAWL_POINT_NOTIFY";
    case Protocol_BRAWL_ENHANCE_DATA_NOTIFY: return "BRAWL_ENHANCE_DATA_NOTIFY";
    case Protocol_BRAWL_ENHANCE_LEVEL_UP_REQUEST: return "BRAWL_ENHANCE_LEVEL_UP_REQUEST";
    case Protocol_BRAWL_ENHANCE_LEVEL_UP_RESPONSE: return "BRAWL_ENHANCE_LEVEL_UP_RESPONSE";
    case Protocol_ADD_ITEM_FAILED_NOT_ENOUGH_STORAGE_SPACE_NOTIFY: return "ADD_ITEM_FAILED_NOT_ENOUGH_STORAGE_SPACE_NOTIFY";
    case Protocol_SCROLL_QUEST_DAILY_INFO_NOTIFY: return "SCROLL_QUEST_DAILY_INFO_NOTIFY";
    case Protocol_SCROLL_QUEST_PROGRESS_INFO_NOTIFY: return "SCROLL_QUEST_PROGRESS_INFO_NOTIFY";
    case Protocol_SCROLL_QUEST_START_PROGRESS_REQUEST: return "SCROLL_QUEST_START_PROGRESS_REQUEST";
    case Protocol_SCROLL_QUEST_START_PROGRESS_RESPONSE: return "SCROLL_QUEST_START_PROGRESS_RESPONSE";
    case Protocol_SCROLL_QUEST_GIVE_UP_REQUEST: return "SCROLL_QUEST_GIVE_UP_REQUEST";
    case Protocol_SCROLL_QUEST_GIVE_UP_RESPONSE: return "SCROLL_QUEST_GIVE_UP_RESPONSE";
    case Protocol_SCROLL_QUEST_REWARD_REQUEST: return "SCROLL_QUEST_REWARD_REQUEST";
    case Protocol_SCROLL_QUEST_REWARD_RESPONSE: return "SCROLL_QUEST_REWARD_RESPONSE";
    case Protocol_BRAWL_LAST_LEAVED_TIME_REQUEST: return "BRAWL_LAST_LEAVED_TIME_REQUEST";
    case Protocol_BRAWL_LAST_LEAVED_TIME_RESPONSE: return "BRAWL_LAST_LEAVED_TIME_RESPONSE";
    case Protocol_BRAWL_LAST_LEAVED_TIME_NOTIFY: return "BRAWL_LAST_LEAVED_TIME_NOTIFY";
    case Protocol_PET_CREATED_WITH_EFFECT_NOTIFY: return "PET_CREATED_WITH_EFFECT_NOTIFY";
    case Protocol_PET_CREATED_NOTIFY: return "PET_CREATED_NOTIFY";
    case Protocol_PET_DELETED_NOTIFY: return "PET_DELETED_NOTIFY";
    case Protocol_PET_DATA_NOTIFY: return "PET_DATA_NOTIFY";
    case Protocol_PET_FEED_REQUEST: return "PET_FEED_REQUEST";
    case Protocol_PET_FEED_RESPONSE: return "PET_FEED_RESPONSE";
    case Protocol_PET_DIGESTION_COMPLETE_NOTIFY: return "PET_DIGESTION_COMPLETE_NOTIFY";
    case Protocol_PET_SUMMON_REQUEST: return "PET_SUMMON_REQUEST";
    case Protocol_PET_SUMMON_RESPONSE: return "PET_SUMMON_RESPONSE";
    case Protocol_PET_SUMMON_CANCEL_REQUEST: return "PET_SUMMON_CANCEL_REQUEST";
    case Protocol_PET_SUMMON_CANCEL_RESPONSE: return "PET_SUMMON_CANCEL_RESPONSE";
    case Protocol_PET_SUPPORT_REQUEST: return "PET_SUPPORT_REQUEST";
    case Protocol_PET_SUPPORT_RESPONSE: return "PET_SUPPORT_RESPONSE";
    case Protocol_PET_SUPPORT_CANCEL_REQUEST: return "PET_SUPPORT_CANCEL_REQUEST";
    case Protocol_PET_SUPPORT_CANCEL_RESPONSE: return "PET_SUPPORT_CANCEL_RESPONSE";
    case Protocol_PET_REMAIN_DIGESTION_TIME_REQUEST: return "PET_REMAIN_DIGESTION_TIME_REQUEST";
    case Protocol_PET_REMAIN_DIGESTION_TIME_RESPONSE: return "PET_REMAIN_DIGESTION_TIME_RESPONSE";
    case Protocol_PET_FUSION_REQUEST: return "PET_FUSION_REQUEST";
    case Protocol_PET_FUSION_RESPONSE: return "PET_FUSION_RESPONSE";
    case Protocol_PET_LEVEL_EXP_UP_NOTIFY: return "PET_LEVEL_EXP_UP_NOTIFY";
    case Protocol_PET_TOGGLE_SAFE_GUARD_REQUEST: return "PET_TOGGLE_SAFE_GUARD_REQUEST";
    case Protocol_PET_TOGGLE_SAFE_GUARD_RESPONSE: return "PET_TOGGLE_SAFE_GUARD_RESPONSE";
    case Protocol_PET_ALTAR_DATA_NOTIFY: return "PET_ALTAR_DATA_NOTIFY";
    case Protocol_PET_ALTAR_LEVEL_EXP_NOTIFY: return "PET_ALTAR_LEVEL_EXP_NOTIFY";
    case Protocol_PET_ALTAR_POINT_NOTIFY: return "PET_ALTAR_POINT_NOTIFY";
    case Protocol_PET_ALTAR_DONATE_REQUEST: return "PET_ALTAR_DONATE_REQUEST";
    case Protocol_PET_ALTAR_DONATE_RESPONSE: return "PET_ALTAR_DONATE_RESPONSE";
    case Protocol_PET_ALTAR_ACTIVE_SKILL_LEVEL_UP_REQUEST: return "PET_ALTAR_ACTIVE_SKILL_LEVEL_UP_REQUEST";
    case Protocol_PET_ALTAR_ACTIVE_SKILL_LEVEL_UP_RESPONSE: return "PET_ALTAR_ACTIVE_SKILL_LEVEL_UP_RESPONSE";
    case Protocol_PET_HATCHERY_DATA_NOTIFY: return "PET_HATCHERY_DATA_NOTIFY";
    case Protocol_PET_HATCHERY_SPAWN_REQUEST: return "PET_HATCHERY_SPAWN_REQUEST";
    case Protocol_PET_HATCHERY_SPAWN_RESPONSE: return "PET_HATCHERY_SPAWN_RESPONSE";
    case Protocol_PET_HATCHERY_HATCH_REQUEST: return "PET_HATCHERY_HATCH_REQUEST";
    case Protocol_PET_HATCHERY_HATCH_RESPONSE: return "PET_HATCHERY_HATCH_RESPONSE";
    case Protocol_DB_PET_MAKE_REQUEST: return "DB_PET_MAKE_REQUEST";
    case Protocol_DB_PET_MAKE_RESPONSE: return "DB_PET_MAKE_RESPONSE";
    case Protocol_DB_PET_FEED_REQUEST: return "DB_PET_FEED_REQUEST";
    case Protocol_DB_PET_FEED_RESPONSE: return "DB_PET_FEED_RESPONSE";
    case Protocol_DB_PET_FUSION_REQUEST: return "DB_PET_FUSION_REQUEST";
    case Protocol_DB_PET_FUSION_RESPONSE: return "DB_PET_FUSION_RESPONSE";
    case Protocol_DB_PET_SET_STATE_REQUEST: return "DB_PET_SET_STATE_REQUEST";
    case Protocol_DB_PET_SET_STATE_RESPONSE: return "DB_PET_SET_STATE_RESPONSE";
    case Protocol_DB_PET_LEVEL_UP_REQUEST: return "DB_PET_LEVEL_UP_REQUEST";
    case Protocol_DB_PET_LEVEL_UP_RESPONSE: return "DB_PET_LEVEL_UP_RESPONSE";
    case Protocol_DB_PET_TOGGLE_SAFE_GUARD_REQUEST: return "DB_PET_TOGGLE_SAFE_GUARD_REQUEST";
    case Protocol_DB_PET_TOGGLE_SAFE_GUARD_RESPONSE: return "DB_PET_TOGGLE_SAFE_GUARD_RESPONSE";
    case Protocol_DB_PET_ALTAR_DONATE_REQUEST: return "DB_PET_ALTAR_DONATE_REQUEST";
    case Protocol_DB_PET_ALTAR_DONATE_RESPONSE: return "DB_PET_ALTAR_DONATE_RESPONSE";
    case Protocol_DB_PET_ALTAR_ACTIVE_SKILL_LEVEL_UP_REQUEST: return "DB_PET_ALTAR_ACTIVE_SKILL_LEVEL_UP_REQUEST";
    case Protocol_DB_PET_ALTAR_ACTIVE_SKILL_LEVEL_UP_RESPONSE: return "DB_PET_ALTAR_ACTIVE_SKILL_LEVEL_UP_RESPONSE";
    case Protocol_DB_PET_HATCHERY_SUMMON_REQUEST: return "DB_PET_HATCHERY_SUMMON_REQUEST";
    case Protocol_DB_PET_HATCHERY_SUMMON_RESPONSE: return "DB_PET_HATCHERY_SUMMON_RESPONSE";
    case Protocol_DB_PET_HATCHERY_HATCH_REQUEST: return "DB_PET_HATCHERY_HATCH_REQUEST";
    case Protocol_DB_PET_HATCHERY_HATCH_RESPONSE: return "DB_PET_HATCHERY_HATCH_RESPONSE";
    case Protocol_DB_PET_SET_REQUEST: return "DB_PET_SET_REQUEST";
    case Protocol_DB_PET_SET_RESPONSE: return "DB_PET_SET_RESPONSE";
    case Protocol_DB_PET_DELETE_REQUEST: return "DB_PET_DELETE_REQUEST";
    case Protocol_DB_PET_DELETE_RESPONSE: return "DB_PET_DELETE_RESPONSE";
    case Protocol_DB_PET_ALTAR_SET_REQUEST: return "DB_PET_ALTAR_SET_REQUEST";
    case Protocol_DB_PET_ALTAR_SET_RESPONSE: return "DB_PET_ALTAR_SET_RESPONSE";
    case Protocol_CONFLICT_FIELD_MOVE_HOME_SERVER_REQUEST: return "CONFLICT_FIELD_MOVE_HOME_SERVER_REQUEST";
    case Protocol_CONFLICT_FIELD_MOVE_HOME_SERVER_RESPONSE: return "CONFLICT_FIELD_MOVE_HOME_SERVER_RESPONSE";
    case Protocol_KINGSROAD_QUERY_MAINSTREAM_QUEST_REQUEST: return "KINGSROAD_QUERY_MAINSTREAM_QUEST_REQUEST";
    case Protocol_KINGSROAD_QUERY_MAINSTREAM_QUEST_RESPONSE: return "KINGSROAD_QUERY_MAINSTREAM_QUEST_RESPONSE";
    case Protocol_PUBLIC_KEY_NOTIFY: return "PUBLIC_KEY_NOTIFY";
    case Protocol_CRYPT_KEY_NOTIFY: return "CRYPT_KEY_NOTIFY";
    case Protocol_MAX: return "MAX";
    default: return "";
  }
}

///-----------------------------------------------------------------------------
/// Client <-> Auth
///-----------------------------------------------------------------------------
enum AdminLevel {
  AdminLevel_ADMIN_LEVEL_NORMAL = 0,
  AdminLevel_ADMIN_LEVEL_OPERATOR = 5,
  AdminLevel_ADMIN_LEVEL_DEVELOPER = 10,
  AdminLevel_ADMIN_LEVEL_MAX = 11,
  AdminLevel_MIN = AdminLevel_ADMIN_LEVEL_NORMAL,
  AdminLevel_MAX = AdminLevel_ADMIN_LEVEL_MAX
};

inline const AdminLevel (&EnumValuesAdminLevel())[4] {
  static const AdminLevel values[] = {
    AdminLevel_ADMIN_LEVEL_NORMAL,
    AdminLevel_ADMIN_LEVEL_OPERATOR,
    AdminLevel_ADMIN_LEVEL_DEVELOPER,
    AdminLevel_ADMIN_LEVEL_MAX
  };
  return values;
}

inline const char * const *EnumNamesAdminLevel() {
  static const char * const names[] = {
    "ADMIN_LEVEL_NORMAL",
    "",
    "",
    "",
    "",
    "ADMIN_LEVEL_OPERATOR",
    "",
    "",
    "",
    "",
    "ADMIN_LEVEL_DEVELOPER",
    "ADMIN_LEVEL_MAX",
    nullptr
  };
  return names;
}

inline const char *EnumNameAdminLevel(AdminLevel e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesAdminLevel()[index];
}

enum ColonyStatus {
  ColonyStatus_CS_GOOD = 0,
  ColonyStatus_CS_SMOOTH = 1,
  ColonyStatus_CS_BUSY = 2,
  ColonyStatus_CS_DOWN = 3,
  ColonyStatus_CS_HIDE = 4,
  ColonyStatus_MIN = ColonyStatus_CS_GOOD,
  ColonyStatus_MAX = ColonyStatus_CS_HIDE
};

inline const ColonyStatus (&EnumValuesColonyStatus())[5] {
  static const ColonyStatus values[] = {
    ColonyStatus_CS_GOOD,
    ColonyStatus_CS_SMOOTH,
    ColonyStatus_CS_BUSY,
    ColonyStatus_CS_DOWN,
    ColonyStatus_CS_HIDE
  };
  return values;
}

inline const char * const *EnumNamesColonyStatus() {
  static const char * const names[] = {
    "CS_GOOD",
    "CS_SMOOTH",
    "CS_BUSY",
    "CS_DOWN",
    "CS_HIDE",
    nullptr
  };
  return names;
}

inline const char *EnumNameColonyStatus(ColonyStatus e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesColonyStatus()[index];
}

///- ExitReason ----------
enum ExitReason {
  /// 일반적 유저 선택
  ExitReason_ER_NORMAL = 1  /// 운영자에 의한
,
  ExitReason_ER_KICKED = 2,
  ExitReason_MIN = ExitReason_ER_NORMAL,
  ExitReason_MAX = ExitReason_ER_KICKED
};

inline const ExitReason (&EnumValuesExitReason())[2] {
  static const ExitReason values[] = {
    ExitReason_ER_NORMAL,
    ExitReason_ER_KICKED
  };
  return values;
}

inline const char * const *EnumNamesExitReason() {
  static const char * const names[] = {
    "ER_NORMAL",
    "ER_KICKED",
    nullptr
  };
  return names;
}

inline const char *EnumNameExitReason(ExitReason e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(ExitReason_ER_NORMAL);
  return EnumNamesExitReason()[index];
}

///-----------------------------------------------------------------------------
/// Client <-> Game
///-----------------------------------------------------------------------------
///- ENTER_EVENTSET_CHANNEL_REQUEST  ----------
enum JoinChannelReason {
  JoinChannelReason_JOIN_CHANNEL_REASON_NONE = 0,
  JoinChannelReason_JOIN_CHANNEL_REASON_SUCCESS = 1,
  JoinChannelReason_JOIN_CHANNEL_REASON_FAIL_ACTIVATE = 2,
  JoinChannelReason_JOIN_CHANNEL_REASON_FAIL_NO_SPAWNED = 3,
  JoinChannelReason_JOIN_CHANNEL_REASON_FAIL_NO_DATA = 4,
  JoinChannelReason_JOIN_CHANNEL_REASON_FAIL_INVALID_SMAPID = 5,
  JoinChannelReason_JOIN_CHANNEL_REASON_FAIL_LEVEL = 6,
  JoinChannelReason_JOIN_CHANNEL_REASON_FAIL_TIME = 7,
  JoinChannelReason_JOIN_CHANNEL_REASON_SAME_EVENTSET_ID = 8,
  JoinChannelReason_JOIN_CHANNEL_REASON_NOT_ENOUGHT_COST = 9,
  JoinChannelReason_JOIN_CHANNEL_REASON_MAX = 10,
  JoinChannelReason_MIN = JoinChannelReason_JOIN_CHANNEL_REASON_NONE,
  JoinChannelReason_MAX = JoinChannelReason_JOIN_CHANNEL_REASON_MAX
};

inline const JoinChannelReason (&EnumValuesJoinChannelReason())[11] {
  static const JoinChannelReason values[] = {
    JoinChannelReason_JOIN_CHANNEL_REASON_NONE,
    JoinChannelReason_JOIN_CHANNEL_REASON_SUCCESS,
    JoinChannelReason_JOIN_CHANNEL_REASON_FAIL_ACTIVATE,
    JoinChannelReason_JOIN_CHANNEL_REASON_FAIL_NO_SPAWNED,
    JoinChannelReason_JOIN_CHANNEL_REASON_FAIL_NO_DATA,
    JoinChannelReason_JOIN_CHANNEL_REASON_FAIL_INVALID_SMAPID,
    JoinChannelReason_JOIN_CHANNEL_REASON_FAIL_LEVEL,
    JoinChannelReason_JOIN_CHANNEL_REASON_FAIL_TIME,
    JoinChannelReason_JOIN_CHANNEL_REASON_SAME_EVENTSET_ID,
    JoinChannelReason_JOIN_CHANNEL_REASON_NOT_ENOUGHT_COST,
    JoinChannelReason_JOIN_CHANNEL_REASON_MAX
  };
  return values;
}

inline const char * const *EnumNamesJoinChannelReason() {
  static const char * const names[] = {
    "JOIN_CHANNEL_REASON_NONE",
    "JOIN_CHANNEL_REASON_SUCCESS",
    "JOIN_CHANNEL_REASON_FAIL_ACTIVATE",
    "JOIN_CHANNEL_REASON_FAIL_NO_SPAWNED",
    "JOIN_CHANNEL_REASON_FAIL_NO_DATA",
    "JOIN_CHANNEL_REASON_FAIL_INVALID_SMAPID",
    "JOIN_CHANNEL_REASON_FAIL_LEVEL",
    "JOIN_CHANNEL_REASON_FAIL_TIME",
    "JOIN_CHANNEL_REASON_SAME_EVENTSET_ID",
    "JOIN_CHANNEL_REASON_NOT_ENOUGHT_COST",
    "JOIN_CHANNEL_REASON_MAX",
    nullptr
  };
  return names;
}

inline const char *EnumNameJoinChannelReason(JoinChannelReason e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesJoinChannelReason()[index];
}

///- TELEPORT_RESPONSE TYPE ----------
enum TeleportType {
  TeleportType_TELEPORT_NONE = 0,
  TeleportType_TELEPORT_IN_SCENE = 1,
  TeleportType_TELEPORT_IN_CHANEL = 2,
  TeleportType_TELEPORT_IN_GAMESERVER = 3,
  TeleportType_MIN = TeleportType_TELEPORT_NONE,
  TeleportType_MAX = TeleportType_TELEPORT_IN_GAMESERVER
};

inline const TeleportType (&EnumValuesTeleportType())[4] {
  static const TeleportType values[] = {
    TeleportType_TELEPORT_NONE,
    TeleportType_TELEPORT_IN_SCENE,
    TeleportType_TELEPORT_IN_CHANEL,
    TeleportType_TELEPORT_IN_GAMESERVER
  };
  return values;
}

inline const char * const *EnumNamesTeleportType() {
  static const char * const names[] = {
    "TELEPORT_NONE",
    "TELEPORT_IN_SCENE",
    "TELEPORT_IN_CHANEL",
    "TELEPORT_IN_GAMESERVER",
    nullptr
  };
  return names;
}

inline const char *EnumNameTeleportType(TeleportType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesTeleportType()[index];
}

///- EVENT_DIRECTION_TYPE ----------
enum EventDirectionType {
  EventDirectionType_EVENT_DIRECTION_TYPE_NONE = 0,
  EventDirectionType_EVENT_DIRECTION_TYPE_NOTICE = 1,
  EventDirectionType_EVENT_DIRECTION_TYPE_UI = 2,
  EventDirectionType_MIN = EventDirectionType_EVENT_DIRECTION_TYPE_NONE,
  EventDirectionType_MAX = EventDirectionType_EVENT_DIRECTION_TYPE_UI
};

inline const EventDirectionType (&EnumValuesEventDirectionType())[3] {
  static const EventDirectionType values[] = {
    EventDirectionType_EVENT_DIRECTION_TYPE_NONE,
    EventDirectionType_EVENT_DIRECTION_TYPE_NOTICE,
    EventDirectionType_EVENT_DIRECTION_TYPE_UI
  };
  return values;
}

inline const char * const *EnumNamesEventDirectionType() {
  static const char * const names[] = {
    "EVENT_DIRECTION_TYPE_NONE",
    "EVENT_DIRECTION_TYPE_NOTICE",
    "EVENT_DIRECTION_TYPE_UI",
    nullptr
  };
  return names;
}

inline const char *EnumNameEventDirectionType(EventDirectionType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEventDirectionType()[index];
}

///- EVENT_STATE_TYPE ----------
enum EventStateType {
  EventStateType_EVENT_STATE_TYPE_NONE = 0,
  EventStateType_EVENT_STATE_TYPE_READY = 1,
  EventStateType_EVENT_STATE_TYPE_RUNNING = 2,
  EventStateType_EVENT_STATE_TYPE_SUCCESS = 3,
  EventStateType_EVENT_STATE_TYPE_FAIL = 4,
  EventStateType_EVENT_STATE_TYPE_FINISH = 5,
  EventStateType_MIN = EventStateType_EVENT_STATE_TYPE_NONE,
  EventStateType_MAX = EventStateType_EVENT_STATE_TYPE_FINISH
};

inline const EventStateType (&EnumValuesEventStateType())[6] {
  static const EventStateType values[] = {
    EventStateType_EVENT_STATE_TYPE_NONE,
    EventStateType_EVENT_STATE_TYPE_READY,
    EventStateType_EVENT_STATE_TYPE_RUNNING,
    EventStateType_EVENT_STATE_TYPE_SUCCESS,
    EventStateType_EVENT_STATE_TYPE_FAIL,
    EventStateType_EVENT_STATE_TYPE_FINISH
  };
  return values;
}

inline const char * const *EnumNamesEventStateType() {
  static const char * const names[] = {
    "EVENT_STATE_TYPE_NONE",
    "EVENT_STATE_TYPE_READY",
    "EVENT_STATE_TYPE_RUNNING",
    "EVENT_STATE_TYPE_SUCCESS",
    "EVENT_STATE_TYPE_FAIL",
    "EVENT_STATE_TYPE_FINISH",
    nullptr
  };
  return names;
}

inline const char *EnumNameEventStateType(EventStateType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEventStateType()[index];
}

///- EVENT_COUNTER_STATE_TYPE ----------
enum EventCounterStateType {
  EventCounterStateType_EVENT_COUNTER_STATE_TYPE_NONE = 0,
  EventCounterStateType_EVENT_COUNTER_STATE_TYPE_INIT = 1,
  EventCounterStateType_EVENT_COUNTER_STATE_TYPE_ACTIVE = 2,
  EventCounterStateType_EVENT_COUNTER_STATE_TYPE_SUCCESS = 3,
  EventCounterStateType_EVENT_COUNTER_STATE_TYPE_WAIT_FINISH = 4,
  EventCounterStateType_EVENT_COUNTER_STATE_TYPE_FINISH = 5,
  EventCounterStateType_EVENT_COUNTER_STATE_TYPE_TERMINATE = 6,
  EventCounterStateType_MIN = EventCounterStateType_EVENT_COUNTER_STATE_TYPE_NONE,
  EventCounterStateType_MAX = EventCounterStateType_EVENT_COUNTER_STATE_TYPE_TERMINATE
};

inline const EventCounterStateType (&EnumValuesEventCounterStateType())[7] {
  static const EventCounterStateType values[] = {
    EventCounterStateType_EVENT_COUNTER_STATE_TYPE_NONE,
    EventCounterStateType_EVENT_COUNTER_STATE_TYPE_INIT,
    EventCounterStateType_EVENT_COUNTER_STATE_TYPE_ACTIVE,
    EventCounterStateType_EVENT_COUNTER_STATE_TYPE_SUCCESS,
    EventCounterStateType_EVENT_COUNTER_STATE_TYPE_WAIT_FINISH,
    EventCounterStateType_EVENT_COUNTER_STATE_TYPE_FINISH,
    EventCounterStateType_EVENT_COUNTER_STATE_TYPE_TERMINATE
  };
  return values;
}

inline const char * const *EnumNamesEventCounterStateType() {
  static const char * const names[] = {
    "EVENT_COUNTER_STATE_TYPE_NONE",
    "EVENT_COUNTER_STATE_TYPE_INIT",
    "EVENT_COUNTER_STATE_TYPE_ACTIVE",
    "EVENT_COUNTER_STATE_TYPE_SUCCESS",
    "EVENT_COUNTER_STATE_TYPE_WAIT_FINISH",
    "EVENT_COUNTER_STATE_TYPE_FINISH",
    "EVENT_COUNTER_STATE_TYPE_TERMINATE",
    nullptr
  };
  return names;
}

inline const char *EnumNameEventCounterStateType(EventCounterStateType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEventCounterStateType()[index];
}

///- EVENT_COUNTER_TYPE ----------
enum EventCounterType {
  EventCounterType_EVENT_COUNTER_TYPE_NONE = 0,
  EventCounterType_EVENT_COUNTER_TYPE_TIME = 1,
  EventCounterType_EVENT_COUNTER_TYPE_COUNTING = 2,
  EventCounterType_EVENT_COUNTER_TYPE_DURABILITRY = 3,
  EventCounterType_EVENT_COUNTER_TYPE_FLAG = 4,
  EventCounterType_MIN = EventCounterType_EVENT_COUNTER_TYPE_NONE,
  EventCounterType_MAX = EventCounterType_EVENT_COUNTER_TYPE_FLAG
};

inline const EventCounterType (&EnumValuesEventCounterType())[5] {
  static const EventCounterType values[] = {
    EventCounterType_EVENT_COUNTER_TYPE_NONE,
    EventCounterType_EVENT_COUNTER_TYPE_TIME,
    EventCounterType_EVENT_COUNTER_TYPE_COUNTING,
    EventCounterType_EVENT_COUNTER_TYPE_DURABILITRY,
    EventCounterType_EVENT_COUNTER_TYPE_FLAG
  };
  return values;
}

inline const char * const *EnumNamesEventCounterType() {
  static const char * const names[] = {
    "EVENT_COUNTER_TYPE_NONE",
    "EVENT_COUNTER_TYPE_TIME",
    "EVENT_COUNTER_TYPE_COUNTING",
    "EVENT_COUNTER_TYPE_DURABILITRY",
    "EVENT_COUNTER_TYPE_FLAG",
    nullptr
  };
  return names;
}

inline const char *EnumNameEventCounterType(EventCounterType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEventCounterType()[index];
}

///- EVENT_NOTICE_STATE_TYPE ----------
enum EventNoticeStateType {
  EventNoticeStateType_EVENT_NOTICE_STATE_TYPE_NONE = 0,
  EventNoticeStateType_EVENT_NOTICE_STATE_TYPE_READY = 1,
  EventNoticeStateType_EVENT_NOTICE_STATE_TYPE_START = 2,
  EventNoticeStateType_EVENT_NOTICE_STATE_TYPE_END_SUCCESS = 3,
  EventNoticeStateType_EVENT_NOTICE_STATE_TYPE_END_FAIL = 4,
  EventNoticeStateType_MIN = EventNoticeStateType_EVENT_NOTICE_STATE_TYPE_NONE,
  EventNoticeStateType_MAX = EventNoticeStateType_EVENT_NOTICE_STATE_TYPE_END_FAIL
};

inline const EventNoticeStateType (&EnumValuesEventNoticeStateType())[5] {
  static const EventNoticeStateType values[] = {
    EventNoticeStateType_EVENT_NOTICE_STATE_TYPE_NONE,
    EventNoticeStateType_EVENT_NOTICE_STATE_TYPE_READY,
    EventNoticeStateType_EVENT_NOTICE_STATE_TYPE_START,
    EventNoticeStateType_EVENT_NOTICE_STATE_TYPE_END_SUCCESS,
    EventNoticeStateType_EVENT_NOTICE_STATE_TYPE_END_FAIL
  };
  return values;
}

inline const char * const *EnumNamesEventNoticeStateType() {
  static const char * const names[] = {
    "EVENT_NOTICE_STATE_TYPE_NONE",
    "EVENT_NOTICE_STATE_TYPE_READY",
    "EVENT_NOTICE_STATE_TYPE_START",
    "EVENT_NOTICE_STATE_TYPE_END_SUCCESS",
    "EVENT_NOTICE_STATE_TYPE_END_FAIL",
    nullptr
  };
  return names;
}

inline const char *EnumNameEventNoticeStateType(EventNoticeStateType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEventNoticeStateType()[index];
}

enum ChannelCongestion {
  ChannelCongestion_ChannelCongestion_Level1 = 0,
  ChannelCongestion_ChannelCongestion_Level2 = 1,
  ChannelCongestion_ChannelCongestion_Level3 = 2,
  ChannelCongestion_MIN = ChannelCongestion_ChannelCongestion_Level1,
  ChannelCongestion_MAX = ChannelCongestion_ChannelCongestion_Level3
};

inline const ChannelCongestion (&EnumValuesChannelCongestion())[3] {
  static const ChannelCongestion values[] = {
    ChannelCongestion_ChannelCongestion_Level1,
    ChannelCongestion_ChannelCongestion_Level2,
    ChannelCongestion_ChannelCongestion_Level3
  };
  return values;
}

inline const char * const *EnumNamesChannelCongestion() {
  static const char * const names[] = {
    "ChannelCongestion_Level1",
    "ChannelCongestion_Level2",
    "ChannelCongestion_Level3",
    nullptr
  };
  return names;
}

inline const char *EnumNameChannelCongestion(ChannelCongestion e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesChannelCongestion()[index];
}

/// 이벤트 기여도 랭크
enum EventRankType {
  EventRankType_ERT_SRANK = 0,
  EventRankType_ERT_ARANK = 1,
  EventRankType_ERT_BRANK = 2,
  EventRankType_ERT_CRANK = 3,
  EventRankType_ERT_FRANK = 4,
  EventRankType_ERT_MAX = 5,
  EventRankType_MIN = EventRankType_ERT_SRANK,
  EventRankType_MAX = EventRankType_ERT_MAX
};

inline const EventRankType (&EnumValuesEventRankType())[6] {
  static const EventRankType values[] = {
    EventRankType_ERT_SRANK,
    EventRankType_ERT_ARANK,
    EventRankType_ERT_BRANK,
    EventRankType_ERT_CRANK,
    EventRankType_ERT_FRANK,
    EventRankType_ERT_MAX
  };
  return values;
}

inline const char * const *EnumNamesEventRankType() {
  static const char * const names[] = {
    "ERT_SRANK",
    "ERT_ARANK",
    "ERT_BRANK",
    "ERT_CRANK",
    "ERT_FRANK",
    "ERT_MAX",
    nullptr
  };
  return names;
}

inline const char *EnumNameEventRankType(EventRankType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEventRankType()[index];
}

enum ResultRewardType {
  /// 기본 보상
  ResultRewardType_DEFAULT = 0  /// 기여도 랭크 보상
,
  ResultRewardType_CONTRIBUTION_RANK = 1  /// #골드던전 웨이브 보상
,
  ResultRewardType_GOLD_DUNGEON = 2  /// 전쟁필드 보상
,
  ResultRewardType_BATTLE_FIELD = 3,
  ResultRewardType_MIN = ResultRewardType_DEFAULT,
  ResultRewardType_MAX = ResultRewardType_BATTLE_FIELD
};

inline const ResultRewardType (&EnumValuesResultRewardType())[4] {
  static const ResultRewardType values[] = {
    ResultRewardType_DEFAULT,
    ResultRewardType_CONTRIBUTION_RANK,
    ResultRewardType_GOLD_DUNGEON,
    ResultRewardType_BATTLE_FIELD
  };
  return values;
}

inline const char * const *EnumNamesResultRewardType() {
  static const char * const names[] = {
    "DEFAULT",
    "CONTRIBUTION_RANK",
    "GOLD_DUNGEON",
    "BATTLE_FIELD",
    nullptr
  };
  return names;
}

inline const char *EnumNameResultRewardType(ResultRewardType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesResultRewardType()[index];
}

enum ContributionCategoryType {
  ContributionCategoryType_CCT_NONE = 0,
  ContributionCategoryType_CCT_DEAL = 1,
  ContributionCategoryType_CCT_WITHOUT_DEAL = 2,
  ContributionCategoryType_CCT_EVENT = 3,
  ContributionCategoryType_MIN = ContributionCategoryType_CCT_NONE,
  ContributionCategoryType_MAX = ContributionCategoryType_CCT_EVENT
};

inline const ContributionCategoryType (&EnumValuesContributionCategoryType())[4] {
  static const ContributionCategoryType values[] = {
    ContributionCategoryType_CCT_NONE,
    ContributionCategoryType_CCT_DEAL,
    ContributionCategoryType_CCT_WITHOUT_DEAL,
    ContributionCategoryType_CCT_EVENT
  };
  return values;
}

inline const char * const *EnumNamesContributionCategoryType() {
  static const char * const names[] = {
    "CCT_NONE",
    "CCT_DEAL",
    "CCT_WITHOUT_DEAL",
    "CCT_EVENT",
    nullptr
  };
  return names;
}

inline const char *EnumNameContributionCategoryType(ContributionCategoryType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesContributionCategoryType()[index];
}

/// 이벤트 ENDTYPE
enum EventEndType {
  EventEndType_EVENT_END_TYPE_NORMAL = 0,
  EventEndType_EVENT_END_TYPE_MAX = 1,
  EventEndType_MIN = EventEndType_EVENT_END_TYPE_NORMAL,
  EventEndType_MAX = EventEndType_EVENT_END_TYPE_MAX
};

inline const EventEndType (&EnumValuesEventEndType())[2] {
  static const EventEndType values[] = {
    EventEndType_EVENT_END_TYPE_NORMAL,
    EventEndType_EVENT_END_TYPE_MAX
  };
  return values;
}

inline const char * const *EnumNamesEventEndType() {
  static const char * const names[] = {
    "EVENT_END_TYPE_NORMAL",
    "EVENT_END_TYPE_MAX",
    nullptr
  };
  return names;
}

inline const char *EnumNameEventEndType(EventEndType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEventEndType()[index];
}

enum ObjectState {
  ObjectState_OBJECT_STATE_SPAWN = 0,
  ObjectState_OBJECT_STATE_PEACE = 1,
  ObjectState_OBJECT_STATE_BATTLE = 2,
  ObjectState_OBJECT_STATE_DEAD = 3,
  ObjectState_OBJECT_STATE_RETURN = 4,
  ObjectState_OBJECT_STATE_DYING = 5,
  ObjectState_OBJECT_STATE_WATCHOUT = 6,
  ObjectState_OBJECT_STATE_MAX = 7,
  ObjectState_MIN = ObjectState_OBJECT_STATE_SPAWN,
  ObjectState_MAX = ObjectState_OBJECT_STATE_MAX
};

inline const ObjectState (&EnumValuesObjectState())[8] {
  static const ObjectState values[] = {
    ObjectState_OBJECT_STATE_SPAWN,
    ObjectState_OBJECT_STATE_PEACE,
    ObjectState_OBJECT_STATE_BATTLE,
    ObjectState_OBJECT_STATE_DEAD,
    ObjectState_OBJECT_STATE_RETURN,
    ObjectState_OBJECT_STATE_DYING,
    ObjectState_OBJECT_STATE_WATCHOUT,
    ObjectState_OBJECT_STATE_MAX
  };
  return values;
}

inline const char * const *EnumNamesObjectState() {
  static const char * const names[] = {
    "OBJECT_STATE_SPAWN",
    "OBJECT_STATE_PEACE",
    "OBJECT_STATE_BATTLE",
    "OBJECT_STATE_DEAD",
    "OBJECT_STATE_RETURN",
    "OBJECT_STATE_DYING",
    "OBJECT_STATE_WATCHOUT",
    "OBJECT_STATE_MAX",
    nullptr
  };
  return names;
}

inline const char *EnumNameObjectState(ObjectState e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesObjectState()[index];
}

enum SkillErrorReason {
  SkillErrorReason_SKILL_ERROR_REASON_NONE = 0,
  SkillErrorReason_SKILL_ERROR_REASON_NOT_LEARN = 1,
  SkillErrorReason_SKILL_ERROR_REASON_DOING_SKILL = 2,
  SkillErrorReason_SKILL_ERROR_REASON_DOING_REACION = 3,
  SkillErrorReason_SKILL_ERROR_REASON_INVALID_SLOT = 4,
  SkillErrorReason_SKILL_ERROR_REASON_INVALID_SKILL = 5,
  SkillErrorReason_SKILL_ERROR_REASON_NOT_ENOUGH_RESOURCE = 6,
  SkillErrorReason_SKILL_ERROR_REASON_COOLING = 7,
  SkillErrorReason_SKILL_ERROR_REASON_INVALID_POS = 8,
  SkillErrorReason_SKILL_ERROR_REASON_YOU_ARE_DYING_OR_DEAD = 9,
  SkillErrorReason_MIN = SkillErrorReason_SKILL_ERROR_REASON_NONE,
  SkillErrorReason_MAX = SkillErrorReason_SKILL_ERROR_REASON_YOU_ARE_DYING_OR_DEAD
};

inline const SkillErrorReason (&EnumValuesSkillErrorReason())[10] {
  static const SkillErrorReason values[] = {
    SkillErrorReason_SKILL_ERROR_REASON_NONE,
    SkillErrorReason_SKILL_ERROR_REASON_NOT_LEARN,
    SkillErrorReason_SKILL_ERROR_REASON_DOING_SKILL,
    SkillErrorReason_SKILL_ERROR_REASON_DOING_REACION,
    SkillErrorReason_SKILL_ERROR_REASON_INVALID_SLOT,
    SkillErrorReason_SKILL_ERROR_REASON_INVALID_SKILL,
    SkillErrorReason_SKILL_ERROR_REASON_NOT_ENOUGH_RESOURCE,
    SkillErrorReason_SKILL_ERROR_REASON_COOLING,
    SkillErrorReason_SKILL_ERROR_REASON_INVALID_POS,
    SkillErrorReason_SKILL_ERROR_REASON_YOU_ARE_DYING_OR_DEAD
  };
  return values;
}

inline const char * const *EnumNamesSkillErrorReason() {
  static const char * const names[] = {
    "SKILL_ERROR_REASON_NONE",
    "SKILL_ERROR_REASON_NOT_LEARN",
    "SKILL_ERROR_REASON_DOING_SKILL",
    "SKILL_ERROR_REASON_DOING_REACION",
    "SKILL_ERROR_REASON_INVALID_SLOT",
    "SKILL_ERROR_REASON_INVALID_SKILL",
    "SKILL_ERROR_REASON_NOT_ENOUGH_RESOURCE",
    "SKILL_ERROR_REASON_COOLING",
    "SKILL_ERROR_REASON_INVALID_POS",
    "SKILL_ERROR_REASON_YOU_ARE_DYING_OR_DEAD",
    nullptr
  };
  return names;
}

inline const char *EnumNameSkillErrorReason(SkillErrorReason e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesSkillErrorReason()[index];
}

enum UpcType {
  UpcType_UPC_TYPE_ARENA = 0,
  UpcType_UPC_TYPE_FAKE_PC = 1,
  UpcType_UPC_TYPE_MAX = 2,
  UpcType_MIN = UpcType_UPC_TYPE_ARENA,
  UpcType_MAX = UpcType_UPC_TYPE_MAX
};

inline const UpcType (&EnumValuesUpcType())[3] {
  static const UpcType values[] = {
    UpcType_UPC_TYPE_ARENA,
    UpcType_UPC_TYPE_FAKE_PC,
    UpcType_UPC_TYPE_MAX
  };
  return values;
}

inline const char * const *EnumNamesUpcType() {
  static const char * const names[] = {
    "UPC_TYPE_ARENA",
    "UPC_TYPE_FAKE_PC",
    "UPC_TYPE_MAX",
    nullptr
  };
  return names;
}

inline const char *EnumNameUpcType(UpcType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesUpcType()[index];
}

enum fromReaction {
  fromReaction_FROM_REACTION_NONE = 0,
  fromReaction_FROM_REACITON_BUFF = 1,
  fromReaction_MIN = fromReaction_FROM_REACTION_NONE,
  fromReaction_MAX = fromReaction_FROM_REACITON_BUFF
};

inline const fromReaction (&EnumValuesfromReaction())[2] {
  static const fromReaction values[] = {
    fromReaction_FROM_REACTION_NONE,
    fromReaction_FROM_REACITON_BUFF
  };
  return values;
}

inline const char * const *EnumNamesfromReaction() {
  static const char * const names[] = {
    "FROM_REACTION_NONE",
    "FROM_REACITON_BUFF",
    nullptr
  };
  return names;
}

inline const char *EnumNamefromReaction(fromReaction e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesfromReaction()[index];
}

///- InteractionState -----
/// 인터렉션 상태
enum InteractionState {
  /// 인터랙션 불가
  InteractionState_GT_CANNOT_INTERACTION = 0  /// 인터랙션 가능
,
  InteractionState_GT_CAN_INTERACTION = 1,
  InteractionState_MIN = InteractionState_GT_CANNOT_INTERACTION,
  InteractionState_MAX = InteractionState_GT_CAN_INTERACTION
};

inline const InteractionState (&EnumValuesInteractionState())[2] {
  static const InteractionState values[] = {
    InteractionState_GT_CANNOT_INTERACTION,
    InteractionState_GT_CAN_INTERACTION
  };
  return values;
}

inline const char * const *EnumNamesInteractionState() {
  static const char * const names[] = {
    "GT_CANNOT_INTERACTION",
    "GT_CAN_INTERACTION",
    nullptr
  };
  return names;
}

inline const char *EnumNameInteractionState(InteractionState e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesInteractionState()[index];
}

enum DoorState {
  /// 문 닫힘
  DoorState_DS_CLOSED = 0  /// 문 열림
,
  DoorState_DS_OPENED = 1,
  DoorState_MIN = DoorState_DS_CLOSED,
  DoorState_MAX = DoorState_DS_OPENED
};

inline const DoorState (&EnumValuesDoorState())[2] {
  static const DoorState values[] = {
    DoorState_DS_CLOSED,
    DoorState_DS_OPENED
  };
  return values;
}

inline const char * const *EnumNamesDoorState() {
  static const char * const names[] = {
    "DS_CLOSED",
    "DS_OPENED",
    nullptr
  };
  return names;
}

inline const char *EnumNameDoorState(DoorState e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesDoorState()[index];
}

enum SwitchState {
  /// 스위치 오프
  SwitchState_SS_OFF = 0  /// 스위치 온
,
  SwitchState_SS_ON = 1,
  SwitchState_MIN = SwitchState_SS_OFF,
  SwitchState_MAX = SwitchState_SS_ON
};

inline const SwitchState (&EnumValuesSwitchState())[2] {
  static const SwitchState values[] = {
    SwitchState_SS_OFF,
    SwitchState_SS_ON
  };
  return values;
}

inline const char * const *EnumNamesSwitchState() {
  static const char * const names[] = {
    "SS_OFF",
    "SS_ON",
    nullptr
  };
  return names;
}

inline const char *EnumNameSwitchState(SwitchState e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesSwitchState()[index];
}

enum FragileState {
  /// 안깨짐
  FragileState_FS_UNBROKEN = 0  /// 깨짐
,
  FragileState_FS_BROKEN = 1,
  FragileState_MIN = FragileState_FS_UNBROKEN,
  FragileState_MAX = FragileState_FS_BROKEN
};

inline const FragileState (&EnumValuesFragileState())[2] {
  static const FragileState values[] = {
    FragileState_FS_UNBROKEN,
    FragileState_FS_BROKEN
  };
  return values;
}

inline const char * const *EnumNamesFragileState() {
  static const char * const names[] = {
    "FS_UNBROKEN",
    "FS_BROKEN",
    nullptr
  };
  return names;
}

inline const char *EnumNameFragileState(FragileState e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesFragileState()[index];
}

/// 미니게임 결과
enum MiniGameRankType {
  MiniGameRankType_MGRT_NONE = 0,
  MiniGameRankType_MGRT_GOOD = 1,
  MiniGameRankType_MGRT_PERFECT = 2,
  MiniGameRankType_MIN = MiniGameRankType_MGRT_NONE,
  MiniGameRankType_MAX = MiniGameRankType_MGRT_PERFECT
};

inline const MiniGameRankType (&EnumValuesMiniGameRankType())[3] {
  static const MiniGameRankType values[] = {
    MiniGameRankType_MGRT_NONE,
    MiniGameRankType_MGRT_GOOD,
    MiniGameRankType_MGRT_PERFECT
  };
  return values;
}

inline const char * const *EnumNamesMiniGameRankType() {
  static const char * const names[] = {
    "MGRT_NONE",
    "MGRT_GOOD",
    "MGRT_PERFECT",
    nullptr
  };
  return names;
}

inline const char *EnumNameMiniGameRankType(MiniGameRankType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMiniGameRankType()[index];
}

enum InteractionRewardType {
  InteractionRewardType_IRT_NONE = 0,
  InteractionRewardType_IRT_GOOD = 1,
  InteractionRewardType_IRT_PERFECT = 2,
  InteractionRewardType_MIN = InteractionRewardType_IRT_NONE,
  InteractionRewardType_MAX = InteractionRewardType_IRT_PERFECT
};

inline const InteractionRewardType (&EnumValuesInteractionRewardType())[3] {
  static const InteractionRewardType values[] = {
    InteractionRewardType_IRT_NONE,
    InteractionRewardType_IRT_GOOD,
    InteractionRewardType_IRT_PERFECT
  };
  return values;
}

inline const char * const *EnumNamesInteractionRewardType() {
  static const char * const names[] = {
    "IRT_NONE",
    "IRT_GOOD",
    "IRT_PERFECT",
    nullptr
  };
  return names;
}

inline const char *EnumNameInteractionRewardType(InteractionRewardType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesInteractionRewardType()[index];
}

/// 메인미션 참여 상태
enum PushMainMissionState {
  /// 참여 안함
  PushMainMissionState_PM_NOT_JOIN = 0  /// 매칭 중
,
  PushMainMissionState_PM_MATCHING = 1,
  PushMainMissionState_MIN = PushMainMissionState_PM_NOT_JOIN,
  PushMainMissionState_MAX = PushMainMissionState_PM_MATCHING
};

inline const PushMainMissionState (&EnumValuesPushMainMissionState())[2] {
  static const PushMainMissionState values[] = {
    PushMainMissionState_PM_NOT_JOIN,
    PushMainMissionState_PM_MATCHING
  };
  return values;
}

inline const char * const *EnumNamesPushMainMissionState() {
  static const char * const names[] = {
    "PM_NOT_JOIN",
    "PM_MATCHING",
    nullptr
  };
  return names;
}

inline const char *EnumNamePushMainMissionState(PushMainMissionState e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesPushMainMissionState()[index];
}

/// 알림의 현재 상태
enum PushState {
  /// 매칭예약 가능
  PushState_PUSH_STATE_READY = 0,
  PushState_PUSH_STATE_RUNNING = 1,
  PushState_PUSH_STATE_TIMEOUT = 2,
  PushState_PUSH_STATE_STOPPED = 3,
  PushState_MIN = PushState_PUSH_STATE_READY,
  PushState_MAX = PushState_PUSH_STATE_STOPPED
};

inline const PushState (&EnumValuesPushState())[4] {
  static const PushState values[] = {
    PushState_PUSH_STATE_READY,
    PushState_PUSH_STATE_RUNNING,
    PushState_PUSH_STATE_TIMEOUT,
    PushState_PUSH_STATE_STOPPED
  };
  return values;
}

inline const char * const *EnumNamesPushState() {
  static const char * const names[] = {
    "PUSH_STATE_READY",
    "PUSH_STATE_RUNNING",
    "PUSH_STATE_TIMEOUT",
    "PUSH_STATE_STOPPED",
    nullptr
  };
  return names;
}

inline const char *EnumNamePushState(PushState e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesPushState()[index];
}

enum SuperArmorState {
  SuperArmorState_SAS_ARMOR = 1,
  SuperArmorState_SAS_RECOVERY = 2,
  SuperArmorState_MIN = SuperArmorState_SAS_ARMOR,
  SuperArmorState_MAX = SuperArmorState_SAS_RECOVERY
};

inline const SuperArmorState (&EnumValuesSuperArmorState())[2] {
  static const SuperArmorState values[] = {
    SuperArmorState_SAS_ARMOR,
    SuperArmorState_SAS_RECOVERY
  };
  return values;
}

inline const char * const *EnumNamesSuperArmorState() {
  static const char * const names[] = {
    "SAS_ARMOR",
    "SAS_RECOVERY",
    nullptr
  };
  return names;
}

inline const char *EnumNameSuperArmorState(SuperArmorState e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(SuperArmorState_SAS_ARMOR);
  return EnumNamesSuperArmorState()[index];
}

/// NOTIFY_EVENT_COUNTER_PROGRESS_INFO
///- QuestTargetType ----------
enum QuestTargetType {
  QuestTargetType_QTT_TYPE_NONE = 0,
  QuestTargetType_QTT_TYPE_MONSTER = 1,
  QuestTargetType_QTT_TYPE_QUEST = 2,
  QuestTargetType_QTT_TYPE_EVENTSET = 3,
  QuestTargetType_QTT_TYPE_GATHERING = 4,
  QuestTargetType_QTT_TYPE_MINER = 5,
  QuestTargetType_QTT_TYPE_FISHING = 6,
  QuestTargetType_QTT_TYPE_M_MAPID = 7,
  QuestTargetType_QTT_TYPE_S_MAPID = 8,
  QuestTargetType_QTT_TYPE_SMAP_FIELD_EVENT = 9,
  QuestTargetType_QTT_TYPE_SMAP_MAIN_MISSION_EVENT = 10,
  QuestTargetType_QTT_TYPE_MAINSTREAMID = 11,
  QuestTargetType_QTT_TYPE_FISH = 12,
  QuestTargetType_QTT_TYPE_PK = 13,
  QuestTargetType_QTT_TYPE_ITEM = 14,
  QuestTargetType_QTT_TYPE_CURRENCY = 15,
  QuestTargetType_QTT_TYPE_SOLO_DUNGEON = 16,
  QuestTargetType_QTT_TYPE_DAILY_DUNGEON = 17,
  QuestTargetType_QTT_TYPE_INVEN_ITEM = 18,
  QuestTargetType_QTT_TYPE_MAX = 19,
  QuestTargetType_MIN = QuestTargetType_QTT_TYPE_NONE,
  QuestTargetType_MAX = QuestTargetType_QTT_TYPE_MAX
};

inline const QuestTargetType (&EnumValuesQuestTargetType())[20] {
  static const QuestTargetType values[] = {
    QuestTargetType_QTT_TYPE_NONE,
    QuestTargetType_QTT_TYPE_MONSTER,
    QuestTargetType_QTT_TYPE_QUEST,
    QuestTargetType_QTT_TYPE_EVENTSET,
    QuestTargetType_QTT_TYPE_GATHERING,
    QuestTargetType_QTT_TYPE_MINER,
    QuestTargetType_QTT_TYPE_FISHING,
    QuestTargetType_QTT_TYPE_M_MAPID,
    QuestTargetType_QTT_TYPE_S_MAPID,
    QuestTargetType_QTT_TYPE_SMAP_FIELD_EVENT,
    QuestTargetType_QTT_TYPE_SMAP_MAIN_MISSION_EVENT,
    QuestTargetType_QTT_TYPE_MAINSTREAMID,
    QuestTargetType_QTT_TYPE_FISH,
    QuestTargetType_QTT_TYPE_PK,
    QuestTargetType_QTT_TYPE_ITEM,
    QuestTargetType_QTT_TYPE_CURRENCY,
    QuestTargetType_QTT_TYPE_SOLO_DUNGEON,
    QuestTargetType_QTT_TYPE_DAILY_DUNGEON,
    QuestTargetType_QTT_TYPE_INVEN_ITEM,
    QuestTargetType_QTT_TYPE_MAX
  };
  return values;
}

inline const char * const *EnumNamesQuestTargetType() {
  static const char * const names[] = {
    "QTT_TYPE_NONE",
    "QTT_TYPE_MONSTER",
    "QTT_TYPE_QUEST",
    "QTT_TYPE_EVENTSET",
    "QTT_TYPE_GATHERING",
    "QTT_TYPE_MINER",
    "QTT_TYPE_FISHING",
    "QTT_TYPE_M_MAPID",
    "QTT_TYPE_S_MAPID",
    "QTT_TYPE_SMAP_FIELD_EVENT",
    "QTT_TYPE_SMAP_MAIN_MISSION_EVENT",
    "QTT_TYPE_MAINSTREAMID",
    "QTT_TYPE_FISH",
    "QTT_TYPE_PK",
    "QTT_TYPE_ITEM",
    "QTT_TYPE_CURRENCY",
    "QTT_TYPE_SOLO_DUNGEON",
    "QTT_TYPE_DAILY_DUNGEON",
    "QTT_TYPE_INVEN_ITEM",
    "QTT_TYPE_MAX",
    nullptr
  };
  return names;
}

inline const char *EnumNameQuestTargetType(QuestTargetType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesQuestTargetType()[index];
}

/// MAINSTREAM_STATE_NOTIFY
enum MainStreamStateType {
  MainStreamStateType_MAIN_STREAM_STATE_NONE = 0,
  MainStreamStateType_MAIN_STREAM_STATE_ACTIVE = 1,
  MainStreamStateType_MAIN_STREAM_STATE_COMPLETE = 2,
  MainStreamStateType_MAIN_STREAM_STATE_MAX = 3,
  MainStreamStateType_MIN = MainStreamStateType_MAIN_STREAM_STATE_NONE,
  MainStreamStateType_MAX = MainStreamStateType_MAIN_STREAM_STATE_MAX
};

inline const MainStreamStateType (&EnumValuesMainStreamStateType())[4] {
  static const MainStreamStateType values[] = {
    MainStreamStateType_MAIN_STREAM_STATE_NONE,
    MainStreamStateType_MAIN_STREAM_STATE_ACTIVE,
    MainStreamStateType_MAIN_STREAM_STATE_COMPLETE,
    MainStreamStateType_MAIN_STREAM_STATE_MAX
  };
  return values;
}

inline const char * const *EnumNamesMainStreamStateType() {
  static const char * const names[] = {
    "MAIN_STREAM_STATE_NONE",
    "MAIN_STREAM_STATE_ACTIVE",
    "MAIN_STREAM_STATE_COMPLETE",
    "MAIN_STREAM_STATE_MAX",
    nullptr
  };
  return names;
}

inline const char *EnumNameMainStreamStateType(MainStreamStateType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMainStreamStateType()[index];
}

/// MAIN_STREAM_PRE_ACTION
enum MainStreamPreActionType {
  MainStreamPreActionType_MS_PRE_ACTION_TYPE_NONE = 0,
  MainStreamPreActionType_MS_PRE_ACTION_TYPE_SMAP = 1,
  MainStreamPreActionType_MS_PRE_ACTION_TYPE_INTERACTION = 2,
  MainStreamPreActionType_MS_PRE_ACTION_TYPE_EVENTSET = 3,
  MainStreamPreActionType_MS_PRE_ACTION_TYPE_COMMAND = 4,
  MainStreamPreActionType_MS_PRE_ACTION_TYPE_TUTORIAL = 5,
  MainStreamPreActionType_MS_PRE_ACTION_TYPE_MAX = 6,
  MainStreamPreActionType_MIN = MainStreamPreActionType_MS_PRE_ACTION_TYPE_NONE,
  MainStreamPreActionType_MAX = MainStreamPreActionType_MS_PRE_ACTION_TYPE_MAX
};

inline const MainStreamPreActionType (&EnumValuesMainStreamPreActionType())[7] {
  static const MainStreamPreActionType values[] = {
    MainStreamPreActionType_MS_PRE_ACTION_TYPE_NONE,
    MainStreamPreActionType_MS_PRE_ACTION_TYPE_SMAP,
    MainStreamPreActionType_MS_PRE_ACTION_TYPE_INTERACTION,
    MainStreamPreActionType_MS_PRE_ACTION_TYPE_EVENTSET,
    MainStreamPreActionType_MS_PRE_ACTION_TYPE_COMMAND,
    MainStreamPreActionType_MS_PRE_ACTION_TYPE_TUTORIAL,
    MainStreamPreActionType_MS_PRE_ACTION_TYPE_MAX
  };
  return values;
}

inline const char * const *EnumNamesMainStreamPreActionType() {
  static const char * const names[] = {
    "MS_PRE_ACTION_TYPE_NONE",
    "MS_PRE_ACTION_TYPE_SMAP",
    "MS_PRE_ACTION_TYPE_INTERACTION",
    "MS_PRE_ACTION_TYPE_EVENTSET",
    "MS_PRE_ACTION_TYPE_COMMAND",
    "MS_PRE_ACTION_TYPE_TUTORIAL",
    "MS_PRE_ACTION_TYPE_MAX",
    nullptr
  };
  return names;
}

inline const char *EnumNameMainStreamPreActionType(MainStreamPreActionType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMainStreamPreActionType()[index];
}

/// DAILY_HOMEWORK
enum DailyHomeworkType {
  DailyHomeworkType_DAILY_HOMEWORK_TYPE_NONE = 0,
  DailyHomeworkType_DAILY_HOMEWORK_TYPE_ESSENTIAL = 1,
  DailyHomeworkType_DAILY_HOMEWORK_TYPE_SPECIAL = 2,
  DailyHomeworkType_DAILY_HOMEWORK_TYPE_ACTIVITY = 3,
  DailyHomeworkType_DAILY_HOMEWORK_TYPE_MAX = 4,
  DailyHomeworkType_MIN = DailyHomeworkType_DAILY_HOMEWORK_TYPE_NONE,
  DailyHomeworkType_MAX = DailyHomeworkType_DAILY_HOMEWORK_TYPE_MAX
};

inline const DailyHomeworkType (&EnumValuesDailyHomeworkType())[5] {
  static const DailyHomeworkType values[] = {
    DailyHomeworkType_DAILY_HOMEWORK_TYPE_NONE,
    DailyHomeworkType_DAILY_HOMEWORK_TYPE_ESSENTIAL,
    DailyHomeworkType_DAILY_HOMEWORK_TYPE_SPECIAL,
    DailyHomeworkType_DAILY_HOMEWORK_TYPE_ACTIVITY,
    DailyHomeworkType_DAILY_HOMEWORK_TYPE_MAX
  };
  return values;
}

inline const char * const *EnumNamesDailyHomeworkType() {
  static const char * const names[] = {
    "DAILY_HOMEWORK_TYPE_NONE",
    "DAILY_HOMEWORK_TYPE_ESSENTIAL",
    "DAILY_HOMEWORK_TYPE_SPECIAL",
    "DAILY_HOMEWORK_TYPE_ACTIVITY",
    "DAILY_HOMEWORK_TYPE_MAX",
    nullptr
  };
  return names;
}

inline const char *EnumNameDailyHomeworkType(DailyHomeworkType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesDailyHomeworkType()[index];
}

///  CHAPTER_JOIN_REQUEST
enum ChapterJoinType {
  ChapterJoinType_CHAPTER_JOIN_TYPE_SMAP = 0,
  ChapterJoinType_CHAPTER_JOIN_TYPE_BOSS_EVENTSET = 1,
  ChapterJoinType_CHAPTER_TARGET_TYPE_MAX = 2,
  ChapterJoinType_MIN = ChapterJoinType_CHAPTER_JOIN_TYPE_SMAP,
  ChapterJoinType_MAX = ChapterJoinType_CHAPTER_TARGET_TYPE_MAX
};

inline const ChapterJoinType (&EnumValuesChapterJoinType())[3] {
  static const ChapterJoinType values[] = {
    ChapterJoinType_CHAPTER_JOIN_TYPE_SMAP,
    ChapterJoinType_CHAPTER_JOIN_TYPE_BOSS_EVENTSET,
    ChapterJoinType_CHAPTER_TARGET_TYPE_MAX
  };
  return values;
}

inline const char * const *EnumNamesChapterJoinType() {
  static const char * const names[] = {
    "CHAPTER_JOIN_TYPE_SMAP",
    "CHAPTER_JOIN_TYPE_BOSS_EVENTSET",
    "CHAPTER_TARGET_TYPE_MAX",
    nullptr
  };
  return names;
}

inline const char *EnumNameChapterJoinType(ChapterJoinType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesChapterJoinType()[index];
}

/// ResurrectionErrorType --------------
enum ResurrectionErrorType {
  ResurrectionErrorType_RET_CAN_NOT = 0,
  ResurrectionErrorType_RET_OK = 1,
  ResurrectionErrorType_RET_INCORRECT_TARGET = 2,
  ResurrectionErrorType_MIN = ResurrectionErrorType_RET_CAN_NOT,
  ResurrectionErrorType_MAX = ResurrectionErrorType_RET_INCORRECT_TARGET
};

inline const ResurrectionErrorType (&EnumValuesResurrectionErrorType())[3] {
  static const ResurrectionErrorType values[] = {
    ResurrectionErrorType_RET_CAN_NOT,
    ResurrectionErrorType_RET_OK,
    ResurrectionErrorType_RET_INCORRECT_TARGET
  };
  return values;
}

inline const char * const *EnumNamesResurrectionErrorType() {
  static const char * const names[] = {
    "RET_CAN_NOT",
    "RET_OK",
    "RET_INCORRECT_TARGET",
    nullptr
  };
  return names;
}

inline const char *EnumNameResurrectionErrorType(ResurrectionErrorType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesResurrectionErrorType()[index];
}

///----- 무한의 탑 -----------------
enum InfiniteTowerPaidType {
  InfiniteTowerPaidType_INFINITE_TOWER_PAID_TYPE_TICKET = 0,
  InfiniteTowerPaidType_INFINITE_TOWER_PAID_TYPE_CONTINUE = 1,
  InfiniteTowerPaidType_INFINITE_TOWER_PAID_TYPE_MAX = 2,
  InfiniteTowerPaidType_MIN = InfiniteTowerPaidType_INFINITE_TOWER_PAID_TYPE_TICKET,
  InfiniteTowerPaidType_MAX = InfiniteTowerPaidType_INFINITE_TOWER_PAID_TYPE_MAX
};

inline const InfiniteTowerPaidType (&EnumValuesInfiniteTowerPaidType())[3] {
  static const InfiniteTowerPaidType values[] = {
    InfiniteTowerPaidType_INFINITE_TOWER_PAID_TYPE_TICKET,
    InfiniteTowerPaidType_INFINITE_TOWER_PAID_TYPE_CONTINUE,
    InfiniteTowerPaidType_INFINITE_TOWER_PAID_TYPE_MAX
  };
  return values;
}

inline const char * const *EnumNamesInfiniteTowerPaidType() {
  static const char * const names[] = {
    "INFINITE_TOWER_PAID_TYPE_TICKET",
    "INFINITE_TOWER_PAID_TYPE_CONTINUE",
    "INFINITE_TOWER_PAID_TYPE_MAX",
    nullptr
  };
  return names;
}

inline const char *EnumNameInfiniteTowerPaidType(InfiniteTowerPaidType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesInfiniteTowerPaidType()[index];
}

///----- 휴식보상 -----------------
enum RestPaidType {
  RestPaidType_REST_PAID_TYPE_FREE = 0,
  RestPaidType_REST_PAID_TYPE_PAID = 1,
  RestPaidType_REST_PAID_TYPE_MAX = 2,
  RestPaidType_MIN = RestPaidType_REST_PAID_TYPE_FREE,
  RestPaidType_MAX = RestPaidType_REST_PAID_TYPE_MAX
};

inline const RestPaidType (&EnumValuesRestPaidType())[3] {
  static const RestPaidType values[] = {
    RestPaidType_REST_PAID_TYPE_FREE,
    RestPaidType_REST_PAID_TYPE_PAID,
    RestPaidType_REST_PAID_TYPE_MAX
  };
  return values;
}

inline const char * const *EnumNamesRestPaidType() {
  static const char * const names[] = {
    "REST_PAID_TYPE_FREE",
    "REST_PAID_TYPE_PAID",
    "REST_PAID_TYPE_MAX",
    nullptr
  };
  return names;
}

inline const char *EnumNameRestPaidType(RestPaidType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesRestPaidType()[index];
}

/// 길드 탈퇴 사유
enum GuildLeaveReason {
  /// 자기가 탈퇴함
  GuildLeaveReason_GuildLeaveReason_Leave = 0  /// 강퇴 다함
,
  GuildLeaveReason_GuildLeaveReason_Kick = 1,
  GuildLeaveReason_MIN = GuildLeaveReason_GuildLeaveReason_Leave,
  GuildLeaveReason_MAX = GuildLeaveReason_GuildLeaveReason_Kick
};

inline const GuildLeaveReason (&EnumValuesGuildLeaveReason())[2] {
  static const GuildLeaveReason values[] = {
    GuildLeaveReason_GuildLeaveReason_Leave,
    GuildLeaveReason_GuildLeaveReason_Kick
  };
  return values;
}

inline const char * const *EnumNamesGuildLeaveReason() {
  static const char * const names[] = {
    "GuildLeaveReason_Leave",
    "GuildLeaveReason_Kick",
    nullptr
  };
  return names;
}

inline const char *EnumNameGuildLeaveReason(GuildLeaveReason e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesGuildLeaveReason()[index];
}

/// 길드원 목록 정렬 타입
enum GuildMemberListSortType {
  /// 계급
  GuildMemberListSortType_GuildMemberListSortType_Grade = 0  /// 레벨
,
  GuildMemberListSortType_GuildMemberListSortType_Level = 1  /// 군주포인트
,
  GuildMemberListSortType_GuildMemberListSortType_MonarchPoint = 2  /// 전투력
,
  GuildMemberListSortType_GuildMemberListSortType_CombatPower = 3  /// 최근 접속
,
  GuildMemberListSortType_GuildMemberListSortType_RecentLogin = 4  /// 누적 기부 금액
,
  GuildMemberListSortType_GuildMemberListSortType_Donate = 5  /// 출석 횟수
,
  GuildMemberListSortType_GuildMemberListSortType_AttendCount = 6,
  GuildMemberListSortType_MIN = GuildMemberListSortType_GuildMemberListSortType_Grade,
  GuildMemberListSortType_MAX = GuildMemberListSortType_GuildMemberListSortType_AttendCount
};

inline const GuildMemberListSortType (&EnumValuesGuildMemberListSortType())[7] {
  static const GuildMemberListSortType values[] = {
    GuildMemberListSortType_GuildMemberListSortType_Grade,
    GuildMemberListSortType_GuildMemberListSortType_Level,
    GuildMemberListSortType_GuildMemberListSortType_MonarchPoint,
    GuildMemberListSortType_GuildMemberListSortType_CombatPower,
    GuildMemberListSortType_GuildMemberListSortType_RecentLogin,
    GuildMemberListSortType_GuildMemberListSortType_Donate,
    GuildMemberListSortType_GuildMemberListSortType_AttendCount
  };
  return values;
}

inline const char * const *EnumNamesGuildMemberListSortType() {
  static const char * const names[] = {
    "GuildMemberListSortType_Grade",
    "GuildMemberListSortType_Level",
    "GuildMemberListSortType_MonarchPoint",
    "GuildMemberListSortType_CombatPower",
    "GuildMemberListSortType_RecentLogin",
    "GuildMemberListSortType_Donate",
    "GuildMemberListSortType_AttendCount",
    nullptr
  };
  return names;
}

inline const char *EnumNameGuildMemberListSortType(GuildMemberListSortType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesGuildMemberListSortType()[index];
}

/// 길드원 목록 접속상태 구분
enum GuildMemberListLoginStatus {
  GuildMemberListLoginStatus_GuildMemberListLoginStatus_All = 0,
  GuildMemberListLoginStatus_GuildMemberListLoginStatus_Online = 1,
  GuildMemberListLoginStatus_GuildMemberListLoginStatus_Offline = 2,
  GuildMemberListLoginStatus_MIN = GuildMemberListLoginStatus_GuildMemberListLoginStatus_All,
  GuildMemberListLoginStatus_MAX = GuildMemberListLoginStatus_GuildMemberListLoginStatus_Offline
};

inline const GuildMemberListLoginStatus (&EnumValuesGuildMemberListLoginStatus())[3] {
  static const GuildMemberListLoginStatus values[] = {
    GuildMemberListLoginStatus_GuildMemberListLoginStatus_All,
    GuildMemberListLoginStatus_GuildMemberListLoginStatus_Online,
    GuildMemberListLoginStatus_GuildMemberListLoginStatus_Offline
  };
  return values;
}

inline const char * const *EnumNamesGuildMemberListLoginStatus() {
  static const char * const names[] = {
    "GuildMemberListLoginStatus_All",
    "GuildMemberListLoginStatus_Online",
    "GuildMemberListLoginStatus_Offline",
    nullptr
  };
  return names;
}

inline const char *EnumNameGuildMemberListLoginStatus(GuildMemberListLoginStatus e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesGuildMemberListLoginStatus()[index];
}

enum GuildRankSortType {
  /// 클라이언트 요청으로 UI 순서와 동일하게 맞춤
  /// 순서 변경시 확인이 필요함
  GuildRankSortType_GuildRankSortType_Level = 0,
  GuildRankSortType_GuildRankSortType_CombatPower = 1,
  GuildRankSortType_GuildRankSortType_MonarchPoint = 2,
  GuildRankSortType_GuildRankSortType_KingGuild = 3,
  GuildRankSortType_GuildRankSortType_DungeonScore = 4,
  GuildRankSortType_GuildRankSortType_PvPPoint = 5,
  GuildRankSortType_MIN = GuildRankSortType_GuildRankSortType_Level,
  GuildRankSortType_MAX = GuildRankSortType_GuildRankSortType_PvPPoint
};

inline const GuildRankSortType (&EnumValuesGuildRankSortType())[6] {
  static const GuildRankSortType values[] = {
    GuildRankSortType_GuildRankSortType_Level,
    GuildRankSortType_GuildRankSortType_CombatPower,
    GuildRankSortType_GuildRankSortType_MonarchPoint,
    GuildRankSortType_GuildRankSortType_KingGuild,
    GuildRankSortType_GuildRankSortType_DungeonScore,
    GuildRankSortType_GuildRankSortType_PvPPoint
  };
  return values;
}

inline const char * const *EnumNamesGuildRankSortType() {
  static const char * const names[] = {
    "GuildRankSortType_Level",
    "GuildRankSortType_CombatPower",
    "GuildRankSortType_MonarchPoint",
    "GuildRankSortType_KingGuild",
    "GuildRankSortType_DungeonScore",
    "GuildRankSortType_PvPPoint",
    nullptr
  };
  return names;
}

inline const char *EnumNameGuildRankSortType(GuildRankSortType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesGuildRankSortType()[index];
}

enum GuildListSortType {
  /// 랭킹
  GuildListSortType_GuildListSortType_Rank = 0,
  GuildListSortType_GuildListSortType_Level = 1,
  GuildListSortType_GuildListSortType_MemberCount = 2,
  GuildListSortType_MIN = GuildListSortType_GuildListSortType_Rank,
  GuildListSortType_MAX = GuildListSortType_GuildListSortType_MemberCount
};

inline const GuildListSortType (&EnumValuesGuildListSortType())[3] {
  static const GuildListSortType values[] = {
    GuildListSortType_GuildListSortType_Rank,
    GuildListSortType_GuildListSortType_Level,
    GuildListSortType_GuildListSortType_MemberCount
  };
  return values;
}

inline const char * const *EnumNamesGuildListSortType() {
  static const char * const names[] = {
    "GuildListSortType_Rank",
    "GuildListSortType_Level",
    "GuildListSortType_MemberCount",
    nullptr
  };
  return names;
}

inline const char *EnumNameGuildListSortType(GuildListSortType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesGuildListSortType()[index];
}

enum GuildMsgType {
  GuildMsgType_GuildMsgType_Intro = 0,
  GuildMsgType_GuildMsgType_Notice = 1,
  GuildMsgType_MIN = GuildMsgType_GuildMsgType_Intro,
  GuildMsgType_MAX = GuildMsgType_GuildMsgType_Notice
};

inline const GuildMsgType (&EnumValuesGuildMsgType())[2] {
  static const GuildMsgType values[] = {
    GuildMsgType_GuildMsgType_Intro,
    GuildMsgType_GuildMsgType_Notice
  };
  return values;
}

inline const char * const *EnumNamesGuildMsgType() {
  static const char * const names[] = {
    "GuildMsgType_Intro",
    "GuildMsgType_Notice",
    nullptr
  };
  return names;
}

inline const char *EnumNameGuildMsgType(GuildMsgType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesGuildMsgType()[index];
}

enum BattleFieldEventStatus {
  BattleFieldEventStatus_BATTLE_FIELD_EVENT_STATUS_NONE = 0,
  BattleFieldEventStatus_BATTLE_FIELD_EVENT_STATUS_READY = 1,
  BattleFieldEventStatus_BATTLE_FIELD_EVENT_STATUS_RUNNING = 2,
  BattleFieldEventStatus_MIN = BattleFieldEventStatus_BATTLE_FIELD_EVENT_STATUS_NONE,
  BattleFieldEventStatus_MAX = BattleFieldEventStatus_BATTLE_FIELD_EVENT_STATUS_RUNNING
};

inline const BattleFieldEventStatus (&EnumValuesBattleFieldEventStatus())[3] {
  static const BattleFieldEventStatus values[] = {
    BattleFieldEventStatus_BATTLE_FIELD_EVENT_STATUS_NONE,
    BattleFieldEventStatus_BATTLE_FIELD_EVENT_STATUS_READY,
    BattleFieldEventStatus_BATTLE_FIELD_EVENT_STATUS_RUNNING
  };
  return values;
}

inline const char * const *EnumNamesBattleFieldEventStatus() {
  static const char * const names[] = {
    "BATTLE_FIELD_EVENT_STATUS_NONE",
    "BATTLE_FIELD_EVENT_STATUS_READY",
    "BATTLE_FIELD_EVENT_STATUS_RUNNING",
    nullptr
  };
  return names;
}

inline const char *EnumNameBattleFieldEventStatus(BattleFieldEventStatus e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesBattleFieldEventStatus()[index];
}

/// ArenaStateType
enum ArenaStateType {
  ArenaStateType_NOTHING = 0,
  ArenaStateType_PREPARE = 1,
  ArenaStateType_READY = 2,
  ArenaStateType_PLAYING = 3,
  ArenaStateType_END = 4,
  ArenaStateType_MIN = ArenaStateType_NOTHING,
  ArenaStateType_MAX = ArenaStateType_END
};

inline const ArenaStateType (&EnumValuesArenaStateType())[5] {
  static const ArenaStateType values[] = {
    ArenaStateType_NOTHING,
    ArenaStateType_PREPARE,
    ArenaStateType_READY,
    ArenaStateType_PLAYING,
    ArenaStateType_END
  };
  return values;
}

inline const char * const *EnumNamesArenaStateType() {
  static const char * const names[] = {
    "NOTHING",
    "PREPARE",
    "READY",
    "PLAYING",
    "END",
    nullptr
  };
  return names;
}

inline const char *EnumNameArenaStateType(ArenaStateType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesArenaStateType()[index];
}

enum PKContentsType {
  PKContentsType_PK_CONTENTS_NONE = 0,
  PKContentsType_PK_CONTENTS_BATTLE_FIELD = 1,
  PKContentsType_PK_CONTENTS_BRAWL = 2,
  PKContentsType_PK_CONTENTS_CONFLICT_FIELD = 3,
  PKContentsType_MIN = PKContentsType_PK_CONTENTS_NONE,
  PKContentsType_MAX = PKContentsType_PK_CONTENTS_CONFLICT_FIELD
};

inline const PKContentsType (&EnumValuesPKContentsType())[4] {
  static const PKContentsType values[] = {
    PKContentsType_PK_CONTENTS_NONE,
    PKContentsType_PK_CONTENTS_BATTLE_FIELD,
    PKContentsType_PK_CONTENTS_BRAWL,
    PKContentsType_PK_CONTENTS_CONFLICT_FIELD
  };
  return values;
}

inline const char * const *EnumNamesPKContentsType() {
  static const char * const names[] = {
    "PK_CONTENTS_NONE",
    "PK_CONTENTS_BATTLE_FIELD",
    "PK_CONTENTS_BRAWL",
    "PK_CONTENTS_CONFLICT_FIELD",
    nullptr
  };
  return names;
}

inline const char *EnumNamePKContentsType(PKContentsType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesPKContentsType()[index];
}

enum SummonTargetType {
  SummonTargetType_SummonTargetType_Buddy = 0,
  SummonTargetType_SummonTargetType_GuildMember = 1,
  SummonTargetType_MIN = SummonTargetType_SummonTargetType_Buddy,
  SummonTargetType_MAX = SummonTargetType_SummonTargetType_GuildMember
};

inline const SummonTargetType (&EnumValuesSummonTargetType())[2] {
  static const SummonTargetType values[] = {
    SummonTargetType_SummonTargetType_Buddy,
    SummonTargetType_SummonTargetType_GuildMember
  };
  return values;
}

inline const char * const *EnumNamesSummonTargetType() {
  static const char * const names[] = {
    "SummonTargetType_Buddy",
    "SummonTargetType_GuildMember",
    nullptr
  };
  return names;
}

inline const char *EnumNameSummonTargetType(SummonTargetType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesSummonTargetType()[index];
}

enum GroupMatchingInviteType {
  GroupMatchingInviteType_GROUP_MATCHING_TYPE_NONE = 0,
  GroupMatchingInviteType_GROUP_MATCHING_TYPE_BUDDY = 1,
  GroupMatchingInviteType_GROUP_MATCHING_TYPE_GUILD = 2,
  GroupMatchingInviteType_MIN = GroupMatchingInviteType_GROUP_MATCHING_TYPE_NONE,
  GroupMatchingInviteType_MAX = GroupMatchingInviteType_GROUP_MATCHING_TYPE_GUILD
};

inline const GroupMatchingInviteType (&EnumValuesGroupMatchingInviteType())[3] {
  static const GroupMatchingInviteType values[] = {
    GroupMatchingInviteType_GROUP_MATCHING_TYPE_NONE,
    GroupMatchingInviteType_GROUP_MATCHING_TYPE_BUDDY,
    GroupMatchingInviteType_GROUP_MATCHING_TYPE_GUILD
  };
  return values;
}

inline const char * const *EnumNamesGroupMatchingInviteType() {
  static const char * const names[] = {
    "GROUP_MATCHING_TYPE_NONE",
    "GROUP_MATCHING_TYPE_BUDDY",
    "GROUP_MATCHING_TYPE_GUILD",
    nullptr
  };
  return names;
}

inline const char *EnumNameGroupMatchingInviteType(GroupMatchingInviteType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesGroupMatchingInviteType()[index];
}

enum ScrollQuestState {
  ScrollQuestState_SCROLL_QUEST_STATE_INIT = 0,
  ScrollQuestState_SCROLL_QUEST_STATE_PROGRESS = 1,
  ScrollQuestState_SCROLL_QUEST_STATE_WAIT_REWARD = 2,
  ScrollQuestState_SCROLL_QUEST_STATE_REWARDED = 3,
  ScrollQuestState_SCROLL_QUEST_STATE_GIVE_UP = 4,
  ScrollQuestState_SCROLL_QUEST_STATE_MAX = 5,
  ScrollQuestState_MIN = ScrollQuestState_SCROLL_QUEST_STATE_INIT,
  ScrollQuestState_MAX = ScrollQuestState_SCROLL_QUEST_STATE_MAX
};

inline const ScrollQuestState (&EnumValuesScrollQuestState())[6] {
  static const ScrollQuestState values[] = {
    ScrollQuestState_SCROLL_QUEST_STATE_INIT,
    ScrollQuestState_SCROLL_QUEST_STATE_PROGRESS,
    ScrollQuestState_SCROLL_QUEST_STATE_WAIT_REWARD,
    ScrollQuestState_SCROLL_QUEST_STATE_REWARDED,
    ScrollQuestState_SCROLL_QUEST_STATE_GIVE_UP,
    ScrollQuestState_SCROLL_QUEST_STATE_MAX
  };
  return values;
}

inline const char * const *EnumNamesScrollQuestState() {
  static const char * const names[] = {
    "SCROLL_QUEST_STATE_INIT",
    "SCROLL_QUEST_STATE_PROGRESS",
    "SCROLL_QUEST_STATE_WAIT_REWARD",
    "SCROLL_QUEST_STATE_REWARDED",
    "SCROLL_QUEST_STATE_GIVE_UP",
    "SCROLL_QUEST_STATE_MAX",
    nullptr
  };
  return names;
}

inline const char *EnumNameScrollQuestState(ScrollQuestState e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesScrollQuestState()[index];
}

/////////////////////////////////////
/////////////////////////////////////	
enum PetState {
  PetState_PET_STATE_SUMMONED = 0,
  PetState_PET_STATE_SUPPORT = 1,
  PetState_PET_STATE_MAX = 2,
  PetState_MIN = PetState_PET_STATE_SUMMONED,
  PetState_MAX = PetState_PET_STATE_MAX
};

inline const PetState (&EnumValuesPetState())[3] {
  static const PetState values[] = {
    PetState_PET_STATE_SUMMONED,
    PetState_PET_STATE_SUPPORT,
    PetState_PET_STATE_MAX
  };
  return values;
}

inline const char * const *EnumNamesPetState() {
  static const char * const names[] = {
    "PET_STATE_SUMMONED",
    "PET_STATE_SUPPORT",
    "PET_STATE_MAX",
    nullptr
  };
  return names;
}

inline const char *EnumNamePetState(PetState e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesPetState()[index];
}

/////////////////////////////////////
/////////////////////////////////////
enum PetHatcheryState {
  PetHatcheryState_PET_HATCHERY_STATE_SPAWN_READY = 0,
  PetHatcheryState_PET_HATCHERY_STATE_SPAWNED = 1,
  PetHatcheryState_PET_HATCHERY_STATE_HATCHED = 2,
  PetHatcheryState_PET_HATCHERY_STATE_MAX = 3,
  PetHatcheryState_MIN = PetHatcheryState_PET_HATCHERY_STATE_SPAWN_READY,
  PetHatcheryState_MAX = PetHatcheryState_PET_HATCHERY_STATE_MAX
};

inline const PetHatcheryState (&EnumValuesPetHatcheryState())[4] {
  static const PetHatcheryState values[] = {
    PetHatcheryState_PET_HATCHERY_STATE_SPAWN_READY,
    PetHatcheryState_PET_HATCHERY_STATE_SPAWNED,
    PetHatcheryState_PET_HATCHERY_STATE_HATCHED,
    PetHatcheryState_PET_HATCHERY_STATE_MAX
  };
  return values;
}

inline const char * const *EnumNamesPetHatcheryState() {
  static const char * const names[] = {
    "PET_HATCHERY_STATE_SPAWN_READY",
    "PET_HATCHERY_STATE_SPAWNED",
    "PET_HATCHERY_STATE_HATCHED",
    "PET_HATCHERY_STATE_MAX",
    nullptr
  };
  return names;
}

inline const char *EnumNamePetHatcheryState(PetHatcheryState e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesPetHatcheryState()[index];
}

///- Pos ----------
struct Pos FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8
  };
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  float z() const {
    return GetField<float>(VT_Z, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_X) &&
           VerifyField<float>(verifier, VT_Y) &&
           VerifyField<float>(verifier, VT_Z) &&
           verifier.EndTable();
  }
};

struct PosBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(float x) {
    fbb_.AddElement<float>(Pos::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(Pos::VT_Y, y, 0.0f);
  }
  void add_z(float z) {
    fbb_.AddElement<float>(Pos::VT_Z, z, 0.0f);
  }
  explicit PosBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PosBuilder &operator=(const PosBuilder &);
  flatbuffers::Offset<Pos> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pos>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pos> CreatePos(
    flatbuffers::FlatBufferBuilder &_fbb,
    float x = 0.0f,
    float y = 0.0f,
    float z = 0.0f) {
  PosBuilder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct ReactionInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_DESTPOS = 6,
    VT_TIME = 8,
    VT_KEY = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  const Pos *destPos() const {
    return GetPointer<const Pos *>(VT_DESTPOS);
  }
  int32_t time() const {
    return GetField<int32_t>(VT_TIME, 0);
  }
  int32_t key() const {
    return GetField<int32_t>(VT_KEY, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffsetRequired(verifier, VT_DESTPOS) &&
           verifier.VerifyTable(destPos()) &&
           VerifyField<int32_t>(verifier, VT_TIME) &&
           VerifyField<int32_t>(verifier, VT_KEY) &&
           verifier.EndTable();
  }
};

struct ReactionInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(ReactionInfo::VT_TYPE, type, 0);
  }
  void add_destPos(flatbuffers::Offset<Pos> destPos) {
    fbb_.AddOffset(ReactionInfo::VT_DESTPOS, destPos);
  }
  void add_time(int32_t time) {
    fbb_.AddElement<int32_t>(ReactionInfo::VT_TIME, time, 0);
  }
  void add_key(int32_t key) {
    fbb_.AddElement<int32_t>(ReactionInfo::VT_KEY, key, 0);
  }
  explicit ReactionInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReactionInfoBuilder &operator=(const ReactionInfoBuilder &);
  flatbuffers::Offset<ReactionInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReactionInfo>(end);
    fbb_.Required(o, ReactionInfo::VT_DESTPOS);
    return o;
  }
};

inline flatbuffers::Offset<ReactionInfo> CreateReactionInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 0,
    flatbuffers::Offset<Pos> destPos = 0,
    int32_t time = 0,
    int32_t key = 0) {
  ReactionInfoBuilder builder_(_fbb);
  builder_.add_key(key);
  builder_.add_time(time);
  builder_.add_destPos(destPos);
  builder_.add_type(type);
  return builder_.Finish();
}

struct EffectTargetInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_POS = 6,
    VT_REACTION = 8
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  const Pos *pos() const {
    return GetPointer<const Pos *>(VT_POS);
  }
  const ReactionInfo *reaction() const {
    return GetPointer<const ReactionInfo *>(VT_REACTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyOffsetRequired(verifier, VT_POS) &&
           verifier.VerifyTable(pos()) &&
           VerifyOffsetRequired(verifier, VT_REACTION) &&
           verifier.VerifyTable(reaction()) &&
           verifier.EndTable();
  }
};

struct EffectTargetInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(EffectTargetInfo::VT_OBJECTID, objectId, 0);
  }
  void add_pos(flatbuffers::Offset<Pos> pos) {
    fbb_.AddOffset(EffectTargetInfo::VT_POS, pos);
  }
  void add_reaction(flatbuffers::Offset<ReactionInfo> reaction) {
    fbb_.AddOffset(EffectTargetInfo::VT_REACTION, reaction);
  }
  explicit EffectTargetInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EffectTargetInfoBuilder &operator=(const EffectTargetInfoBuilder &);
  flatbuffers::Offset<EffectTargetInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EffectTargetInfo>(end);
    fbb_.Required(o, EffectTargetInfo::VT_POS);
    fbb_.Required(o, EffectTargetInfo::VT_REACTION);
    return o;
  }
};

inline flatbuffers::Offset<EffectTargetInfo> CreateEffectTargetInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    flatbuffers::Offset<Pos> pos = 0,
    flatbuffers::Offset<ReactionInfo> reaction = 0) {
  EffectTargetInfoBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_reaction(reaction);
  builder_.add_pos(pos);
  return builder_.Finish();
}

///- PING_NOTIFY ----------
struct PingNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TICK = 4
  };
  uint32_t tick() const {
    return GetField<uint32_t>(VT_TICK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TICK) &&
           verifier.EndTable();
  }
};

struct PingNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tick(uint32_t tick) {
    fbb_.AddElement<uint32_t>(PingNotify::VT_TICK, tick, 0);
  }
  explicit PingNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PingNotifyBuilder &operator=(const PingNotifyBuilder &);
  flatbuffers::Offset<PingNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PingNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<PingNotify> CreatePingNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t tick = 0) {
  PingNotifyBuilder builder_(_fbb);
  builder_.add_tick(tick);
  return builder_.Finish();
}

///- KEEP_ALIVE_NOTIFY
struct KeepAliveNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct KeepAliveNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit KeepAliveNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  KeepAliveNotifyBuilder &operator=(const KeepAliveNotifyBuilder &);
  flatbuffers::Offset<KeepAliveNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KeepAliveNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<KeepAliveNotify> CreateKeepAliveNotify(
    flatbuffers::FlatBufferBuilder &_fbb) {
  KeepAliveNotifyBuilder builder_(_fbb);
  return builder_.Finish();
}

///- GAME_PING ----------
struct GamePingRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_AVG = 6,
    VT_KEY = 8
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int64_t avg() const {
    return GetField<int64_t>(VT_AVG, 0);
  }
  int64_t key() const {
    return GetField<int64_t>(VT_KEY, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int64_t>(verifier, VT_AVG) &&
           VerifyField<int64_t>(verifier, VT_KEY) &&
           verifier.EndTable();
  }
};

struct GamePingRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(GamePingRequest::VT_OBJECTID, objectId, 0);
  }
  void add_avg(int64_t avg) {
    fbb_.AddElement<int64_t>(GamePingRequest::VT_AVG, avg, 0);
  }
  void add_key(int64_t key) {
    fbb_.AddElement<int64_t>(GamePingRequest::VT_KEY, key, 0);
  }
  explicit GamePingRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GamePingRequestBuilder &operator=(const GamePingRequestBuilder &);
  flatbuffers::Offset<GamePingRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GamePingRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GamePingRequest> CreateGamePingRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int64_t avg = 0,
    int64_t key = 0) {
  GamePingRequestBuilder builder_(_fbb);
  builder_.add_key(key);
  builder_.add_avg(avg);
  builder_.add_objectId(objectId);
  return builder_.Finish();
}

struct GamePingResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_KEY = 6
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int64_t key() const {
    return GetField<int64_t>(VT_KEY, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int64_t>(verifier, VT_KEY) &&
           verifier.EndTable();
  }
};

struct GamePingResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(GamePingResponse::VT_OBJECTID, objectId, 0);
  }
  void add_key(int64_t key) {
    fbb_.AddElement<int64_t>(GamePingResponse::VT_KEY, key, 0);
  }
  explicit GamePingResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GamePingResponseBuilder &operator=(const GamePingResponseBuilder &);
  flatbuffers::Offset<GamePingResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GamePingResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GamePingResponse> CreateGamePingResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int64_t key = 0) {
  GamePingResponseBuilder builder_(_fbb);
  builder_.add_key(key);
  builder_.add_objectId(objectId);
  return builder_.Finish();
}

/// GAME_CONTENTS_CONFIG_NOTIFY
struct GameContentsConfigNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONTENTCONFIG = 4
  };
  const ContentConfigList *contentConfig() const {
    return GetPointer<const ContentConfigList *>(VT_CONTENTCONFIG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTENTCONFIG) &&
           verifier.VerifyTable(contentConfig()) &&
           verifier.EndTable();
  }
};

struct GameContentsConfigNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_contentConfig(flatbuffers::Offset<ContentConfigList> contentConfig) {
    fbb_.AddOffset(GameContentsConfigNotify::VT_CONTENTCONFIG, contentConfig);
  }
  explicit GameContentsConfigNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GameContentsConfigNotifyBuilder &operator=(const GameContentsConfigNotifyBuilder &);
  flatbuffers::Offset<GameContentsConfigNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GameContentsConfigNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<GameContentsConfigNotify> CreateGameContentsConfigNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ContentConfigList> contentConfig = 0) {
  GameContentsConfigNotifyBuilder builder_(_fbb);
  builder_.add_contentConfig(contentConfig);
  return builder_.Finish();
}

/// ACCOUNT_RECONNECT_REQUEST
struct AccountReconnectRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCOUNTDBID = 4,
    VT_TICKET = 6
  };
  int64_t accountDbId() const {
    return GetField<int64_t>(VT_ACCOUNTDBID, 0);
  }
  const flatbuffers::Vector<uint8_t> *ticket() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_TICKET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ACCOUNTDBID) &&
           VerifyOffsetRequired(verifier, VT_TICKET) &&
           verifier.VerifyVector(ticket()) &&
           verifier.EndTable();
  }
};

struct AccountReconnectRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accountDbId(int64_t accountDbId) {
    fbb_.AddElement<int64_t>(AccountReconnectRequest::VT_ACCOUNTDBID, accountDbId, 0);
  }
  void add_ticket(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> ticket) {
    fbb_.AddOffset(AccountReconnectRequest::VT_TICKET, ticket);
  }
  explicit AccountReconnectRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AccountReconnectRequestBuilder &operator=(const AccountReconnectRequestBuilder &);
  flatbuffers::Offset<AccountReconnectRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AccountReconnectRequest>(end);
    fbb_.Required(o, AccountReconnectRequest::VT_TICKET);
    return o;
  }
};

inline flatbuffers::Offset<AccountReconnectRequest> CreateAccountReconnectRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t accountDbId = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> ticket = 0) {
  AccountReconnectRequestBuilder builder_(_fbb);
  builder_.add_accountDbId(accountDbId);
  builder_.add_ticket(ticket);
  return builder_.Finish();
}

inline flatbuffers::Offset<AccountReconnectRequest> CreateAccountReconnectRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t accountDbId = 0,
    const std::vector<uint8_t> *ticket = nullptr) {
  return LeanPacket::CreateAccountReconnectRequest(
      _fbb,
      accountDbId,
      ticket ? _fbb.CreateVector<uint8_t>(*ticket) : 0);
}

/// ACCOUNT_RECONNECT_RESPONSE
struct AccountReconnectResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERROR = 4,
    VT_STATE = 6,
    VT_TICKET = 8
  };
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  int8_t state() const {
    return GetField<int8_t>(VT_STATE, 0);
  }
  const flatbuffers::Vector<uint8_t> *ticket() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_TICKET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           VerifyField<int8_t>(verifier, VT_STATE) &&
           VerifyOffset(verifier, VT_TICKET) &&
           verifier.VerifyVector(ticket()) &&
           verifier.EndTable();
  }
};

struct AccountReconnectResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(AccountReconnectResponse::VT_ERROR, error, 0);
  }
  void add_state(int8_t state) {
    fbb_.AddElement<int8_t>(AccountReconnectResponse::VT_STATE, state, 0);
  }
  void add_ticket(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> ticket) {
    fbb_.AddOffset(AccountReconnectResponse::VT_TICKET, ticket);
  }
  explicit AccountReconnectResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AccountReconnectResponseBuilder &operator=(const AccountReconnectResponseBuilder &);
  flatbuffers::Offset<AccountReconnectResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AccountReconnectResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<AccountReconnectResponse> CreateAccountReconnectResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t error = 0,
    int8_t state = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> ticket = 0) {
  AccountReconnectResponseBuilder builder_(_fbb);
  builder_.add_ticket(ticket);
  builder_.add_error(error);
  builder_.add_state(state);
  return builder_.Finish();
}

inline flatbuffers::Offset<AccountReconnectResponse> CreateAccountReconnectResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t error = 0,
    int8_t state = 0,
    const std::vector<uint8_t> *ticket = nullptr) {
  return LeanPacket::CreateAccountReconnectResponse(
      _fbb,
      error,
      state,
      ticket ? _fbb.CreateVector<uint8_t>(*ticket) : 0);
}

/// HIVE_TOP_PC_INFO_REQUEST
struct HiveTopPcInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYERID = 4
  };
  int64_t playerId() const {
    return GetField<int64_t>(VT_PLAYERID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PLAYERID) &&
           verifier.EndTable();
  }
};

struct HiveTopPcInfoRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_playerId(int64_t playerId) {
    fbb_.AddElement<int64_t>(HiveTopPcInfoRequest::VT_PLAYERID, playerId, 0);
  }
  explicit HiveTopPcInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HiveTopPcInfoRequestBuilder &operator=(const HiveTopPcInfoRequestBuilder &);
  flatbuffers::Offset<HiveTopPcInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HiveTopPcInfoRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<HiveTopPcInfoRequest> CreateHiveTopPcInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t playerId = 0) {
  HiveTopPcInfoRequestBuilder builder_(_fbb);
  builder_.add_playerId(playerId);
  return builder_.Finish();
}

/// HIVE_TOP_PC_INFO_RESPONSE
struct HiveTopPcInfoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COLONYNAME = 4,
    VT_CHARACTERDATA = 6
  };
  const flatbuffers::String *colonyName() const {
    return GetPointer<const flatbuffers::String *>(VT_COLONYNAME);
  }
  const CharacterData *characterData() const {
    return GetPointer<const CharacterData *>(VT_CHARACTERDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLONYNAME) &&
           verifier.VerifyString(colonyName()) &&
           VerifyOffset(verifier, VT_CHARACTERDATA) &&
           verifier.VerifyTable(characterData()) &&
           verifier.EndTable();
  }
};

struct HiveTopPcInfoResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_colonyName(flatbuffers::Offset<flatbuffers::String> colonyName) {
    fbb_.AddOffset(HiveTopPcInfoResponse::VT_COLONYNAME, colonyName);
  }
  void add_characterData(flatbuffers::Offset<CharacterData> characterData) {
    fbb_.AddOffset(HiveTopPcInfoResponse::VT_CHARACTERDATA, characterData);
  }
  explicit HiveTopPcInfoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HiveTopPcInfoResponseBuilder &operator=(const HiveTopPcInfoResponseBuilder &);
  flatbuffers::Offset<HiveTopPcInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HiveTopPcInfoResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<HiveTopPcInfoResponse> CreateHiveTopPcInfoResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> colonyName = 0,
    flatbuffers::Offset<CharacterData> characterData = 0) {
  HiveTopPcInfoResponseBuilder builder_(_fbb);
  builder_.add_characterData(characterData);
  builder_.add_colonyName(colonyName);
  return builder_.Finish();
}

inline flatbuffers::Offset<HiveTopPcInfoResponse> CreateHiveTopPcInfoResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *colonyName = nullptr,
    flatbuffers::Offset<CharacterData> characterData = 0) {
  return LeanPacket::CreateHiveTopPcInfoResponse(
      _fbb,
      colonyName ? _fbb.CreateString(colonyName) : 0,
      characterData);
}

/// HIVE_COMPANION_COUNT_REQUEST
struct HiveCompanionCountRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct HiveCompanionCountRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HiveCompanionCountRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HiveCompanionCountRequestBuilder &operator=(const HiveCompanionCountRequestBuilder &);
  flatbuffers::Offset<HiveCompanionCountRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HiveCompanionCountRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<HiveCompanionCountRequest> CreateHiveCompanionCountRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HiveCompanionCountRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// HIVE_COMPANION_COUNT_RESPONSE
struct HiveCompanionCountResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COMPANIONCOUNT = 4
  };
  int32_t companionCount() const {
    return GetField<int32_t>(VT_COMPANIONCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_COMPANIONCOUNT) &&
           verifier.EndTable();
  }
};

struct HiveCompanionCountResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_companionCount(int32_t companionCount) {
    fbb_.AddElement<int32_t>(HiveCompanionCountResponse::VT_COMPANIONCOUNT, companionCount, 0);
  }
  explicit HiveCompanionCountResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HiveCompanionCountResponseBuilder &operator=(const HiveCompanionCountResponseBuilder &);
  flatbuffers::Offset<HiveCompanionCountResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HiveCompanionCountResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<HiveCompanionCountResponse> CreateHiveCompanionCountResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t companionCount = 0) {
  HiveCompanionCountResponseBuilder builder_(_fbb);
  builder_.add_companionCount(companionCount);
  return builder_.Finish();
}

/// HIVE_SHOP_PURCHASE_PRODUCT_NOTIFY
struct HiveShopPurchaseProductNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRODUCTID = 4
  };
  int32_t productId() const {
    return GetField<int32_t>(VT_PRODUCTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PRODUCTID) &&
           verifier.EndTable();
  }
};

struct HiveShopPurchaseProductNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_productId(int32_t productId) {
    fbb_.AddElement<int32_t>(HiveShopPurchaseProductNotify::VT_PRODUCTID, productId, 0);
  }
  explicit HiveShopPurchaseProductNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HiveShopPurchaseProductNotifyBuilder &operator=(const HiveShopPurchaseProductNotifyBuilder &);
  flatbuffers::Offset<HiveShopPurchaseProductNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HiveShopPurchaseProductNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<HiveShopPurchaseProductNotify> CreateHiveShopPurchaseProductNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t productId = 0) {
  HiveShopPurchaseProductNotifyBuilder builder_(_fbb);
  builder_.add_productId(productId);
  return builder_.Finish();
}

/// DELAY_PING_NOTIFY
struct DelayPingNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PING = 4
  };
  int16_t ping() const {
    return GetField<int16_t>(VT_PING, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_PING) &&
           verifier.EndTable();
  }
};

struct DelayPingNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ping(int16_t ping) {
    fbb_.AddElement<int16_t>(DelayPingNotify::VT_PING, ping, 0);
  }
  explicit DelayPingNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DelayPingNotifyBuilder &operator=(const DelayPingNotifyBuilder &);
  flatbuffers::Offset<DelayPingNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DelayPingNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<DelayPingNotify> CreateDelayPingNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t ping = 0) {
  DelayPingNotifyBuilder builder_(_fbb);
  builder_.add_ping(ping);
  return builder_.Finish();
}

///- CHECK_CLIENT_VERSION_REQUEST
struct CheckClientVersionRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PACKET = 4,
    VT_MAJOR = 6,
    VT_MINOR = 8,
    VT_PATCH = 10,
    VT_HASH = 12
  };
  int32_t packet() const {
    return GetField<int32_t>(VT_PACKET, 0);
  }
  int32_t major() const {
    return GetField<int32_t>(VT_MAJOR, 0);
  }
  int32_t minor() const {
    return GetField<int32_t>(VT_MINOR, 0);
  }
  int32_t patch() const {
    return GetField<int32_t>(VT_PATCH, 0);
  }
  const flatbuffers::String *hash() const {
    return GetPointer<const flatbuffers::String *>(VT_HASH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PACKET) &&
           VerifyField<int32_t>(verifier, VT_MAJOR) &&
           VerifyField<int32_t>(verifier, VT_MINOR) &&
           VerifyField<int32_t>(verifier, VT_PATCH) &&
           VerifyOffset(verifier, VT_HASH) &&
           verifier.VerifyString(hash()) &&
           verifier.EndTable();
  }
};

struct CheckClientVersionRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_packet(int32_t packet) {
    fbb_.AddElement<int32_t>(CheckClientVersionRequest::VT_PACKET, packet, 0);
  }
  void add_major(int32_t major) {
    fbb_.AddElement<int32_t>(CheckClientVersionRequest::VT_MAJOR, major, 0);
  }
  void add_minor(int32_t minor) {
    fbb_.AddElement<int32_t>(CheckClientVersionRequest::VT_MINOR, minor, 0);
  }
  void add_patch(int32_t patch) {
    fbb_.AddElement<int32_t>(CheckClientVersionRequest::VT_PATCH, patch, 0);
  }
  void add_hash(flatbuffers::Offset<flatbuffers::String> hash) {
    fbb_.AddOffset(CheckClientVersionRequest::VT_HASH, hash);
  }
  explicit CheckClientVersionRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CheckClientVersionRequestBuilder &operator=(const CheckClientVersionRequestBuilder &);
  flatbuffers::Offset<CheckClientVersionRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CheckClientVersionRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<CheckClientVersionRequest> CreateCheckClientVersionRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t packet = 0,
    int32_t major = 0,
    int32_t minor = 0,
    int32_t patch = 0,
    flatbuffers::Offset<flatbuffers::String> hash = 0) {
  CheckClientVersionRequestBuilder builder_(_fbb);
  builder_.add_hash(hash);
  builder_.add_patch(patch);
  builder_.add_minor(minor);
  builder_.add_major(major);
  builder_.add_packet(packet);
  return builder_.Finish();
}

inline flatbuffers::Offset<CheckClientVersionRequest> CreateCheckClientVersionRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t packet = 0,
    int32_t major = 0,
    int32_t minor = 0,
    int32_t patch = 0,
    const char *hash = nullptr) {
  return LeanPacket::CreateCheckClientVersionRequest(
      _fbb,
      packet,
      major,
      minor,
      patch,
      hash ? _fbb.CreateString(hash) : 0);
}

///- CHECK_CLIENT_VERSION_RESPONSE
struct CheckClientVersionResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_PACKET = 6,
    VT_MAJOR = 8,
    VT_MINOR = 10,
    VT_PATCH = 12,
    VT_CONTENTCONFIG = 14
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  /// 클라이언트에서 보낸 버전
  int32_t packet() const {
    return GetField<int32_t>(VT_PACKET, 0);
  }
  int32_t major() const {
    return GetField<int32_t>(VT_MAJOR, 0);
  }
  int32_t minor() const {
    return GetField<int32_t>(VT_MINOR, 0);
  }
  int32_t patch() const {
    return GetField<int32_t>(VT_PATCH, 0);
  }
  const ContentConfigList *contentConfig() const {
    return GetPointer<const ContentConfigList *>(VT_CONTENTCONFIG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int32_t>(verifier, VT_PACKET) &&
           VerifyField<int32_t>(verifier, VT_MAJOR) &&
           VerifyField<int32_t>(verifier, VT_MINOR) &&
           VerifyField<int32_t>(verifier, VT_PATCH) &&
           VerifyOffset(verifier, VT_CONTENTCONFIG) &&
           verifier.VerifyTable(contentConfig()) &&
           verifier.EndTable();
  }
};

struct CheckClientVersionResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(CheckClientVersionResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_packet(int32_t packet) {
    fbb_.AddElement<int32_t>(CheckClientVersionResponse::VT_PACKET, packet, 0);
  }
  void add_major(int32_t major) {
    fbb_.AddElement<int32_t>(CheckClientVersionResponse::VT_MAJOR, major, 0);
  }
  void add_minor(int32_t minor) {
    fbb_.AddElement<int32_t>(CheckClientVersionResponse::VT_MINOR, minor, 0);
  }
  void add_patch(int32_t patch) {
    fbb_.AddElement<int32_t>(CheckClientVersionResponse::VT_PATCH, patch, 0);
  }
  void add_contentConfig(flatbuffers::Offset<ContentConfigList> contentConfig) {
    fbb_.AddOffset(CheckClientVersionResponse::VT_CONTENTCONFIG, contentConfig);
  }
  explicit CheckClientVersionResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CheckClientVersionResponseBuilder &operator=(const CheckClientVersionResponseBuilder &);
  flatbuffers::Offset<CheckClientVersionResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CheckClientVersionResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<CheckClientVersionResponse> CreateCheckClientVersionResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    int32_t packet = 0,
    int32_t major = 0,
    int32_t minor = 0,
    int32_t patch = 0,
    flatbuffers::Offset<ContentConfigList> contentConfig = 0) {
  CheckClientVersionResponseBuilder builder_(_fbb);
  builder_.add_contentConfig(contentConfig);
  builder_.add_patch(patch);
  builder_.add_minor(minor);
  builder_.add_major(major);
  builder_.add_packet(packet);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

///- ACCOUNT_AUTH_REQUEST ----------
struct AccountAuthRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCOUNTNAME = 4,
    VT_ACCOUNTPW = 6
  };
  const flatbuffers::String *accountName() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNTNAME);
  }
  const flatbuffers::String *accountPw() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNTPW);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ACCOUNTNAME) &&
           verifier.VerifyString(accountName()) &&
           VerifyOffsetRequired(verifier, VT_ACCOUNTPW) &&
           verifier.VerifyString(accountPw()) &&
           verifier.EndTable();
  }
};

struct AccountAuthRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accountName(flatbuffers::Offset<flatbuffers::String> accountName) {
    fbb_.AddOffset(AccountAuthRequest::VT_ACCOUNTNAME, accountName);
  }
  void add_accountPw(flatbuffers::Offset<flatbuffers::String> accountPw) {
    fbb_.AddOffset(AccountAuthRequest::VT_ACCOUNTPW, accountPw);
  }
  explicit AccountAuthRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AccountAuthRequestBuilder &operator=(const AccountAuthRequestBuilder &);
  flatbuffers::Offset<AccountAuthRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AccountAuthRequest>(end);
    fbb_.Required(o, AccountAuthRequest::VT_ACCOUNTNAME);
    fbb_.Required(o, AccountAuthRequest::VT_ACCOUNTPW);
    return o;
  }
};

inline flatbuffers::Offset<AccountAuthRequest> CreateAccountAuthRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> accountName = 0,
    flatbuffers::Offset<flatbuffers::String> accountPw = 0) {
  AccountAuthRequestBuilder builder_(_fbb);
  builder_.add_accountPw(accountPw);
  builder_.add_accountName(accountName);
  return builder_.Finish();
}

inline flatbuffers::Offset<AccountAuthRequest> CreateAccountAuthRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *accountName = nullptr,
    const char *accountPw = nullptr) {
  return LeanPacket::CreateAccountAuthRequest(
      _fbb,
      accountName ? _fbb.CreateString(accountName) : 0,
      accountPw ? _fbb.CreateString(accountPw) : 0);
}

///- ACCOUNT_AUTH_RESPONSE ----------
struct AccountAuthResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_ACCOUNTNAME = 6,
    VT_ACCOUNTDBID = 8,
    VT_RECENTLYCOLONYID = 10,
    VT_ADMINLEVEL = 12
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  const flatbuffers::String *accountName() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNTNAME);
  }
  int64_t accountDbId() const {
    return GetField<int64_t>(VT_ACCOUNTDBID, 0);
  }
  int16_t recentlyColonyId() const {
    return GetField<int16_t>(VT_RECENTLYCOLONYID, 0);
  }
  int32_t adminLevel() const {
    return GetField<int32_t>(VT_ADMINLEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyOffsetRequired(verifier, VT_ACCOUNTNAME) &&
           verifier.VerifyString(accountName()) &&
           VerifyField<int64_t>(verifier, VT_ACCOUNTDBID) &&
           VerifyField<int16_t>(verifier, VT_RECENTLYCOLONYID) &&
           VerifyField<int32_t>(verifier, VT_ADMINLEVEL) &&
           verifier.EndTable();
  }
};

struct AccountAuthResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(AccountAuthResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_accountName(flatbuffers::Offset<flatbuffers::String> accountName) {
    fbb_.AddOffset(AccountAuthResponse::VT_ACCOUNTNAME, accountName);
  }
  void add_accountDbId(int64_t accountDbId) {
    fbb_.AddElement<int64_t>(AccountAuthResponse::VT_ACCOUNTDBID, accountDbId, 0);
  }
  void add_recentlyColonyId(int16_t recentlyColonyId) {
    fbb_.AddElement<int16_t>(AccountAuthResponse::VT_RECENTLYCOLONYID, recentlyColonyId, 0);
  }
  void add_adminLevel(int32_t adminLevel) {
    fbb_.AddElement<int32_t>(AccountAuthResponse::VT_ADMINLEVEL, adminLevel, 0);
  }
  explicit AccountAuthResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AccountAuthResponseBuilder &operator=(const AccountAuthResponseBuilder &);
  flatbuffers::Offset<AccountAuthResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AccountAuthResponse>(end);
    fbb_.Required(o, AccountAuthResponse::VT_ACCOUNTNAME);
    return o;
  }
};

inline flatbuffers::Offset<AccountAuthResponse> CreateAccountAuthResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    flatbuffers::Offset<flatbuffers::String> accountName = 0,
    int64_t accountDbId = 0,
    int16_t recentlyColonyId = 0,
    int32_t adminLevel = 0) {
  AccountAuthResponseBuilder builder_(_fbb);
  builder_.add_accountDbId(accountDbId);
  builder_.add_adminLevel(adminLevel);
  builder_.add_accountName(accountName);
  builder_.add_errorCode(errorCode);
  builder_.add_recentlyColonyId(recentlyColonyId);
  return builder_.Finish();
}

inline flatbuffers::Offset<AccountAuthResponse> CreateAccountAuthResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    const char *accountName = nullptr,
    int64_t accountDbId = 0,
    int16_t recentlyColonyId = 0,
    int32_t adminLevel = 0) {
  return LeanPacket::CreateAccountAuthResponse(
      _fbb,
      errorCode,
      accountName ? _fbb.CreateString(accountName) : 0,
      accountDbId,
      recentlyColonyId,
      adminLevel);
}

///- ACCOUNT_AUTH_AGENT_TICKET_REQUEST
struct AccountAuthAgentTicketRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCOUNTDBID = 4,
    VT_ACCOUNTNAME = 6,
    VT_TICKET = 8
  };
  int64_t accountDbId() const {
    return GetField<int64_t>(VT_ACCOUNTDBID, 0);
  }
  const flatbuffers::String *accountName() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNTNAME);
  }
  const flatbuffers::Vector<uint8_t> *ticket() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_TICKET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ACCOUNTDBID) &&
           VerifyOffsetRequired(verifier, VT_ACCOUNTNAME) &&
           verifier.VerifyString(accountName()) &&
           VerifyOffsetRequired(verifier, VT_TICKET) &&
           verifier.VerifyVector(ticket()) &&
           verifier.EndTable();
  }
};

struct AccountAuthAgentTicketRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accountDbId(int64_t accountDbId) {
    fbb_.AddElement<int64_t>(AccountAuthAgentTicketRequest::VT_ACCOUNTDBID, accountDbId, 0);
  }
  void add_accountName(flatbuffers::Offset<flatbuffers::String> accountName) {
    fbb_.AddOffset(AccountAuthAgentTicketRequest::VT_ACCOUNTNAME, accountName);
  }
  void add_ticket(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> ticket) {
    fbb_.AddOffset(AccountAuthAgentTicketRequest::VT_TICKET, ticket);
  }
  explicit AccountAuthAgentTicketRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AccountAuthAgentTicketRequestBuilder &operator=(const AccountAuthAgentTicketRequestBuilder &);
  flatbuffers::Offset<AccountAuthAgentTicketRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AccountAuthAgentTicketRequest>(end);
    fbb_.Required(o, AccountAuthAgentTicketRequest::VT_ACCOUNTNAME);
    fbb_.Required(o, AccountAuthAgentTicketRequest::VT_TICKET);
    return o;
  }
};

inline flatbuffers::Offset<AccountAuthAgentTicketRequest> CreateAccountAuthAgentTicketRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t accountDbId = 0,
    flatbuffers::Offset<flatbuffers::String> accountName = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> ticket = 0) {
  AccountAuthAgentTicketRequestBuilder builder_(_fbb);
  builder_.add_accountDbId(accountDbId);
  builder_.add_ticket(ticket);
  builder_.add_accountName(accountName);
  return builder_.Finish();
}

inline flatbuffers::Offset<AccountAuthAgentTicketRequest> CreateAccountAuthAgentTicketRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t accountDbId = 0,
    const char *accountName = nullptr,
    const std::vector<uint8_t> *ticket = nullptr) {
  return LeanPacket::CreateAccountAuthAgentTicketRequest(
      _fbb,
      accountDbId,
      accountName ? _fbb.CreateString(accountName) : 0,
      ticket ? _fbb.CreateVector<uint8_t>(*ticket) : 0);
}

struct ColonyData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_GROUP = 6,
    VT_NAME = 8,
    VT_STATUS = 10,
    VT_ISNEW = 12,
    VT_MYPCCOUNT = 14
  };
  int16_t id() const {
    return GetField<int16_t>(VT_ID, 0);
  }
  int32_t group() const {
    return GetField<int32_t>(VT_GROUP, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  /// ColonyStatus
  int32_t status() const {
    return GetField<int32_t>(VT_STATUS, 0);
  }
  bool isNew() const {
    return GetField<uint8_t>(VT_ISNEW, 0) != 0;
  }
  int32_t myPcCount() const {
    return GetField<int32_t>(VT_MYPCCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_ID) &&
           VerifyField<int32_t>(verifier, VT_GROUP) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_STATUS) &&
           VerifyField<uint8_t>(verifier, VT_ISNEW) &&
           VerifyField<int32_t>(verifier, VT_MYPCCOUNT) &&
           verifier.EndTable();
  }
};

struct ColonyDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int16_t id) {
    fbb_.AddElement<int16_t>(ColonyData::VT_ID, id, 0);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(ColonyData::VT_GROUP, group, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ColonyData::VT_NAME, name);
  }
  void add_status(int32_t status) {
    fbb_.AddElement<int32_t>(ColonyData::VT_STATUS, status, 0);
  }
  void add_isNew(bool isNew) {
    fbb_.AddElement<uint8_t>(ColonyData::VT_ISNEW, static_cast<uint8_t>(isNew), 0);
  }
  void add_myPcCount(int32_t myPcCount) {
    fbb_.AddElement<int32_t>(ColonyData::VT_MYPCCOUNT, myPcCount, 0);
  }
  explicit ColonyDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ColonyDataBuilder &operator=(const ColonyDataBuilder &);
  flatbuffers::Offset<ColonyData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ColonyData>(end);
    fbb_.Required(o, ColonyData::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<ColonyData> CreateColonyData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t id = 0,
    int32_t group = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t status = 0,
    bool isNew = false,
    int32_t myPcCount = 0) {
  ColonyDataBuilder builder_(_fbb);
  builder_.add_myPcCount(myPcCount);
  builder_.add_status(status);
  builder_.add_name(name);
  builder_.add_group(group);
  builder_.add_id(id);
  builder_.add_isNew(isNew);
  return builder_.Finish();
}

inline flatbuffers::Offset<ColonyData> CreateColonyDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t id = 0,
    int32_t group = 0,
    const char *name = nullptr,
    int32_t status = 0,
    bool isNew = false,
    int32_t myPcCount = 0) {
  return LeanPacket::CreateColonyData(
      _fbb,
      id,
      group,
      name ? _fbb.CreateString(name) : 0,
      status,
      isNew,
      myPcCount);
}

struct CharacterData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COLONY = 4,
    VT_REALM = 6,
    VT_PCNAME = 8,
    VT_LEVEL = 10,
    VT_COMBATPOWER = 12,
    VT_CLASSTYPE = 14
  };
  int16_t colony() const {
    return GetField<int16_t>(VT_COLONY, 0);
  }
  int16_t realm() const {
    return GetField<int16_t>(VT_REALM, 0);
  }
  const flatbuffers::String *pcName() const {
    return GetPointer<const flatbuffers::String *>(VT_PCNAME);
  }
  int16_t level() const {
    return GetField<int16_t>(VT_LEVEL, 0);
  }
  int32_t combatPower() const {
    return GetField<int32_t>(VT_COMBATPOWER, 0);
  }
  int16_t classType() const {
    return GetField<int16_t>(VT_CLASSTYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_COLONY) &&
           VerifyField<int16_t>(verifier, VT_REALM) &&
           VerifyOffsetRequired(verifier, VT_PCNAME) &&
           verifier.VerifyString(pcName()) &&
           VerifyField<int16_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_COMBATPOWER) &&
           VerifyField<int16_t>(verifier, VT_CLASSTYPE) &&
           verifier.EndTable();
  }
};

struct CharacterDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_colony(int16_t colony) {
    fbb_.AddElement<int16_t>(CharacterData::VT_COLONY, colony, 0);
  }
  void add_realm(int16_t realm) {
    fbb_.AddElement<int16_t>(CharacterData::VT_REALM, realm, 0);
  }
  void add_pcName(flatbuffers::Offset<flatbuffers::String> pcName) {
    fbb_.AddOffset(CharacterData::VT_PCNAME, pcName);
  }
  void add_level(int16_t level) {
    fbb_.AddElement<int16_t>(CharacterData::VT_LEVEL, level, 0);
  }
  void add_combatPower(int32_t combatPower) {
    fbb_.AddElement<int32_t>(CharacterData::VT_COMBATPOWER, combatPower, 0);
  }
  void add_classType(int16_t classType) {
    fbb_.AddElement<int16_t>(CharacterData::VT_CLASSTYPE, classType, 0);
  }
  explicit CharacterDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CharacterDataBuilder &operator=(const CharacterDataBuilder &);
  flatbuffers::Offset<CharacterData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CharacterData>(end);
    fbb_.Required(o, CharacterData::VT_PCNAME);
    return o;
  }
};

inline flatbuffers::Offset<CharacterData> CreateCharacterData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t colony = 0,
    int16_t realm = 0,
    flatbuffers::Offset<flatbuffers::String> pcName = 0,
    int16_t level = 0,
    int32_t combatPower = 0,
    int16_t classType = 0) {
  CharacterDataBuilder builder_(_fbb);
  builder_.add_combatPower(combatPower);
  builder_.add_pcName(pcName);
  builder_.add_classType(classType);
  builder_.add_level(level);
  builder_.add_realm(realm);
  builder_.add_colony(colony);
  return builder_.Finish();
}

inline flatbuffers::Offset<CharacterData> CreateCharacterDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t colony = 0,
    int16_t realm = 0,
    const char *pcName = nullptr,
    int16_t level = 0,
    int32_t combatPower = 0,
    int16_t classType = 0) {
  return LeanPacket::CreateCharacterData(
      _fbb,
      colony,
      realm,
      pcName ? _fbb.CreateString(pcName) : 0,
      level,
      combatPower,
      classType);
}

struct GroupData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GROUPID = 4,
    VT_NAME = 6,
    VT_ISOPEN = 8,
    VT_ISVIEW = 10
  };
  int32_t groupId() const {
    return GetField<int32_t>(VT_GROUPID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool isOpen() const {
    return GetField<uint8_t>(VT_ISOPEN, 0) != 0;
  }
  bool isView() const {
    return GetField<uint8_t>(VT_ISVIEW, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_GROUPID) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_ISOPEN) &&
           VerifyField<uint8_t>(verifier, VT_ISVIEW) &&
           verifier.EndTable();
  }
};

struct GroupDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_groupId(int32_t groupId) {
    fbb_.AddElement<int32_t>(GroupData::VT_GROUPID, groupId, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(GroupData::VT_NAME, name);
  }
  void add_isOpen(bool isOpen) {
    fbb_.AddElement<uint8_t>(GroupData::VT_ISOPEN, static_cast<uint8_t>(isOpen), 0);
  }
  void add_isView(bool isView) {
    fbb_.AddElement<uint8_t>(GroupData::VT_ISVIEW, static_cast<uint8_t>(isView), 0);
  }
  explicit GroupDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GroupDataBuilder &operator=(const GroupDataBuilder &);
  flatbuffers::Offset<GroupData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GroupData>(end);
    fbb_.Required(o, GroupData::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<GroupData> CreateGroupData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t groupId = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    bool isOpen = false,
    bool isView = false) {
  GroupDataBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_groupId(groupId);
  builder_.add_isView(isView);
  builder_.add_isOpen(isOpen);
  return builder_.Finish();
}

inline flatbuffers::Offset<GroupData> CreateGroupDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t groupId = 0,
    const char *name = nullptr,
    bool isOpen = false,
    bool isView = false) {
  return LeanPacket::CreateGroupData(
      _fbb,
      groupId,
      name ? _fbb.CreateString(name) : 0,
      isOpen,
      isView);
}

struct PcAbility FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_VALUE = 6,
    VT_RATE = 8,
    VT_HARDCAP = 10
  };
  int16_t type() const {
    return GetField<int16_t>(VT_TYPE, 0);
  }
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  float rate() const {
    return GetField<float>(VT_RATE, 0.0f);
  }
  int32_t hardCap() const {
    return GetField<int32_t>(VT_HARDCAP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           VerifyField<float>(verifier, VT_RATE) &&
           VerifyField<int32_t>(verifier, VT_HARDCAP) &&
           verifier.EndTable();
  }
};

struct PcAbilityBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int16_t type) {
    fbb_.AddElement<int16_t>(PcAbility::VT_TYPE, type, 0);
  }
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(PcAbility::VT_VALUE, value, 0);
  }
  void add_rate(float rate) {
    fbb_.AddElement<float>(PcAbility::VT_RATE, rate, 0.0f);
  }
  void add_hardCap(int32_t hardCap) {
    fbb_.AddElement<int32_t>(PcAbility::VT_HARDCAP, hardCap, 0);
  }
  explicit PcAbilityBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PcAbilityBuilder &operator=(const PcAbilityBuilder &);
  flatbuffers::Offset<PcAbility> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PcAbility>(end);
    return o;
  }
};

inline flatbuffers::Offset<PcAbility> CreatePcAbility(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t type = 0,
    int32_t value = 0,
    float rate = 0.0f,
    int32_t hardCap = 0) {
  PcAbilityBuilder builder_(_fbb);
  builder_.add_hardCap(hardCap);
  builder_.add_rate(rate);
  builder_.add_value(value);
  builder_.add_type(type);
  return builder_.Finish();
}

///- COLONY_LIST_REQUEST --------
struct ColonyListRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ColonyListRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ColonyListRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ColonyListRequestBuilder &operator=(const ColonyListRequestBuilder &);
  flatbuffers::Offset<ColonyListRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ColonyListRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ColonyListRequest> CreateColonyListRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ColonyListRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

///- COLONY_LIST_RESPONSE --------
struct ColonyListResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COLONYS = 4,
    VT_GROUPS = 6,
    VT_RECOMMAND = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<ColonyData>> *colonys() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ColonyData>> *>(VT_COLONYS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GroupData>> *groups() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GroupData>> *>(VT_GROUPS);
  }
  int16_t recommand() const {
    return GetField<int16_t>(VT_RECOMMAND, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLONYS) &&
           verifier.VerifyVector(colonys()) &&
           verifier.VerifyVectorOfTables(colonys()) &&
           VerifyOffset(verifier, VT_GROUPS) &&
           verifier.VerifyVector(groups()) &&
           verifier.VerifyVectorOfTables(groups()) &&
           VerifyField<int16_t>(verifier, VT_RECOMMAND) &&
           verifier.EndTable();
  }
};

struct ColonyListResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_colonys(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ColonyData>>> colonys) {
    fbb_.AddOffset(ColonyListResponse::VT_COLONYS, colonys);
  }
  void add_groups(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GroupData>>> groups) {
    fbb_.AddOffset(ColonyListResponse::VT_GROUPS, groups);
  }
  void add_recommand(int16_t recommand) {
    fbb_.AddElement<int16_t>(ColonyListResponse::VT_RECOMMAND, recommand, 0);
  }
  explicit ColonyListResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ColonyListResponseBuilder &operator=(const ColonyListResponseBuilder &);
  flatbuffers::Offset<ColonyListResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ColonyListResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ColonyListResponse> CreateColonyListResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ColonyData>>> colonys = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GroupData>>> groups = 0,
    int16_t recommand = 0) {
  ColonyListResponseBuilder builder_(_fbb);
  builder_.add_groups(groups);
  builder_.add_colonys(colonys);
  builder_.add_recommand(recommand);
  return builder_.Finish();
}

inline flatbuffers::Offset<ColonyListResponse> CreateColonyListResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<ColonyData>> *colonys = nullptr,
    const std::vector<flatbuffers::Offset<GroupData>> *groups = nullptr,
    int16_t recommand = 0) {
  return LeanPacket::CreateColonyListResponse(
      _fbb,
      colonys ? _fbb.CreateVector<flatbuffers::Offset<ColonyData>>(*colonys) : 0,
      groups ? _fbb.CreateVector<flatbuffers::Offset<GroupData>>(*groups) : 0,
      recommand);
}

///- CHARACTER_LIST_REQUEST -------
struct CharacterListRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CharacterListRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CharacterListRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CharacterListRequestBuilder &operator=(const CharacterListRequestBuilder &);
  flatbuffers::Offset<CharacterListRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CharacterListRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<CharacterListRequest> CreateCharacterListRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CharacterListRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

///- CHARACTER_LIST_RESPONSE -------
struct CharacterListResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CHARACTERS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<CharacterData>> *characters() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CharacterData>> *>(VT_CHARACTERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHARACTERS) &&
           verifier.VerifyVector(characters()) &&
           verifier.VerifyVectorOfTables(characters()) &&
           verifier.EndTable();
  }
};

struct CharacterListResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_characters(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CharacterData>>> characters) {
    fbb_.AddOffset(CharacterListResponse::VT_CHARACTERS, characters);
  }
  explicit CharacterListResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CharacterListResponseBuilder &operator=(const CharacterListResponseBuilder &);
  flatbuffers::Offset<CharacterListResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CharacterListResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<CharacterListResponse> CreateCharacterListResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CharacterData>>> characters = 0) {
  CharacterListResponseBuilder builder_(_fbb);
  builder_.add_characters(characters);
  return builder_.Finish();
}

inline flatbuffers::Offset<CharacterListResponse> CreateCharacterListResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<CharacterData>> *characters = nullptr) {
  return LeanPacket::CreateCharacterListResponse(
      _fbb,
      characters ? _fbb.CreateVector<flatbuffers::Offset<CharacterData>>(*characters) : 0);
}

///- HIVE_AUTH_REQUEST ----------
struct HiveAuthRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_APPID = 4,
    VT_PLAYERID = 6,
    VT_PLAYERNAME = 8,
    VT_DID = 10,
    VT_DEVICENAME = 12,
    VT_PROVIDERCOUNT = 14,
    VT_OSVERSION = 16,
    VT_VERSION = 18,
    VT_LANGUAGE = 20,
    VT_PLAYERTOKEN = 22,
    VT_GAMELANGUAGE = 24,
    VT_COUNTRY = 26
  };
  const flatbuffers::String *appId() const {
    return GetPointer<const flatbuffers::String *>(VT_APPID);
  }
  int64_t playerId() const {
    return GetField<int64_t>(VT_PLAYERID, 0);
  }
  const flatbuffers::String *playerName() const {
    return GetPointer<const flatbuffers::String *>(VT_PLAYERNAME);
  }
  const flatbuffers::String *did() const {
    return GetPointer<const flatbuffers::String *>(VT_DID);
  }
  const flatbuffers::String *deviceName() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICENAME);
  }
  int16_t providerCount() const {
    return GetField<int16_t>(VT_PROVIDERCOUNT, 0);
  }
  const flatbuffers::String *osVersion() const {
    return GetPointer<const flatbuffers::String *>(VT_OSVERSION);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::String *language() const {
    return GetPointer<const flatbuffers::String *>(VT_LANGUAGE);
  }
  const flatbuffers::String *playerToken() const {
    return GetPointer<const flatbuffers::String *>(VT_PLAYERTOKEN);
  }
  int16_t gameLanguage() const {
    return GetField<int16_t>(VT_GAMELANGUAGE, 0);
  }
  const flatbuffers::String *country() const {
    return GetPointer<const flatbuffers::String *>(VT_COUNTRY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_APPID) &&
           verifier.VerifyString(appId()) &&
           VerifyField<int64_t>(verifier, VT_PLAYERID) &&
           VerifyOffsetRequired(verifier, VT_PLAYERNAME) &&
           verifier.VerifyString(playerName()) &&
           VerifyOffsetRequired(verifier, VT_DID) &&
           verifier.VerifyString(did()) &&
           VerifyOffset(verifier, VT_DEVICENAME) &&
           verifier.VerifyString(deviceName()) &&
           VerifyField<int16_t>(verifier, VT_PROVIDERCOUNT) &&
           VerifyOffsetRequired(verifier, VT_OSVERSION) &&
           verifier.VerifyString(osVersion()) &&
           VerifyOffsetRequired(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           VerifyOffsetRequired(verifier, VT_LANGUAGE) &&
           verifier.VerifyString(language()) &&
           VerifyOffsetRequired(verifier, VT_PLAYERTOKEN) &&
           verifier.VerifyString(playerToken()) &&
           VerifyField<int16_t>(verifier, VT_GAMELANGUAGE) &&
           VerifyOffsetRequired(verifier, VT_COUNTRY) &&
           verifier.VerifyString(country()) &&
           verifier.EndTable();
  }
};

struct HiveAuthRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_appId(flatbuffers::Offset<flatbuffers::String> appId) {
    fbb_.AddOffset(HiveAuthRequest::VT_APPID, appId);
  }
  void add_playerId(int64_t playerId) {
    fbb_.AddElement<int64_t>(HiveAuthRequest::VT_PLAYERID, playerId, 0);
  }
  void add_playerName(flatbuffers::Offset<flatbuffers::String> playerName) {
    fbb_.AddOffset(HiveAuthRequest::VT_PLAYERNAME, playerName);
  }
  void add_did(flatbuffers::Offset<flatbuffers::String> did) {
    fbb_.AddOffset(HiveAuthRequest::VT_DID, did);
  }
  void add_deviceName(flatbuffers::Offset<flatbuffers::String> deviceName) {
    fbb_.AddOffset(HiveAuthRequest::VT_DEVICENAME, deviceName);
  }
  void add_providerCount(int16_t providerCount) {
    fbb_.AddElement<int16_t>(HiveAuthRequest::VT_PROVIDERCOUNT, providerCount, 0);
  }
  void add_osVersion(flatbuffers::Offset<flatbuffers::String> osVersion) {
    fbb_.AddOffset(HiveAuthRequest::VT_OSVERSION, osVersion);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(HiveAuthRequest::VT_VERSION, version);
  }
  void add_language(flatbuffers::Offset<flatbuffers::String> language) {
    fbb_.AddOffset(HiveAuthRequest::VT_LANGUAGE, language);
  }
  void add_playerToken(flatbuffers::Offset<flatbuffers::String> playerToken) {
    fbb_.AddOffset(HiveAuthRequest::VT_PLAYERTOKEN, playerToken);
  }
  void add_gameLanguage(int16_t gameLanguage) {
    fbb_.AddElement<int16_t>(HiveAuthRequest::VT_GAMELANGUAGE, gameLanguage, 0);
  }
  void add_country(flatbuffers::Offset<flatbuffers::String> country) {
    fbb_.AddOffset(HiveAuthRequest::VT_COUNTRY, country);
  }
  explicit HiveAuthRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HiveAuthRequestBuilder &operator=(const HiveAuthRequestBuilder &);
  flatbuffers::Offset<HiveAuthRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HiveAuthRequest>(end);
    fbb_.Required(o, HiveAuthRequest::VT_APPID);
    fbb_.Required(o, HiveAuthRequest::VT_PLAYERNAME);
    fbb_.Required(o, HiveAuthRequest::VT_DID);
    fbb_.Required(o, HiveAuthRequest::VT_OSVERSION);
    fbb_.Required(o, HiveAuthRequest::VT_VERSION);
    fbb_.Required(o, HiveAuthRequest::VT_LANGUAGE);
    fbb_.Required(o, HiveAuthRequest::VT_PLAYERTOKEN);
    fbb_.Required(o, HiveAuthRequest::VT_COUNTRY);
    return o;
  }
};

inline flatbuffers::Offset<HiveAuthRequest> CreateHiveAuthRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> appId = 0,
    int64_t playerId = 0,
    flatbuffers::Offset<flatbuffers::String> playerName = 0,
    flatbuffers::Offset<flatbuffers::String> did = 0,
    flatbuffers::Offset<flatbuffers::String> deviceName = 0,
    int16_t providerCount = 0,
    flatbuffers::Offset<flatbuffers::String> osVersion = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::String> language = 0,
    flatbuffers::Offset<flatbuffers::String> playerToken = 0,
    int16_t gameLanguage = 0,
    flatbuffers::Offset<flatbuffers::String> country = 0) {
  HiveAuthRequestBuilder builder_(_fbb);
  builder_.add_playerId(playerId);
  builder_.add_country(country);
  builder_.add_playerToken(playerToken);
  builder_.add_language(language);
  builder_.add_version(version);
  builder_.add_osVersion(osVersion);
  builder_.add_deviceName(deviceName);
  builder_.add_did(did);
  builder_.add_playerName(playerName);
  builder_.add_appId(appId);
  builder_.add_gameLanguage(gameLanguage);
  builder_.add_providerCount(providerCount);
  return builder_.Finish();
}

inline flatbuffers::Offset<HiveAuthRequest> CreateHiveAuthRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *appId = nullptr,
    int64_t playerId = 0,
    const char *playerName = nullptr,
    const char *did = nullptr,
    const char *deviceName = nullptr,
    int16_t providerCount = 0,
    const char *osVersion = nullptr,
    const char *version = nullptr,
    const char *language = nullptr,
    const char *playerToken = nullptr,
    int16_t gameLanguage = 0,
    const char *country = nullptr) {
  return LeanPacket::CreateHiveAuthRequest(
      _fbb,
      appId ? _fbb.CreateString(appId) : 0,
      playerId,
      playerName ? _fbb.CreateString(playerName) : 0,
      did ? _fbb.CreateString(did) : 0,
      deviceName ? _fbb.CreateString(deviceName) : 0,
      providerCount,
      osVersion ? _fbb.CreateString(osVersion) : 0,
      version ? _fbb.CreateString(version) : 0,
      language ? _fbb.CreateString(language) : 0,
      playerToken ? _fbb.CreateString(playerToken) : 0,
      gameLanguage,
      country ? _fbb.CreateString(country) : 0);
}

///- HIVE_AUTH_RESPONSE ----------
struct HiveAuthResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_ACCOUNTDBID = 6,
    VT_RECENTLYCOLONYID = 8,
    VT_ADMINLEVEL = 10
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  int64_t accountDbId() const {
    return GetField<int64_t>(VT_ACCOUNTDBID, 0);
  }
  int16_t recentlyColonyId() const {
    return GetField<int16_t>(VT_RECENTLYCOLONYID, 0);
  }
  int32_t adminLevel() const {
    return GetField<int32_t>(VT_ADMINLEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int64_t>(verifier, VT_ACCOUNTDBID) &&
           VerifyField<int16_t>(verifier, VT_RECENTLYCOLONYID) &&
           VerifyField<int32_t>(verifier, VT_ADMINLEVEL) &&
           verifier.EndTable();
  }
};

struct HiveAuthResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(HiveAuthResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_accountDbId(int64_t accountDbId) {
    fbb_.AddElement<int64_t>(HiveAuthResponse::VT_ACCOUNTDBID, accountDbId, 0);
  }
  void add_recentlyColonyId(int16_t recentlyColonyId) {
    fbb_.AddElement<int16_t>(HiveAuthResponse::VT_RECENTLYCOLONYID, recentlyColonyId, 0);
  }
  void add_adminLevel(int32_t adminLevel) {
    fbb_.AddElement<int32_t>(HiveAuthResponse::VT_ADMINLEVEL, adminLevel, 0);
  }
  explicit HiveAuthResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HiveAuthResponseBuilder &operator=(const HiveAuthResponseBuilder &);
  flatbuffers::Offset<HiveAuthResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HiveAuthResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<HiveAuthResponse> CreateHiveAuthResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    int64_t accountDbId = 0,
    int16_t recentlyColonyId = 0,
    int32_t adminLevel = 0) {
  HiveAuthResponseBuilder builder_(_fbb);
  builder_.add_accountDbId(accountDbId);
  builder_.add_adminLevel(adminLevel);
  builder_.add_errorCode(errorCode);
  builder_.add_recentlyColonyId(recentlyColonyId);
  return builder_.Finish();
}

///- SELECT_COLONY_REQUEST --------
struct SelectColonyRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COLONYID = 4
  };
  int16_t colonyId() const {
    return GetField<int16_t>(VT_COLONYID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_COLONYID) &&
           verifier.EndTable();
  }
};

struct SelectColonyRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_colonyId(int16_t colonyId) {
    fbb_.AddElement<int16_t>(SelectColonyRequest::VT_COLONYID, colonyId, 0);
  }
  explicit SelectColonyRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SelectColonyRequestBuilder &operator=(const SelectColonyRequestBuilder &);
  flatbuffers::Offset<SelectColonyRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SelectColonyRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SelectColonyRequest> CreateSelectColonyRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t colonyId = 0) {
  SelectColonyRequestBuilder builder_(_fbb);
  builder_.add_colonyId(colonyId);
  return builder_.Finish();
}

///- SELECT_COLONY_RESPONSE --------
struct SelectColonyResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_COLONYID = 6,
    VT_SERVERLOCALE = 8,
    VT_IP = 10,
    VT_PORT = 12,
    VT_TICKET = 14
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  int16_t colonyId() const {
    return GetField<int16_t>(VT_COLONYID, 0);
  }
  const flatbuffers::String *serverLocale() const {
    return GetPointer<const flatbuffers::String *>(VT_SERVERLOCALE);
  }
  const flatbuffers::String *ip() const {
    return GetPointer<const flatbuffers::String *>(VT_IP);
  }
  int32_t port() const {
    return GetField<int32_t>(VT_PORT, 0);
  }
  const flatbuffers::Vector<uint8_t> *ticket() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_TICKET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int16_t>(verifier, VT_COLONYID) &&
           VerifyOffset(verifier, VT_SERVERLOCALE) &&
           verifier.VerifyString(serverLocale()) &&
           VerifyOffset(verifier, VT_IP) &&
           verifier.VerifyString(ip()) &&
           VerifyField<int32_t>(verifier, VT_PORT) &&
           VerifyOffset(verifier, VT_TICKET) &&
           verifier.VerifyVector(ticket()) &&
           verifier.EndTable();
  }
};

struct SelectColonyResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(SelectColonyResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_colonyId(int16_t colonyId) {
    fbb_.AddElement<int16_t>(SelectColonyResponse::VT_COLONYID, colonyId, 0);
  }
  void add_serverLocale(flatbuffers::Offset<flatbuffers::String> serverLocale) {
    fbb_.AddOffset(SelectColonyResponse::VT_SERVERLOCALE, serverLocale);
  }
  void add_ip(flatbuffers::Offset<flatbuffers::String> ip) {
    fbb_.AddOffset(SelectColonyResponse::VT_IP, ip);
  }
  void add_port(int32_t port) {
    fbb_.AddElement<int32_t>(SelectColonyResponse::VT_PORT, port, 0);
  }
  void add_ticket(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> ticket) {
    fbb_.AddOffset(SelectColonyResponse::VT_TICKET, ticket);
  }
  explicit SelectColonyResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SelectColonyResponseBuilder &operator=(const SelectColonyResponseBuilder &);
  flatbuffers::Offset<SelectColonyResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SelectColonyResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<SelectColonyResponse> CreateSelectColonyResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    int16_t colonyId = 0,
    flatbuffers::Offset<flatbuffers::String> serverLocale = 0,
    flatbuffers::Offset<flatbuffers::String> ip = 0,
    int32_t port = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> ticket = 0) {
  SelectColonyResponseBuilder builder_(_fbb);
  builder_.add_ticket(ticket);
  builder_.add_port(port);
  builder_.add_ip(ip);
  builder_.add_serverLocale(serverLocale);
  builder_.add_errorCode(errorCode);
  builder_.add_colonyId(colonyId);
  return builder_.Finish();
}

inline flatbuffers::Offset<SelectColonyResponse> CreateSelectColonyResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    int16_t colonyId = 0,
    const char *serverLocale = nullptr,
    const char *ip = nullptr,
    int32_t port = 0,
    const std::vector<uint8_t> *ticket = nullptr) {
  return LeanPacket::CreateSelectColonyResponse(
      _fbb,
      errorCode,
      colonyId,
      serverLocale ? _fbb.CreateString(serverLocale) : 0,
      ip ? _fbb.CreateString(ip) : 0,
      port,
      ticket ? _fbb.CreateVector<uint8_t>(*ticket) : 0);
}

///- SELECT_REALM_REQUEST --------
struct SelectRealmRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COLONYID = 4,
    VT_LIMITREALM = 6,
    VT_RECOMMANDREALM = 8
  };
  int16_t colonyId() const {
    return GetField<int16_t>(VT_COLONYID, 0);
  }
  int16_t limitRealm() const {
    return GetField<int16_t>(VT_LIMITREALM, 0);
  }
  int16_t recommandRealm() const {
    return GetField<int16_t>(VT_RECOMMANDREALM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_COLONYID) &&
           VerifyField<int16_t>(verifier, VT_LIMITREALM) &&
           VerifyField<int16_t>(verifier, VT_RECOMMANDREALM) &&
           verifier.EndTable();
  }
};

struct SelectRealmRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_colonyId(int16_t colonyId) {
    fbb_.AddElement<int16_t>(SelectRealmRequest::VT_COLONYID, colonyId, 0);
  }
  void add_limitRealm(int16_t limitRealm) {
    fbb_.AddElement<int16_t>(SelectRealmRequest::VT_LIMITREALM, limitRealm, 0);
  }
  void add_recommandRealm(int16_t recommandRealm) {
    fbb_.AddElement<int16_t>(SelectRealmRequest::VT_RECOMMANDREALM, recommandRealm, 0);
  }
  explicit SelectRealmRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SelectRealmRequestBuilder &operator=(const SelectRealmRequestBuilder &);
  flatbuffers::Offset<SelectRealmRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SelectRealmRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SelectRealmRequest> CreateSelectRealmRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t colonyId = 0,
    int16_t limitRealm = 0,
    int16_t recommandRealm = 0) {
  SelectRealmRequestBuilder builder_(_fbb);
  builder_.add_recommandRealm(recommandRealm);
  builder_.add_limitRealm(limitRealm);
  builder_.add_colonyId(colonyId);
  return builder_.Finish();
}

///- SELECT_REALM_RESPONSE --------
struct SelectRealmResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COLONYID = 4,
    VT_REALM = 6
  };
  int16_t colonyId() const {
    return GetField<int16_t>(VT_COLONYID, 0);
  }
  int32_t realm() const {
    return GetField<int32_t>(VT_REALM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_COLONYID) &&
           VerifyField<int32_t>(verifier, VT_REALM) &&
           verifier.EndTable();
  }
};

struct SelectRealmResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_colonyId(int16_t colonyId) {
    fbb_.AddElement<int16_t>(SelectRealmResponse::VT_COLONYID, colonyId, 0);
  }
  void add_realm(int32_t realm) {
    fbb_.AddElement<int32_t>(SelectRealmResponse::VT_REALM, realm, 0);
  }
  explicit SelectRealmResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SelectRealmResponseBuilder &operator=(const SelectRealmResponseBuilder &);
  flatbuffers::Offset<SelectRealmResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SelectRealmResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<SelectRealmResponse> CreateSelectRealmResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t colonyId = 0,
    int32_t realm = 0) {
  SelectRealmResponseBuilder builder_(_fbb);
  builder_.add_realm(realm);
  builder_.add_colonyId(colonyId);
  return builder_.Finish();
}

///- SELECT_COLONY_BOT_REQUEST --------
struct SelectColonyBotRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COLONYID = 4,
    VT_ENTERREALM = 6
  };
  int16_t colonyId() const {
    return GetField<int16_t>(VT_COLONYID, 0);
  }
  int16_t enterRealm() const {
    return GetField<int16_t>(VT_ENTERREALM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_COLONYID) &&
           VerifyField<int16_t>(verifier, VT_ENTERREALM) &&
           verifier.EndTable();
  }
};

struct SelectColonyBotRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_colonyId(int16_t colonyId) {
    fbb_.AddElement<int16_t>(SelectColonyBotRequest::VT_COLONYID, colonyId, 0);
  }
  void add_enterRealm(int16_t enterRealm) {
    fbb_.AddElement<int16_t>(SelectColonyBotRequest::VT_ENTERREALM, enterRealm, 0);
  }
  explicit SelectColonyBotRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SelectColonyBotRequestBuilder &operator=(const SelectColonyBotRequestBuilder &);
  flatbuffers::Offset<SelectColonyBotRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SelectColonyBotRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SelectColonyBotRequest> CreateSelectColonyBotRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t colonyId = 0,
    int16_t enterRealm = 0) {
  SelectColonyBotRequestBuilder builder_(_fbb);
  builder_.add_enterRealm(enterRealm);
  builder_.add_colonyId(colonyId);
  return builder_.Finish();
}

///- COLONY_WAITING_NOTIFY		-------
struct ColonyWaitingNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COLONYID = 4,
    VT_WAITINGCOUNT = 6
  };
  int16_t colonyId() const {
    return GetField<int16_t>(VT_COLONYID, 0);
  }
  int32_t waitingCount() const {
    return GetField<int32_t>(VT_WAITINGCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_COLONYID) &&
           VerifyField<int32_t>(verifier, VT_WAITINGCOUNT) &&
           verifier.EndTable();
  }
};

struct ColonyWaitingNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_colonyId(int16_t colonyId) {
    fbb_.AddElement<int16_t>(ColonyWaitingNotify::VT_COLONYID, colonyId, 0);
  }
  void add_waitingCount(int32_t waitingCount) {
    fbb_.AddElement<int32_t>(ColonyWaitingNotify::VT_WAITINGCOUNT, waitingCount, 0);
  }
  explicit ColonyWaitingNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ColonyWaitingNotifyBuilder &operator=(const ColonyWaitingNotifyBuilder &);
  flatbuffers::Offset<ColonyWaitingNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ColonyWaitingNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<ColonyWaitingNotify> CreateColonyWaitingNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t colonyId = 0,
    int32_t waitingCount = 0) {
  ColonyWaitingNotifyBuilder builder_(_fbb);
  builder_.add_waitingCount(waitingCount);
  builder_.add_colonyId(colonyId);
  return builder_.Finish();
}

///- INQUIRE_WAITING_REQUEST	-------
struct InquireWaitingRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct InquireWaitingRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit InquireWaitingRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InquireWaitingRequestBuilder &operator=(const InquireWaitingRequestBuilder &);
  flatbuffers::Offset<InquireWaitingRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InquireWaitingRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<InquireWaitingRequest> CreateInquireWaitingRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  InquireWaitingRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

///- INQUIRE_WAITING_RESPONSE	-------
struct InquireWaitingResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERROR = 4,
    VT_COLONYID = 6,
    VT_WAITINGCOUNT = 8
  };
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  int16_t colonyId() const {
    return GetField<int16_t>(VT_COLONYID, 0);
  }
  int32_t waitingCount() const {
    return GetField<int32_t>(VT_WAITINGCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           VerifyField<int16_t>(verifier, VT_COLONYID) &&
           VerifyField<int32_t>(verifier, VT_WAITINGCOUNT) &&
           verifier.EndTable();
  }
};

struct InquireWaitingResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(InquireWaitingResponse::VT_ERROR, error, 0);
  }
  void add_colonyId(int16_t colonyId) {
    fbb_.AddElement<int16_t>(InquireWaitingResponse::VT_COLONYID, colonyId, 0);
  }
  void add_waitingCount(int32_t waitingCount) {
    fbb_.AddElement<int32_t>(InquireWaitingResponse::VT_WAITINGCOUNT, waitingCount, 0);
  }
  explicit InquireWaitingResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InquireWaitingResponseBuilder &operator=(const InquireWaitingResponseBuilder &);
  flatbuffers::Offset<InquireWaitingResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InquireWaitingResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<InquireWaitingResponse> CreateInquireWaitingResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t error = 0,
    int16_t colonyId = 0,
    int32_t waitingCount = 0) {
  InquireWaitingResponseBuilder builder_(_fbb);
  builder_.add_waitingCount(waitingCount);
  builder_.add_error(error);
  builder_.add_colonyId(colonyId);
  return builder_.Finish();
}

///- CANCEL_WAITING_REQUEST		-------
struct CancelWaitingRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CancelWaitingRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CancelWaitingRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CancelWaitingRequestBuilder &operator=(const CancelWaitingRequestBuilder &);
  flatbuffers::Offset<CancelWaitingRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CancelWaitingRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<CancelWaitingRequest> CreateCancelWaitingRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CancelWaitingRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

///- CANCEL_WAITING_RESPONSE	-------
struct CancelWaitingResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           verifier.EndTable();
  }
};

struct CancelWaitingResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(CancelWaitingResponse::VT_ERRORCODE, errorCode, 0);
  }
  explicit CancelWaitingResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CancelWaitingResponseBuilder &operator=(const CancelWaitingResponseBuilder &);
  flatbuffers::Offset<CancelWaitingResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CancelWaitingResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<CancelWaitingResponse> CreateCancelWaitingResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0) {
  CancelWaitingResponseBuilder builder_(_fbb);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

///-----------------------------------------------------------------------------
/// Common
///-----------------------------------------------------------------------------
///- STRING_MESSAGE_NOTIFY ----------
struct StringMessageNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MESSAGE = 4
  };
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct StringMessageNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(StringMessageNotify::VT_MESSAGE, message);
  }
  explicit StringMessageNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StringMessageNotifyBuilder &operator=(const StringMessageNotifyBuilder &);
  flatbuffers::Offset<StringMessageNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StringMessageNotify>(end);
    fbb_.Required(o, StringMessageNotify::VT_MESSAGE);
    return o;
  }
};

inline flatbuffers::Offset<StringMessageNotify> CreateStringMessageNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  StringMessageNotifyBuilder builder_(_fbb);
  builder_.add_message(message);
  return builder_.Finish();
}

inline flatbuffers::Offset<StringMessageNotify> CreateStringMessageNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *message = nullptr) {
  return LeanPacket::CreateStringMessageNotify(
      _fbb,
      message ? _fbb.CreateString(message) : 0);
}

///- USER_KICK_NOTIFY -------------
struct UserKickNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TARGET = 4,
    VT_REASON = 6
  };
  int64_t target() const {
    return GetField<int64_t>(VT_TARGET, 0);
  }
  int32_t reason() const {
    return GetField<int32_t>(VT_REASON, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TARGET) &&
           VerifyField<int32_t>(verifier, VT_REASON) &&
           verifier.EndTable();
  }
};

struct UserKickNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_target(int64_t target) {
    fbb_.AddElement<int64_t>(UserKickNotify::VT_TARGET, target, 0);
  }
  void add_reason(int32_t reason) {
    fbb_.AddElement<int32_t>(UserKickNotify::VT_REASON, reason, 0);
  }
  explicit UserKickNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UserKickNotifyBuilder &operator=(const UserKickNotifyBuilder &);
  flatbuffers::Offset<UserKickNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UserKickNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<UserKickNotify> CreateUserKickNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t target = 0,
    int32_t reason = 0) {
  UserKickNotifyBuilder builder_(_fbb);
  builder_.add_target(target);
  builder_.add_reason(reason);
  return builder_.Finish();
}

///- PC_LOGIN_DATA_NOTIFY : ItemPartsInfo ----------
struct ItemPartsInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMID = 4,
    VT_GRADE = 6,
    VT_LEVEL = 8,
    VT_TRANSCENDLEVEL = 10
  };
  int32_t itemId() const {
    return GetField<int32_t>(VT_ITEMID, 0);
  }
  int16_t grade() const {
    return GetField<int16_t>(VT_GRADE, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int16_t transcendLevel() const {
    return GetField<int16_t>(VT_TRANSCENDLEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ITEMID) &&
           VerifyField<int16_t>(verifier, VT_GRADE) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int16_t>(verifier, VT_TRANSCENDLEVEL) &&
           verifier.EndTable();
  }
};

struct ItemPartsInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemId(int32_t itemId) {
    fbb_.AddElement<int32_t>(ItemPartsInfo::VT_ITEMID, itemId, 0);
  }
  void add_grade(int16_t grade) {
    fbb_.AddElement<int16_t>(ItemPartsInfo::VT_GRADE, grade, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(ItemPartsInfo::VT_LEVEL, level, 0);
  }
  void add_transcendLevel(int16_t transcendLevel) {
    fbb_.AddElement<int16_t>(ItemPartsInfo::VT_TRANSCENDLEVEL, transcendLevel, 0);
  }
  explicit ItemPartsInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ItemPartsInfoBuilder &operator=(const ItemPartsInfoBuilder &);
  flatbuffers::Offset<ItemPartsInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ItemPartsInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ItemPartsInfo> CreateItemPartsInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t itemId = 0,
    int16_t grade = 0,
    int32_t level = 0,
    int16_t transcendLevel = 0) {
  ItemPartsInfoBuilder builder_(_fbb);
  builder_.add_level(level);
  builder_.add_itemId(itemId);
  builder_.add_transcendLevel(transcendLevel);
  builder_.add_grade(grade);
  return builder_.Finish();
}

struct CostumePartsInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMID = 4,
    VT_GRADE = 6,
    VT_LEVEL = 8,
    VT_ISVISIBLE = 10,
    VT_TRANSCENDLEVEL = 12
  };
  int32_t itemId() const {
    return GetField<int32_t>(VT_ITEMID, 0);
  }
  int16_t grade() const {
    return GetField<int16_t>(VT_GRADE, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  bool isVisible() const {
    return GetField<uint8_t>(VT_ISVISIBLE, 0) != 0;
  }
  int16_t transcendLevel() const {
    return GetField<int16_t>(VT_TRANSCENDLEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ITEMID) &&
           VerifyField<int16_t>(verifier, VT_GRADE) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<uint8_t>(verifier, VT_ISVISIBLE) &&
           VerifyField<int16_t>(verifier, VT_TRANSCENDLEVEL) &&
           verifier.EndTable();
  }
};

struct CostumePartsInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemId(int32_t itemId) {
    fbb_.AddElement<int32_t>(CostumePartsInfo::VT_ITEMID, itemId, 0);
  }
  void add_grade(int16_t grade) {
    fbb_.AddElement<int16_t>(CostumePartsInfo::VT_GRADE, grade, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(CostumePartsInfo::VT_LEVEL, level, 0);
  }
  void add_isVisible(bool isVisible) {
    fbb_.AddElement<uint8_t>(CostumePartsInfo::VT_ISVISIBLE, static_cast<uint8_t>(isVisible), 0);
  }
  void add_transcendLevel(int16_t transcendLevel) {
    fbb_.AddElement<int16_t>(CostumePartsInfo::VT_TRANSCENDLEVEL, transcendLevel, 0);
  }
  explicit CostumePartsInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CostumePartsInfoBuilder &operator=(const CostumePartsInfoBuilder &);
  flatbuffers::Offset<CostumePartsInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CostumePartsInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<CostumePartsInfo> CreateCostumePartsInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t itemId = 0,
    int16_t grade = 0,
    int32_t level = 0,
    bool isVisible = false,
    int16_t transcendLevel = 0) {
  CostumePartsInfoBuilder builder_(_fbb);
  builder_.add_level(level);
  builder_.add_itemId(itemId);
  builder_.add_transcendLevel(transcendLevel);
  builder_.add_grade(grade);
  builder_.add_isVisible(isVisible);
  return builder_.Finish();
}

///-----------------------------------------------------------------------------
/// Client <-> Agent
///-----------------------------------------------------------------------------
///- ACCOUNT_LOGIN_REQUEST ----------
struct AccountLoginRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCOUNTID = 4,
    VT_ACCOUNT = 6,
    VT_TICKET = 8
  };
  int64_t accountId() const {
    return GetField<int64_t>(VT_ACCOUNTID, 0);
  }
  const flatbuffers::String *account() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNT);
  }
  const flatbuffers::Vector<uint8_t> *ticket() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_TICKET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ACCOUNTID) &&
           VerifyOffsetRequired(verifier, VT_ACCOUNT) &&
           verifier.VerifyString(account()) &&
           VerifyOffsetRequired(verifier, VT_TICKET) &&
           verifier.VerifyVector(ticket()) &&
           verifier.EndTable();
  }
};

struct AccountLoginRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accountId(int64_t accountId) {
    fbb_.AddElement<int64_t>(AccountLoginRequest::VT_ACCOUNTID, accountId, 0);
  }
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(AccountLoginRequest::VT_ACCOUNT, account);
  }
  void add_ticket(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> ticket) {
    fbb_.AddOffset(AccountLoginRequest::VT_TICKET, ticket);
  }
  explicit AccountLoginRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AccountLoginRequestBuilder &operator=(const AccountLoginRequestBuilder &);
  flatbuffers::Offset<AccountLoginRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AccountLoginRequest>(end);
    fbb_.Required(o, AccountLoginRequest::VT_ACCOUNT);
    fbb_.Required(o, AccountLoginRequest::VT_TICKET);
    return o;
  }
};

inline flatbuffers::Offset<AccountLoginRequest> CreateAccountLoginRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t accountId = 0,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> ticket = 0) {
  AccountLoginRequestBuilder builder_(_fbb);
  builder_.add_accountId(accountId);
  builder_.add_ticket(ticket);
  builder_.add_account(account);
  return builder_.Finish();
}

inline flatbuffers::Offset<AccountLoginRequest> CreateAccountLoginRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t accountId = 0,
    const char *account = nullptr,
    const std::vector<uint8_t> *ticket = nullptr) {
  return LeanPacket::CreateAccountLoginRequest(
      _fbb,
      accountId,
      account ? _fbb.CreateString(account) : 0,
      ticket ? _fbb.CreateVector<uint8_t>(*ticket) : 0);
}

///- ACCOUNT_LOGIN_RESPONSE ----------
struct AccountLoginResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_REALM = 6,
    VT_RECONNECTTICKET = 8
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  int32_t realm() const {
    return GetField<int32_t>(VT_REALM, 0);
  }
  const flatbuffers::Vector<uint8_t> *reconnectTicket() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_RECONNECTTICKET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int32_t>(verifier, VT_REALM) &&
           VerifyOffset(verifier, VT_RECONNECTTICKET) &&
           verifier.VerifyVector(reconnectTicket()) &&
           verifier.EndTable();
  }
};

struct AccountLoginResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(AccountLoginResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_realm(int32_t realm) {
    fbb_.AddElement<int32_t>(AccountLoginResponse::VT_REALM, realm, 0);
  }
  void add_reconnectTicket(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> reconnectTicket) {
    fbb_.AddOffset(AccountLoginResponse::VT_RECONNECTTICKET, reconnectTicket);
  }
  explicit AccountLoginResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AccountLoginResponseBuilder &operator=(const AccountLoginResponseBuilder &);
  flatbuffers::Offset<AccountLoginResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AccountLoginResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<AccountLoginResponse> CreateAccountLoginResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    int32_t realm = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> reconnectTicket = 0) {
  AccountLoginResponseBuilder builder_(_fbb);
  builder_.add_reconnectTicket(reconnectTicket);
  builder_.add_realm(realm);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

inline flatbuffers::Offset<AccountLoginResponse> CreateAccountLoginResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    int32_t realm = 0,
    const std::vector<uint8_t> *reconnectTicket = nullptr) {
  return LeanPacket::CreateAccountLoginResponse(
      _fbb,
      errorCode,
      realm,
      reconnectTicket ? _fbb.CreateVector<uint8_t>(*reconnectTicket) : 0);
}

/// SERVER_LOCAL_TIME_NOTIFY				= 2004,	// 서버의 로컬타임
struct ServerLocalTimeNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_YEAR = 4,
    VT_MONTH = 6,
    VT_DAY = 8,
    VT_HOUR = 10,
    VT_MINUTE = 12,
    VT_SECOND = 14,
    VT_MILLISECOND = 16,
    VT_UTCOFFSETMILLISECOND = 18
  };
  int16_t year() const {
    return GetField<int16_t>(VT_YEAR, 0);
  }
  int16_t month() const {
    return GetField<int16_t>(VT_MONTH, 0);
  }
  int16_t day() const {
    return GetField<int16_t>(VT_DAY, 0);
  }
  int16_t hour() const {
    return GetField<int16_t>(VT_HOUR, 0);
  }
  int16_t minute() const {
    return GetField<int16_t>(VT_MINUTE, 0);
  }
  int16_t second() const {
    return GetField<int16_t>(VT_SECOND, 0);
  }
  int16_t millisecond() const {
    return GetField<int16_t>(VT_MILLISECOND, 0);
  }
  int64_t utcOffsetMillisecond() const {
    return GetField<int64_t>(VT_UTCOFFSETMILLISECOND, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_YEAR) &&
           VerifyField<int16_t>(verifier, VT_MONTH) &&
           VerifyField<int16_t>(verifier, VT_DAY) &&
           VerifyField<int16_t>(verifier, VT_HOUR) &&
           VerifyField<int16_t>(verifier, VT_MINUTE) &&
           VerifyField<int16_t>(verifier, VT_SECOND) &&
           VerifyField<int16_t>(verifier, VT_MILLISECOND) &&
           VerifyField<int64_t>(verifier, VT_UTCOFFSETMILLISECOND) &&
           verifier.EndTable();
  }
};

struct ServerLocalTimeNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_year(int16_t year) {
    fbb_.AddElement<int16_t>(ServerLocalTimeNotify::VT_YEAR, year, 0);
  }
  void add_month(int16_t month) {
    fbb_.AddElement<int16_t>(ServerLocalTimeNotify::VT_MONTH, month, 0);
  }
  void add_day(int16_t day) {
    fbb_.AddElement<int16_t>(ServerLocalTimeNotify::VT_DAY, day, 0);
  }
  void add_hour(int16_t hour) {
    fbb_.AddElement<int16_t>(ServerLocalTimeNotify::VT_HOUR, hour, 0);
  }
  void add_minute(int16_t minute) {
    fbb_.AddElement<int16_t>(ServerLocalTimeNotify::VT_MINUTE, minute, 0);
  }
  void add_second(int16_t second) {
    fbb_.AddElement<int16_t>(ServerLocalTimeNotify::VT_SECOND, second, 0);
  }
  void add_millisecond(int16_t millisecond) {
    fbb_.AddElement<int16_t>(ServerLocalTimeNotify::VT_MILLISECOND, millisecond, 0);
  }
  void add_utcOffsetMillisecond(int64_t utcOffsetMillisecond) {
    fbb_.AddElement<int64_t>(ServerLocalTimeNotify::VT_UTCOFFSETMILLISECOND, utcOffsetMillisecond, 0);
  }
  explicit ServerLocalTimeNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerLocalTimeNotifyBuilder &operator=(const ServerLocalTimeNotifyBuilder &);
  flatbuffers::Offset<ServerLocalTimeNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerLocalTimeNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerLocalTimeNotify> CreateServerLocalTimeNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t year = 0,
    int16_t month = 0,
    int16_t day = 0,
    int16_t hour = 0,
    int16_t minute = 0,
    int16_t second = 0,
    int16_t millisecond = 0,
    int64_t utcOffsetMillisecond = 0) {
  ServerLocalTimeNotifyBuilder builder_(_fbb);
  builder_.add_utcOffsetMillisecond(utcOffsetMillisecond);
  builder_.add_millisecond(millisecond);
  builder_.add_second(second);
  builder_.add_minute(minute);
  builder_.add_hour(hour);
  builder_.add_day(day);
  builder_.add_month(month);
  builder_.add_year(year);
  return builder_.Finish();
}

/// DEVICE_PERFORMANCE_POINT_NOTIFY
struct DevicePerformancePointNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PERFORMANCEPOINT = 4
  };
  int64_t performancePoint() const {
    return GetField<int64_t>(VT_PERFORMANCEPOINT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PERFORMANCEPOINT) &&
           verifier.EndTable();
  }
};

struct DevicePerformancePointNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_performancePoint(int64_t performancePoint) {
    fbb_.AddElement<int64_t>(DevicePerformancePointNotify::VT_PERFORMANCEPOINT, performancePoint, 0);
  }
  explicit DevicePerformancePointNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DevicePerformancePointNotifyBuilder &operator=(const DevicePerformancePointNotifyBuilder &);
  flatbuffers::Offset<DevicePerformancePointNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DevicePerformancePointNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<DevicePerformancePointNotify> CreateDevicePerformancePointNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t performancePoint = 0) {
  DevicePerformancePointNotifyBuilder builder_(_fbb);
  builder_.add_performancePoint(performancePoint);
  return builder_.Finish();
}

/// SEASON_INFO_NOTIFY
struct SeasonInfoNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SEASONNUMBER = 4,
    VT_SEASONFLAG = 6,
    VT_LEADERGUILDNAME = 8,
    VT_LEADERGUILDCREST = 10
  };
  int32_t seasonNumber() const {
    return GetField<int32_t>(VT_SEASONNUMBER, 0);
  }
  int32_t seasonFlag() const {
    return GetField<int32_t>(VT_SEASONFLAG, 0);
  }
  const flatbuffers::String *leaderGuildName() const {
    return GetPointer<const flatbuffers::String *>(VT_LEADERGUILDNAME);
  }
  const GuildCrest *leaderGuildCrest() const {
    return GetPointer<const GuildCrest *>(VT_LEADERGUILDCREST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SEASONNUMBER) &&
           VerifyField<int32_t>(verifier, VT_SEASONFLAG) &&
           VerifyOffset(verifier, VT_LEADERGUILDNAME) &&
           verifier.VerifyString(leaderGuildName()) &&
           VerifyOffset(verifier, VT_LEADERGUILDCREST) &&
           verifier.VerifyTable(leaderGuildCrest()) &&
           verifier.EndTable();
  }
};

struct SeasonInfoNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_seasonNumber(int32_t seasonNumber) {
    fbb_.AddElement<int32_t>(SeasonInfoNotify::VT_SEASONNUMBER, seasonNumber, 0);
  }
  void add_seasonFlag(int32_t seasonFlag) {
    fbb_.AddElement<int32_t>(SeasonInfoNotify::VT_SEASONFLAG, seasonFlag, 0);
  }
  void add_leaderGuildName(flatbuffers::Offset<flatbuffers::String> leaderGuildName) {
    fbb_.AddOffset(SeasonInfoNotify::VT_LEADERGUILDNAME, leaderGuildName);
  }
  void add_leaderGuildCrest(flatbuffers::Offset<GuildCrest> leaderGuildCrest) {
    fbb_.AddOffset(SeasonInfoNotify::VT_LEADERGUILDCREST, leaderGuildCrest);
  }
  explicit SeasonInfoNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SeasonInfoNotifyBuilder &operator=(const SeasonInfoNotifyBuilder &);
  flatbuffers::Offset<SeasonInfoNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SeasonInfoNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<SeasonInfoNotify> CreateSeasonInfoNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t seasonNumber = 0,
    int32_t seasonFlag = 0,
    flatbuffers::Offset<flatbuffers::String> leaderGuildName = 0,
    flatbuffers::Offset<GuildCrest> leaderGuildCrest = 0) {
  SeasonInfoNotifyBuilder builder_(_fbb);
  builder_.add_leaderGuildCrest(leaderGuildCrest);
  builder_.add_leaderGuildName(leaderGuildName);
  builder_.add_seasonFlag(seasonFlag);
  builder_.add_seasonNumber(seasonNumber);
  return builder_.Finish();
}

inline flatbuffers::Offset<SeasonInfoNotify> CreateSeasonInfoNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t seasonNumber = 0,
    int32_t seasonFlag = 0,
    const char *leaderGuildName = nullptr,
    flatbuffers::Offset<GuildCrest> leaderGuildCrest = 0) {
  return LeanPacket::CreateSeasonInfoNotify(
      _fbb,
      seasonNumber,
      seasonFlag,
      leaderGuildName ? _fbb.CreateString(leaderGuildName) : 0,
      leaderGuildCrest);
}

/// SERVER_LOCAL_TIME_REQUEST
struct ServerLocalTimeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ServerLocalTimeRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ServerLocalTimeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerLocalTimeRequestBuilder &operator=(const ServerLocalTimeRequestBuilder &);
  flatbuffers::Offset<ServerLocalTimeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerLocalTimeRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerLocalTimeRequest> CreateServerLocalTimeRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ServerLocalTimeRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// SERVER_LOCAL_TIME_RESPONSE 
struct ServerLocalTimeResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_YEAR = 4,
    VT_MONTH = 6,
    VT_DAY = 8,
    VT_HOUR = 10,
    VT_MINUTE = 12,
    VT_SECOND = 14,
    VT_MILLISECOND = 16,
    VT_UTCOFFSETMILLISECOND = 18
  };
  int16_t year() const {
    return GetField<int16_t>(VT_YEAR, 0);
  }
  int16_t month() const {
    return GetField<int16_t>(VT_MONTH, 0);
  }
  int16_t day() const {
    return GetField<int16_t>(VT_DAY, 0);
  }
  int16_t hour() const {
    return GetField<int16_t>(VT_HOUR, 0);
  }
  int16_t minute() const {
    return GetField<int16_t>(VT_MINUTE, 0);
  }
  int16_t second() const {
    return GetField<int16_t>(VT_SECOND, 0);
  }
  int16_t millisecond() const {
    return GetField<int16_t>(VT_MILLISECOND, 0);
  }
  int64_t utcOffsetMillisecond() const {
    return GetField<int64_t>(VT_UTCOFFSETMILLISECOND, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_YEAR) &&
           VerifyField<int16_t>(verifier, VT_MONTH) &&
           VerifyField<int16_t>(verifier, VT_DAY) &&
           VerifyField<int16_t>(verifier, VT_HOUR) &&
           VerifyField<int16_t>(verifier, VT_MINUTE) &&
           VerifyField<int16_t>(verifier, VT_SECOND) &&
           VerifyField<int16_t>(verifier, VT_MILLISECOND) &&
           VerifyField<int64_t>(verifier, VT_UTCOFFSETMILLISECOND) &&
           verifier.EndTable();
  }
};

struct ServerLocalTimeResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_year(int16_t year) {
    fbb_.AddElement<int16_t>(ServerLocalTimeResponse::VT_YEAR, year, 0);
  }
  void add_month(int16_t month) {
    fbb_.AddElement<int16_t>(ServerLocalTimeResponse::VT_MONTH, month, 0);
  }
  void add_day(int16_t day) {
    fbb_.AddElement<int16_t>(ServerLocalTimeResponse::VT_DAY, day, 0);
  }
  void add_hour(int16_t hour) {
    fbb_.AddElement<int16_t>(ServerLocalTimeResponse::VT_HOUR, hour, 0);
  }
  void add_minute(int16_t minute) {
    fbb_.AddElement<int16_t>(ServerLocalTimeResponse::VT_MINUTE, minute, 0);
  }
  void add_second(int16_t second) {
    fbb_.AddElement<int16_t>(ServerLocalTimeResponse::VT_SECOND, second, 0);
  }
  void add_millisecond(int16_t millisecond) {
    fbb_.AddElement<int16_t>(ServerLocalTimeResponse::VT_MILLISECOND, millisecond, 0);
  }
  void add_utcOffsetMillisecond(int64_t utcOffsetMillisecond) {
    fbb_.AddElement<int64_t>(ServerLocalTimeResponse::VT_UTCOFFSETMILLISECOND, utcOffsetMillisecond, 0);
  }
  explicit ServerLocalTimeResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerLocalTimeResponseBuilder &operator=(const ServerLocalTimeResponseBuilder &);
  flatbuffers::Offset<ServerLocalTimeResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerLocalTimeResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerLocalTimeResponse> CreateServerLocalTimeResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t year = 0,
    int16_t month = 0,
    int16_t day = 0,
    int16_t hour = 0,
    int16_t minute = 0,
    int16_t second = 0,
    int16_t millisecond = 0,
    int64_t utcOffsetMillisecond = 0) {
  ServerLocalTimeResponseBuilder builder_(_fbb);
  builder_.add_utcOffsetMillisecond(utcOffsetMillisecond);
  builder_.add_millisecond(millisecond);
  builder_.add_second(second);
  builder_.add_minute(minute);
  builder_.add_hour(hour);
  builder_.add_day(day);
  builder_.add_month(month);
  builder_.add_year(year);
  return builder_.Finish();
}

///- SLOT_LIST_REQUEST ----------
struct SlotListRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SlotListRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SlotListRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SlotListRequestBuilder &operator=(const SlotListRequestBuilder &);
  flatbuffers::Offset<SlotListRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SlotListRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SlotListRequest> CreateSlotListRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SlotListRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

///- SLOT_LIST_RESPONSE : PCSlotData ----------
struct PCSlotData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJID = 4,
    VT_NAME = 6,
    VT_CUSTOMIZINGINFO = 8,
    VT_CLASSTYPE = 10,
    VT_LEVEL = 12,
    VT_EXP = 14,
    VT_INFLUENCESCORE = 16,
    VT_INFLUENCETIER = 18,
    VT_INFLUENCELEV = 20,
    VT_COMBATPOWER = 22,
    VT_ITEMPARTS = 24,
    VT_COSTUMEPARTS = 26,
    VT_LOGOUTTIME = 28,
    VT_PCGUILDINFO = 30,
    VT_GUILDRANK = 32,
    VT_DELETEEXPIRE = 34,
    VT_ISRENAME = 36,
    VT_ISTUTORIAL = 38
  };
  int64_t objId() const {
    return GetField<int64_t>(VT_OBJID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const CustomizeInfo *customizingInfo() const {
    return GetPointer<const CustomizeInfo *>(VT_CUSTOMIZINGINFO);
  }
  int32_t classType() const {
    return GetField<int32_t>(VT_CLASSTYPE, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int32_t exp() const {
    return GetField<int32_t>(VT_EXP, 0);
  }
  int64_t influenceScore() const {
    return GetField<int64_t>(VT_INFLUENCESCORE, 0);
  }
  int16_t influenceTier() const {
    return GetField<int16_t>(VT_INFLUENCETIER, 0);
  }
  int16_t influenceLev() const {
    return GetField<int16_t>(VT_INFLUENCELEV, 0);
  }
  int32_t combatpower() const {
    return GetField<int32_t>(VT_COMBATPOWER, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ItemPartsInfo>> *itemParts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ItemPartsInfo>> *>(VT_ITEMPARTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<CostumePartsInfo>> *costumeParts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CostumePartsInfo>> *>(VT_COSTUMEPARTS);
  }
  int64_t logoutTime() const {
    return GetField<int64_t>(VT_LOGOUTTIME, 0);
  }
  const PcGuildInfo *pcGuildInfo() const {
    return GetPointer<const PcGuildInfo *>(VT_PCGUILDINFO);
  }
  int32_t guildRank() const {
    return GetField<int32_t>(VT_GUILDRANK, 0);
  }
  int32_t deleteExpire() const {
    return GetField<int32_t>(VT_DELETEEXPIRE, 0);
  }
  bool isRename() const {
    return GetField<uint8_t>(VT_ISRENAME, 0) != 0;
  }
  bool isTutorial() const {
    return GetField<uint8_t>(VT_ISTUTORIAL, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJID) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_CUSTOMIZINGINFO) &&
           verifier.VerifyTable(customizingInfo()) &&
           VerifyField<int32_t>(verifier, VT_CLASSTYPE) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_EXP) &&
           VerifyField<int64_t>(verifier, VT_INFLUENCESCORE) &&
           VerifyField<int16_t>(verifier, VT_INFLUENCETIER) &&
           VerifyField<int16_t>(verifier, VT_INFLUENCELEV) &&
           VerifyField<int32_t>(verifier, VT_COMBATPOWER) &&
           VerifyOffsetRequired(verifier, VT_ITEMPARTS) &&
           verifier.VerifyVector(itemParts()) &&
           verifier.VerifyVectorOfTables(itemParts()) &&
           VerifyOffsetRequired(verifier, VT_COSTUMEPARTS) &&
           verifier.VerifyVector(costumeParts()) &&
           verifier.VerifyVectorOfTables(costumeParts()) &&
           VerifyField<int64_t>(verifier, VT_LOGOUTTIME) &&
           VerifyOffset(verifier, VT_PCGUILDINFO) &&
           verifier.VerifyTable(pcGuildInfo()) &&
           VerifyField<int32_t>(verifier, VT_GUILDRANK) &&
           VerifyField<int32_t>(verifier, VT_DELETEEXPIRE) &&
           VerifyField<uint8_t>(verifier, VT_ISRENAME) &&
           VerifyField<uint8_t>(verifier, VT_ISTUTORIAL) &&
           verifier.EndTable();
  }
};

struct PCSlotDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objId(int64_t objId) {
    fbb_.AddElement<int64_t>(PCSlotData::VT_OBJID, objId, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(PCSlotData::VT_NAME, name);
  }
  void add_customizingInfo(flatbuffers::Offset<CustomizeInfo> customizingInfo) {
    fbb_.AddOffset(PCSlotData::VT_CUSTOMIZINGINFO, customizingInfo);
  }
  void add_classType(int32_t classType) {
    fbb_.AddElement<int32_t>(PCSlotData::VT_CLASSTYPE, classType, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(PCSlotData::VT_LEVEL, level, 0);
  }
  void add_exp(int32_t exp) {
    fbb_.AddElement<int32_t>(PCSlotData::VT_EXP, exp, 0);
  }
  void add_influenceScore(int64_t influenceScore) {
    fbb_.AddElement<int64_t>(PCSlotData::VT_INFLUENCESCORE, influenceScore, 0);
  }
  void add_influenceTier(int16_t influenceTier) {
    fbb_.AddElement<int16_t>(PCSlotData::VT_INFLUENCETIER, influenceTier, 0);
  }
  void add_influenceLev(int16_t influenceLev) {
    fbb_.AddElement<int16_t>(PCSlotData::VT_INFLUENCELEV, influenceLev, 0);
  }
  void add_combatpower(int32_t combatpower) {
    fbb_.AddElement<int32_t>(PCSlotData::VT_COMBATPOWER, combatpower, 0);
  }
  void add_itemParts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ItemPartsInfo>>> itemParts) {
    fbb_.AddOffset(PCSlotData::VT_ITEMPARTS, itemParts);
  }
  void add_costumeParts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CostumePartsInfo>>> costumeParts) {
    fbb_.AddOffset(PCSlotData::VT_COSTUMEPARTS, costumeParts);
  }
  void add_logoutTime(int64_t logoutTime) {
    fbb_.AddElement<int64_t>(PCSlotData::VT_LOGOUTTIME, logoutTime, 0);
  }
  void add_pcGuildInfo(flatbuffers::Offset<PcGuildInfo> pcGuildInfo) {
    fbb_.AddOffset(PCSlotData::VT_PCGUILDINFO, pcGuildInfo);
  }
  void add_guildRank(int32_t guildRank) {
    fbb_.AddElement<int32_t>(PCSlotData::VT_GUILDRANK, guildRank, 0);
  }
  void add_deleteExpire(int32_t deleteExpire) {
    fbb_.AddElement<int32_t>(PCSlotData::VT_DELETEEXPIRE, deleteExpire, 0);
  }
  void add_isRename(bool isRename) {
    fbb_.AddElement<uint8_t>(PCSlotData::VT_ISRENAME, static_cast<uint8_t>(isRename), 0);
  }
  void add_isTutorial(bool isTutorial) {
    fbb_.AddElement<uint8_t>(PCSlotData::VT_ISTUTORIAL, static_cast<uint8_t>(isTutorial), 0);
  }
  explicit PCSlotDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PCSlotDataBuilder &operator=(const PCSlotDataBuilder &);
  flatbuffers::Offset<PCSlotData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PCSlotData>(end);
    fbb_.Required(o, PCSlotData::VT_NAME);
    fbb_.Required(o, PCSlotData::VT_CUSTOMIZINGINFO);
    fbb_.Required(o, PCSlotData::VT_ITEMPARTS);
    fbb_.Required(o, PCSlotData::VT_COSTUMEPARTS);
    return o;
  }
};

inline flatbuffers::Offset<PCSlotData> CreatePCSlotData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objId = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<CustomizeInfo> customizingInfo = 0,
    int32_t classType = 0,
    int32_t level = 0,
    int32_t exp = 0,
    int64_t influenceScore = 0,
    int16_t influenceTier = 0,
    int16_t influenceLev = 0,
    int32_t combatpower = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ItemPartsInfo>>> itemParts = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CostumePartsInfo>>> costumeParts = 0,
    int64_t logoutTime = 0,
    flatbuffers::Offset<PcGuildInfo> pcGuildInfo = 0,
    int32_t guildRank = 0,
    int32_t deleteExpire = 0,
    bool isRename = false,
    bool isTutorial = false) {
  PCSlotDataBuilder builder_(_fbb);
  builder_.add_logoutTime(logoutTime);
  builder_.add_influenceScore(influenceScore);
  builder_.add_objId(objId);
  builder_.add_deleteExpire(deleteExpire);
  builder_.add_guildRank(guildRank);
  builder_.add_pcGuildInfo(pcGuildInfo);
  builder_.add_costumeParts(costumeParts);
  builder_.add_itemParts(itemParts);
  builder_.add_combatpower(combatpower);
  builder_.add_exp(exp);
  builder_.add_level(level);
  builder_.add_classType(classType);
  builder_.add_customizingInfo(customizingInfo);
  builder_.add_name(name);
  builder_.add_influenceLev(influenceLev);
  builder_.add_influenceTier(influenceTier);
  builder_.add_isTutorial(isTutorial);
  builder_.add_isRename(isRename);
  return builder_.Finish();
}

inline flatbuffers::Offset<PCSlotData> CreatePCSlotDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objId = 0,
    const char *name = nullptr,
    flatbuffers::Offset<CustomizeInfo> customizingInfo = 0,
    int32_t classType = 0,
    int32_t level = 0,
    int32_t exp = 0,
    int64_t influenceScore = 0,
    int16_t influenceTier = 0,
    int16_t influenceLev = 0,
    int32_t combatpower = 0,
    const std::vector<flatbuffers::Offset<ItemPartsInfo>> *itemParts = nullptr,
    const std::vector<flatbuffers::Offset<CostumePartsInfo>> *costumeParts = nullptr,
    int64_t logoutTime = 0,
    flatbuffers::Offset<PcGuildInfo> pcGuildInfo = 0,
    int32_t guildRank = 0,
    int32_t deleteExpire = 0,
    bool isRename = false,
    bool isTutorial = false) {
  return LeanPacket::CreatePCSlotData(
      _fbb,
      objId,
      name ? _fbb.CreateString(name) : 0,
      customizingInfo,
      classType,
      level,
      exp,
      influenceScore,
      influenceTier,
      influenceLev,
      combatpower,
      itemParts ? _fbb.CreateVector<flatbuffers::Offset<ItemPartsInfo>>(*itemParts) : 0,
      costumeParts ? _fbb.CreateVector<flatbuffers::Offset<CostumePartsInfo>>(*costumeParts) : 0,
      logoutTime,
      pcGuildInfo,
      guildRank,
      deleteExpire,
      isRename,
      isTutorial);
}

///- PC_TUTORIAL_SKIP_REQUEST --------------
struct PcTutorialSkipRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CLASSTYPE = 4
  };
  int32_t classType() const {
    return GetField<int32_t>(VT_CLASSTYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CLASSTYPE) &&
           verifier.EndTable();
  }
};

struct PcTutorialSkipRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_classType(int32_t classType) {
    fbb_.AddElement<int32_t>(PcTutorialSkipRequest::VT_CLASSTYPE, classType, 0);
  }
  explicit PcTutorialSkipRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PcTutorialSkipRequestBuilder &operator=(const PcTutorialSkipRequestBuilder &);
  flatbuffers::Offset<PcTutorialSkipRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PcTutorialSkipRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<PcTutorialSkipRequest> CreatePcTutorialSkipRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t classType = 0) {
  PcTutorialSkipRequestBuilder builder_(_fbb);
  builder_.add_classType(classType);
  return builder_.Finish();
}

///- PC_TUTORIAL_SKIP_RESPONSE --------------
struct PcTutorialSkipResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CLASSTYPE = 4
  };
  int32_t classType() const {
    return GetField<int32_t>(VT_CLASSTYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CLASSTYPE) &&
           verifier.EndTable();
  }
};

struct PcTutorialSkipResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_classType(int32_t classType) {
    fbb_.AddElement<int32_t>(PcTutorialSkipResponse::VT_CLASSTYPE, classType, 0);
  }
  explicit PcTutorialSkipResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PcTutorialSkipResponseBuilder &operator=(const PcTutorialSkipResponseBuilder &);
  flatbuffers::Offset<PcTutorialSkipResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PcTutorialSkipResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<PcTutorialSkipResponse> CreatePcTutorialSkipResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t classType = 0) {
  PcTutorialSkipResponseBuilder builder_(_fbb);
  builder_.add_classType(classType);
  return builder_.Finish();
}

///- SLOT_LIST_RESPONSE ----------
struct SlotListResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_JUMPINGSTACKCOUNT = 4,
    VT_SLOTS = 6
  };
  int16_t jumpingStackCount() const {
    return GetField<int16_t>(VT_JUMPINGSTACKCOUNT, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PCSlotData>> *slots() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PCSlotData>> *>(VT_SLOTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_JUMPINGSTACKCOUNT) &&
           VerifyOffset(verifier, VT_SLOTS) &&
           verifier.VerifyVector(slots()) &&
           verifier.VerifyVectorOfTables(slots()) &&
           verifier.EndTable();
  }
};

struct SlotListResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_jumpingStackCount(int16_t jumpingStackCount) {
    fbb_.AddElement<int16_t>(SlotListResponse::VT_JUMPINGSTACKCOUNT, jumpingStackCount, 0);
  }
  void add_slots(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PCSlotData>>> slots) {
    fbb_.AddOffset(SlotListResponse::VT_SLOTS, slots);
  }
  explicit SlotListResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SlotListResponseBuilder &operator=(const SlotListResponseBuilder &);
  flatbuffers::Offset<SlotListResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SlotListResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<SlotListResponse> CreateSlotListResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t jumpingStackCount = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PCSlotData>>> slots = 0) {
  SlotListResponseBuilder builder_(_fbb);
  builder_.add_slots(slots);
  builder_.add_jumpingStackCount(jumpingStackCount);
  return builder_.Finish();
}

inline flatbuffers::Offset<SlotListResponse> CreateSlotListResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t jumpingStackCount = 0,
    const std::vector<flatbuffers::Offset<PCSlotData>> *slots = nullptr) {
  return LeanPacket::CreateSlotListResponse(
      _fbb,
      jumpingStackCount,
      slots ? _fbb.CreateVector<flatbuffers::Offset<PCSlotData>>(*slots) : 0);
}

///- PC_CHECK_NEW_NAME_REQUEST ---------
struct PCCheckNewNameRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_CODE = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *code() const {
    return GetPointer<const flatbuffers::String *>(VT_CODE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_CODE) &&
           verifier.VerifyString(code()) &&
           verifier.EndTable();
  }
};

struct PCCheckNewNameRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(PCCheckNewNameRequest::VT_NAME, name);
  }
  void add_code(flatbuffers::Offset<flatbuffers::String> code) {
    fbb_.AddOffset(PCCheckNewNameRequest::VT_CODE, code);
  }
  explicit PCCheckNewNameRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PCCheckNewNameRequestBuilder &operator=(const PCCheckNewNameRequestBuilder &);
  flatbuffers::Offset<PCCheckNewNameRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PCCheckNewNameRequest>(end);
    fbb_.Required(o, PCCheckNewNameRequest::VT_NAME);
    fbb_.Required(o, PCCheckNewNameRequest::VT_CODE);
    return o;
  }
};

inline flatbuffers::Offset<PCCheckNewNameRequest> CreatePCCheckNewNameRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> code = 0) {
  PCCheckNewNameRequestBuilder builder_(_fbb);
  builder_.add_code(code);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<PCCheckNewNameRequest> CreatePCCheckNewNameRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *code = nullptr) {
  return LeanPacket::CreatePCCheckNewNameRequest(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      code ? _fbb.CreateString(code) : 0);
}

///- PC_CHECK_NEW_NAME_RESPONSE ---------
struct PCCheckNewNameResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_EXPIRE = 6
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  int16_t expire() const {
    return GetField<int16_t>(VT_EXPIRE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int16_t>(verifier, VT_EXPIRE) &&
           verifier.EndTable();
  }
};

struct PCCheckNewNameResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(PCCheckNewNameResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_expire(int16_t expire) {
    fbb_.AddElement<int16_t>(PCCheckNewNameResponse::VT_EXPIRE, expire, 0);
  }
  explicit PCCheckNewNameResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PCCheckNewNameResponseBuilder &operator=(const PCCheckNewNameResponseBuilder &);
  flatbuffers::Offset<PCCheckNewNameResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PCCheckNewNameResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<PCCheckNewNameResponse> CreatePCCheckNewNameResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    int16_t expire = 0) {
  PCCheckNewNameResponseBuilder builder_(_fbb);
  builder_.add_errorCode(errorCode);
  builder_.add_expire(expire);
  return builder_.Finish();
}

///- PC_RENAME_REQUEST ---------
struct PCRenameRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCDBID = 4,
    VT_NAME = 6
  };
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct PCRenameRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(PCRenameRequest::VT_PCDBID, pcDbId, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(PCRenameRequest::VT_NAME, name);
  }
  explicit PCRenameRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PCRenameRequestBuilder &operator=(const PCRenameRequestBuilder &);
  flatbuffers::Offset<PCRenameRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PCRenameRequest>(end);
    fbb_.Required(o, PCRenameRequest::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<PCRenameRequest> CreatePCRenameRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcDbId = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  PCRenameRequestBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<PCRenameRequest> CreatePCRenameRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcDbId = 0,
    const char *name = nullptr) {
  return LeanPacket::CreatePCRenameRequest(
      _fbb,
      pcDbId,
      name ? _fbb.CreateString(name) : 0);
}

///- PC_RENAME_RESPONSE ---------
struct PCRenameResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_PCDBID = 6,
    VT_NAME = 8
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct PCRenameResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(PCRenameResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(PCRenameResponse::VT_PCDBID, pcDbId, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(PCRenameResponse::VT_NAME, name);
  }
  explicit PCRenameResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PCRenameResponseBuilder &operator=(const PCRenameResponseBuilder &);
  flatbuffers::Offset<PCRenameResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PCRenameResponse>(end);
    fbb_.Required(o, PCRenameResponse::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<PCRenameResponse> CreatePCRenameResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    int64_t pcDbId = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  PCRenameResponseBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  builder_.add_name(name);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

inline flatbuffers::Offset<PCRenameResponse> CreatePCRenameResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    int64_t pcDbId = 0,
    const char *name = nullptr) {
  return LeanPacket::CreatePCRenameResponse(
      _fbb,
      errorCode,
      pcDbId,
      name ? _fbb.CreateString(name) : 0);
}

///- 커스터마이징 정보 --------
struct CustomizeInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HAIRTYPE = 4,
    VT_HAIRCOLOR = 6,
    VT_FACETYPE = 8,
    VT_FACECOLOR = 10
  };
  int16_t hairType() const {
    return GetField<int16_t>(VT_HAIRTYPE, 0);
  }
  int16_t hairColor() const {
    return GetField<int16_t>(VT_HAIRCOLOR, 0);
  }
  int16_t faceType() const {
    return GetField<int16_t>(VT_FACETYPE, 0);
  }
  int16_t faceColor() const {
    return GetField<int16_t>(VT_FACECOLOR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_HAIRTYPE) &&
           VerifyField<int16_t>(verifier, VT_HAIRCOLOR) &&
           VerifyField<int16_t>(verifier, VT_FACETYPE) &&
           VerifyField<int16_t>(verifier, VT_FACECOLOR) &&
           verifier.EndTable();
  }
};

struct CustomizeInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hairType(int16_t hairType) {
    fbb_.AddElement<int16_t>(CustomizeInfo::VT_HAIRTYPE, hairType, 0);
  }
  void add_hairColor(int16_t hairColor) {
    fbb_.AddElement<int16_t>(CustomizeInfo::VT_HAIRCOLOR, hairColor, 0);
  }
  void add_faceType(int16_t faceType) {
    fbb_.AddElement<int16_t>(CustomizeInfo::VT_FACETYPE, faceType, 0);
  }
  void add_faceColor(int16_t faceColor) {
    fbb_.AddElement<int16_t>(CustomizeInfo::VT_FACECOLOR, faceColor, 0);
  }
  explicit CustomizeInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CustomizeInfoBuilder &operator=(const CustomizeInfoBuilder &);
  flatbuffers::Offset<CustomizeInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CustomizeInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<CustomizeInfo> CreateCustomizeInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t hairType = 0,
    int16_t hairColor = 0,
    int16_t faceType = 0,
    int16_t faceColor = 0) {
  CustomizeInfoBuilder builder_(_fbb);
  builder_.add_faceColor(faceColor);
  builder_.add_faceType(faceType);
  builder_.add_hairColor(hairColor);
  builder_.add_hairType(hairType);
  return builder_.Finish();
}

///- PC_CREATION_REQUEST ----------
struct PCCreationRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CLASSTYPE = 4,
    VT_NAME = 6,
    VT_CUSTOMIZINGINFO = 8,
    VT_CODE = 10,
    VT_ISJUMPING = 12
  };
  int32_t classType() const {
    return GetField<int32_t>(VT_CLASSTYPE, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const CustomizeInfo *customizingInfo() const {
    return GetPointer<const CustomizeInfo *>(VT_CUSTOMIZINGINFO);
  }
  const flatbuffers::String *code() const {
    return GetPointer<const flatbuffers::String *>(VT_CODE);
  }
  bool isJumping() const {
    return GetField<uint8_t>(VT_ISJUMPING, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CLASSTYPE) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_CUSTOMIZINGINFO) &&
           verifier.VerifyTable(customizingInfo()) &&
           VerifyOffsetRequired(verifier, VT_CODE) &&
           verifier.VerifyString(code()) &&
           VerifyField<uint8_t>(verifier, VT_ISJUMPING) &&
           verifier.EndTable();
  }
};

struct PCCreationRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_classType(int32_t classType) {
    fbb_.AddElement<int32_t>(PCCreationRequest::VT_CLASSTYPE, classType, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(PCCreationRequest::VT_NAME, name);
  }
  void add_customizingInfo(flatbuffers::Offset<CustomizeInfo> customizingInfo) {
    fbb_.AddOffset(PCCreationRequest::VT_CUSTOMIZINGINFO, customizingInfo);
  }
  void add_code(flatbuffers::Offset<flatbuffers::String> code) {
    fbb_.AddOffset(PCCreationRequest::VT_CODE, code);
  }
  void add_isJumping(bool isJumping) {
    fbb_.AddElement<uint8_t>(PCCreationRequest::VT_ISJUMPING, static_cast<uint8_t>(isJumping), 0);
  }
  explicit PCCreationRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PCCreationRequestBuilder &operator=(const PCCreationRequestBuilder &);
  flatbuffers::Offset<PCCreationRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PCCreationRequest>(end);
    fbb_.Required(o, PCCreationRequest::VT_NAME);
    fbb_.Required(o, PCCreationRequest::VT_CUSTOMIZINGINFO);
    fbb_.Required(o, PCCreationRequest::VT_CODE);
    return o;
  }
};

inline flatbuffers::Offset<PCCreationRequest> CreatePCCreationRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t classType = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<CustomizeInfo> customizingInfo = 0,
    flatbuffers::Offset<flatbuffers::String> code = 0,
    bool isJumping = false) {
  PCCreationRequestBuilder builder_(_fbb);
  builder_.add_code(code);
  builder_.add_customizingInfo(customizingInfo);
  builder_.add_name(name);
  builder_.add_classType(classType);
  builder_.add_isJumping(isJumping);
  return builder_.Finish();
}

inline flatbuffers::Offset<PCCreationRequest> CreatePCCreationRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t classType = 0,
    const char *name = nullptr,
    flatbuffers::Offset<CustomizeInfo> customizingInfo = 0,
    const char *code = nullptr,
    bool isJumping = false) {
  return LeanPacket::CreatePCCreationRequest(
      _fbb,
      classType,
      name ? _fbb.CreateString(name) : 0,
      customizingInfo,
      code ? _fbb.CreateString(code) : 0,
      isJumping);
}

///- PC_CREATION_RESPONSE ----------
struct PCCreationResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_JUMPINGSTACKCOUNT = 6
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  int16_t jumpingStackCount() const {
    return GetField<int16_t>(VT_JUMPINGSTACKCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int16_t>(verifier, VT_JUMPINGSTACKCOUNT) &&
           verifier.EndTable();
  }
};

struct PCCreationResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(PCCreationResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_jumpingStackCount(int16_t jumpingStackCount) {
    fbb_.AddElement<int16_t>(PCCreationResponse::VT_JUMPINGSTACKCOUNT, jumpingStackCount, 0);
  }
  explicit PCCreationResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PCCreationResponseBuilder &operator=(const PCCreationResponseBuilder &);
  flatbuffers::Offset<PCCreationResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PCCreationResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<PCCreationResponse> CreatePCCreationResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    int16_t jumpingStackCount = 0) {
  PCCreationResponseBuilder builder_(_fbb);
  builder_.add_errorCode(errorCode);
  builder_.add_jumpingStackCount(jumpingStackCount);
  return builder_.Finish();
}

///- PC_DELETE_REQUEST ----------
struct PCDeleteRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCDBID = 4
  };
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           verifier.EndTable();
  }
};

struct PCDeleteRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(PCDeleteRequest::VT_PCDBID, pcDbId, 0);
  }
  explicit PCDeleteRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PCDeleteRequestBuilder &operator=(const PCDeleteRequestBuilder &);
  flatbuffers::Offset<PCDeleteRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PCDeleteRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<PCDeleteRequest> CreatePCDeleteRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcDbId = 0) {
  PCDeleteRequestBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  return builder_.Finish();
}

///- PC_DELETE_RESPONSE ----------
struct PCDeleteResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           verifier.EndTable();
  }
};

struct PCDeleteResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(PCDeleteResponse::VT_ERRORCODE, errorCode, 0);
  }
  explicit PCDeleteResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PCDeleteResponseBuilder &operator=(const PCDeleteResponseBuilder &);
  flatbuffers::Offset<PCDeleteResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PCDeleteResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<PCDeleteResponse> CreatePCDeleteResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0) {
  PCDeleteResponseBuilder builder_(_fbb);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

///- PC_CANCEL_DELETE_REQUEST ----------
struct PCCancelDeleteRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCDBID = 4
  };
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           verifier.EndTable();
  }
};

struct PCCancelDeleteRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(PCCancelDeleteRequest::VT_PCDBID, pcDbId, 0);
  }
  explicit PCCancelDeleteRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PCCancelDeleteRequestBuilder &operator=(const PCCancelDeleteRequestBuilder &);
  flatbuffers::Offset<PCCancelDeleteRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PCCancelDeleteRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<PCCancelDeleteRequest> CreatePCCancelDeleteRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcDbId = 0) {
  PCCancelDeleteRequestBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  return builder_.Finish();
}

///- PC_CANCEL_DELETE_RESPONSE ----------
struct PCCancelDeleteResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           verifier.EndTable();
  }
};

struct PCCancelDeleteResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(PCCancelDeleteResponse::VT_ERRORCODE, errorCode, 0);
  }
  explicit PCCancelDeleteResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PCCancelDeleteResponseBuilder &operator=(const PCCancelDeleteResponseBuilder &);
  flatbuffers::Offset<PCCancelDeleteResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PCCancelDeleteResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<PCCancelDeleteResponse> CreatePCCancelDeleteResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0) {
  PCCancelDeleteResponseBuilder builder_(_fbb);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

///- PC_LOGIN_REQUEST ----------
struct PCLoginRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCDBID = 4
  };
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           verifier.EndTable();
  }
};

struct PCLoginRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(PCLoginRequest::VT_PCDBID, pcDbId, 0);
  }
  explicit PCLoginRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PCLoginRequestBuilder &operator=(const PCLoginRequestBuilder &);
  flatbuffers::Offset<PCLoginRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PCLoginRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<PCLoginRequest> CreatePCLoginRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcDbId = 0) {
  PCLoginRequestBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  return builder_.Finish();
}

///- PC_LOGIN_RESPONSE ----------
struct PCLoginResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           verifier.EndTable();
  }
};

struct PCLoginResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(PCLoginResponse::VT_ERRORCODE, errorCode, 0);
  }
  explicit PCLoginResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PCLoginResponseBuilder &operator=(const PCLoginResponseBuilder &);
  flatbuffers::Offset<PCLoginResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PCLoginResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<PCLoginResponse> CreatePCLoginResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0) {
  PCLoginResponseBuilder builder_(_fbb);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

///- PC_GOTO_LOBBY_REQUEST ----------
struct PcGotoLobbyRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct PcGotoLobbyRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PcGotoLobbyRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PcGotoLobbyRequestBuilder &operator=(const PcGotoLobbyRequestBuilder &);
  flatbuffers::Offset<PcGotoLobbyRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PcGotoLobbyRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<PcGotoLobbyRequest> CreatePcGotoLobbyRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PcGotoLobbyRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

///- PC_GOTO_LOBBY_RESPONSE ----------
struct PcGotoLobbyResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERROR = 4
  };
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           verifier.EndTable();
  }
};

struct PcGotoLobbyResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(PcGotoLobbyResponse::VT_ERROR, error, 0);
  }
  explicit PcGotoLobbyResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PcGotoLobbyResponseBuilder &operator=(const PcGotoLobbyResponseBuilder &);
  flatbuffers::Offset<PcGotoLobbyResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PcGotoLobbyResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<PcGotoLobbyResponse> CreatePcGotoLobbyResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t error = 0) {
  PcGotoLobbyResponseBuilder builder_(_fbb);
  builder_.add_error(error);
  return builder_.Finish();
}

///- ACCOUNT_LOGOUT_REQUEST ----------
struct AccountLogoutRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AccountLogoutRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AccountLogoutRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AccountLogoutRequestBuilder &operator=(const AccountLogoutRequestBuilder &);
  flatbuffers::Offset<AccountLogoutRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AccountLogoutRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<AccountLogoutRequest> CreateAccountLogoutRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AccountLogoutRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

///- ACCOUNT_LOGOUT_RESPONSE ----------
struct AccountLogoutResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERROR = 4
  };
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           verifier.EndTable();
  }
};

struct AccountLogoutResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(AccountLogoutResponse::VT_ERROR, error, 0);
  }
  explicit AccountLogoutResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AccountLogoutResponseBuilder &operator=(const AccountLogoutResponseBuilder &);
  flatbuffers::Offset<AccountLogoutResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AccountLogoutResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<AccountLogoutResponse> CreateAccountLogoutResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t error = 0) {
  AccountLogoutResponseBuilder builder_(_fbb);
  builder_.add_error(error);
  return builder_.Finish();
}

///- GOTO_SERVER_LIST_REQUEST
struct GotoServerListRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GotoServerListRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GotoServerListRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GotoServerListRequestBuilder &operator=(const GotoServerListRequestBuilder &);
  flatbuffers::Offset<GotoServerListRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GotoServerListRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GotoServerListRequest> CreateGotoServerListRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GotoServerListRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

///- GOTO_SERVER_LIST_RESPONSE
struct GotoServerListResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERROR = 4,
    VT_TICKET = 6
  };
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  const flatbuffers::Vector<uint8_t> *ticket() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_TICKET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           VerifyOffset(verifier, VT_TICKET) &&
           verifier.VerifyVector(ticket()) &&
           verifier.EndTable();
  }
};

struct GotoServerListResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(GotoServerListResponse::VT_ERROR, error, 0);
  }
  void add_ticket(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> ticket) {
    fbb_.AddOffset(GotoServerListResponse::VT_TICKET, ticket);
  }
  explicit GotoServerListResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GotoServerListResponseBuilder &operator=(const GotoServerListResponseBuilder &);
  flatbuffers::Offset<GotoServerListResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GotoServerListResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GotoServerListResponse> CreateGotoServerListResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t error = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> ticket = 0) {
  GotoServerListResponseBuilder builder_(_fbb);
  builder_.add_ticket(ticket);
  builder_.add_error(error);
  return builder_.Finish();
}

inline flatbuffers::Offset<GotoServerListResponse> CreateGotoServerListResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t error = 0,
    const std::vector<uint8_t> *ticket = nullptr) {
  return LeanPacket::CreateGotoServerListResponse(
      _fbb,
      error,
      ticket ? _fbb.CreateVector<uint8_t>(*ticket) : 0);
}

///- TICKET_NOTIFY -------------
struct TicketNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TICKETINFO = 4
  };
  const TicketInfo *ticketInfo() const {
    return GetPointer<const TicketInfo *>(VT_TICKETINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TICKETINFO) &&
           verifier.VerifyTable(ticketInfo()) &&
           verifier.EndTable();
  }
};

struct TicketNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ticketInfo(flatbuffers::Offset<TicketInfo> ticketInfo) {
    fbb_.AddOffset(TicketNotify::VT_TICKETINFO, ticketInfo);
  }
  explicit TicketNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TicketNotifyBuilder &operator=(const TicketNotifyBuilder &);
  flatbuffers::Offset<TicketNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TicketNotify>(end);
    fbb_.Required(o, TicketNotify::VT_TICKETINFO);
    return o;
  }
};

inline flatbuffers::Offset<TicketNotify> CreateTicketNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<TicketInfo> ticketInfo = 0) {
  TicketNotifyBuilder builder_(_fbb);
  builder_.add_ticketInfo(ticketInfo);
  return builder_.Finish();
}

///- TICKET_ALL_NOTIFY ------------
struct TicketAllNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TICKETINFOS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<TicketInfo>> *ticketInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TicketInfo>> *>(VT_TICKETINFOS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TICKETINFOS) &&
           verifier.VerifyVector(ticketInfos()) &&
           verifier.VerifyVectorOfTables(ticketInfos()) &&
           verifier.EndTable();
  }
};

struct TicketAllNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ticketInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TicketInfo>>> ticketInfos) {
    fbb_.AddOffset(TicketAllNotify::VT_TICKETINFOS, ticketInfos);
  }
  explicit TicketAllNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TicketAllNotifyBuilder &operator=(const TicketAllNotifyBuilder &);
  flatbuffers::Offset<TicketAllNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TicketAllNotify>(end);
    fbb_.Required(o, TicketAllNotify::VT_TICKETINFOS);
    return o;
  }
};

inline flatbuffers::Offset<TicketAllNotify> CreateTicketAllNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TicketInfo>>> ticketInfos = 0) {
  TicketAllNotifyBuilder builder_(_fbb);
  builder_.add_ticketInfos(ticketInfos);
  return builder_.Finish();
}

inline flatbuffers::Offset<TicketAllNotify> CreateTicketAllNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<TicketInfo>> *ticketInfos = nullptr) {
  return LeanPacket::CreateTicketAllNotify(
      _fbb,
      ticketInfos ? _fbb.CreateVector<flatbuffers::Offset<TicketInfo>>(*ticketInfos) : 0);
}

///- PC_SPAWN_COMPLETE_NOTIFY ----------
struct PcSpawnCompleteNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_CHANNELNUMBER = 6,
    VT_CHANNELMOVEREMAINTIMESEC = 8
  };
  /// PC 스폰 완료, 채널 이동 완료 등 게임 진행이 가능하게 됨을 알림.
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  int32_t channelNumber() const {
    return GetField<int32_t>(VT_CHANNELNUMBER, 0);
  }
  /// 채널 이동이 가능하기 까지 남은 시간 (초)
  int32_t channelMoveRemainTimeSec() const {
    return GetField<int32_t>(VT_CHANNELMOVEREMAINTIMESEC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int32_t>(verifier, VT_CHANNELNUMBER) &&
           VerifyField<int32_t>(verifier, VT_CHANNELMOVEREMAINTIMESEC) &&
           verifier.EndTable();
  }
};

struct PcSpawnCompleteNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(PcSpawnCompleteNotify::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  void add_channelNumber(int32_t channelNumber) {
    fbb_.AddElement<int32_t>(PcSpawnCompleteNotify::VT_CHANNELNUMBER, channelNumber, 0);
  }
  void add_channelMoveRemainTimeSec(int32_t channelMoveRemainTimeSec) {
    fbb_.AddElement<int32_t>(PcSpawnCompleteNotify::VT_CHANNELMOVEREMAINTIMESEC, channelMoveRemainTimeSec, 0);
  }
  explicit PcSpawnCompleteNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PcSpawnCompleteNotifyBuilder &operator=(const PcSpawnCompleteNotifyBuilder &);
  flatbuffers::Offset<PcSpawnCompleteNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PcSpawnCompleteNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<PcSpawnCompleteNotify> CreatePcSpawnCompleteNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE,
    int32_t channelNumber = 0,
    int32_t channelMoveRemainTimeSec = 0) {
  PcSpawnCompleteNotifyBuilder builder_(_fbb);
  builder_.add_channelMoveRemainTimeSec(channelMoveRemainTimeSec);
  builder_.add_channelNumber(channelNumber);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

///- UPC_SPAWN_COMPLETE_NOTIFY ----------
struct UpcSpawnCompleteNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULT = 4,
    VT_OBJECTID = 6
  };
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           verifier.EndTable();
  }
};

struct UpcSpawnCompleteNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(UpcSpawnCompleteNotify::VT_RESULT, result, 0);
  }
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(UpcSpawnCompleteNotify::VT_OBJECTID, objectId, 0);
  }
  explicit UpcSpawnCompleteNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UpcSpawnCompleteNotifyBuilder &operator=(const UpcSpawnCompleteNotifyBuilder &);
  flatbuffers::Offset<UpcSpawnCompleteNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UpcSpawnCompleteNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<UpcSpawnCompleteNotify> CreateUpcSpawnCompleteNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    int64_t objectId = 0) {
  UpcSpawnCompleteNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_result(result);
  return builder_.Finish();
}

struct ChannelInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NUMBER = 4,
    VT_CONGESTION = 6,
    VT_DEBUGINFO = 8
  };
  /// 참고. 채널아이디가 아님
  int32_t number() const {
    return GetField<int32_t>(VT_NUMBER, 0);
  }
  /// 혼잡도
  ChannelCongestion congestion() const {
    return static_cast<ChannelCongestion>(GetField<int8_t>(VT_CONGESTION, 0));
  }
  /// 개발 확인용 (디버그 서버만 전달됩니다)
  const flatbuffers::String *debugInfo() const {
    return GetPointer<const flatbuffers::String *>(VT_DEBUGINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUMBER) &&
           VerifyField<int8_t>(verifier, VT_CONGESTION) &&
           VerifyOffset(verifier, VT_DEBUGINFO) &&
           verifier.VerifyString(debugInfo()) &&
           verifier.EndTable();
  }
};

struct ChannelInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_number(int32_t number) {
    fbb_.AddElement<int32_t>(ChannelInfo::VT_NUMBER, number, 0);
  }
  void add_congestion(ChannelCongestion congestion) {
    fbb_.AddElement<int8_t>(ChannelInfo::VT_CONGESTION, static_cast<int8_t>(congestion), 0);
  }
  void add_debugInfo(flatbuffers::Offset<flatbuffers::String> debugInfo) {
    fbb_.AddOffset(ChannelInfo::VT_DEBUGINFO, debugInfo);
  }
  explicit ChannelInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChannelInfoBuilder &operator=(const ChannelInfoBuilder &);
  flatbuffers::Offset<ChannelInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChannelInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChannelInfo> CreateChannelInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t number = 0,
    ChannelCongestion congestion = ChannelCongestion_ChannelCongestion_Level1,
    flatbuffers::Offset<flatbuffers::String> debugInfo = 0) {
  ChannelInfoBuilder builder_(_fbb);
  builder_.add_debugInfo(debugInfo);
  builder_.add_number(number);
  builder_.add_congestion(congestion);
  return builder_.Finish();
}

inline flatbuffers::Offset<ChannelInfo> CreateChannelInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t number = 0,
    ChannelCongestion congestion = ChannelCongestion_ChannelCongestion_Level1,
    const char *debugInfo = nullptr) {
  return LeanPacket::CreateChannelInfo(
      _fbb,
      number,
      congestion,
      debugInfo ? _fbb.CreateString(debugInfo) : 0);
}

/// SMAP_CHANNEL_LIST_REQUEST
struct SMapChannelListRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SMapChannelListRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SMapChannelListRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SMapChannelListRequestBuilder &operator=(const SMapChannelListRequestBuilder &);
  flatbuffers::Offset<SMapChannelListRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SMapChannelListRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SMapChannelListRequest> CreateSMapChannelListRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SMapChannelListRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// SMAP_CHANNEL_LIST_RESPONSE
struct SMapChannelListResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_SMAPID = 6,
    VT_CONTENTSTYPE = 8,
    VT_CHANNELINFOS = 10,
    VT_REMAINTIMESEC = 12
  };
  /// 실패시 이하 필드는 없음
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  int32_t smapId() const {
    return GetField<int32_t>(VT_SMAPID, 0);
  }
  ContentsType contentsType() const {
    return static_cast<ContentsType>(GetField<int32_t>(VT_CONTENTSTYPE, 0));
  }
  /// 채널 정보 목록 (1~10개)
  const flatbuffers::Vector<flatbuffers::Offset<ChannelInfo>> *channelInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ChannelInfo>> *>(VT_CHANNELINFOS);
  }
  /// 채널 이동이 가능하기 까지 남은 시간 (초)
  int32_t remainTimeSec() const {
    return GetField<int32_t>(VT_REMAINTIMESEC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int32_t>(verifier, VT_SMAPID) &&
           VerifyField<int32_t>(verifier, VT_CONTENTSTYPE) &&
           VerifyOffset(verifier, VT_CHANNELINFOS) &&
           verifier.VerifyVector(channelInfos()) &&
           verifier.VerifyVectorOfTables(channelInfos()) &&
           VerifyField<int32_t>(verifier, VT_REMAINTIMESEC) &&
           verifier.EndTable();
  }
};

struct SMapChannelListResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(SMapChannelListResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  void add_smapId(int32_t smapId) {
    fbb_.AddElement<int32_t>(SMapChannelListResponse::VT_SMAPID, smapId, 0);
  }
  void add_contentsType(ContentsType contentsType) {
    fbb_.AddElement<int32_t>(SMapChannelListResponse::VT_CONTENTSTYPE, static_cast<int32_t>(contentsType), 0);
  }
  void add_channelInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ChannelInfo>>> channelInfos) {
    fbb_.AddOffset(SMapChannelListResponse::VT_CHANNELINFOS, channelInfos);
  }
  void add_remainTimeSec(int32_t remainTimeSec) {
    fbb_.AddElement<int32_t>(SMapChannelListResponse::VT_REMAINTIMESEC, remainTimeSec, 0);
  }
  explicit SMapChannelListResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SMapChannelListResponseBuilder &operator=(const SMapChannelListResponseBuilder &);
  flatbuffers::Offset<SMapChannelListResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SMapChannelListResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<SMapChannelListResponse> CreateSMapChannelListResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE,
    int32_t smapId = 0,
    ContentsType contentsType = ContentsType_CONTENTS_TYPE_NONE,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ChannelInfo>>> channelInfos = 0,
    int32_t remainTimeSec = 0) {
  SMapChannelListResponseBuilder builder_(_fbb);
  builder_.add_remainTimeSec(remainTimeSec);
  builder_.add_channelInfos(channelInfos);
  builder_.add_contentsType(contentsType);
  builder_.add_smapId(smapId);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

inline flatbuffers::Offset<SMapChannelListResponse> CreateSMapChannelListResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE,
    int32_t smapId = 0,
    ContentsType contentsType = ContentsType_CONTENTS_TYPE_NONE,
    const std::vector<flatbuffers::Offset<ChannelInfo>> *channelInfos = nullptr,
    int32_t remainTimeSec = 0) {
  return LeanPacket::CreateSMapChannelListResponse(
      _fbb,
      errorCode,
      smapId,
      contentsType,
      channelInfos ? _fbb.CreateVector<flatbuffers::Offset<ChannelInfo>>(*channelInfos) : 0,
      remainTimeSec);
}

/// SMAP_CHANNEL_MOVE_REQUEST
struct SMapChannelMoveRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SMAPID = 4,
    VT_CONTENTSTYPE = 6,
    VT_CHANNELNUMBER = 8
  };
  /// 아래 2개는 SMapChannelListResponse 의 값을 채워주세요
  int32_t smapId() const {
    return GetField<int32_t>(VT_SMAPID, 0);
  }
  ContentsType contentsType() const {
    return static_cast<ContentsType>(GetField<int32_t>(VT_CONTENTSTYPE, 0));
  }
  /// 이동하고자 하는 채널번호 (ChannelInfo.number)
  int32_t channelNumber() const {
    return GetField<int32_t>(VT_CHANNELNUMBER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SMAPID) &&
           VerifyField<int32_t>(verifier, VT_CONTENTSTYPE) &&
           VerifyField<int32_t>(verifier, VT_CHANNELNUMBER) &&
           verifier.EndTable();
  }
};

struct SMapChannelMoveRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_smapId(int32_t smapId) {
    fbb_.AddElement<int32_t>(SMapChannelMoveRequest::VT_SMAPID, smapId, 0);
  }
  void add_contentsType(ContentsType contentsType) {
    fbb_.AddElement<int32_t>(SMapChannelMoveRequest::VT_CONTENTSTYPE, static_cast<int32_t>(contentsType), 0);
  }
  void add_channelNumber(int32_t channelNumber) {
    fbb_.AddElement<int32_t>(SMapChannelMoveRequest::VT_CHANNELNUMBER, channelNumber, 0);
  }
  explicit SMapChannelMoveRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SMapChannelMoveRequestBuilder &operator=(const SMapChannelMoveRequestBuilder &);
  flatbuffers::Offset<SMapChannelMoveRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SMapChannelMoveRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SMapChannelMoveRequest> CreateSMapChannelMoveRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t smapId = 0,
    ContentsType contentsType = ContentsType_CONTENTS_TYPE_NONE,
    int32_t channelNumber = 0) {
  SMapChannelMoveRequestBuilder builder_(_fbb);
  builder_.add_channelNumber(channelNumber);
  builder_.add_contentsType(contentsType);
  builder_.add_smapId(smapId);
  return builder_.Finish();
}

/// SMAP_CHANNEL_MOVE_RESPONSE
struct SMapChannelMoveResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_REMAINTIMESEC = 6
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  /// 채널 이동이 가능하기 까지 남은 시간 (초)
  int32_t remainTimeSec() const {
    return GetField<int32_t>(VT_REMAINTIMESEC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int32_t>(verifier, VT_REMAINTIMESEC) &&
           verifier.EndTable();
  }
};

struct SMapChannelMoveResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(SMapChannelMoveResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  void add_remainTimeSec(int32_t remainTimeSec) {
    fbb_.AddElement<int32_t>(SMapChannelMoveResponse::VT_REMAINTIMESEC, remainTimeSec, 0);
  }
  explicit SMapChannelMoveResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SMapChannelMoveResponseBuilder &operator=(const SMapChannelMoveResponseBuilder &);
  flatbuffers::Offset<SMapChannelMoveResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SMapChannelMoveResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<SMapChannelMoveResponse> CreateSMapChannelMoveResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE,
    int32_t remainTimeSec = 0) {
  SMapChannelMoveResponseBuilder builder_(_fbb);
  builder_.add_remainTimeSec(remainTimeSec);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

///- JOIN_EVENTSET_CHANNEL_REQUEST ----------
struct JoinEventSetChannelRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_EVENTSETID = 6
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int32_t eventSetId() const {
    return GetField<int32_t>(VT_EVENTSETID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int32_t>(verifier, VT_EVENTSETID) &&
           verifier.EndTable();
  }
};

struct JoinEventSetChannelRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(JoinEventSetChannelRequest::VT_OBJECTID, objectId, 0);
  }
  void add_eventSetId(int32_t eventSetId) {
    fbb_.AddElement<int32_t>(JoinEventSetChannelRequest::VT_EVENTSETID, eventSetId, 0);
  }
  explicit JoinEventSetChannelRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  JoinEventSetChannelRequestBuilder &operator=(const JoinEventSetChannelRequestBuilder &);
  flatbuffers::Offset<JoinEventSetChannelRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<JoinEventSetChannelRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<JoinEventSetChannelRequest> CreateJoinEventSetChannelRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int32_t eventSetId = 0) {
  JoinEventSetChannelRequestBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_eventSetId(eventSetId);
  return builder_.Finish();
}

///- JOIN_EVENTSET_CHANNEL_RESPONSE ----------
struct JoinEventSetChannelResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EVENTSETID = 4,
    VT_REASON = 6
  };
  int32_t eventSetId() const {
    return GetField<int32_t>(VT_EVENTSETID, 0);
  }
  JoinChannelReason reason() const {
    return static_cast<JoinChannelReason>(GetField<int32_t>(VT_REASON, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_EVENTSETID) &&
           VerifyField<int32_t>(verifier, VT_REASON) &&
           verifier.EndTable();
  }
};

struct JoinEventSetChannelResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eventSetId(int32_t eventSetId) {
    fbb_.AddElement<int32_t>(JoinEventSetChannelResponse::VT_EVENTSETID, eventSetId, 0);
  }
  void add_reason(JoinChannelReason reason) {
    fbb_.AddElement<int32_t>(JoinEventSetChannelResponse::VT_REASON, static_cast<int32_t>(reason), 0);
  }
  explicit JoinEventSetChannelResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  JoinEventSetChannelResponseBuilder &operator=(const JoinEventSetChannelResponseBuilder &);
  flatbuffers::Offset<JoinEventSetChannelResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<JoinEventSetChannelResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<JoinEventSetChannelResponse> CreateJoinEventSetChannelResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t eventSetId = 0,
    JoinChannelReason reason = JoinChannelReason_JOIN_CHANNEL_REASON_NONE) {
  JoinEventSetChannelResponseBuilder builder_(_fbb);
  builder_.add_reason(reason);
  builder_.add_eventSetId(eventSetId);
  return builder_.Finish();
}

///- TELEPORT_REQUEST ----------
struct TeleportRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_PORTALID = 6,
    VT_POS = 8
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int32_t portalId() const {
    return GetField<int32_t>(VT_PORTALID, 0);
  }
  const Pos *pos() const {
    return GetPointer<const Pos *>(VT_POS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int32_t>(verifier, VT_PORTALID) &&
           VerifyOffsetRequired(verifier, VT_POS) &&
           verifier.VerifyTable(pos()) &&
           verifier.EndTable();
  }
};

struct TeleportRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(TeleportRequest::VT_OBJECTID, objectId, 0);
  }
  void add_portalId(int32_t portalId) {
    fbb_.AddElement<int32_t>(TeleportRequest::VT_PORTALID, portalId, 0);
  }
  void add_pos(flatbuffers::Offset<Pos> pos) {
    fbb_.AddOffset(TeleportRequest::VT_POS, pos);
  }
  explicit TeleportRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TeleportRequestBuilder &operator=(const TeleportRequestBuilder &);
  flatbuffers::Offset<TeleportRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TeleportRequest>(end);
    fbb_.Required(o, TeleportRequest::VT_POS);
    return o;
  }
};

inline flatbuffers::Offset<TeleportRequest> CreateTeleportRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int32_t portalId = 0,
    flatbuffers::Offset<Pos> pos = 0) {
  TeleportRequestBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_pos(pos);
  builder_.add_portalId(portalId);
  return builder_.Finish();
}

///- TELEPORT_RESPONSE ----------
struct TeleportResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRCODE = 4,
    VT_OBJECTID = 6,
    VT_SRCSCENEID = 8,
    VT_SRCPOS = 10,
    VT_DESTSCENEID = 12,
    VT_DESTPOS = 14,
    VT_TELEPORTTYPE = 16
  };
  int32_t errCode() const {
    return GetField<int32_t>(VT_ERRCODE, 0);
  }
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int32_t srcSceneId() const {
    return GetField<int32_t>(VT_SRCSCENEID, 0);
  }
  const Pos *srcPos() const {
    return GetPointer<const Pos *>(VT_SRCPOS);
  }
  int32_t destSceneId() const {
    return GetField<int32_t>(VT_DESTSCENEID, 0);
  }
  const Pos *destPos() const {
    return GetPointer<const Pos *>(VT_DESTPOS);
  }
  TeleportType teleportType() const {
    return static_cast<TeleportType>(GetField<int32_t>(VT_TELEPORTTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int32_t>(verifier, VT_SRCSCENEID) &&
           VerifyOffset(verifier, VT_SRCPOS) &&
           verifier.VerifyTable(srcPos()) &&
           VerifyField<int32_t>(verifier, VT_DESTSCENEID) &&
           VerifyOffset(verifier, VT_DESTPOS) &&
           verifier.VerifyTable(destPos()) &&
           VerifyField<int32_t>(verifier, VT_TELEPORTTYPE) &&
           verifier.EndTable();
  }
};

struct TeleportResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errCode(int32_t errCode) {
    fbb_.AddElement<int32_t>(TeleportResponse::VT_ERRCODE, errCode, 0);
  }
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(TeleportResponse::VT_OBJECTID, objectId, 0);
  }
  void add_srcSceneId(int32_t srcSceneId) {
    fbb_.AddElement<int32_t>(TeleportResponse::VT_SRCSCENEID, srcSceneId, 0);
  }
  void add_srcPos(flatbuffers::Offset<Pos> srcPos) {
    fbb_.AddOffset(TeleportResponse::VT_SRCPOS, srcPos);
  }
  void add_destSceneId(int32_t destSceneId) {
    fbb_.AddElement<int32_t>(TeleportResponse::VT_DESTSCENEID, destSceneId, 0);
  }
  void add_destPos(flatbuffers::Offset<Pos> destPos) {
    fbb_.AddOffset(TeleportResponse::VT_DESTPOS, destPos);
  }
  void add_teleportType(TeleportType teleportType) {
    fbb_.AddElement<int32_t>(TeleportResponse::VT_TELEPORTTYPE, static_cast<int32_t>(teleportType), 0);
  }
  explicit TeleportResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TeleportResponseBuilder &operator=(const TeleportResponseBuilder &);
  flatbuffers::Offset<TeleportResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TeleportResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<TeleportResponse> CreateTeleportResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errCode = 0,
    int64_t objectId = 0,
    int32_t srcSceneId = 0,
    flatbuffers::Offset<Pos> srcPos = 0,
    int32_t destSceneId = 0,
    flatbuffers::Offset<Pos> destPos = 0,
    TeleportType teleportType = TeleportType_TELEPORT_NONE) {
  TeleportResponseBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_teleportType(teleportType);
  builder_.add_destPos(destPos);
  builder_.add_destSceneId(destSceneId);
  builder_.add_srcPos(srcPos);
  builder_.add_srcSceneId(srcSceneId);
  builder_.add_errCode(errCode);
  return builder_.Finish();
}

/// TELEPORT_NOTIFY_OTHER_PC_IN_VIEW
struct TeleportNotifyOhterPcInView FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_SRCPOS = 6,
    VT_DESTPOS = 8
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  const Pos *srcPos() const {
    return GetPointer<const Pos *>(VT_SRCPOS);
  }
  const Pos *destPos() const {
    return GetPointer<const Pos *>(VT_DESTPOS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyOffset(verifier, VT_SRCPOS) &&
           verifier.VerifyTable(srcPos()) &&
           VerifyOffset(verifier, VT_DESTPOS) &&
           verifier.VerifyTable(destPos()) &&
           verifier.EndTable();
  }
};

struct TeleportNotifyOhterPcInViewBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(TeleportNotifyOhterPcInView::VT_OBJECTID, objectId, 0);
  }
  void add_srcPos(flatbuffers::Offset<Pos> srcPos) {
    fbb_.AddOffset(TeleportNotifyOhterPcInView::VT_SRCPOS, srcPos);
  }
  void add_destPos(flatbuffers::Offset<Pos> destPos) {
    fbb_.AddOffset(TeleportNotifyOhterPcInView::VT_DESTPOS, destPos);
  }
  explicit TeleportNotifyOhterPcInViewBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TeleportNotifyOhterPcInViewBuilder &operator=(const TeleportNotifyOhterPcInViewBuilder &);
  flatbuffers::Offset<TeleportNotifyOhterPcInView> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TeleportNotifyOhterPcInView>(end);
    return o;
  }
};

inline flatbuffers::Offset<TeleportNotifyOhterPcInView> CreateTeleportNotifyOhterPcInView(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    flatbuffers::Offset<Pos> srcPos = 0,
    flatbuffers::Offset<Pos> destPos = 0) {
  TeleportNotifyOhterPcInViewBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_destPos(destPos);
  builder_.add_srcPos(srcPos);
  return builder_.Finish();
}

///- ENTER_EVENT_AREA_REQUEST ----------
struct EnterEventAreaRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_EVENTAREAID = 6,
    VT_POS = 8
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int32_t eventAreaId() const {
    return GetField<int32_t>(VT_EVENTAREAID, 0);
  }
  const Pos *pos() const {
    return GetPointer<const Pos *>(VT_POS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int32_t>(verifier, VT_EVENTAREAID) &&
           VerifyOffsetRequired(verifier, VT_POS) &&
           verifier.VerifyTable(pos()) &&
           verifier.EndTable();
  }
};

struct EnterEventAreaRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(EnterEventAreaRequest::VT_OBJECTID, objectId, 0);
  }
  void add_eventAreaId(int32_t eventAreaId) {
    fbb_.AddElement<int32_t>(EnterEventAreaRequest::VT_EVENTAREAID, eventAreaId, 0);
  }
  void add_pos(flatbuffers::Offset<Pos> pos) {
    fbb_.AddOffset(EnterEventAreaRequest::VT_POS, pos);
  }
  explicit EnterEventAreaRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EnterEventAreaRequestBuilder &operator=(const EnterEventAreaRequestBuilder &);
  flatbuffers::Offset<EnterEventAreaRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EnterEventAreaRequest>(end);
    fbb_.Required(o, EnterEventAreaRequest::VT_POS);
    return o;
  }
};

inline flatbuffers::Offset<EnterEventAreaRequest> CreateEnterEventAreaRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int32_t eventAreaId = 0,
    flatbuffers::Offset<Pos> pos = 0) {
  EnterEventAreaRequestBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_pos(pos);
  builder_.add_eventAreaId(eventAreaId);
  return builder_.Finish();
}

///- ENTER_EVENT_AREA_RESPONSE ----------
struct EnterEventAreaResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct EnterEventAreaResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit EnterEventAreaResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EnterEventAreaResponseBuilder &operator=(const EnterEventAreaResponseBuilder &);
  flatbuffers::Offset<EnterEventAreaResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EnterEventAreaResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<EnterEventAreaResponse> CreateEnterEventAreaResponse(
    flatbuffers::FlatBufferBuilder &_fbb) {
  EnterEventAreaResponseBuilder builder_(_fbb);
  return builder_.Finish();
}

///- EVENT_MESSAGE_NOTIFY ----------
struct EventMessageNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_DEBUGMESSAGE = 6
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  const flatbuffers::String *debugMessage() const {
    return GetPointer<const flatbuffers::String *>(VT_DEBUGMESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyOffsetRequired(verifier, VT_DEBUGMESSAGE) &&
           verifier.VerifyString(debugMessage()) &&
           verifier.EndTable();
  }
};

struct EventMessageNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(EventMessageNotify::VT_OBJECTID, objectId, 0);
  }
  void add_debugMessage(flatbuffers::Offset<flatbuffers::String> debugMessage) {
    fbb_.AddOffset(EventMessageNotify::VT_DEBUGMESSAGE, debugMessage);
  }
  explicit EventMessageNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EventMessageNotifyBuilder &operator=(const EventMessageNotifyBuilder &);
  flatbuffers::Offset<EventMessageNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EventMessageNotify>(end);
    fbb_.Required(o, EventMessageNotify::VT_DEBUGMESSAGE);
    return o;
  }
};

inline flatbuffers::Offset<EventMessageNotify> CreateEventMessageNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    flatbuffers::Offset<flatbuffers::String> debugMessage = 0) {
  EventMessageNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_debugMessage(debugMessage);
  return builder_.Finish();
}

inline flatbuffers::Offset<EventMessageNotify> CreateEventMessageNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    const char *debugMessage = nullptr) {
  return LeanPacket::CreateEventMessageNotify(
      _fbb,
      objectId,
      debugMessage ? _fbb.CreateString(debugMessage) : 0);
}

///- SAFE_ZONE_IN_REQUEST ----------
struct SafeZoneInRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EVENTAREAID = 4,
    VT_POS = 6
  };
  int32_t eventAreaId() const {
    return GetField<int32_t>(VT_EVENTAREAID, 0);
  }
  const Pos *pos() const {
    return GetPointer<const Pos *>(VT_POS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_EVENTAREAID) &&
           VerifyOffsetRequired(verifier, VT_POS) &&
           verifier.VerifyTable(pos()) &&
           verifier.EndTable();
  }
};

struct SafeZoneInRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eventAreaId(int32_t eventAreaId) {
    fbb_.AddElement<int32_t>(SafeZoneInRequest::VT_EVENTAREAID, eventAreaId, 0);
  }
  void add_pos(flatbuffers::Offset<Pos> pos) {
    fbb_.AddOffset(SafeZoneInRequest::VT_POS, pos);
  }
  explicit SafeZoneInRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SafeZoneInRequestBuilder &operator=(const SafeZoneInRequestBuilder &);
  flatbuffers::Offset<SafeZoneInRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SafeZoneInRequest>(end);
    fbb_.Required(o, SafeZoneInRequest::VT_POS);
    return o;
  }
};

inline flatbuffers::Offset<SafeZoneInRequest> CreateSafeZoneInRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t eventAreaId = 0,
    flatbuffers::Offset<Pos> pos = 0) {
  SafeZoneInRequestBuilder builder_(_fbb);
  builder_.add_pos(pos);
  builder_.add_eventAreaId(eventAreaId);
  return builder_.Finish();
}

///- SAFE_ZONE_IN_RESPONSE ----------
struct SafeZoneInResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRCODE = 4
  };
  int32_t errCode() const {
    return GetField<int32_t>(VT_ERRCODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           verifier.EndTable();
  }
};

struct SafeZoneInResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errCode(int32_t errCode) {
    fbb_.AddElement<int32_t>(SafeZoneInResponse::VT_ERRCODE, errCode, 0);
  }
  explicit SafeZoneInResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SafeZoneInResponseBuilder &operator=(const SafeZoneInResponseBuilder &);
  flatbuffers::Offset<SafeZoneInResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SafeZoneInResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<SafeZoneInResponse> CreateSafeZoneInResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errCode = 0) {
  SafeZoneInResponseBuilder builder_(_fbb);
  builder_.add_errCode(errCode);
  return builder_.Finish();
}

///- SAFE_ZONE_OUT_REQUEST ----------
struct SafeZoneOutRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EVENTAREAID = 4,
    VT_POS = 6
  };
  int32_t eventAreaId() const {
    return GetField<int32_t>(VT_EVENTAREAID, 0);
  }
  const Pos *pos() const {
    return GetPointer<const Pos *>(VT_POS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_EVENTAREAID) &&
           VerifyOffsetRequired(verifier, VT_POS) &&
           verifier.VerifyTable(pos()) &&
           verifier.EndTable();
  }
};

struct SafeZoneOutRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eventAreaId(int32_t eventAreaId) {
    fbb_.AddElement<int32_t>(SafeZoneOutRequest::VT_EVENTAREAID, eventAreaId, 0);
  }
  void add_pos(flatbuffers::Offset<Pos> pos) {
    fbb_.AddOffset(SafeZoneOutRequest::VT_POS, pos);
  }
  explicit SafeZoneOutRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SafeZoneOutRequestBuilder &operator=(const SafeZoneOutRequestBuilder &);
  flatbuffers::Offset<SafeZoneOutRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SafeZoneOutRequest>(end);
    fbb_.Required(o, SafeZoneOutRequest::VT_POS);
    return o;
  }
};

inline flatbuffers::Offset<SafeZoneOutRequest> CreateSafeZoneOutRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t eventAreaId = 0,
    flatbuffers::Offset<Pos> pos = 0) {
  SafeZoneOutRequestBuilder builder_(_fbb);
  builder_.add_pos(pos);
  builder_.add_eventAreaId(eventAreaId);
  return builder_.Finish();
}

///- SAFE_ZONE_OUT_RESPONSE ----------
struct SafeZoneOutResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRCODE = 4
  };
  int32_t errCode() const {
    return GetField<int32_t>(VT_ERRCODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           verifier.EndTable();
  }
};

struct SafeZoneOutResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errCode(int32_t errCode) {
    fbb_.AddElement<int32_t>(SafeZoneOutResponse::VT_ERRCODE, errCode, 0);
  }
  explicit SafeZoneOutResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SafeZoneOutResponseBuilder &operator=(const SafeZoneOutResponseBuilder &);
  flatbuffers::Offset<SafeZoneOutResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SafeZoneOutResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<SafeZoneOutResponse> CreateSafeZoneOutResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errCode = 0) {
  SafeZoneOutResponseBuilder builder_(_fbb);
  builder_.add_errCode(errCode);
  return builder_.Finish();
}

///- CLIENT_CREATURE_MOVE_NOTIFY ----------
struct ClientCreatureMoveNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_CURPOS = 6,
    VT_DESTPOS = 8,
    VT_MOVETYPE = 10,
    VT_SPEED = 12,
    VT_ANGLE = 14,
    VT_CLIENTTICKCOUNT = 16
  };
  /// 서버에서 이동 시뮬레이션에 필요한 최소 정보
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  const Pos *curPos() const {
    return GetPointer<const Pos *>(VT_CURPOS);
  }
  const Pos *destPos() const {
    return GetPointer<const Pos *>(VT_DESTPOS);
  }
  int32_t moveType() const {
    return GetField<int32_t>(VT_MOVETYPE, 0);
  }
  /// 클라이언트 동작 검증에 사용
  int16_t speed() const {
    return GetField<int16_t>(VT_SPEED, 0);
  }
  int16_t angle() const {
    return GetField<int16_t>(VT_ANGLE, 0);
  }
  int32_t clientTickCount() const {
    return GetField<int32_t>(VT_CLIENTTICKCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyOffsetRequired(verifier, VT_CURPOS) &&
           verifier.VerifyTable(curPos()) &&
           VerifyOffsetRequired(verifier, VT_DESTPOS) &&
           verifier.VerifyTable(destPos()) &&
           VerifyField<int32_t>(verifier, VT_MOVETYPE) &&
           VerifyField<int16_t>(verifier, VT_SPEED) &&
           VerifyField<int16_t>(verifier, VT_ANGLE) &&
           VerifyField<int32_t>(verifier, VT_CLIENTTICKCOUNT) &&
           verifier.EndTable();
  }
};

struct ClientCreatureMoveNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(ClientCreatureMoveNotify::VT_OBJECTID, objectId, 0);
  }
  void add_curPos(flatbuffers::Offset<Pos> curPos) {
    fbb_.AddOffset(ClientCreatureMoveNotify::VT_CURPOS, curPos);
  }
  void add_destPos(flatbuffers::Offset<Pos> destPos) {
    fbb_.AddOffset(ClientCreatureMoveNotify::VT_DESTPOS, destPos);
  }
  void add_moveType(int32_t moveType) {
    fbb_.AddElement<int32_t>(ClientCreatureMoveNotify::VT_MOVETYPE, moveType, 0);
  }
  void add_speed(int16_t speed) {
    fbb_.AddElement<int16_t>(ClientCreatureMoveNotify::VT_SPEED, speed, 0);
  }
  void add_angle(int16_t angle) {
    fbb_.AddElement<int16_t>(ClientCreatureMoveNotify::VT_ANGLE, angle, 0);
  }
  void add_clientTickCount(int32_t clientTickCount) {
    fbb_.AddElement<int32_t>(ClientCreatureMoveNotify::VT_CLIENTTICKCOUNT, clientTickCount, 0);
  }
  explicit ClientCreatureMoveNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClientCreatureMoveNotifyBuilder &operator=(const ClientCreatureMoveNotifyBuilder &);
  flatbuffers::Offset<ClientCreatureMoveNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientCreatureMoveNotify>(end);
    fbb_.Required(o, ClientCreatureMoveNotify::VT_CURPOS);
    fbb_.Required(o, ClientCreatureMoveNotify::VT_DESTPOS);
    return o;
  }
};

inline flatbuffers::Offset<ClientCreatureMoveNotify> CreateClientCreatureMoveNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    flatbuffers::Offset<Pos> curPos = 0,
    flatbuffers::Offset<Pos> destPos = 0,
    int32_t moveType = 0,
    int16_t speed = 0,
    int16_t angle = 0,
    int32_t clientTickCount = 0) {
  ClientCreatureMoveNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_clientTickCount(clientTickCount);
  builder_.add_moveType(moveType);
  builder_.add_destPos(destPos);
  builder_.add_curPos(curPos);
  builder_.add_angle(angle);
  builder_.add_speed(speed);
  return builder_.Finish();
}

/// SERVER_CREATURE_MOVE_NOTIFY ----------
struct ServerCreatureMoveNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_CURPOS = 6,
    VT_ANGLE = 8,
    VT_SPEED = 10,
    VT_DESTPOS = 12,
    VT_DESTANGLE = 14,
    VT_MOVETYPE = 16
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  const Pos *curPos() const {
    return GetPointer<const Pos *>(VT_CURPOS);
  }
  int16_t angle() const {
    return GetField<int16_t>(VT_ANGLE, 0);
  }
  int32_t speed() const {
    return GetField<int32_t>(VT_SPEED, 0);
  }
  const Pos *destPos() const {
    return GetPointer<const Pos *>(VT_DESTPOS);
  }
  int16_t destAngle() const {
    return GetField<int16_t>(VT_DESTANGLE, 0);
  }
  int32_t moveType() const {
    return GetField<int32_t>(VT_MOVETYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyOffsetRequired(verifier, VT_CURPOS) &&
           verifier.VerifyTable(curPos()) &&
           VerifyField<int16_t>(verifier, VT_ANGLE) &&
           VerifyField<int32_t>(verifier, VT_SPEED) &&
           VerifyOffsetRequired(verifier, VT_DESTPOS) &&
           verifier.VerifyTable(destPos()) &&
           VerifyField<int16_t>(verifier, VT_DESTANGLE) &&
           VerifyField<int32_t>(verifier, VT_MOVETYPE) &&
           verifier.EndTable();
  }
};

struct ServerCreatureMoveNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(ServerCreatureMoveNotify::VT_OBJECTID, objectId, 0);
  }
  void add_curPos(flatbuffers::Offset<Pos> curPos) {
    fbb_.AddOffset(ServerCreatureMoveNotify::VT_CURPOS, curPos);
  }
  void add_angle(int16_t angle) {
    fbb_.AddElement<int16_t>(ServerCreatureMoveNotify::VT_ANGLE, angle, 0);
  }
  void add_speed(int32_t speed) {
    fbb_.AddElement<int32_t>(ServerCreatureMoveNotify::VT_SPEED, speed, 0);
  }
  void add_destPos(flatbuffers::Offset<Pos> destPos) {
    fbb_.AddOffset(ServerCreatureMoveNotify::VT_DESTPOS, destPos);
  }
  void add_destAngle(int16_t destAngle) {
    fbb_.AddElement<int16_t>(ServerCreatureMoveNotify::VT_DESTANGLE, destAngle, 0);
  }
  void add_moveType(int32_t moveType) {
    fbb_.AddElement<int32_t>(ServerCreatureMoveNotify::VT_MOVETYPE, moveType, 0);
  }
  explicit ServerCreatureMoveNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerCreatureMoveNotifyBuilder &operator=(const ServerCreatureMoveNotifyBuilder &);
  flatbuffers::Offset<ServerCreatureMoveNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerCreatureMoveNotify>(end);
    fbb_.Required(o, ServerCreatureMoveNotify::VT_CURPOS);
    fbb_.Required(o, ServerCreatureMoveNotify::VT_DESTPOS);
    return o;
  }
};

inline flatbuffers::Offset<ServerCreatureMoveNotify> CreateServerCreatureMoveNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    flatbuffers::Offset<Pos> curPos = 0,
    int16_t angle = 0,
    int32_t speed = 0,
    flatbuffers::Offset<Pos> destPos = 0,
    int16_t destAngle = 0,
    int32_t moveType = 0) {
  ServerCreatureMoveNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_moveType(moveType);
  builder_.add_destPos(destPos);
  builder_.add_speed(speed);
  builder_.add_curPos(curPos);
  builder_.add_destAngle(destAngle);
  builder_.add_angle(angle);
  return builder_.Finish();
}

/// CLIENT_SHORT_TERM_MOVE_NOTIFY
struct ClientShortTermMoveNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_CURPOS = 6,
    VT_MOVETYPE = 8
  };
  /// 이동에 필요한 최소 정보 (ex. 0.3s 주기)
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  const Pos *curPos() const {
    return GetPointer<const Pos *>(VT_CURPOS);
  }
  int32_t moveType() const {
    return GetField<int32_t>(VT_MOVETYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyOffsetRequired(verifier, VT_CURPOS) &&
           verifier.VerifyTable(curPos()) &&
           VerifyField<int32_t>(verifier, VT_MOVETYPE) &&
           verifier.EndTable();
  }
};

struct ClientShortTermMoveNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(ClientShortTermMoveNotify::VT_OBJECTID, objectId, 0);
  }
  void add_curPos(flatbuffers::Offset<Pos> curPos) {
    fbb_.AddOffset(ClientShortTermMoveNotify::VT_CURPOS, curPos);
  }
  void add_moveType(int32_t moveType) {
    fbb_.AddElement<int32_t>(ClientShortTermMoveNotify::VT_MOVETYPE, moveType, 0);
  }
  explicit ClientShortTermMoveNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClientShortTermMoveNotifyBuilder &operator=(const ClientShortTermMoveNotifyBuilder &);
  flatbuffers::Offset<ClientShortTermMoveNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientShortTermMoveNotify>(end);
    fbb_.Required(o, ClientShortTermMoveNotify::VT_CURPOS);
    return o;
  }
};

inline flatbuffers::Offset<ClientShortTermMoveNotify> CreateClientShortTermMoveNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    flatbuffers::Offset<Pos> curPos = 0,
    int32_t moveType = 0) {
  ClientShortTermMoveNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_moveType(moveType);
  builder_.add_curPos(curPos);
  return builder_.Finish();
}

/// CLIENT_LONG_TERM_MOVE_NOTIFY
struct ClientLongTermMoveNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_ANGLE = 6
  };
  /// 이동에 필요한 부가 정보 (ex. 1s 주기)
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int16_t angle() const {
    return GetField<int16_t>(VT_ANGLE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int16_t>(verifier, VT_ANGLE) &&
           verifier.EndTable();
  }
};

struct ClientLongTermMoveNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(ClientLongTermMoveNotify::VT_OBJECTID, objectId, 0);
  }
  void add_angle(int16_t angle) {
    fbb_.AddElement<int16_t>(ClientLongTermMoveNotify::VT_ANGLE, angle, 0);
  }
  explicit ClientLongTermMoveNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClientLongTermMoveNotifyBuilder &operator=(const ClientLongTermMoveNotifyBuilder &);
  flatbuffers::Offset<ClientLongTermMoveNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientLongTermMoveNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClientLongTermMoveNotify> CreateClientLongTermMoveNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int16_t angle = 0) {
  ClientLongTermMoveNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_angle(angle);
  return builder_.Finish();
}

/// SERVER_SHORT_TERM_MOVE_NOTIFY
struct ServerShortTermMoveNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_CURPOS = 6,
    VT_MOVETYPE = 8,
    VT_MOVESPEED = 10
  };
  /// 클라에서 이동 시뮬레이션에 필요한 최소 정보
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  const Pos *curPos() const {
    return GetPointer<const Pos *>(VT_CURPOS);
  }
  int32_t moveType() const {
    return GetField<int32_t>(VT_MOVETYPE, 0);
  }
  int32_t moveSpeed() const {
    return GetField<int32_t>(VT_MOVESPEED, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyOffsetRequired(verifier, VT_CURPOS) &&
           verifier.VerifyTable(curPos()) &&
           VerifyField<int32_t>(verifier, VT_MOVETYPE) &&
           VerifyField<int32_t>(verifier, VT_MOVESPEED) &&
           verifier.EndTable();
  }
};

struct ServerShortTermMoveNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(ServerShortTermMoveNotify::VT_OBJECTID, objectId, 0);
  }
  void add_curPos(flatbuffers::Offset<Pos> curPos) {
    fbb_.AddOffset(ServerShortTermMoveNotify::VT_CURPOS, curPos);
  }
  void add_moveType(int32_t moveType) {
    fbb_.AddElement<int32_t>(ServerShortTermMoveNotify::VT_MOVETYPE, moveType, 0);
  }
  void add_moveSpeed(int32_t moveSpeed) {
    fbb_.AddElement<int32_t>(ServerShortTermMoveNotify::VT_MOVESPEED, moveSpeed, 0);
  }
  explicit ServerShortTermMoveNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerShortTermMoveNotifyBuilder &operator=(const ServerShortTermMoveNotifyBuilder &);
  flatbuffers::Offset<ServerShortTermMoveNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerShortTermMoveNotify>(end);
    fbb_.Required(o, ServerShortTermMoveNotify::VT_CURPOS);
    return o;
  }
};

inline flatbuffers::Offset<ServerShortTermMoveNotify> CreateServerShortTermMoveNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    flatbuffers::Offset<Pos> curPos = 0,
    int32_t moveType = 0,
    int32_t moveSpeed = 0) {
  ServerShortTermMoveNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_moveSpeed(moveSpeed);
  builder_.add_moveType(moveType);
  builder_.add_curPos(curPos);
  return builder_.Finish();
}

/// SERVER_LONG_TERM_MOVE_NOTIFY
struct ServerLongTermMoveNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_ANGLE = 6
  };
  /// 이동에 필요한 부가 정보 (ex. 1s 주기)
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int16_t angle() const {
    return GetField<int16_t>(VT_ANGLE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int16_t>(verifier, VT_ANGLE) &&
           verifier.EndTable();
  }
};

struct ServerLongTermMoveNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(ServerLongTermMoveNotify::VT_OBJECTID, objectId, 0);
  }
  void add_angle(int16_t angle) {
    fbb_.AddElement<int16_t>(ServerLongTermMoveNotify::VT_ANGLE, angle, 0);
  }
  explicit ServerLongTermMoveNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerLongTermMoveNotifyBuilder &operator=(const ServerLongTermMoveNotifyBuilder &);
  flatbuffers::Offset<ServerLongTermMoveNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerLongTermMoveNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerLongTermMoveNotify> CreateServerLongTermMoveNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int16_t angle = 0) {
  ServerLongTermMoveNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_angle(angle);
  return builder_.Finish();
}

/// EVENT_DIRECTION_BEGIN_NOTIFY 서버 -> 클라
struct EventDirectionBeginNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EVENTSETID = 4,
    VT_EVENTID = 6,
    VT_REACTIONTYPE = 8,
    VT_DIRECTIONID = 10,
    VT_RESPONSEID = 12
  };
  int32_t eventSetId() const {
    return GetField<int32_t>(VT_EVENTSETID, 0);
  }
  int32_t eventId() const {
    return GetField<int32_t>(VT_EVENTID, 0);
  }
  int32_t reactionType() const {
    return GetField<int32_t>(VT_REACTIONTYPE, 0);
  }
  int32_t directionId() const {
    return GetField<int32_t>(VT_DIRECTIONID, 0);
  }
  int32_t responseId() const {
    return GetField<int32_t>(VT_RESPONSEID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_EVENTSETID) &&
           VerifyField<int32_t>(verifier, VT_EVENTID) &&
           VerifyField<int32_t>(verifier, VT_REACTIONTYPE) &&
           VerifyField<int32_t>(verifier, VT_DIRECTIONID) &&
           VerifyField<int32_t>(verifier, VT_RESPONSEID) &&
           verifier.EndTable();
  }
};

struct EventDirectionBeginNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eventSetId(int32_t eventSetId) {
    fbb_.AddElement<int32_t>(EventDirectionBeginNotify::VT_EVENTSETID, eventSetId, 0);
  }
  void add_eventId(int32_t eventId) {
    fbb_.AddElement<int32_t>(EventDirectionBeginNotify::VT_EVENTID, eventId, 0);
  }
  void add_reactionType(int32_t reactionType) {
    fbb_.AddElement<int32_t>(EventDirectionBeginNotify::VT_REACTIONTYPE, reactionType, 0);
  }
  void add_directionId(int32_t directionId) {
    fbb_.AddElement<int32_t>(EventDirectionBeginNotify::VT_DIRECTIONID, directionId, 0);
  }
  void add_responseId(int32_t responseId) {
    fbb_.AddElement<int32_t>(EventDirectionBeginNotify::VT_RESPONSEID, responseId, 0);
  }
  explicit EventDirectionBeginNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EventDirectionBeginNotifyBuilder &operator=(const EventDirectionBeginNotifyBuilder &);
  flatbuffers::Offset<EventDirectionBeginNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EventDirectionBeginNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<EventDirectionBeginNotify> CreateEventDirectionBeginNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t eventSetId = 0,
    int32_t eventId = 0,
    int32_t reactionType = 0,
    int32_t directionId = 0,
    int32_t responseId = 0) {
  EventDirectionBeginNotifyBuilder builder_(_fbb);
  builder_.add_responseId(responseId);
  builder_.add_directionId(directionId);
  builder_.add_reactionType(reactionType);
  builder_.add_eventId(eventId);
  builder_.add_eventSetId(eventSetId);
  return builder_.Finish();
}

///  EVENT_DIRECTION_FINISH_NOTIFY 클라 -> 서버
struct EventDirectionFinishNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EVENTSETID = 4,
    VT_EVENTID = 6,
    VT_RESPONSEID = 8
  };
  int32_t eventSetId() const {
    return GetField<int32_t>(VT_EVENTSETID, 0);
  }
  int32_t eventId() const {
    return GetField<int32_t>(VT_EVENTID, 0);
  }
  int32_t responseId() const {
    return GetField<int32_t>(VT_RESPONSEID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_EVENTSETID) &&
           VerifyField<int32_t>(verifier, VT_EVENTID) &&
           VerifyField<int32_t>(verifier, VT_RESPONSEID) &&
           verifier.EndTable();
  }
};

struct EventDirectionFinishNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eventSetId(int32_t eventSetId) {
    fbb_.AddElement<int32_t>(EventDirectionFinishNotify::VT_EVENTSETID, eventSetId, 0);
  }
  void add_eventId(int32_t eventId) {
    fbb_.AddElement<int32_t>(EventDirectionFinishNotify::VT_EVENTID, eventId, 0);
  }
  void add_responseId(int32_t responseId) {
    fbb_.AddElement<int32_t>(EventDirectionFinishNotify::VT_RESPONSEID, responseId, 0);
  }
  explicit EventDirectionFinishNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EventDirectionFinishNotifyBuilder &operator=(const EventDirectionFinishNotifyBuilder &);
  flatbuffers::Offset<EventDirectionFinishNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EventDirectionFinishNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<EventDirectionFinishNotify> CreateEventDirectionFinishNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t eventSetId = 0,
    int32_t eventId = 0,
    int32_t responseId = 0) {
  EventDirectionFinishNotifyBuilder builder_(_fbb);
  builder_.add_responseId(responseId);
  builder_.add_eventId(eventId);
  builder_.add_eventSetId(eventSetId);
  return builder_.Finish();
}

struct ContributionPoint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_POINT = 6
  };
  int16_t type() const {
    return GetField<int16_t>(VT_TYPE, 0);
  }
  double point() const {
    return GetField<double>(VT_POINT, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPE) &&
           VerifyField<double>(verifier, VT_POINT) &&
           verifier.EndTable();
  }
};

struct ContributionPointBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int16_t type) {
    fbb_.AddElement<int16_t>(ContributionPoint::VT_TYPE, type, 0);
  }
  void add_point(double point) {
    fbb_.AddElement<double>(ContributionPoint::VT_POINT, point, 0.0);
  }
  explicit ContributionPointBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ContributionPointBuilder &operator=(const ContributionPointBuilder &);
  flatbuffers::Offset<ContributionPoint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ContributionPoint>(end);
    return o;
  }
};

inline flatbuffers::Offset<ContributionPoint> CreateContributionPoint(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t type = 0,
    double point = 0.0) {
  ContributionPointBuilder builder_(_fbb);
  builder_.add_point(point);
  builder_.add_type(type);
  return builder_.Finish();
}

struct EventContribution FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_PCNAME = 6,
    VT_RANK = 8,
    VT_RANKING = 10,
    VT_CONTRIBUTION = 12,
    VT_ACQPOINTS = 14
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  const flatbuffers::String *pcName() const {
    return GetPointer<const flatbuffers::String *>(VT_PCNAME);
  }
  EventRankType rank() const {
    return static_cast<EventRankType>(GetField<int32_t>(VT_RANK, 0));
  }
  int32_t ranking() const {
    return GetField<int32_t>(VT_RANKING, 0);
  }
  double contribution() const {
    return GetField<double>(VT_CONTRIBUTION, 0.0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ContributionPoint>> *acqPoints() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ContributionPoint>> *>(VT_ACQPOINTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyOffsetRequired(verifier, VT_PCNAME) &&
           verifier.VerifyString(pcName()) &&
           VerifyField<int32_t>(verifier, VT_RANK) &&
           VerifyField<int32_t>(verifier, VT_RANKING) &&
           VerifyField<double>(verifier, VT_CONTRIBUTION) &&
           VerifyOffset(verifier, VT_ACQPOINTS) &&
           verifier.VerifyVector(acqPoints()) &&
           verifier.VerifyVectorOfTables(acqPoints()) &&
           verifier.EndTable();
  }
};

struct EventContributionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(EventContribution::VT_OBJECTID, objectId, 0);
  }
  void add_pcName(flatbuffers::Offset<flatbuffers::String> pcName) {
    fbb_.AddOffset(EventContribution::VT_PCNAME, pcName);
  }
  void add_rank(EventRankType rank) {
    fbb_.AddElement<int32_t>(EventContribution::VT_RANK, static_cast<int32_t>(rank), 0);
  }
  void add_ranking(int32_t ranking) {
    fbb_.AddElement<int32_t>(EventContribution::VT_RANKING, ranking, 0);
  }
  void add_contribution(double contribution) {
    fbb_.AddElement<double>(EventContribution::VT_CONTRIBUTION, contribution, 0.0);
  }
  void add_acqPoints(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ContributionPoint>>> acqPoints) {
    fbb_.AddOffset(EventContribution::VT_ACQPOINTS, acqPoints);
  }
  explicit EventContributionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EventContributionBuilder &operator=(const EventContributionBuilder &);
  flatbuffers::Offset<EventContribution> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EventContribution>(end);
    fbb_.Required(o, EventContribution::VT_PCNAME);
    return o;
  }
};

inline flatbuffers::Offset<EventContribution> CreateEventContribution(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    flatbuffers::Offset<flatbuffers::String> pcName = 0,
    EventRankType rank = EventRankType_ERT_SRANK,
    int32_t ranking = 0,
    double contribution = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ContributionPoint>>> acqPoints = 0) {
  EventContributionBuilder builder_(_fbb);
  builder_.add_contribution(contribution);
  builder_.add_objectId(objectId);
  builder_.add_acqPoints(acqPoints);
  builder_.add_ranking(ranking);
  builder_.add_rank(rank);
  builder_.add_pcName(pcName);
  return builder_.Finish();
}

inline flatbuffers::Offset<EventContribution> CreateEventContributionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    const char *pcName = nullptr,
    EventRankType rank = EventRankType_ERT_SRANK,
    int32_t ranking = 0,
    double contribution = 0.0,
    const std::vector<flatbuffers::Offset<ContributionPoint>> *acqPoints = nullptr) {
  return LeanPacket::CreateEventContribution(
      _fbb,
      objectId,
      pcName ? _fbb.CreateString(pcName) : 0,
      rank,
      ranking,
      contribution,
      acqPoints ? _fbb.CreateVector<flatbuffers::Offset<ContributionPoint>>(*acqPoints) : 0);
}

/// NOTIFY_EVENT_CONTRIBUTION
struct NotifyEventContribution FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONTRIBUTIONS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<EventContribution>> *contributions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EventContribution>> *>(VT_CONTRIBUTIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CONTRIBUTIONS) &&
           verifier.VerifyVector(contributions()) &&
           verifier.VerifyVectorOfTables(contributions()) &&
           verifier.EndTable();
  }
};

struct NotifyEventContributionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_contributions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EventContribution>>> contributions) {
    fbb_.AddOffset(NotifyEventContribution::VT_CONTRIBUTIONS, contributions);
  }
  explicit NotifyEventContributionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NotifyEventContributionBuilder &operator=(const NotifyEventContributionBuilder &);
  flatbuffers::Offset<NotifyEventContribution> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NotifyEventContribution>(end);
    fbb_.Required(o, NotifyEventContribution::VT_CONTRIBUTIONS);
    return o;
  }
};

inline flatbuffers::Offset<NotifyEventContribution> CreateNotifyEventContribution(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EventContribution>>> contributions = 0) {
  NotifyEventContributionBuilder builder_(_fbb);
  builder_.add_contributions(contributions);
  return builder_.Finish();
}

inline flatbuffers::Offset<NotifyEventContribution> CreateNotifyEventContributionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<EventContribution>> *contributions = nullptr) {
  return LeanPacket::CreateNotifyEventContribution(
      _fbb,
      contributions ? _fbb.CreateVector<flatbuffers::Offset<EventContribution>>(*contributions) : 0);
}

struct BattleRealmGuildContribution FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GUILDID = 4,
    VT_GUILDNAME = 6,
    VT_GUILDCREST = 8,
    VT_REALMID = 10,
    VT_RANKING = 12,
    VT_DAMAGEPOINT = 14,
    VT_INTERACTPOINT = 16,
    VT_TOTALPOINT = 18,
    VT_PARTICIPANT = 20,
    VT_REALMRANKING = 22,
    VT_WORLDID = 24
  };
  int32_t guildId() const {
    return GetField<int32_t>(VT_GUILDID, 0);
  }
  const flatbuffers::String *guildName() const {
    return GetPointer<const flatbuffers::String *>(VT_GUILDNAME);
  }
  const GuildCrest *guildCrest() const {
    return GetPointer<const GuildCrest *>(VT_GUILDCREST);
  }
  int32_t realmId() const {
    return GetField<int32_t>(VT_REALMID, 0);
  }
  int32_t ranking() const {
    return GetField<int32_t>(VT_RANKING, 0);
  }
  double damagePoint() const {
    return GetField<double>(VT_DAMAGEPOINT, 0.0);
  }
  double interactPoint() const {
    return GetField<double>(VT_INTERACTPOINT, 0.0);
  }
  double totalPoint() const {
    return GetField<double>(VT_TOTALPOINT, 0.0);
  }
  int32_t participant() const {
    return GetField<int32_t>(VT_PARTICIPANT, 0);
  }
  int32_t realmRanking() const {
    return GetField<int32_t>(VT_REALMRANKING, 0);
  }
  int16_t worldId() const {
    return GetField<int16_t>(VT_WORLDID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_GUILDID) &&
           VerifyOffsetRequired(verifier, VT_GUILDNAME) &&
           verifier.VerifyString(guildName()) &&
           VerifyOffsetRequired(verifier, VT_GUILDCREST) &&
           verifier.VerifyTable(guildCrest()) &&
           VerifyField<int32_t>(verifier, VT_REALMID) &&
           VerifyField<int32_t>(verifier, VT_RANKING) &&
           VerifyField<double>(verifier, VT_DAMAGEPOINT) &&
           VerifyField<double>(verifier, VT_INTERACTPOINT) &&
           VerifyField<double>(verifier, VT_TOTALPOINT) &&
           VerifyField<int32_t>(verifier, VT_PARTICIPANT) &&
           VerifyField<int32_t>(verifier, VT_REALMRANKING) &&
           VerifyField<int16_t>(verifier, VT_WORLDID) &&
           verifier.EndTable();
  }
};

struct BattleRealmGuildContributionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_guildId(int32_t guildId) {
    fbb_.AddElement<int32_t>(BattleRealmGuildContribution::VT_GUILDID, guildId, 0);
  }
  void add_guildName(flatbuffers::Offset<flatbuffers::String> guildName) {
    fbb_.AddOffset(BattleRealmGuildContribution::VT_GUILDNAME, guildName);
  }
  void add_guildCrest(flatbuffers::Offset<GuildCrest> guildCrest) {
    fbb_.AddOffset(BattleRealmGuildContribution::VT_GUILDCREST, guildCrest);
  }
  void add_realmId(int32_t realmId) {
    fbb_.AddElement<int32_t>(BattleRealmGuildContribution::VT_REALMID, realmId, 0);
  }
  void add_ranking(int32_t ranking) {
    fbb_.AddElement<int32_t>(BattleRealmGuildContribution::VT_RANKING, ranking, 0);
  }
  void add_damagePoint(double damagePoint) {
    fbb_.AddElement<double>(BattleRealmGuildContribution::VT_DAMAGEPOINT, damagePoint, 0.0);
  }
  void add_interactPoint(double interactPoint) {
    fbb_.AddElement<double>(BattleRealmGuildContribution::VT_INTERACTPOINT, interactPoint, 0.0);
  }
  void add_totalPoint(double totalPoint) {
    fbb_.AddElement<double>(BattleRealmGuildContribution::VT_TOTALPOINT, totalPoint, 0.0);
  }
  void add_participant(int32_t participant) {
    fbb_.AddElement<int32_t>(BattleRealmGuildContribution::VT_PARTICIPANT, participant, 0);
  }
  void add_realmRanking(int32_t realmRanking) {
    fbb_.AddElement<int32_t>(BattleRealmGuildContribution::VT_REALMRANKING, realmRanking, 0);
  }
  void add_worldId(int16_t worldId) {
    fbb_.AddElement<int16_t>(BattleRealmGuildContribution::VT_WORLDID, worldId, 0);
  }
  explicit BattleRealmGuildContributionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BattleRealmGuildContributionBuilder &operator=(const BattleRealmGuildContributionBuilder &);
  flatbuffers::Offset<BattleRealmGuildContribution> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BattleRealmGuildContribution>(end);
    fbb_.Required(o, BattleRealmGuildContribution::VT_GUILDNAME);
    fbb_.Required(o, BattleRealmGuildContribution::VT_GUILDCREST);
    return o;
  }
};

inline flatbuffers::Offset<BattleRealmGuildContribution> CreateBattleRealmGuildContribution(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t guildId = 0,
    flatbuffers::Offset<flatbuffers::String> guildName = 0,
    flatbuffers::Offset<GuildCrest> guildCrest = 0,
    int32_t realmId = 0,
    int32_t ranking = 0,
    double damagePoint = 0.0,
    double interactPoint = 0.0,
    double totalPoint = 0.0,
    int32_t participant = 0,
    int32_t realmRanking = 0,
    int16_t worldId = 0) {
  BattleRealmGuildContributionBuilder builder_(_fbb);
  builder_.add_totalPoint(totalPoint);
  builder_.add_interactPoint(interactPoint);
  builder_.add_damagePoint(damagePoint);
  builder_.add_realmRanking(realmRanking);
  builder_.add_participant(participant);
  builder_.add_ranking(ranking);
  builder_.add_realmId(realmId);
  builder_.add_guildCrest(guildCrest);
  builder_.add_guildName(guildName);
  builder_.add_guildId(guildId);
  builder_.add_worldId(worldId);
  return builder_.Finish();
}

inline flatbuffers::Offset<BattleRealmGuildContribution> CreateBattleRealmGuildContributionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t guildId = 0,
    const char *guildName = nullptr,
    flatbuffers::Offset<GuildCrest> guildCrest = 0,
    int32_t realmId = 0,
    int32_t ranking = 0,
    double damagePoint = 0.0,
    double interactPoint = 0.0,
    double totalPoint = 0.0,
    int32_t participant = 0,
    int32_t realmRanking = 0,
    int16_t worldId = 0) {
  return LeanPacket::CreateBattleRealmGuildContribution(
      _fbb,
      guildId,
      guildName ? _fbb.CreateString(guildName) : 0,
      guildCrest,
      realmId,
      ranking,
      damagePoint,
      interactPoint,
      totalPoint,
      participant,
      realmRanking,
      worldId);
}

/// EVENT_BATTLE_REALM_CONTRIBUTION_NOTIFY
struct EventBattleRealmContributionNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MYGUILDCONTRIBUTION = 4,
    VT_RANKGUILDCONTRIBUTIONS = 6,
    VT_ASLANPOINT = 8,
    VT_HARMIONPOINT = 10
  };
  const BattleRealmGuildContribution *myGuildContribution() const {
    return GetPointer<const BattleRealmGuildContribution *>(VT_MYGUILDCONTRIBUTION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<BattleRealmGuildContribution>> *rankGuildContributions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BattleRealmGuildContribution>> *>(VT_RANKGUILDCONTRIBUTIONS);
  }
  double aslanPoint() const {
    return GetField<double>(VT_ASLANPOINT, 0.0);
  }
  double harmionPoint() const {
    return GetField<double>(VT_HARMIONPOINT, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_MYGUILDCONTRIBUTION) &&
           verifier.VerifyTable(myGuildContribution()) &&
           VerifyOffsetRequired(verifier, VT_RANKGUILDCONTRIBUTIONS) &&
           verifier.VerifyVector(rankGuildContributions()) &&
           verifier.VerifyVectorOfTables(rankGuildContributions()) &&
           VerifyField<double>(verifier, VT_ASLANPOINT) &&
           VerifyField<double>(verifier, VT_HARMIONPOINT) &&
           verifier.EndTable();
  }
};

struct EventBattleRealmContributionNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_myGuildContribution(flatbuffers::Offset<BattleRealmGuildContribution> myGuildContribution) {
    fbb_.AddOffset(EventBattleRealmContributionNotify::VT_MYGUILDCONTRIBUTION, myGuildContribution);
  }
  void add_rankGuildContributions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BattleRealmGuildContribution>>> rankGuildContributions) {
    fbb_.AddOffset(EventBattleRealmContributionNotify::VT_RANKGUILDCONTRIBUTIONS, rankGuildContributions);
  }
  void add_aslanPoint(double aslanPoint) {
    fbb_.AddElement<double>(EventBattleRealmContributionNotify::VT_ASLANPOINT, aslanPoint, 0.0);
  }
  void add_harmionPoint(double harmionPoint) {
    fbb_.AddElement<double>(EventBattleRealmContributionNotify::VT_HARMIONPOINT, harmionPoint, 0.0);
  }
  explicit EventBattleRealmContributionNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EventBattleRealmContributionNotifyBuilder &operator=(const EventBattleRealmContributionNotifyBuilder &);
  flatbuffers::Offset<EventBattleRealmContributionNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EventBattleRealmContributionNotify>(end);
    fbb_.Required(o, EventBattleRealmContributionNotify::VT_MYGUILDCONTRIBUTION);
    fbb_.Required(o, EventBattleRealmContributionNotify::VT_RANKGUILDCONTRIBUTIONS);
    return o;
  }
};

inline flatbuffers::Offset<EventBattleRealmContributionNotify> CreateEventBattleRealmContributionNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<BattleRealmGuildContribution> myGuildContribution = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BattleRealmGuildContribution>>> rankGuildContributions = 0,
    double aslanPoint = 0.0,
    double harmionPoint = 0.0) {
  EventBattleRealmContributionNotifyBuilder builder_(_fbb);
  builder_.add_harmionPoint(harmionPoint);
  builder_.add_aslanPoint(aslanPoint);
  builder_.add_rankGuildContributions(rankGuildContributions);
  builder_.add_myGuildContribution(myGuildContribution);
  return builder_.Finish();
}

inline flatbuffers::Offset<EventBattleRealmContributionNotify> CreateEventBattleRealmContributionNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<BattleRealmGuildContribution> myGuildContribution = 0,
    const std::vector<flatbuffers::Offset<BattleRealmGuildContribution>> *rankGuildContributions = nullptr,
    double aslanPoint = 0.0,
    double harmionPoint = 0.0) {
  return LeanPacket::CreateEventBattleRealmContributionNotify(
      _fbb,
      myGuildContribution,
      rankGuildContributions ? _fbb.CreateVector<flatbuffers::Offset<BattleRealmGuildContribution>>(*rankGuildContributions) : 0,
      aslanPoint,
      harmionPoint);
}

struct RewardItemInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMID = 4,
    VT_AMOUNT = 6,
    VT_GRADE = 8
  };
  int32_t itemId() const {
    return GetField<int32_t>(VT_ITEMID, 0);
  }
  int32_t amount() const {
    return GetField<int32_t>(VT_AMOUNT, 0);
  }
  int16_t grade() const {
    return GetField<int16_t>(VT_GRADE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ITEMID) &&
           VerifyField<int32_t>(verifier, VT_AMOUNT) &&
           VerifyField<int16_t>(verifier, VT_GRADE) &&
           verifier.EndTable();
  }
};

struct RewardItemInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemId(int32_t itemId) {
    fbb_.AddElement<int32_t>(RewardItemInfo::VT_ITEMID, itemId, 0);
  }
  void add_amount(int32_t amount) {
    fbb_.AddElement<int32_t>(RewardItemInfo::VT_AMOUNT, amount, 0);
  }
  void add_grade(int16_t grade) {
    fbb_.AddElement<int16_t>(RewardItemInfo::VT_GRADE, grade, 0);
  }
  explicit RewardItemInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RewardItemInfoBuilder &operator=(const RewardItemInfoBuilder &);
  flatbuffers::Offset<RewardItemInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RewardItemInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<RewardItemInfo> CreateRewardItemInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t itemId = 0,
    int32_t amount = 0,
    int16_t grade = 0) {
  RewardItemInfoBuilder builder_(_fbb);
  builder_.add_amount(amount);
  builder_.add_itemId(itemId);
  builder_.add_grade(grade);
  return builder_.Finish();
}

struct RewardInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COSTINFO = 4,
    VT_ITEMS = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<CostInfo>> *costInfo() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CostInfo>> *>(VT_COSTINFO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<RewardItemInfo>> *items() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<RewardItemInfo>> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_COSTINFO) &&
           verifier.VerifyVector(costInfo()) &&
           verifier.VerifyVectorOfTables(costInfo()) &&
           VerifyOffsetRequired(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.VerifyVectorOfTables(items()) &&
           verifier.EndTable();
  }
};

struct RewardInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_costInfo(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CostInfo>>> costInfo) {
    fbb_.AddOffset(RewardInfo::VT_COSTINFO, costInfo);
  }
  void add_items(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RewardItemInfo>>> items) {
    fbb_.AddOffset(RewardInfo::VT_ITEMS, items);
  }
  explicit RewardInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RewardInfoBuilder &operator=(const RewardInfoBuilder &);
  flatbuffers::Offset<RewardInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RewardInfo>(end);
    fbb_.Required(o, RewardInfo::VT_COSTINFO);
    fbb_.Required(o, RewardInfo::VT_ITEMS);
    return o;
  }
};

inline flatbuffers::Offset<RewardInfo> CreateRewardInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CostInfo>>> costInfo = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RewardItemInfo>>> items = 0) {
  RewardInfoBuilder builder_(_fbb);
  builder_.add_items(items);
  builder_.add_costInfo(costInfo);
  return builder_.Finish();
}

inline flatbuffers::Offset<RewardInfo> CreateRewardInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<CostInfo>> *costInfo = nullptr,
    const std::vector<flatbuffers::Offset<RewardItemInfo>> *items = nullptr) {
  return LeanPacket::CreateRewardInfo(
      _fbb,
      costInfo ? _fbb.CreateVector<flatbuffers::Offset<CostInfo>>(*costInfo) : 0,
      items ? _fbb.CreateVector<flatbuffers::Offset<RewardItemInfo>>(*items) : 0);
}

struct ResultRewardInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_REWARDINFO = 6
  };
  ResultRewardType type() const {
    return static_cast<ResultRewardType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  const RewardInfo *rewardInfo() const {
    return GetPointer<const RewardInfo *>(VT_REWARDINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyOffsetRequired(verifier, VT_REWARDINFO) &&
           verifier.VerifyTable(rewardInfo()) &&
           verifier.EndTable();
  }
};

struct ResultRewardInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(ResultRewardType type) {
    fbb_.AddElement<uint8_t>(ResultRewardInfo::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_rewardInfo(flatbuffers::Offset<RewardInfo> rewardInfo) {
    fbb_.AddOffset(ResultRewardInfo::VT_REWARDINFO, rewardInfo);
  }
  explicit ResultRewardInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResultRewardInfoBuilder &operator=(const ResultRewardInfoBuilder &);
  flatbuffers::Offset<ResultRewardInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResultRewardInfo>(end);
    fbb_.Required(o, ResultRewardInfo::VT_REWARDINFO);
    return o;
  }
};

inline flatbuffers::Offset<ResultRewardInfo> CreateResultRewardInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    ResultRewardType type = ResultRewardType_DEFAULT,
    flatbuffers::Offset<RewardInfo> rewardInfo = 0) {
  ResultRewardInfoBuilder builder_(_fbb);
  builder_.add_rewardInfo(rewardInfo);
  builder_.add_type(type);
  return builder_.Finish();
}

struct ContributionCategoryInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CATEGORY = 4,
    VT_CONTRIBUTION = 6
  };
  ContributionCategoryType category() const {
    return static_cast<ContributionCategoryType>(GetField<int32_t>(VT_CATEGORY, 0));
  }
  double contribution() const {
    return GetField<double>(VT_CONTRIBUTION, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CATEGORY) &&
           VerifyField<double>(verifier, VT_CONTRIBUTION) &&
           verifier.EndTable();
  }
};

struct ContributionCategoryInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_category(ContributionCategoryType category) {
    fbb_.AddElement<int32_t>(ContributionCategoryInfo::VT_CATEGORY, static_cast<int32_t>(category), 0);
  }
  void add_contribution(double contribution) {
    fbb_.AddElement<double>(ContributionCategoryInfo::VT_CONTRIBUTION, contribution, 0.0);
  }
  explicit ContributionCategoryInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ContributionCategoryInfoBuilder &operator=(const ContributionCategoryInfoBuilder &);
  flatbuffers::Offset<ContributionCategoryInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ContributionCategoryInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ContributionCategoryInfo> CreateContributionCategoryInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    ContributionCategoryType category = ContributionCategoryType_CCT_NONE,
    double contribution = 0.0) {
  ContributionCategoryInfoBuilder builder_(_fbb);
  builder_.add_contribution(contribution);
  builder_.add_category(category);
  return builder_.Finish();
}

struct EventContributionRewardInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RANKING = 4,
    VT_BASEREWARD = 6,
    VT_RANKREWARD = 8,
    VT_EACHCONTRIBUTION = 10,
    VT_TOTALCONTRIBUTION = 12
  };
  int32_t ranking() const {
    return GetField<int32_t>(VT_RANKING, 0);
  }
  const RewardInfo *baseReward() const {
    return GetPointer<const RewardInfo *>(VT_BASEREWARD);
  }
  const RewardInfo *rankReward() const {
    return GetPointer<const RewardInfo *>(VT_RANKREWARD);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ContributionCategoryInfo>> *eachContribution() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ContributionCategoryInfo>> *>(VT_EACHCONTRIBUTION);
  }
  double totalContribution() const {
    return GetField<double>(VT_TOTALCONTRIBUTION, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RANKING) &&
           VerifyOffsetRequired(verifier, VT_BASEREWARD) &&
           verifier.VerifyTable(baseReward()) &&
           VerifyOffsetRequired(verifier, VT_RANKREWARD) &&
           verifier.VerifyTable(rankReward()) &&
           VerifyOffsetRequired(verifier, VT_EACHCONTRIBUTION) &&
           verifier.VerifyVector(eachContribution()) &&
           verifier.VerifyVectorOfTables(eachContribution()) &&
           VerifyField<double>(verifier, VT_TOTALCONTRIBUTION) &&
           verifier.EndTable();
  }
};

struct EventContributionRewardInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ranking(int32_t ranking) {
    fbb_.AddElement<int32_t>(EventContributionRewardInfo::VT_RANKING, ranking, 0);
  }
  void add_baseReward(flatbuffers::Offset<RewardInfo> baseReward) {
    fbb_.AddOffset(EventContributionRewardInfo::VT_BASEREWARD, baseReward);
  }
  void add_rankReward(flatbuffers::Offset<RewardInfo> rankReward) {
    fbb_.AddOffset(EventContributionRewardInfo::VT_RANKREWARD, rankReward);
  }
  void add_eachContribution(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ContributionCategoryInfo>>> eachContribution) {
    fbb_.AddOffset(EventContributionRewardInfo::VT_EACHCONTRIBUTION, eachContribution);
  }
  void add_totalContribution(double totalContribution) {
    fbb_.AddElement<double>(EventContributionRewardInfo::VT_TOTALCONTRIBUTION, totalContribution, 0.0);
  }
  explicit EventContributionRewardInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EventContributionRewardInfoBuilder &operator=(const EventContributionRewardInfoBuilder &);
  flatbuffers::Offset<EventContributionRewardInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EventContributionRewardInfo>(end);
    fbb_.Required(o, EventContributionRewardInfo::VT_BASEREWARD);
    fbb_.Required(o, EventContributionRewardInfo::VT_RANKREWARD);
    fbb_.Required(o, EventContributionRewardInfo::VT_EACHCONTRIBUTION);
    return o;
  }
};

inline flatbuffers::Offset<EventContributionRewardInfo> CreateEventContributionRewardInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ranking = 0,
    flatbuffers::Offset<RewardInfo> baseReward = 0,
    flatbuffers::Offset<RewardInfo> rankReward = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ContributionCategoryInfo>>> eachContribution = 0,
    double totalContribution = 0.0) {
  EventContributionRewardInfoBuilder builder_(_fbb);
  builder_.add_totalContribution(totalContribution);
  builder_.add_eachContribution(eachContribution);
  builder_.add_rankReward(rankReward);
  builder_.add_baseReward(baseReward);
  builder_.add_ranking(ranking);
  return builder_.Finish();
}

inline flatbuffers::Offset<EventContributionRewardInfo> CreateEventContributionRewardInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ranking = 0,
    flatbuffers::Offset<RewardInfo> baseReward = 0,
    flatbuffers::Offset<RewardInfo> rankReward = 0,
    const std::vector<flatbuffers::Offset<ContributionCategoryInfo>> *eachContribution = nullptr,
    double totalContribution = 0.0) {
  return LeanPacket::CreateEventContributionRewardInfo(
      _fbb,
      ranking,
      baseReward,
      rankReward,
      eachContribution ? _fbb.CreateVector<flatbuffers::Offset<ContributionCategoryInfo>>(*eachContribution) : 0,
      totalContribution);
}

struct ContributionResultInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RANKING = 4,
    VT_TOTALCONTRIBUTION = 6,
    VT_EACHCONTRIBUTION = 8
  };
  int32_t ranking() const {
    return GetField<int32_t>(VT_RANKING, 0);
  }
  double totalContribution() const {
    return GetField<double>(VT_TOTALCONTRIBUTION, 0.0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ContributionCategoryInfo>> *eachContribution() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ContributionCategoryInfo>> *>(VT_EACHCONTRIBUTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RANKING) &&
           VerifyField<double>(verifier, VT_TOTALCONTRIBUTION) &&
           VerifyOffsetRequired(verifier, VT_EACHCONTRIBUTION) &&
           verifier.VerifyVector(eachContribution()) &&
           verifier.VerifyVectorOfTables(eachContribution()) &&
           verifier.EndTable();
  }
};

struct ContributionResultInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ranking(int32_t ranking) {
    fbb_.AddElement<int32_t>(ContributionResultInfo::VT_RANKING, ranking, 0);
  }
  void add_totalContribution(double totalContribution) {
    fbb_.AddElement<double>(ContributionResultInfo::VT_TOTALCONTRIBUTION, totalContribution, 0.0);
  }
  void add_eachContribution(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ContributionCategoryInfo>>> eachContribution) {
    fbb_.AddOffset(ContributionResultInfo::VT_EACHCONTRIBUTION, eachContribution);
  }
  explicit ContributionResultInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ContributionResultInfoBuilder &operator=(const ContributionResultInfoBuilder &);
  flatbuffers::Offset<ContributionResultInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ContributionResultInfo>(end);
    fbb_.Required(o, ContributionResultInfo::VT_EACHCONTRIBUTION);
    return o;
  }
};

inline flatbuffers::Offset<ContributionResultInfo> CreateContributionResultInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ranking = 0,
    double totalContribution = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ContributionCategoryInfo>>> eachContribution = 0) {
  ContributionResultInfoBuilder builder_(_fbb);
  builder_.add_totalContribution(totalContribution);
  builder_.add_eachContribution(eachContribution);
  builder_.add_ranking(ranking);
  return builder_.Finish();
}

inline flatbuffers::Offset<ContributionResultInfo> CreateContributionResultInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ranking = 0,
    double totalContribution = 0.0,
    const std::vector<flatbuffers::Offset<ContributionCategoryInfo>> *eachContribution = nullptr) {
  return LeanPacket::CreateContributionResultInfo(
      _fbb,
      ranking,
      totalContribution,
      eachContribution ? _fbb.CreateVector<flatbuffers::Offset<ContributionCategoryInfo>>(*eachContribution) : 0);
}

struct EventPraiserInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCDBID = 4,
    VT_RANKING = 6,
    VT_NAME = 8,
    VT_CLASSTYPE = 10,
    VT_CONTRIBUTION = 12,
    VT_RANKTYPE = 14,
    VT_OBJECTID = 16
  };
  uint64_t pcDbId() const {
    return GetField<uint64_t>(VT_PCDBID, 0);
  }
  int16_t ranking() const {
    return GetField<int16_t>(VT_RANKING, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t classType() const {
    return GetField<int32_t>(VT_CLASSTYPE, 0);
  }
  double contribution() const {
    return GetField<double>(VT_CONTRIBUTION, 0.0);
  }
  EventRankType rankType() const {
    return static_cast<EventRankType>(GetField<int32_t>(VT_RANKTYPE, 0));
  }
  uint64_t objectId() const {
    return GetField<uint64_t>(VT_OBJECTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PCDBID) &&
           VerifyField<int16_t>(verifier, VT_RANKING) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_CLASSTYPE) &&
           VerifyField<double>(verifier, VT_CONTRIBUTION) &&
           VerifyField<int32_t>(verifier, VT_RANKTYPE) &&
           VerifyField<uint64_t>(verifier, VT_OBJECTID) &&
           verifier.EndTable();
  }
};

struct EventPraiserInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcDbId(uint64_t pcDbId) {
    fbb_.AddElement<uint64_t>(EventPraiserInfo::VT_PCDBID, pcDbId, 0);
  }
  void add_ranking(int16_t ranking) {
    fbb_.AddElement<int16_t>(EventPraiserInfo::VT_RANKING, ranking, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(EventPraiserInfo::VT_NAME, name);
  }
  void add_classType(int32_t classType) {
    fbb_.AddElement<int32_t>(EventPraiserInfo::VT_CLASSTYPE, classType, 0);
  }
  void add_contribution(double contribution) {
    fbb_.AddElement<double>(EventPraiserInfo::VT_CONTRIBUTION, contribution, 0.0);
  }
  void add_rankType(EventRankType rankType) {
    fbb_.AddElement<int32_t>(EventPraiserInfo::VT_RANKTYPE, static_cast<int32_t>(rankType), 0);
  }
  void add_objectId(uint64_t objectId) {
    fbb_.AddElement<uint64_t>(EventPraiserInfo::VT_OBJECTID, objectId, 0);
  }
  explicit EventPraiserInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EventPraiserInfoBuilder &operator=(const EventPraiserInfoBuilder &);
  flatbuffers::Offset<EventPraiserInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EventPraiserInfo>(end);
    fbb_.Required(o, EventPraiserInfo::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<EventPraiserInfo> CreateEventPraiserInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t pcDbId = 0,
    int16_t ranking = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t classType = 0,
    double contribution = 0.0,
    EventRankType rankType = EventRankType_ERT_SRANK,
    uint64_t objectId = 0) {
  EventPraiserInfoBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_contribution(contribution);
  builder_.add_pcDbId(pcDbId);
  builder_.add_rankType(rankType);
  builder_.add_classType(classType);
  builder_.add_name(name);
  builder_.add_ranking(ranking);
  return builder_.Finish();
}

inline flatbuffers::Offset<EventPraiserInfo> CreateEventPraiserInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t pcDbId = 0,
    int16_t ranking = 0,
    const char *name = nullptr,
    int32_t classType = 0,
    double contribution = 0.0,
    EventRankType rankType = EventRankType_ERT_SRANK,
    uint64_t objectId = 0) {
  return LeanPacket::CreateEventPraiserInfo(
      _fbb,
      pcDbId,
      ranking,
      name ? _fbb.CreateString(name) : 0,
      classType,
      contribution,
      rankType,
      objectId);
}

struct EventRecommendPraiserInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_REMAINTIME = 4,
    VT_TOTALCONTRIBUTION = 6,
    VT_PRAISERLIST = 8
  };
  int32_t remainTime() const {
    return GetField<int32_t>(VT_REMAINTIME, 0);
  }
  double totalContribution() const {
    return GetField<double>(VT_TOTALCONTRIBUTION, 0.0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<EventPraiserInfo>> *praiserList() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EventPraiserInfo>> *>(VT_PRAISERLIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_REMAINTIME) &&
           VerifyField<double>(verifier, VT_TOTALCONTRIBUTION) &&
           VerifyOffsetRequired(verifier, VT_PRAISERLIST) &&
           verifier.VerifyVector(praiserList()) &&
           verifier.VerifyVectorOfTables(praiserList()) &&
           verifier.EndTable();
  }
};

struct EventRecommendPraiserInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_remainTime(int32_t remainTime) {
    fbb_.AddElement<int32_t>(EventRecommendPraiserInfo::VT_REMAINTIME, remainTime, 0);
  }
  void add_totalContribution(double totalContribution) {
    fbb_.AddElement<double>(EventRecommendPraiserInfo::VT_TOTALCONTRIBUTION, totalContribution, 0.0);
  }
  void add_praiserList(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EventPraiserInfo>>> praiserList) {
    fbb_.AddOffset(EventRecommendPraiserInfo::VT_PRAISERLIST, praiserList);
  }
  explicit EventRecommendPraiserInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EventRecommendPraiserInfoBuilder &operator=(const EventRecommendPraiserInfoBuilder &);
  flatbuffers::Offset<EventRecommendPraiserInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EventRecommendPraiserInfo>(end);
    fbb_.Required(o, EventRecommendPraiserInfo::VT_PRAISERLIST);
    return o;
  }
};

inline flatbuffers::Offset<EventRecommendPraiserInfo> CreateEventRecommendPraiserInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t remainTime = 0,
    double totalContribution = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EventPraiserInfo>>> praiserList = 0) {
  EventRecommendPraiserInfoBuilder builder_(_fbb);
  builder_.add_totalContribution(totalContribution);
  builder_.add_praiserList(praiserList);
  builder_.add_remainTime(remainTime);
  return builder_.Finish();
}

inline flatbuffers::Offset<EventRecommendPraiserInfo> CreateEventRecommendPraiserInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t remainTime = 0,
    double totalContribution = 0.0,
    const std::vector<flatbuffers::Offset<EventPraiserInfo>> *praiserList = nullptr) {
  return LeanPacket::CreateEventRecommendPraiserInfo(
      _fbb,
      remainTime,
      totalContribution,
      praiserList ? _fbb.CreateVector<flatbuffers::Offset<EventPraiserInfo>>(*praiserList) : 0);
}

/// NOTIFY_EVENT_TOTAL_REWARD
struct NotifyEventTotalReward FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EVENTSETID = 4,
    VT_EVENTID = 6,
    VT_RESULTREWARDINFOS = 8,
    VT_CONTRIBUTIONRESULT = 10,
    VT_RECOMMENDINFO = 12,
    VT_ORIGNRESULTREWARDINFOS = 14
  };
  int32_t eventSetId() const {
    return GetField<int32_t>(VT_EVENTSETID, 0);
  }
  int32_t eventId() const {
    return GetField<int32_t>(VT_EVENTID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ResultRewardInfo>> *resultRewardInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ResultRewardInfo>> *>(VT_RESULTREWARDINFOS);
  }
  const ContributionResultInfo *contributionResult() const {
    return GetPointer<const ContributionResultInfo *>(VT_CONTRIBUTIONRESULT);
  }
  const EventRecommendPraiserInfo *recommendInfo() const {
    return GetPointer<const EventRecommendPraiserInfo *>(VT_RECOMMENDINFO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ResultRewardInfo>> *orignResultRewardInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ResultRewardInfo>> *>(VT_ORIGNRESULTREWARDINFOS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_EVENTSETID) &&
           VerifyField<int32_t>(verifier, VT_EVENTID) &&
           VerifyOffsetRequired(verifier, VT_RESULTREWARDINFOS) &&
           verifier.VerifyVector(resultRewardInfos()) &&
           verifier.VerifyVectorOfTables(resultRewardInfos()) &&
           VerifyOffsetRequired(verifier, VT_CONTRIBUTIONRESULT) &&
           verifier.VerifyTable(contributionResult()) &&
           VerifyOffsetRequired(verifier, VT_RECOMMENDINFO) &&
           verifier.VerifyTable(recommendInfo()) &&
           VerifyOffsetRequired(verifier, VT_ORIGNRESULTREWARDINFOS) &&
           verifier.VerifyVector(orignResultRewardInfos()) &&
           verifier.VerifyVectorOfTables(orignResultRewardInfos()) &&
           verifier.EndTable();
  }
};

struct NotifyEventTotalRewardBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eventSetId(int32_t eventSetId) {
    fbb_.AddElement<int32_t>(NotifyEventTotalReward::VT_EVENTSETID, eventSetId, 0);
  }
  void add_eventId(int32_t eventId) {
    fbb_.AddElement<int32_t>(NotifyEventTotalReward::VT_EVENTID, eventId, 0);
  }
  void add_resultRewardInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ResultRewardInfo>>> resultRewardInfos) {
    fbb_.AddOffset(NotifyEventTotalReward::VT_RESULTREWARDINFOS, resultRewardInfos);
  }
  void add_contributionResult(flatbuffers::Offset<ContributionResultInfo> contributionResult) {
    fbb_.AddOffset(NotifyEventTotalReward::VT_CONTRIBUTIONRESULT, contributionResult);
  }
  void add_recommendInfo(flatbuffers::Offset<EventRecommendPraiserInfo> recommendInfo) {
    fbb_.AddOffset(NotifyEventTotalReward::VT_RECOMMENDINFO, recommendInfo);
  }
  void add_orignResultRewardInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ResultRewardInfo>>> orignResultRewardInfos) {
    fbb_.AddOffset(NotifyEventTotalReward::VT_ORIGNRESULTREWARDINFOS, orignResultRewardInfos);
  }
  explicit NotifyEventTotalRewardBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NotifyEventTotalRewardBuilder &operator=(const NotifyEventTotalRewardBuilder &);
  flatbuffers::Offset<NotifyEventTotalReward> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NotifyEventTotalReward>(end);
    fbb_.Required(o, NotifyEventTotalReward::VT_RESULTREWARDINFOS);
    fbb_.Required(o, NotifyEventTotalReward::VT_CONTRIBUTIONRESULT);
    fbb_.Required(o, NotifyEventTotalReward::VT_RECOMMENDINFO);
    fbb_.Required(o, NotifyEventTotalReward::VT_ORIGNRESULTREWARDINFOS);
    return o;
  }
};

inline flatbuffers::Offset<NotifyEventTotalReward> CreateNotifyEventTotalReward(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t eventSetId = 0,
    int32_t eventId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ResultRewardInfo>>> resultRewardInfos = 0,
    flatbuffers::Offset<ContributionResultInfo> contributionResult = 0,
    flatbuffers::Offset<EventRecommendPraiserInfo> recommendInfo = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ResultRewardInfo>>> orignResultRewardInfos = 0) {
  NotifyEventTotalRewardBuilder builder_(_fbb);
  builder_.add_orignResultRewardInfos(orignResultRewardInfos);
  builder_.add_recommendInfo(recommendInfo);
  builder_.add_contributionResult(contributionResult);
  builder_.add_resultRewardInfos(resultRewardInfos);
  builder_.add_eventId(eventId);
  builder_.add_eventSetId(eventSetId);
  return builder_.Finish();
}

inline flatbuffers::Offset<NotifyEventTotalReward> CreateNotifyEventTotalRewardDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t eventSetId = 0,
    int32_t eventId = 0,
    const std::vector<flatbuffers::Offset<ResultRewardInfo>> *resultRewardInfos = nullptr,
    flatbuffers::Offset<ContributionResultInfo> contributionResult = 0,
    flatbuffers::Offset<EventRecommendPraiserInfo> recommendInfo = 0,
    const std::vector<flatbuffers::Offset<ResultRewardInfo>> *orignResultRewardInfos = nullptr) {
  return LeanPacket::CreateNotifyEventTotalReward(
      _fbb,
      eventSetId,
      eventId,
      resultRewardInfos ? _fbb.CreateVector<flatbuffers::Offset<ResultRewardInfo>>(*resultRewardInfos) : 0,
      contributionResult,
      recommendInfo,
      orignResultRewardInfos ? _fbb.CreateVector<flatbuffers::Offset<ResultRewardInfo>>(*orignResultRewardInfos) : 0);
}

/// NOTIFY_EVENT_START
struct NotifyEventStart FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EVENTSETID = 4,
    VT_EVENTID = 6,
    VT_EVENTPHASEID = 8
  };
  int32_t eventSetId() const {
    return GetField<int32_t>(VT_EVENTSETID, 0);
  }
  int32_t eventId() const {
    return GetField<int32_t>(VT_EVENTID, 0);
  }
  int32_t eventPhaseId() const {
    return GetField<int32_t>(VT_EVENTPHASEID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_EVENTSETID) &&
           VerifyField<int32_t>(verifier, VT_EVENTID) &&
           VerifyField<int32_t>(verifier, VT_EVENTPHASEID) &&
           verifier.EndTable();
  }
};

struct NotifyEventStartBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eventSetId(int32_t eventSetId) {
    fbb_.AddElement<int32_t>(NotifyEventStart::VT_EVENTSETID, eventSetId, 0);
  }
  void add_eventId(int32_t eventId) {
    fbb_.AddElement<int32_t>(NotifyEventStart::VT_EVENTID, eventId, 0);
  }
  void add_eventPhaseId(int32_t eventPhaseId) {
    fbb_.AddElement<int32_t>(NotifyEventStart::VT_EVENTPHASEID, eventPhaseId, 0);
  }
  explicit NotifyEventStartBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NotifyEventStartBuilder &operator=(const NotifyEventStartBuilder &);
  flatbuffers::Offset<NotifyEventStart> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NotifyEventStart>(end);
    return o;
  }
};

inline flatbuffers::Offset<NotifyEventStart> CreateNotifyEventStart(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t eventSetId = 0,
    int32_t eventId = 0,
    int32_t eventPhaseId = 0) {
  NotifyEventStartBuilder builder_(_fbb);
  builder_.add_eventPhaseId(eventPhaseId);
  builder_.add_eventId(eventId);
  builder_.add_eventSetId(eventSetId);
  return builder_.Finish();
}

/// NOTIFY_EVENT_END
struct NotifyEventEnd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EVENTSETID = 4,
    VT_EVENTID = 6,
    VT_REASON = 8,
    VT_CONTENTSTYPE = 10,
    VT_ISSUCCESS = 12,
    VT_FINISHDIRECTIONID = 14,
    VT_OBJECTID = 16
  };
  int32_t eventSetId() const {
    return GetField<int32_t>(VT_EVENTSETID, 0);
  }
  int32_t eventId() const {
    return GetField<int32_t>(VT_EVENTID, 0);
  }
  EventEndType reason() const {
    return static_cast<EventEndType>(GetField<int32_t>(VT_REASON, 0));
  }
  int16_t contentsType() const {
    return GetField<int16_t>(VT_CONTENTSTYPE, 0);
  }
  bool isSuccess() const {
    return GetField<uint8_t>(VT_ISSUCCESS, 0) != 0;
  }
  int32_t finishDirectionId() const {
    return GetField<int32_t>(VT_FINISHDIRECTIONID, 0);
  }
  const flatbuffers::Vector<int64_t> *objectId() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_OBJECTID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_EVENTSETID) &&
           VerifyField<int32_t>(verifier, VT_EVENTID) &&
           VerifyField<int32_t>(verifier, VT_REASON) &&
           VerifyField<int16_t>(verifier, VT_CONTENTSTYPE) &&
           VerifyField<uint8_t>(verifier, VT_ISSUCCESS) &&
           VerifyField<int32_t>(verifier, VT_FINISHDIRECTIONID) &&
           VerifyOffsetRequired(verifier, VT_OBJECTID) &&
           verifier.VerifyVector(objectId()) &&
           verifier.EndTable();
  }
};

struct NotifyEventEndBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eventSetId(int32_t eventSetId) {
    fbb_.AddElement<int32_t>(NotifyEventEnd::VT_EVENTSETID, eventSetId, 0);
  }
  void add_eventId(int32_t eventId) {
    fbb_.AddElement<int32_t>(NotifyEventEnd::VT_EVENTID, eventId, 0);
  }
  void add_reason(EventEndType reason) {
    fbb_.AddElement<int32_t>(NotifyEventEnd::VT_REASON, static_cast<int32_t>(reason), 0);
  }
  void add_contentsType(int16_t contentsType) {
    fbb_.AddElement<int16_t>(NotifyEventEnd::VT_CONTENTSTYPE, contentsType, 0);
  }
  void add_isSuccess(bool isSuccess) {
    fbb_.AddElement<uint8_t>(NotifyEventEnd::VT_ISSUCCESS, static_cast<uint8_t>(isSuccess), 0);
  }
  void add_finishDirectionId(int32_t finishDirectionId) {
    fbb_.AddElement<int32_t>(NotifyEventEnd::VT_FINISHDIRECTIONID, finishDirectionId, 0);
  }
  void add_objectId(flatbuffers::Offset<flatbuffers::Vector<int64_t>> objectId) {
    fbb_.AddOffset(NotifyEventEnd::VT_OBJECTID, objectId);
  }
  explicit NotifyEventEndBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NotifyEventEndBuilder &operator=(const NotifyEventEndBuilder &);
  flatbuffers::Offset<NotifyEventEnd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NotifyEventEnd>(end);
    fbb_.Required(o, NotifyEventEnd::VT_OBJECTID);
    return o;
  }
};

inline flatbuffers::Offset<NotifyEventEnd> CreateNotifyEventEnd(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t eventSetId = 0,
    int32_t eventId = 0,
    EventEndType reason = EventEndType_EVENT_END_TYPE_NORMAL,
    int16_t contentsType = 0,
    bool isSuccess = false,
    int32_t finishDirectionId = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> objectId = 0) {
  NotifyEventEndBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_finishDirectionId(finishDirectionId);
  builder_.add_reason(reason);
  builder_.add_eventId(eventId);
  builder_.add_eventSetId(eventSetId);
  builder_.add_contentsType(contentsType);
  builder_.add_isSuccess(isSuccess);
  return builder_.Finish();
}

inline flatbuffers::Offset<NotifyEventEnd> CreateNotifyEventEndDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t eventSetId = 0,
    int32_t eventId = 0,
    EventEndType reason = EventEndType_EVENT_END_TYPE_NORMAL,
    int16_t contentsType = 0,
    bool isSuccess = false,
    int32_t finishDirectionId = 0,
    const std::vector<int64_t> *objectId = nullptr) {
  return LeanPacket::CreateNotifyEventEnd(
      _fbb,
      eventSetId,
      eventId,
      reason,
      contentsType,
      isSuccess,
      finishDirectionId,
      objectId ? _fbb.CreateVector<int64_t>(*objectId) : 0);
}

/// NOTIFY_NEXT_NORMAL_EVENTSET_INFO
struct NotifyNextNormalEventSetInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EVENTSETID = 4,
    VT_EVENTID = 6,
    VT_DELAYTICK = 8
  };
  int32_t eventSetId() const {
    return GetField<int32_t>(VT_EVENTSETID, 0);
  }
  int32_t eventId() const {
    return GetField<int32_t>(VT_EVENTID, 0);
  }
  int32_t delayTick() const {
    return GetField<int32_t>(VT_DELAYTICK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_EVENTSETID) &&
           VerifyField<int32_t>(verifier, VT_EVENTID) &&
           VerifyField<int32_t>(verifier, VT_DELAYTICK) &&
           verifier.EndTable();
  }
};

struct NotifyNextNormalEventSetInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eventSetId(int32_t eventSetId) {
    fbb_.AddElement<int32_t>(NotifyNextNormalEventSetInfo::VT_EVENTSETID, eventSetId, 0);
  }
  void add_eventId(int32_t eventId) {
    fbb_.AddElement<int32_t>(NotifyNextNormalEventSetInfo::VT_EVENTID, eventId, 0);
  }
  void add_delayTick(int32_t delayTick) {
    fbb_.AddElement<int32_t>(NotifyNextNormalEventSetInfo::VT_DELAYTICK, delayTick, 0);
  }
  explicit NotifyNextNormalEventSetInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NotifyNextNormalEventSetInfoBuilder &operator=(const NotifyNextNormalEventSetInfoBuilder &);
  flatbuffers::Offset<NotifyNextNormalEventSetInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NotifyNextNormalEventSetInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<NotifyNextNormalEventSetInfo> CreateNotifyNextNormalEventSetInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t eventSetId = 0,
    int32_t eventId = 0,
    int32_t delayTick = 0) {
  NotifyNextNormalEventSetInfoBuilder builder_(_fbb);
  builder_.add_delayTick(delayTick);
  builder_.add_eventId(eventId);
  builder_.add_eventSetId(eventSetId);
  return builder_.Finish();
}

/// NOTIFY_EVENT_PHASE_START
struct NotifyEventPhaseStart FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EVENTSETID = 4,
    VT_EVENTID = 6,
    VT_STARTPHASEID = 8
  };
  int32_t eventSetId() const {
    return GetField<int32_t>(VT_EVENTSETID, 0);
  }
  int32_t eventId() const {
    return GetField<int32_t>(VT_EVENTID, 0);
  }
  int32_t startPhaseId() const {
    return GetField<int32_t>(VT_STARTPHASEID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_EVENTSETID) &&
           VerifyField<int32_t>(verifier, VT_EVENTID) &&
           VerifyField<int32_t>(verifier, VT_STARTPHASEID) &&
           verifier.EndTable();
  }
};

struct NotifyEventPhaseStartBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eventSetId(int32_t eventSetId) {
    fbb_.AddElement<int32_t>(NotifyEventPhaseStart::VT_EVENTSETID, eventSetId, 0);
  }
  void add_eventId(int32_t eventId) {
    fbb_.AddElement<int32_t>(NotifyEventPhaseStart::VT_EVENTID, eventId, 0);
  }
  void add_startPhaseId(int32_t startPhaseId) {
    fbb_.AddElement<int32_t>(NotifyEventPhaseStart::VT_STARTPHASEID, startPhaseId, 0);
  }
  explicit NotifyEventPhaseStartBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NotifyEventPhaseStartBuilder &operator=(const NotifyEventPhaseStartBuilder &);
  flatbuffers::Offset<NotifyEventPhaseStart> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NotifyEventPhaseStart>(end);
    return o;
  }
};

inline flatbuffers::Offset<NotifyEventPhaseStart> CreateNotifyEventPhaseStart(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t eventSetId = 0,
    int32_t eventId = 0,
    int32_t startPhaseId = 0) {
  NotifyEventPhaseStartBuilder builder_(_fbb);
  builder_.add_startPhaseId(startPhaseId);
  builder_.add_eventId(eventId);
  builder_.add_eventSetId(eventSetId);
  return builder_.Finish();
}

struct EventSpeechBubbleNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EVENTUIGROUPID = 4,
    VT_SPEECHLIST = 6
  };
  int32_t eventUiGroupId() const {
    return GetField<int32_t>(VT_EVENTUIGROUPID, 0);
  }
  const flatbuffers::Vector<int32_t> *speechList() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SPEECHLIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_EVENTUIGROUPID) &&
           VerifyOffsetRequired(verifier, VT_SPEECHLIST) &&
           verifier.VerifyVector(speechList()) &&
           verifier.EndTable();
  }
};

struct EventSpeechBubbleNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eventUiGroupId(int32_t eventUiGroupId) {
    fbb_.AddElement<int32_t>(EventSpeechBubbleNotify::VT_EVENTUIGROUPID, eventUiGroupId, 0);
  }
  void add_speechList(flatbuffers::Offset<flatbuffers::Vector<int32_t>> speechList) {
    fbb_.AddOffset(EventSpeechBubbleNotify::VT_SPEECHLIST, speechList);
  }
  explicit EventSpeechBubbleNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EventSpeechBubbleNotifyBuilder &operator=(const EventSpeechBubbleNotifyBuilder &);
  flatbuffers::Offset<EventSpeechBubbleNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EventSpeechBubbleNotify>(end);
    fbb_.Required(o, EventSpeechBubbleNotify::VT_SPEECHLIST);
    return o;
  }
};

inline flatbuffers::Offset<EventSpeechBubbleNotify> CreateEventSpeechBubbleNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t eventUiGroupId = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> speechList = 0) {
  EventSpeechBubbleNotifyBuilder builder_(_fbb);
  builder_.add_speechList(speechList);
  builder_.add_eventUiGroupId(eventUiGroupId);
  return builder_.Finish();
}

inline flatbuffers::Offset<EventSpeechBubbleNotify> CreateEventSpeechBubbleNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t eventUiGroupId = 0,
    const std::vector<int32_t> *speechList = nullptr) {
  return LeanPacket::CreateEventSpeechBubbleNotify(
      _fbb,
      eventUiGroupId,
      speechList ? _fbb.CreateVector<int32_t>(*speechList) : 0);
}

struct EventChannelCloseNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EVENTSETID = 4,
    VT_CLOSEDREMAINTIME = 6
  };
  int32_t eventSetId() const {
    return GetField<int32_t>(VT_EVENTSETID, 0);
  }
  int32_t closedRemainTime() const {
    return GetField<int32_t>(VT_CLOSEDREMAINTIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_EVENTSETID) &&
           VerifyField<int32_t>(verifier, VT_CLOSEDREMAINTIME) &&
           verifier.EndTable();
  }
};

struct EventChannelCloseNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eventSetId(int32_t eventSetId) {
    fbb_.AddElement<int32_t>(EventChannelCloseNotify::VT_EVENTSETID, eventSetId, 0);
  }
  void add_closedRemainTime(int32_t closedRemainTime) {
    fbb_.AddElement<int32_t>(EventChannelCloseNotify::VT_CLOSEDREMAINTIME, closedRemainTime, 0);
  }
  explicit EventChannelCloseNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EventChannelCloseNotifyBuilder &operator=(const EventChannelCloseNotifyBuilder &);
  flatbuffers::Offset<EventChannelCloseNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EventChannelCloseNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<EventChannelCloseNotify> CreateEventChannelCloseNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t eventSetId = 0,
    int32_t closedRemainTime = 0) {
  EventChannelCloseNotifyBuilder builder_(_fbb);
  builder_.add_closedRemainTime(closedRemainTime);
  builder_.add_eventSetId(eventSetId);
  return builder_.Finish();
}

struct EventGoTownRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           verifier.EndTable();
  }
};

struct EventGoTownRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(EventGoTownRequest::VT_OBJECTID, objectId, 0);
  }
  explicit EventGoTownRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EventGoTownRequestBuilder &operator=(const EventGoTownRequestBuilder &);
  flatbuffers::Offset<EventGoTownRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EventGoTownRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<EventGoTownRequest> CreateEventGoTownRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0) {
  EventGoTownRequestBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  return builder_.Finish();
}

struct EventGoTownResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_REASON = 4
  };
  JoinChannelReason reason() const {
    return static_cast<JoinChannelReason>(GetField<int32_t>(VT_REASON, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_REASON) &&
           verifier.EndTable();
  }
};

struct EventGoTownResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_reason(JoinChannelReason reason) {
    fbb_.AddElement<int32_t>(EventGoTownResponse::VT_REASON, static_cast<int32_t>(reason), 0);
  }
  explicit EventGoTownResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EventGoTownResponseBuilder &operator=(const EventGoTownResponseBuilder &);
  flatbuffers::Offset<EventGoTownResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EventGoTownResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<EventGoTownResponse> CreateEventGoTownResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    JoinChannelReason reason = JoinChannelReason_JOIN_CHANNEL_REASON_NONE) {
  EventGoTownResponseBuilder builder_(_fbb);
  builder_.add_reason(reason);
  return builder_.Finish();
}

struct EventDisappearBarriorNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EVENTSETID = 4
  };
  int32_t eventSetId() const {
    return GetField<int32_t>(VT_EVENTSETID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_EVENTSETID) &&
           verifier.EndTable();
  }
};

struct EventDisappearBarriorNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eventSetId(int32_t eventSetId) {
    fbb_.AddElement<int32_t>(EventDisappearBarriorNotify::VT_EVENTSETID, eventSetId, 0);
  }
  explicit EventDisappearBarriorNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EventDisappearBarriorNotifyBuilder &operator=(const EventDisappearBarriorNotifyBuilder &);
  flatbuffers::Offset<EventDisappearBarriorNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EventDisappearBarriorNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<EventDisappearBarriorNotify> CreateEventDisappearBarriorNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t eventSetId = 0) {
  EventDisappearBarriorNotifyBuilder builder_(_fbb);
  builder_.add_eventSetId(eventSetId);
  return builder_.Finish();
}

struct transformWithCutScene FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CUTSCENETABLEID = 4,
    VT_LOCATION = 6,
    VT_ROTATE = 8
  };
  int32_t cutSceneTableId() const {
    return GetField<int32_t>(VT_CUTSCENETABLEID, 0);
  }
  const Pos *location() const {
    return GetPointer<const Pos *>(VT_LOCATION);
  }
  const Pos *rotate() const {
    return GetPointer<const Pos *>(VT_ROTATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CUTSCENETABLEID) &&
           VerifyOffsetRequired(verifier, VT_LOCATION) &&
           verifier.VerifyTable(location()) &&
           VerifyOffsetRequired(verifier, VT_ROTATE) &&
           verifier.VerifyTable(rotate()) &&
           verifier.EndTable();
  }
};

struct transformWithCutSceneBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cutSceneTableId(int32_t cutSceneTableId) {
    fbb_.AddElement<int32_t>(transformWithCutScene::VT_CUTSCENETABLEID, cutSceneTableId, 0);
  }
  void add_location(flatbuffers::Offset<Pos> location) {
    fbb_.AddOffset(transformWithCutScene::VT_LOCATION, location);
  }
  void add_rotate(flatbuffers::Offset<Pos> rotate) {
    fbb_.AddOffset(transformWithCutScene::VT_ROTATE, rotate);
  }
  explicit transformWithCutSceneBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  transformWithCutSceneBuilder &operator=(const transformWithCutSceneBuilder &);
  flatbuffers::Offset<transformWithCutScene> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<transformWithCutScene>(end);
    fbb_.Required(o, transformWithCutScene::VT_LOCATION);
    fbb_.Required(o, transformWithCutScene::VT_ROTATE);
    return o;
  }
};

inline flatbuffers::Offset<transformWithCutScene> CreatetransformWithCutScene(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t cutSceneTableId = 0,
    flatbuffers::Offset<Pos> location = 0,
    flatbuffers::Offset<Pos> rotate = 0) {
  transformWithCutSceneBuilder builder_(_fbb);
  builder_.add_rotate(rotate);
  builder_.add_location(location);
  builder_.add_cutSceneTableId(cutSceneTableId);
  return builder_.Finish();
}

/// NPC_SCENEMAP_INFO_UPDATE_NOTIFY
struct NpcSceneMapInfoUpdateNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_SCENEID = 6,
    VT_CURPOS = 8,
    VT_CURRENTHP = 10,
    VT_NPCID = 12,
    VT_NPCWORKSTATE = 14,
    VT_PATROLID = 16,
    VT_PATROLINDEX = 18
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int32_t sceneId() const {
    return GetField<int32_t>(VT_SCENEID, 0);
  }
  const Pos *curPos() const {
    return GetPointer<const Pos *>(VT_CURPOS);
  }
  int64_t currentHp() const {
    return GetField<int64_t>(VT_CURRENTHP, 0);
  }
  int32_t npcId() const {
    return GetField<int32_t>(VT_NPCID, 0);
  }
  int32_t npcWorkState() const {
    return GetField<int32_t>(VT_NPCWORKSTATE, 0);
  }
  int32_t patrolId() const {
    return GetField<int32_t>(VT_PATROLID, 0);
  }
  int32_t patrolIndex() const {
    return GetField<int32_t>(VT_PATROLINDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int32_t>(verifier, VT_SCENEID) &&
           VerifyOffsetRequired(verifier, VT_CURPOS) &&
           verifier.VerifyTable(curPos()) &&
           VerifyField<int64_t>(verifier, VT_CURRENTHP) &&
           VerifyField<int32_t>(verifier, VT_NPCID) &&
           VerifyField<int32_t>(verifier, VT_NPCWORKSTATE) &&
           VerifyField<int32_t>(verifier, VT_PATROLID) &&
           VerifyField<int32_t>(verifier, VT_PATROLINDEX) &&
           verifier.EndTable();
  }
};

struct NpcSceneMapInfoUpdateNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(NpcSceneMapInfoUpdateNotify::VT_OBJECTID, objectId, 0);
  }
  void add_sceneId(int32_t sceneId) {
    fbb_.AddElement<int32_t>(NpcSceneMapInfoUpdateNotify::VT_SCENEID, sceneId, 0);
  }
  void add_curPos(flatbuffers::Offset<Pos> curPos) {
    fbb_.AddOffset(NpcSceneMapInfoUpdateNotify::VT_CURPOS, curPos);
  }
  void add_currentHp(int64_t currentHp) {
    fbb_.AddElement<int64_t>(NpcSceneMapInfoUpdateNotify::VT_CURRENTHP, currentHp, 0);
  }
  void add_npcId(int32_t npcId) {
    fbb_.AddElement<int32_t>(NpcSceneMapInfoUpdateNotify::VT_NPCID, npcId, 0);
  }
  void add_npcWorkState(int32_t npcWorkState) {
    fbb_.AddElement<int32_t>(NpcSceneMapInfoUpdateNotify::VT_NPCWORKSTATE, npcWorkState, 0);
  }
  void add_patrolId(int32_t patrolId) {
    fbb_.AddElement<int32_t>(NpcSceneMapInfoUpdateNotify::VT_PATROLID, patrolId, 0);
  }
  void add_patrolIndex(int32_t patrolIndex) {
    fbb_.AddElement<int32_t>(NpcSceneMapInfoUpdateNotify::VT_PATROLINDEX, patrolIndex, 0);
  }
  explicit NpcSceneMapInfoUpdateNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NpcSceneMapInfoUpdateNotifyBuilder &operator=(const NpcSceneMapInfoUpdateNotifyBuilder &);
  flatbuffers::Offset<NpcSceneMapInfoUpdateNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NpcSceneMapInfoUpdateNotify>(end);
    fbb_.Required(o, NpcSceneMapInfoUpdateNotify::VT_CURPOS);
    return o;
  }
};

inline flatbuffers::Offset<NpcSceneMapInfoUpdateNotify> CreateNpcSceneMapInfoUpdateNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int32_t sceneId = 0,
    flatbuffers::Offset<Pos> curPos = 0,
    int64_t currentHp = 0,
    int32_t npcId = 0,
    int32_t npcWorkState = 0,
    int32_t patrolId = 0,
    int32_t patrolIndex = 0) {
  NpcSceneMapInfoUpdateNotifyBuilder builder_(_fbb);
  builder_.add_currentHp(currentHp);
  builder_.add_objectId(objectId);
  builder_.add_patrolIndex(patrolIndex);
  builder_.add_patrolId(patrolId);
  builder_.add_npcWorkState(npcWorkState);
  builder_.add_npcId(npcId);
  builder_.add_curPos(curPos);
  builder_.add_sceneId(sceneId);
  return builder_.Finish();
}

/// NPC_SCENEMAP_INFO_DESTROY_NOTIFY
struct NpcSceneMapInfoDestroyNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           verifier.EndTable();
  }
};

struct NpcSceneMapInfoDestroyNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(NpcSceneMapInfoDestroyNotify::VT_OBJECTID, objectId, 0);
  }
  explicit NpcSceneMapInfoDestroyNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NpcSceneMapInfoDestroyNotifyBuilder &operator=(const NpcSceneMapInfoDestroyNotifyBuilder &);
  flatbuffers::Offset<NpcSceneMapInfoDestroyNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NpcSceneMapInfoDestroyNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<NpcSceneMapInfoDestroyNotify> CreateNpcSceneMapInfoDestroyNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0) {
  NpcSceneMapInfoDestroyNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  return builder_.Finish();
}

/// PC_SCENEMAP_INFO_UPDATE_NOTIFY
struct PcSceneMapInfoUpdateNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_SCENEID = 6,
    VT_CURPOS = 8,
    VT_IFF = 10,
    VT_PCNAME = 12,
    VT_GUILDNAME = 14,
    VT_CLASSTYPE = 16,
    VT_STATE = 18,
    VT_KILLCOUNT = 20,
    VT_ASSISTCOUNT = 22,
    VT_WORLDID = 24
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int32_t sceneId() const {
    return GetField<int32_t>(VT_SCENEID, 0);
  }
  const Pos *curPos() const {
    return GetPointer<const Pos *>(VT_CURPOS);
  }
  int32_t iff() const {
    return GetField<int32_t>(VT_IFF, 0);
  }
  const flatbuffers::String *pcName() const {
    return GetPointer<const flatbuffers::String *>(VT_PCNAME);
  }
  const flatbuffers::String *guildName() const {
    return GetPointer<const flatbuffers::String *>(VT_GUILDNAME);
  }
  int32_t classType() const {
    return GetField<int32_t>(VT_CLASSTYPE, 0);
  }
  ObjectState state() const {
    return static_cast<ObjectState>(GetField<int32_t>(VT_STATE, 0));
  }
  int32_t killCount() const {
    return GetField<int32_t>(VT_KILLCOUNT, 0);
  }
  int32_t assistCount() const {
    return GetField<int32_t>(VT_ASSISTCOUNT, 0);
  }
  int16_t worldId() const {
    return GetField<int16_t>(VT_WORLDID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int32_t>(verifier, VT_SCENEID) &&
           VerifyOffsetRequired(verifier, VT_CURPOS) &&
           verifier.VerifyTable(curPos()) &&
           VerifyField<int32_t>(verifier, VT_IFF) &&
           VerifyOffsetRequired(verifier, VT_PCNAME) &&
           verifier.VerifyString(pcName()) &&
           VerifyOffset(verifier, VT_GUILDNAME) &&
           verifier.VerifyString(guildName()) &&
           VerifyField<int32_t>(verifier, VT_CLASSTYPE) &&
           VerifyField<int32_t>(verifier, VT_STATE) &&
           VerifyField<int32_t>(verifier, VT_KILLCOUNT) &&
           VerifyField<int32_t>(verifier, VT_ASSISTCOUNT) &&
           VerifyField<int16_t>(verifier, VT_WORLDID) &&
           verifier.EndTable();
  }
};

struct PcSceneMapInfoUpdateNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(PcSceneMapInfoUpdateNotify::VT_OBJECTID, objectId, 0);
  }
  void add_sceneId(int32_t sceneId) {
    fbb_.AddElement<int32_t>(PcSceneMapInfoUpdateNotify::VT_SCENEID, sceneId, 0);
  }
  void add_curPos(flatbuffers::Offset<Pos> curPos) {
    fbb_.AddOffset(PcSceneMapInfoUpdateNotify::VT_CURPOS, curPos);
  }
  void add_iff(int32_t iff) {
    fbb_.AddElement<int32_t>(PcSceneMapInfoUpdateNotify::VT_IFF, iff, 0);
  }
  void add_pcName(flatbuffers::Offset<flatbuffers::String> pcName) {
    fbb_.AddOffset(PcSceneMapInfoUpdateNotify::VT_PCNAME, pcName);
  }
  void add_guildName(flatbuffers::Offset<flatbuffers::String> guildName) {
    fbb_.AddOffset(PcSceneMapInfoUpdateNotify::VT_GUILDNAME, guildName);
  }
  void add_classType(int32_t classType) {
    fbb_.AddElement<int32_t>(PcSceneMapInfoUpdateNotify::VT_CLASSTYPE, classType, 0);
  }
  void add_state(ObjectState state) {
    fbb_.AddElement<int32_t>(PcSceneMapInfoUpdateNotify::VT_STATE, static_cast<int32_t>(state), 0);
  }
  void add_killCount(int32_t killCount) {
    fbb_.AddElement<int32_t>(PcSceneMapInfoUpdateNotify::VT_KILLCOUNT, killCount, 0);
  }
  void add_assistCount(int32_t assistCount) {
    fbb_.AddElement<int32_t>(PcSceneMapInfoUpdateNotify::VT_ASSISTCOUNT, assistCount, 0);
  }
  void add_worldId(int16_t worldId) {
    fbb_.AddElement<int16_t>(PcSceneMapInfoUpdateNotify::VT_WORLDID, worldId, 0);
  }
  explicit PcSceneMapInfoUpdateNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PcSceneMapInfoUpdateNotifyBuilder &operator=(const PcSceneMapInfoUpdateNotifyBuilder &);
  flatbuffers::Offset<PcSceneMapInfoUpdateNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PcSceneMapInfoUpdateNotify>(end);
    fbb_.Required(o, PcSceneMapInfoUpdateNotify::VT_CURPOS);
    fbb_.Required(o, PcSceneMapInfoUpdateNotify::VT_PCNAME);
    return o;
  }
};

inline flatbuffers::Offset<PcSceneMapInfoUpdateNotify> CreatePcSceneMapInfoUpdateNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int32_t sceneId = 0,
    flatbuffers::Offset<Pos> curPos = 0,
    int32_t iff = 0,
    flatbuffers::Offset<flatbuffers::String> pcName = 0,
    flatbuffers::Offset<flatbuffers::String> guildName = 0,
    int32_t classType = 0,
    ObjectState state = ObjectState_OBJECT_STATE_SPAWN,
    int32_t killCount = 0,
    int32_t assistCount = 0,
    int16_t worldId = 0) {
  PcSceneMapInfoUpdateNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_assistCount(assistCount);
  builder_.add_killCount(killCount);
  builder_.add_state(state);
  builder_.add_classType(classType);
  builder_.add_guildName(guildName);
  builder_.add_pcName(pcName);
  builder_.add_iff(iff);
  builder_.add_curPos(curPos);
  builder_.add_sceneId(sceneId);
  builder_.add_worldId(worldId);
  return builder_.Finish();
}

inline flatbuffers::Offset<PcSceneMapInfoUpdateNotify> CreatePcSceneMapInfoUpdateNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int32_t sceneId = 0,
    flatbuffers::Offset<Pos> curPos = 0,
    int32_t iff = 0,
    const char *pcName = nullptr,
    const char *guildName = nullptr,
    int32_t classType = 0,
    ObjectState state = ObjectState_OBJECT_STATE_SPAWN,
    int32_t killCount = 0,
    int32_t assistCount = 0,
    int16_t worldId = 0) {
  return LeanPacket::CreatePcSceneMapInfoUpdateNotify(
      _fbb,
      objectId,
      sceneId,
      curPos,
      iff,
      pcName ? _fbb.CreateString(pcName) : 0,
      guildName ? _fbb.CreateString(guildName) : 0,
      classType,
      state,
      killCount,
      assistCount,
      worldId);
}

/// PC_SCENEMAP_INFO_DESTROY_NOTIFY
struct PcSceneMapInfoDestroyNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           verifier.EndTable();
  }
};

struct PcSceneMapInfoDestroyNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(PcSceneMapInfoDestroyNotify::VT_OBJECTID, objectId, 0);
  }
  explicit PcSceneMapInfoDestroyNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PcSceneMapInfoDestroyNotifyBuilder &operator=(const PcSceneMapInfoDestroyNotifyBuilder &);
  flatbuffers::Offset<PcSceneMapInfoDestroyNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PcSceneMapInfoDestroyNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<PcSceneMapInfoDestroyNotify> CreatePcSceneMapInfoDestroyNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0) {
  PcSceneMapInfoDestroyNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  return builder_.Finish();
}

///- CRAFT_ITEM_REQUEST ----------
struct CraftItemRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCOBJECTID = 4,
    VT_CRAFTID = 6,
    VT_COUNT = 8
  };
  uint64_t pcObjectId() const {
    return GetField<uint64_t>(VT_PCOBJECTID, 0);
  }
  int32_t craftId() const {
    return GetField<int32_t>(VT_CRAFTID, 0);
  }
  int32_t count() const {
    return GetField<int32_t>(VT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PCOBJECTID) &&
           VerifyField<int32_t>(verifier, VT_CRAFTID) &&
           VerifyField<int32_t>(verifier, VT_COUNT) &&
           verifier.EndTable();
  }
};

struct CraftItemRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcObjectId(uint64_t pcObjectId) {
    fbb_.AddElement<uint64_t>(CraftItemRequest::VT_PCOBJECTID, pcObjectId, 0);
  }
  void add_craftId(int32_t craftId) {
    fbb_.AddElement<int32_t>(CraftItemRequest::VT_CRAFTID, craftId, 0);
  }
  void add_count(int32_t count) {
    fbb_.AddElement<int32_t>(CraftItemRequest::VT_COUNT, count, 0);
  }
  explicit CraftItemRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CraftItemRequestBuilder &operator=(const CraftItemRequestBuilder &);
  flatbuffers::Offset<CraftItemRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CraftItemRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<CraftItemRequest> CreateCraftItemRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t pcObjectId = 0,
    int32_t craftId = 0,
    int32_t count = 0) {
  CraftItemRequestBuilder builder_(_fbb);
  builder_.add_pcObjectId(pcObjectId);
  builder_.add_count(count);
  builder_.add_craftId(craftId);
  return builder_.Finish();
}

///- CRAFT_ITEM_RESPONSE ----------
struct CraftItemResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_CRAFTID = 6,
    VT_RESULT = 8
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  int32_t craftId() const {
    return GetField<int32_t>(VT_CRAFTID, 0);
  }
  const ClientItemResultInfo *result() const {
    return GetPointer<const ClientItemResultInfo *>(VT_RESULT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int32_t>(verifier, VT_CRAFTID) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyTable(result()) &&
           verifier.EndTable();
  }
};

struct CraftItemResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(CraftItemResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_craftId(int32_t craftId) {
    fbb_.AddElement<int32_t>(CraftItemResponse::VT_CRAFTID, craftId, 0);
  }
  void add_result(flatbuffers::Offset<ClientItemResultInfo> result) {
    fbb_.AddOffset(CraftItemResponse::VT_RESULT, result);
  }
  explicit CraftItemResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CraftItemResponseBuilder &operator=(const CraftItemResponseBuilder &);
  flatbuffers::Offset<CraftItemResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CraftItemResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<CraftItemResponse> CreateCraftItemResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    int32_t craftId = 0,
    flatbuffers::Offset<ClientItemResultInfo> result = 0) {
  CraftItemResponseBuilder builder_(_fbb);
  builder_.add_result(result);
  builder_.add_craftId(craftId);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

///- TRANSMUTE_CRYSTAL_ITEM_REQUEST
struct TransmuteCrystalItemRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CRAFTID = 4,
    VT_ITEMOBJECTID = 6
  };
  int32_t craftId() const {
    return GetField<int32_t>(VT_CRAFTID, 0);
  }
  const flatbuffers::Vector<uint64_t> *itemObjectId() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_ITEMOBJECTID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CRAFTID) &&
           VerifyOffset(verifier, VT_ITEMOBJECTID) &&
           verifier.VerifyVector(itemObjectId()) &&
           verifier.EndTable();
  }
};

struct TransmuteCrystalItemRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_craftId(int32_t craftId) {
    fbb_.AddElement<int32_t>(TransmuteCrystalItemRequest::VT_CRAFTID, craftId, 0);
  }
  void add_itemObjectId(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> itemObjectId) {
    fbb_.AddOffset(TransmuteCrystalItemRequest::VT_ITEMOBJECTID, itemObjectId);
  }
  explicit TransmuteCrystalItemRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransmuteCrystalItemRequestBuilder &operator=(const TransmuteCrystalItemRequestBuilder &);
  flatbuffers::Offset<TransmuteCrystalItemRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TransmuteCrystalItemRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<TransmuteCrystalItemRequest> CreateTransmuteCrystalItemRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t craftId = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> itemObjectId = 0) {
  TransmuteCrystalItemRequestBuilder builder_(_fbb);
  builder_.add_itemObjectId(itemObjectId);
  builder_.add_craftId(craftId);
  return builder_.Finish();
}

inline flatbuffers::Offset<TransmuteCrystalItemRequest> CreateTransmuteCrystalItemRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t craftId = 0,
    const std::vector<uint64_t> *itemObjectId = nullptr) {
  return LeanPacket::CreateTransmuteCrystalItemRequest(
      _fbb,
      craftId,
      itemObjectId ? _fbb.CreateVector<uint64_t>(*itemObjectId) : 0);
}

///- TRANSMUTE_CRYSTAL_ITEM_RESPONSE
struct TransmuteCrystalItemResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_CRAFTID = 6,
    VT_RESULT = 8
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  int32_t craftId() const {
    return GetField<int32_t>(VT_CRAFTID, 0);
  }
  const ClientItemResultInfo *result() const {
    return GetPointer<const ClientItemResultInfo *>(VT_RESULT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int32_t>(verifier, VT_CRAFTID) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyTable(result()) &&
           verifier.EndTable();
  }
};

struct TransmuteCrystalItemResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(TransmuteCrystalItemResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_craftId(int32_t craftId) {
    fbb_.AddElement<int32_t>(TransmuteCrystalItemResponse::VT_CRAFTID, craftId, 0);
  }
  void add_result(flatbuffers::Offset<ClientItemResultInfo> result) {
    fbb_.AddOffset(TransmuteCrystalItemResponse::VT_RESULT, result);
  }
  explicit TransmuteCrystalItemResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransmuteCrystalItemResponseBuilder &operator=(const TransmuteCrystalItemResponseBuilder &);
  flatbuffers::Offset<TransmuteCrystalItemResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TransmuteCrystalItemResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<TransmuteCrystalItemResponse> CreateTransmuteCrystalItemResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    int32_t craftId = 0,
    flatbuffers::Offset<ClientItemResultInfo> result = 0) {
  TransmuteCrystalItemResponseBuilder builder_(_fbb);
  builder_.add_result(result);
  builder_.add_craftId(craftId);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

///- PRISM_TRANSMUTATION_REQUEST ----------
struct PrismTransmutationRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRISMAMOUNT = 4
  };
  int32_t prismAmount() const {
    return GetField<int32_t>(VT_PRISMAMOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PRISMAMOUNT) &&
           verifier.EndTable();
  }
};

struct PrismTransmutationRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_prismAmount(int32_t prismAmount) {
    fbb_.AddElement<int32_t>(PrismTransmutationRequest::VT_PRISMAMOUNT, prismAmount, 0);
  }
  explicit PrismTransmutationRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PrismTransmutationRequestBuilder &operator=(const PrismTransmutationRequestBuilder &);
  flatbuffers::Offset<PrismTransmutationRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PrismTransmutationRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<PrismTransmutationRequest> CreatePrismTransmutationRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t prismAmount = 0) {
  PrismTransmutationRequestBuilder builder_(_fbb);
  builder_.add_prismAmount(prismAmount);
  return builder_.Finish();
}

///- PRISM_TRANSMUTATION_RESPONSE ----------
struct PrismTransmutationResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_ARTIFACTLEVEL = 6,
    VT_ARTIFACTEXP = 8
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  int16_t artifactLevel() const {
    return GetField<int16_t>(VT_ARTIFACTLEVEL, 0);
  }
  int64_t artifactExp() const {
    return GetField<int64_t>(VT_ARTIFACTEXP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int16_t>(verifier, VT_ARTIFACTLEVEL) &&
           VerifyField<int64_t>(verifier, VT_ARTIFACTEXP) &&
           verifier.EndTable();
  }
};

struct PrismTransmutationResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(PrismTransmutationResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_artifactLevel(int16_t artifactLevel) {
    fbb_.AddElement<int16_t>(PrismTransmutationResponse::VT_ARTIFACTLEVEL, artifactLevel, 0);
  }
  void add_artifactExp(int64_t artifactExp) {
    fbb_.AddElement<int64_t>(PrismTransmutationResponse::VT_ARTIFACTEXP, artifactExp, 0);
  }
  explicit PrismTransmutationResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PrismTransmutationResponseBuilder &operator=(const PrismTransmutationResponseBuilder &);
  flatbuffers::Offset<PrismTransmutationResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PrismTransmutationResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<PrismTransmutationResponse> CreatePrismTransmutationResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    int16_t artifactLevel = 0,
    int64_t artifactExp = 0) {
  PrismTransmutationResponseBuilder builder_(_fbb);
  builder_.add_artifactExp(artifactExp);
  builder_.add_errorCode(errorCode);
  builder_.add_artifactLevel(artifactLevel);
  return builder_.Finish();
}

///-----------------------------------------------------------------------------
/// Game -> Client
///-----------------------------------------------------------------------------
///- PC_LOGIN_DATA_NOTIFY : StorageData ----------
struct StorageData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STORAGETYPE = 4,
    VT_STORAGESIZE = 6
  };
  /// KEY
  int16_t storageType() const {
    return GetField<int16_t>(VT_STORAGETYPE, 0);
  }
  int16_t storageSize() const {
    return GetField<int16_t>(VT_STORAGESIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_STORAGETYPE) &&
           VerifyField<int16_t>(verifier, VT_STORAGESIZE) &&
           verifier.EndTable();
  }
};

struct StorageDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_storageType(int16_t storageType) {
    fbb_.AddElement<int16_t>(StorageData::VT_STORAGETYPE, storageType, 0);
  }
  void add_storageSize(int16_t storageSize) {
    fbb_.AddElement<int16_t>(StorageData::VT_STORAGESIZE, storageSize, 0);
  }
  explicit StorageDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StorageDataBuilder &operator=(const StorageDataBuilder &);
  flatbuffers::Offset<StorageData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StorageData>(end);
    return o;
  }
};

inline flatbuffers::Offset<StorageData> CreateStorageData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t storageType = 0,
    int16_t storageSize = 0) {
  StorageDataBuilder builder_(_fbb);
  builder_.add_storageSize(storageSize);
  builder_.add_storageType(storageType);
  return builder_.Finish();
}

///- PC_LOGIN_DATA_NOTIFY : ClientLItem ----------
struct ClientLItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMOBJECTID = 4,
    VT_ITEMID = 6,
    VT_STORAGETYPE = 8,
    VT_GRADE = 10,
    VT_LEVEL = 12,
    VT_ENCHANTEXP = 14,
    VT_STACKCOUNT = 16,
    VT_SAFEGUARDED = 18,
    VT_BOUNDSTATE = 20,
    VT_SLOTPOSITION = 22,
    VT_DIMENSIONCRYSTALSLOTS = 24,
    VT_REFITEMOBJECTID = 26,
    VT_TRANSCENDLEVEL = 28,
    VT_STATS = 30
  };
  /// KEY : itemDbId 와 objectId 는 1:1 매칭
  uint64_t itemObjectId() const {
    return GetField<uint64_t>(VT_ITEMOBJECTID, 0);
  }
  /// ItemId
  int32_t itemId() const {
    return GetField<int32_t>(VT_ITEMID, 0);
  }
  /// 주장비, 보조장비, 코스츔, 소지품, 개인창고...
  int16_t storageType() const {
    return GetField<int16_t>(VT_STORAGETYPE, 0);
  }
  /// 아이템 등급
  int16_t grade() const {
    return GetField<int16_t>(VT_GRADE, 0);
  }
  /// 아이템 레벨
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  /// 강화 경험치
  int32_t enchantExp() const {
    return GetField<int32_t>(VT_ENCHANTEXP, 0);
  }
  /// 아이템 누적 수량
  int32_t stackCount() const {
    return GetField<int32_t>(VT_STACKCOUNT, 0);
  }
  /// 장비 보호 여부
  int8_t safeguarded() const {
    return GetField<int8_t>(VT_SAFEGUARDED, 0);
  }
  /// 귀속 여부 (0:비귀속, 1:귀속)
  int8_t boundState() const {
    return GetField<int8_t>(VT_BOUNDSTATE, 0);
  }
  int16_t slotPosition() const {
    return GetField<int16_t>(VT_SLOTPOSITION, 0);
  }
  const flatbuffers::Vector<uint64_t> *dimensionCrystalSlots() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_DIMENSIONCRYSTALSLOTS);
  }
  uint64_t refItemObjectId() const {
    return GetField<uint64_t>(VT_REFITEMOBJECTID, 0);
  }
  int16_t transcendLevel() const {
    return GetField<int16_t>(VT_TRANSCENDLEVEL, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TranscendStat>> *stats() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TranscendStat>> *>(VT_STATS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ITEMOBJECTID) &&
           VerifyField<int32_t>(verifier, VT_ITEMID) &&
           VerifyField<int16_t>(verifier, VT_STORAGETYPE) &&
           VerifyField<int16_t>(verifier, VT_GRADE) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_ENCHANTEXP) &&
           VerifyField<int32_t>(verifier, VT_STACKCOUNT) &&
           VerifyField<int8_t>(verifier, VT_SAFEGUARDED) &&
           VerifyField<int8_t>(verifier, VT_BOUNDSTATE) &&
           VerifyField<int16_t>(verifier, VT_SLOTPOSITION) &&
           VerifyOffset(verifier, VT_DIMENSIONCRYSTALSLOTS) &&
           verifier.VerifyVector(dimensionCrystalSlots()) &&
           VerifyField<uint64_t>(verifier, VT_REFITEMOBJECTID) &&
           VerifyField<int16_t>(verifier, VT_TRANSCENDLEVEL) &&
           VerifyOffset(verifier, VT_STATS) &&
           verifier.VerifyVector(stats()) &&
           verifier.VerifyVectorOfTables(stats()) &&
           verifier.EndTable();
  }
};

struct ClientLItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemObjectId(uint64_t itemObjectId) {
    fbb_.AddElement<uint64_t>(ClientLItem::VT_ITEMOBJECTID, itemObjectId, 0);
  }
  void add_itemId(int32_t itemId) {
    fbb_.AddElement<int32_t>(ClientLItem::VT_ITEMID, itemId, 0);
  }
  void add_storageType(int16_t storageType) {
    fbb_.AddElement<int16_t>(ClientLItem::VT_STORAGETYPE, storageType, 0);
  }
  void add_grade(int16_t grade) {
    fbb_.AddElement<int16_t>(ClientLItem::VT_GRADE, grade, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(ClientLItem::VT_LEVEL, level, 0);
  }
  void add_enchantExp(int32_t enchantExp) {
    fbb_.AddElement<int32_t>(ClientLItem::VT_ENCHANTEXP, enchantExp, 0);
  }
  void add_stackCount(int32_t stackCount) {
    fbb_.AddElement<int32_t>(ClientLItem::VT_STACKCOUNT, stackCount, 0);
  }
  void add_safeguarded(int8_t safeguarded) {
    fbb_.AddElement<int8_t>(ClientLItem::VT_SAFEGUARDED, safeguarded, 0);
  }
  void add_boundState(int8_t boundState) {
    fbb_.AddElement<int8_t>(ClientLItem::VT_BOUNDSTATE, boundState, 0);
  }
  void add_slotPosition(int16_t slotPosition) {
    fbb_.AddElement<int16_t>(ClientLItem::VT_SLOTPOSITION, slotPosition, 0);
  }
  void add_dimensionCrystalSlots(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> dimensionCrystalSlots) {
    fbb_.AddOffset(ClientLItem::VT_DIMENSIONCRYSTALSLOTS, dimensionCrystalSlots);
  }
  void add_refItemObjectId(uint64_t refItemObjectId) {
    fbb_.AddElement<uint64_t>(ClientLItem::VT_REFITEMOBJECTID, refItemObjectId, 0);
  }
  void add_transcendLevel(int16_t transcendLevel) {
    fbb_.AddElement<int16_t>(ClientLItem::VT_TRANSCENDLEVEL, transcendLevel, 0);
  }
  void add_stats(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TranscendStat>>> stats) {
    fbb_.AddOffset(ClientLItem::VT_STATS, stats);
  }
  explicit ClientLItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClientLItemBuilder &operator=(const ClientLItemBuilder &);
  flatbuffers::Offset<ClientLItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientLItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClientLItem> CreateClientLItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t itemObjectId = 0,
    int32_t itemId = 0,
    int16_t storageType = 0,
    int16_t grade = 0,
    int32_t level = 0,
    int32_t enchantExp = 0,
    int32_t stackCount = 0,
    int8_t safeguarded = 0,
    int8_t boundState = 0,
    int16_t slotPosition = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> dimensionCrystalSlots = 0,
    uint64_t refItemObjectId = 0,
    int16_t transcendLevel = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TranscendStat>>> stats = 0) {
  ClientLItemBuilder builder_(_fbb);
  builder_.add_refItemObjectId(refItemObjectId);
  builder_.add_itemObjectId(itemObjectId);
  builder_.add_stats(stats);
  builder_.add_dimensionCrystalSlots(dimensionCrystalSlots);
  builder_.add_stackCount(stackCount);
  builder_.add_enchantExp(enchantExp);
  builder_.add_level(level);
  builder_.add_itemId(itemId);
  builder_.add_transcendLevel(transcendLevel);
  builder_.add_slotPosition(slotPosition);
  builder_.add_grade(grade);
  builder_.add_storageType(storageType);
  builder_.add_boundState(boundState);
  builder_.add_safeguarded(safeguarded);
  return builder_.Finish();
}

inline flatbuffers::Offset<ClientLItem> CreateClientLItemDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t itemObjectId = 0,
    int32_t itemId = 0,
    int16_t storageType = 0,
    int16_t grade = 0,
    int32_t level = 0,
    int32_t enchantExp = 0,
    int32_t stackCount = 0,
    int8_t safeguarded = 0,
    int8_t boundState = 0,
    int16_t slotPosition = 0,
    const std::vector<uint64_t> *dimensionCrystalSlots = nullptr,
    uint64_t refItemObjectId = 0,
    int16_t transcendLevel = 0,
    const std::vector<flatbuffers::Offset<TranscendStat>> *stats = nullptr) {
  return LeanPacket::CreateClientLItem(
      _fbb,
      itemObjectId,
      itemId,
      storageType,
      grade,
      level,
      enchantExp,
      stackCount,
      safeguarded,
      boundState,
      slotPosition,
      dimensionCrystalSlots ? _fbb.CreateVector<uint64_t>(*dimensionCrystalSlots) : 0,
      refItemObjectId,
      transcendLevel,
      stats ? _fbb.CreateVector<flatbuffers::Offset<TranscendStat>>(*stats) : 0);
}

struct SkillSlotInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SLOTINDEX = 4,
    VT_SKILLID = 6
  };
  int32_t slotIndex() const {
    return GetField<int32_t>(VT_SLOTINDEX, 0);
  }
  int32_t skillId() const {
    return GetField<int32_t>(VT_SKILLID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SLOTINDEX) &&
           VerifyField<int32_t>(verifier, VT_SKILLID) &&
           verifier.EndTable();
  }
};

struct SkillSlotInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slotIndex(int32_t slotIndex) {
    fbb_.AddElement<int32_t>(SkillSlotInfo::VT_SLOTINDEX, slotIndex, 0);
  }
  void add_skillId(int32_t skillId) {
    fbb_.AddElement<int32_t>(SkillSlotInfo::VT_SKILLID, skillId, 0);
  }
  explicit SkillSlotInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SkillSlotInfoBuilder &operator=(const SkillSlotInfoBuilder &);
  flatbuffers::Offset<SkillSlotInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkillSlotInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkillSlotInfo> CreateSkillSlotInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t slotIndex = 0,
    int32_t skillId = 0) {
  SkillSlotInfoBuilder builder_(_fbb);
  builder_.add_skillId(skillId);
  builder_.add_slotIndex(slotIndex);
  return builder_.Finish();
}

struct SkillSlot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MAINSLOTINDEX = 4,
    VT_SKILLSLOTINFOS = 6
  };
  int8_t mainSlotIndex() const {
    return GetField<int8_t>(VT_MAINSLOTINDEX, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SkillSlotInfo>> *skillSlotInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SkillSlotInfo>> *>(VT_SKILLSLOTINFOS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MAINSLOTINDEX) &&
           VerifyOffsetRequired(verifier, VT_SKILLSLOTINFOS) &&
           verifier.VerifyVector(skillSlotInfos()) &&
           verifier.VerifyVectorOfTables(skillSlotInfos()) &&
           verifier.EndTable();
  }
};

struct SkillSlotBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mainSlotIndex(int8_t mainSlotIndex) {
    fbb_.AddElement<int8_t>(SkillSlot::VT_MAINSLOTINDEX, mainSlotIndex, 0);
  }
  void add_skillSlotInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SkillSlotInfo>>> skillSlotInfos) {
    fbb_.AddOffset(SkillSlot::VT_SKILLSLOTINFOS, skillSlotInfos);
  }
  explicit SkillSlotBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SkillSlotBuilder &operator=(const SkillSlotBuilder &);
  flatbuffers::Offset<SkillSlot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkillSlot>(end);
    fbb_.Required(o, SkillSlot::VT_SKILLSLOTINFOS);
    return o;
  }
};

inline flatbuffers::Offset<SkillSlot> CreateSkillSlot(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t mainSlotIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SkillSlotInfo>>> skillSlotInfos = 0) {
  SkillSlotBuilder builder_(_fbb);
  builder_.add_skillSlotInfos(skillSlotInfos);
  builder_.add_mainSlotIndex(mainSlotIndex);
  return builder_.Finish();
}

inline flatbuffers::Offset<SkillSlot> CreateSkillSlotDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t mainSlotIndex = 0,
    const std::vector<flatbuffers::Offset<SkillSlotInfo>> *skillSlotInfos = nullptr) {
  return LeanPacket::CreateSkillSlot(
      _fbb,
      mainSlotIndex,
      skillSlotInfos ? _fbb.CreateVector<flatbuffers::Offset<SkillSlotInfo>>(*skillSlotInfos) : 0);
}

struct PurseInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PAIDGOLD = 4,
    VT_REWARDGOLD = 6,
    VT_PAIDDIA = 8,
    VT_REWARDDIA = 10,
    VT_REWARDPRISM = 12,
    VT_PAIDPRISM = 14,
    VT_FORTUNEPOINT = 16,
    VT_GUILDCOIN = 18,
    VT_MONARCHPOINT = 20,
    VT_PVPCOIN = 22
  };
  int64_t paidGold() const {
    return GetField<int64_t>(VT_PAIDGOLD, 0);
  }
  int64_t rewardGold() const {
    return GetField<int64_t>(VT_REWARDGOLD, 0);
  }
  int32_t paidDia() const {
    return GetField<int32_t>(VT_PAIDDIA, 0);
  }
  int32_t rewardDia() const {
    return GetField<int32_t>(VT_REWARDDIA, 0);
  }
  int32_t rewardPrism() const {
    return GetField<int32_t>(VT_REWARDPRISM, 0);
  }
  int32_t paidPrism() const {
    return GetField<int32_t>(VT_PAIDPRISM, 0);
  }
  int32_t fortunePoint() const {
    return GetField<int32_t>(VT_FORTUNEPOINT, 0);
  }
  int32_t guildCoin() const {
    return GetField<int32_t>(VT_GUILDCOIN, 0);
  }
  int32_t monarchPoint() const {
    return GetField<int32_t>(VT_MONARCHPOINT, 0);
  }
  int64_t pvpCoin() const {
    return GetField<int64_t>(VT_PVPCOIN, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PAIDGOLD) &&
           VerifyField<int64_t>(verifier, VT_REWARDGOLD) &&
           VerifyField<int32_t>(verifier, VT_PAIDDIA) &&
           VerifyField<int32_t>(verifier, VT_REWARDDIA) &&
           VerifyField<int32_t>(verifier, VT_REWARDPRISM) &&
           VerifyField<int32_t>(verifier, VT_PAIDPRISM) &&
           VerifyField<int32_t>(verifier, VT_FORTUNEPOINT) &&
           VerifyField<int32_t>(verifier, VT_GUILDCOIN) &&
           VerifyField<int32_t>(verifier, VT_MONARCHPOINT) &&
           VerifyField<int64_t>(verifier, VT_PVPCOIN) &&
           verifier.EndTable();
  }
};

struct PurseInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_paidGold(int64_t paidGold) {
    fbb_.AddElement<int64_t>(PurseInfo::VT_PAIDGOLD, paidGold, 0);
  }
  void add_rewardGold(int64_t rewardGold) {
    fbb_.AddElement<int64_t>(PurseInfo::VT_REWARDGOLD, rewardGold, 0);
  }
  void add_paidDia(int32_t paidDia) {
    fbb_.AddElement<int32_t>(PurseInfo::VT_PAIDDIA, paidDia, 0);
  }
  void add_rewardDia(int32_t rewardDia) {
    fbb_.AddElement<int32_t>(PurseInfo::VT_REWARDDIA, rewardDia, 0);
  }
  void add_rewardPrism(int32_t rewardPrism) {
    fbb_.AddElement<int32_t>(PurseInfo::VT_REWARDPRISM, rewardPrism, 0);
  }
  void add_paidPrism(int32_t paidPrism) {
    fbb_.AddElement<int32_t>(PurseInfo::VT_PAIDPRISM, paidPrism, 0);
  }
  void add_fortunePoint(int32_t fortunePoint) {
    fbb_.AddElement<int32_t>(PurseInfo::VT_FORTUNEPOINT, fortunePoint, 0);
  }
  void add_guildCoin(int32_t guildCoin) {
    fbb_.AddElement<int32_t>(PurseInfo::VT_GUILDCOIN, guildCoin, 0);
  }
  void add_monarchPoint(int32_t monarchPoint) {
    fbb_.AddElement<int32_t>(PurseInfo::VT_MONARCHPOINT, monarchPoint, 0);
  }
  void add_pvpCoin(int64_t pvpCoin) {
    fbb_.AddElement<int64_t>(PurseInfo::VT_PVPCOIN, pvpCoin, 0);
  }
  explicit PurseInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PurseInfoBuilder &operator=(const PurseInfoBuilder &);
  flatbuffers::Offset<PurseInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PurseInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<PurseInfo> CreatePurseInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t paidGold = 0,
    int64_t rewardGold = 0,
    int32_t paidDia = 0,
    int32_t rewardDia = 0,
    int32_t rewardPrism = 0,
    int32_t paidPrism = 0,
    int32_t fortunePoint = 0,
    int32_t guildCoin = 0,
    int32_t monarchPoint = 0,
    int64_t pvpCoin = 0) {
  PurseInfoBuilder builder_(_fbb);
  builder_.add_pvpCoin(pvpCoin);
  builder_.add_rewardGold(rewardGold);
  builder_.add_paidGold(paidGold);
  builder_.add_monarchPoint(monarchPoint);
  builder_.add_guildCoin(guildCoin);
  builder_.add_fortunePoint(fortunePoint);
  builder_.add_paidPrism(paidPrism);
  builder_.add_rewardPrism(rewardPrism);
  builder_.add_rewardDia(rewardDia);
  builder_.add_paidDia(paidDia);
  return builder_.Finish();
}

struct CostInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COSTTYPE = 4,
    VT_AMOUNT = 6
  };
  int16_t costType() const {
    return GetField<int16_t>(VT_COSTTYPE, 0);
  }
  int32_t amount() const {
    return GetField<int32_t>(VT_AMOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_COSTTYPE) &&
           VerifyField<int32_t>(verifier, VT_AMOUNT) &&
           verifier.EndTable();
  }
};

struct CostInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_costType(int16_t costType) {
    fbb_.AddElement<int16_t>(CostInfo::VT_COSTTYPE, costType, 0);
  }
  void add_amount(int32_t amount) {
    fbb_.AddElement<int32_t>(CostInfo::VT_AMOUNT, amount, 0);
  }
  explicit CostInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CostInfoBuilder &operator=(const CostInfoBuilder &);
  flatbuffers::Offset<CostInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CostInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<CostInfo> CreateCostInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t costType = 0,
    int32_t amount = 0) {
  CostInfoBuilder builder_(_fbb);
  builder_.add_amount(amount);
  builder_.add_costType(costType);
  return builder_.Finish();
}

struct FollowerInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FOLLOWERID = 4,
    VT_LEVEL = 6,
    VT_STONECOUNT = 8,
    VT_POSITIONIDX = 10,
    VT_STARTTIME = 12
  };
  int32_t followerId() const {
    return GetField<int32_t>(VT_FOLLOWERID, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int32_t stoneCount() const {
    return GetField<int32_t>(VT_STONECOUNT, 0);
  }
  int32_t positionIdx() const {
    return GetField<int32_t>(VT_POSITIONIDX, 0);
  }
  int64_t startTime() const {
    return GetField<int64_t>(VT_STARTTIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FOLLOWERID) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_STONECOUNT) &&
           VerifyField<int32_t>(verifier, VT_POSITIONIDX) &&
           VerifyField<int64_t>(verifier, VT_STARTTIME) &&
           verifier.EndTable();
  }
};

struct FollowerInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_followerId(int32_t followerId) {
    fbb_.AddElement<int32_t>(FollowerInfo::VT_FOLLOWERID, followerId, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(FollowerInfo::VT_LEVEL, level, 0);
  }
  void add_stoneCount(int32_t stoneCount) {
    fbb_.AddElement<int32_t>(FollowerInfo::VT_STONECOUNT, stoneCount, 0);
  }
  void add_positionIdx(int32_t positionIdx) {
    fbb_.AddElement<int32_t>(FollowerInfo::VT_POSITIONIDX, positionIdx, 0);
  }
  void add_startTime(int64_t startTime) {
    fbb_.AddElement<int64_t>(FollowerInfo::VT_STARTTIME, startTime, 0);
  }
  explicit FollowerInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FollowerInfoBuilder &operator=(const FollowerInfoBuilder &);
  flatbuffers::Offset<FollowerInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FollowerInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<FollowerInfo> CreateFollowerInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t followerId = 0,
    int32_t level = 0,
    int32_t stoneCount = 0,
    int32_t positionIdx = 0,
    int64_t startTime = 0) {
  FollowerInfoBuilder builder_(_fbb);
  builder_.add_startTime(startTime);
  builder_.add_positionIdx(positionIdx);
  builder_.add_stoneCount(stoneCount);
  builder_.add_level(level);
  builder_.add_followerId(followerId);
  return builder_.Finish();
}

struct TicketInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_PAIDTICKET = 6,
    VT_FREETICKET = 8,
    VT_MAXFREETICKET = 10
  };
  int16_t type() const {
    return GetField<int16_t>(VT_TYPE, 0);
  }
  int16_t paidTicket() const {
    return GetField<int16_t>(VT_PAIDTICKET, 0);
  }
  int16_t freeTicket() const {
    return GetField<int16_t>(VT_FREETICKET, 0);
  }
  int32_t maxFreeTicket() const {
    return GetField<int32_t>(VT_MAXFREETICKET, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPE) &&
           VerifyField<int16_t>(verifier, VT_PAIDTICKET) &&
           VerifyField<int16_t>(verifier, VT_FREETICKET) &&
           VerifyField<int32_t>(verifier, VT_MAXFREETICKET) &&
           verifier.EndTable();
  }
};

struct TicketInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int16_t type) {
    fbb_.AddElement<int16_t>(TicketInfo::VT_TYPE, type, 0);
  }
  void add_paidTicket(int16_t paidTicket) {
    fbb_.AddElement<int16_t>(TicketInfo::VT_PAIDTICKET, paidTicket, 0);
  }
  void add_freeTicket(int16_t freeTicket) {
    fbb_.AddElement<int16_t>(TicketInfo::VT_FREETICKET, freeTicket, 0);
  }
  void add_maxFreeTicket(int32_t maxFreeTicket) {
    fbb_.AddElement<int32_t>(TicketInfo::VT_MAXFREETICKET, maxFreeTicket, 0);
  }
  explicit TicketInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TicketInfoBuilder &operator=(const TicketInfoBuilder &);
  flatbuffers::Offset<TicketInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TicketInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<TicketInfo> CreateTicketInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t type = 0,
    int16_t paidTicket = 0,
    int16_t freeTicket = 0,
    int32_t maxFreeTicket = 0) {
  TicketInfoBuilder builder_(_fbb);
  builder_.add_maxFreeTicket(maxFreeTicket);
  builder_.add_freeTicket(freeTicket);
  builder_.add_paidTicket(paidTicket);
  builder_.add_type(type);
  return builder_.Finish();
}

struct PcGuildInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GUILDNAME = 4,
    VT_GUILDMEMBERGRADE = 6,
    VT_ISLEADERGUILD = 8,
    VT_GUILDCREST = 10
  };
  const flatbuffers::String *guildName() const {
    return GetPointer<const flatbuffers::String *>(VT_GUILDNAME);
  }
  int8_t guildMemberGrade() const {
    return GetField<int8_t>(VT_GUILDMEMBERGRADE, 0);
  }
  /// 군주 길드 여부
  bool isLeaderGuild() const {
    return GetField<uint8_t>(VT_ISLEADERGUILD, 0) != 0;
  }
  /// 삭제 예정 (네임플레이트에 길드문장을 보여줄 필요가 없어서)
  const GuildCrest *guildCrest() const {
    return GetPointer<const GuildCrest *>(VT_GUILDCREST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_GUILDNAME) &&
           verifier.VerifyString(guildName()) &&
           VerifyField<int8_t>(verifier, VT_GUILDMEMBERGRADE) &&
           VerifyField<uint8_t>(verifier, VT_ISLEADERGUILD) &&
           VerifyOffsetRequired(verifier, VT_GUILDCREST) &&
           verifier.VerifyTable(guildCrest()) &&
           verifier.EndTable();
  }
};

struct PcGuildInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_guildName(flatbuffers::Offset<flatbuffers::String> guildName) {
    fbb_.AddOffset(PcGuildInfo::VT_GUILDNAME, guildName);
  }
  void add_guildMemberGrade(int8_t guildMemberGrade) {
    fbb_.AddElement<int8_t>(PcGuildInfo::VT_GUILDMEMBERGRADE, guildMemberGrade, 0);
  }
  void add_isLeaderGuild(bool isLeaderGuild) {
    fbb_.AddElement<uint8_t>(PcGuildInfo::VT_ISLEADERGUILD, static_cast<uint8_t>(isLeaderGuild), 0);
  }
  void add_guildCrest(flatbuffers::Offset<GuildCrest> guildCrest) {
    fbb_.AddOffset(PcGuildInfo::VT_GUILDCREST, guildCrest);
  }
  explicit PcGuildInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PcGuildInfoBuilder &operator=(const PcGuildInfoBuilder &);
  flatbuffers::Offset<PcGuildInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PcGuildInfo>(end);
    fbb_.Required(o, PcGuildInfo::VT_GUILDNAME);
    fbb_.Required(o, PcGuildInfo::VT_GUILDCREST);
    return o;
  }
};

inline flatbuffers::Offset<PcGuildInfo> CreatePcGuildInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> guildName = 0,
    int8_t guildMemberGrade = 0,
    bool isLeaderGuild = false,
    flatbuffers::Offset<GuildCrest> guildCrest = 0) {
  PcGuildInfoBuilder builder_(_fbb);
  builder_.add_guildCrest(guildCrest);
  builder_.add_guildName(guildName);
  builder_.add_isLeaderGuild(isLeaderGuild);
  builder_.add_guildMemberGrade(guildMemberGrade);
  return builder_.Finish();
}

inline flatbuffers::Offset<PcGuildInfo> CreatePcGuildInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *guildName = nullptr,
    int8_t guildMemberGrade = 0,
    bool isLeaderGuild = false,
    flatbuffers::Offset<GuildCrest> guildCrest = 0) {
  return LeanPacket::CreatePcGuildInfo(
      _fbb,
      guildName ? _fbb.CreateString(guildName) : 0,
      guildMemberGrade,
      isLeaderGuild,
      guildCrest);
}

///- PC_LOGIN_DATA_NOTIFY ----------
struct PcLoginDataNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_PCDBID = 6,
    VT_NAME = 8,
    VT_POS = 10,
    VT_IFF = 12,
    VT_CLASSTYPE = 14,
    VT_LEVEL = 16,
    VT_ACCUMEXP = 18,
    VT_CURRENTHP = 20,
    VT_SCENEID = 22,
    VT_ANGLE = 24,
    VT_CUSTOMIZINGINFO = 26,
    VT_SKILLSLOTINFOS = 28,
    VT_PURSEINFO = 30,
    VT_SKILLFEATUREINFOS = 32,
    VT_CURSKILLPOINT = 34,
    VT_LIMITSKILLPOINT = 36,
    VT_ARTIFACT = 38,
    VT_MAIL = 40,
    VT_INFLUENCE = 42,
    VT_TICKET = 44,
    VT_ISMANUALRECHARGABLE = 46,
    VT_PCGUILDINFO = 48,
    VT_CREATETIME = 50,
    VT_ACCOUNTCREATETIME = 52,
    VT_WORLDID = 54
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const Pos *pos() const {
    return GetPointer<const Pos *>(VT_POS);
  }
  int32_t iff() const {
    return GetField<int32_t>(VT_IFF, 0);
  }
  int32_t classType() const {
    return GetField<int32_t>(VT_CLASSTYPE, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int64_t accumExp() const {
    return GetField<int64_t>(VT_ACCUMEXP, 0);
  }
  int64_t currentHp() const {
    return GetField<int64_t>(VT_CURRENTHP, 0);
  }
  int32_t sceneId() const {
    return GetField<int32_t>(VT_SCENEID, 0);
  }
  int16_t angle() const {
    return GetField<int16_t>(VT_ANGLE, 0);
  }
  const CustomizeInfo *customizingInfo() const {
    return GetPointer<const CustomizeInfo *>(VT_CUSTOMIZINGINFO);
  }
  const SkillSlot *skillSlotInfos() const {
    return GetPointer<const SkillSlot *>(VT_SKILLSLOTINFOS);
  }
  const PurseInfo *purseInfo() const {
    return GetPointer<const PurseInfo *>(VT_PURSEINFO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<LoadedSkillFeatureInfo>> *skillFeatureInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LoadedSkillFeatureInfo>> *>(VT_SKILLFEATUREINFOS);
  }
  int16_t curSkillPoint() const {
    return GetField<int16_t>(VT_CURSKILLPOINT, 0);
  }
  int16_t limitSkillPoint() const {
    return GetField<int16_t>(VT_LIMITSKILLPOINT, 0);
  }
  const ArtifactInfo *artifact() const {
    return GetPointer<const ArtifactInfo *>(VT_ARTIFACT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<MailInfo>> *mail() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MailInfo>> *>(VT_MAIL);
  }
  int64_t influence() const {
    return GetField<int64_t>(VT_INFLUENCE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TicketInfo>> *ticket() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TicketInfo>> *>(VT_TICKET);
  }
  bool isManualRechargable() const {
    return GetField<uint8_t>(VT_ISMANUALRECHARGABLE, 0) != 0;
  }
  const PcGuildInfo *pcGuildInfo() const {
    return GetPointer<const PcGuildInfo *>(VT_PCGUILDINFO);
  }
  int64_t createTime() const {
    return GetField<int64_t>(VT_CREATETIME, 0);
  }
  int64_t accountCreateTime() const {
    return GetField<int64_t>(VT_ACCOUNTCREATETIME, 0);
  }
  int16_t worldId() const {
    return GetField<int16_t>(VT_WORLDID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_POS) &&
           verifier.VerifyTable(pos()) &&
           VerifyField<int32_t>(verifier, VT_IFF) &&
           VerifyField<int32_t>(verifier, VT_CLASSTYPE) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int64_t>(verifier, VT_ACCUMEXP) &&
           VerifyField<int64_t>(verifier, VT_CURRENTHP) &&
           VerifyField<int32_t>(verifier, VT_SCENEID) &&
           VerifyField<int16_t>(verifier, VT_ANGLE) &&
           VerifyOffsetRequired(verifier, VT_CUSTOMIZINGINFO) &&
           verifier.VerifyTable(customizingInfo()) &&
           VerifyOffsetRequired(verifier, VT_SKILLSLOTINFOS) &&
           verifier.VerifyTable(skillSlotInfos()) &&
           VerifyOffsetRequired(verifier, VT_PURSEINFO) &&
           verifier.VerifyTable(purseInfo()) &&
           VerifyOffsetRequired(verifier, VT_SKILLFEATUREINFOS) &&
           verifier.VerifyVector(skillFeatureInfos()) &&
           verifier.VerifyVectorOfTables(skillFeatureInfos()) &&
           VerifyField<int16_t>(verifier, VT_CURSKILLPOINT) &&
           VerifyField<int16_t>(verifier, VT_LIMITSKILLPOINT) &&
           VerifyOffsetRequired(verifier, VT_ARTIFACT) &&
           verifier.VerifyTable(artifact()) &&
           VerifyOffsetRequired(verifier, VT_MAIL) &&
           verifier.VerifyVector(mail()) &&
           verifier.VerifyVectorOfTables(mail()) &&
           VerifyField<int64_t>(verifier, VT_INFLUENCE) &&
           VerifyOffsetRequired(verifier, VT_TICKET) &&
           verifier.VerifyVector(ticket()) &&
           verifier.VerifyVectorOfTables(ticket()) &&
           VerifyField<uint8_t>(verifier, VT_ISMANUALRECHARGABLE) &&
           VerifyOffset(verifier, VT_PCGUILDINFO) &&
           verifier.VerifyTable(pcGuildInfo()) &&
           VerifyField<int64_t>(verifier, VT_CREATETIME) &&
           VerifyField<int64_t>(verifier, VT_ACCOUNTCREATETIME) &&
           VerifyField<int16_t>(verifier, VT_WORLDID) &&
           verifier.EndTable();
  }
};

struct PcLoginDataNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(PcLoginDataNotify::VT_OBJECTID, objectId, 0);
  }
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(PcLoginDataNotify::VT_PCDBID, pcDbId, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(PcLoginDataNotify::VT_NAME, name);
  }
  void add_pos(flatbuffers::Offset<Pos> pos) {
    fbb_.AddOffset(PcLoginDataNotify::VT_POS, pos);
  }
  void add_iff(int32_t iff) {
    fbb_.AddElement<int32_t>(PcLoginDataNotify::VT_IFF, iff, 0);
  }
  void add_classType(int32_t classType) {
    fbb_.AddElement<int32_t>(PcLoginDataNotify::VT_CLASSTYPE, classType, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(PcLoginDataNotify::VT_LEVEL, level, 0);
  }
  void add_accumExp(int64_t accumExp) {
    fbb_.AddElement<int64_t>(PcLoginDataNotify::VT_ACCUMEXP, accumExp, 0);
  }
  void add_currentHp(int64_t currentHp) {
    fbb_.AddElement<int64_t>(PcLoginDataNotify::VT_CURRENTHP, currentHp, 0);
  }
  void add_sceneId(int32_t sceneId) {
    fbb_.AddElement<int32_t>(PcLoginDataNotify::VT_SCENEID, sceneId, 0);
  }
  void add_angle(int16_t angle) {
    fbb_.AddElement<int16_t>(PcLoginDataNotify::VT_ANGLE, angle, 0);
  }
  void add_customizingInfo(flatbuffers::Offset<CustomizeInfo> customizingInfo) {
    fbb_.AddOffset(PcLoginDataNotify::VT_CUSTOMIZINGINFO, customizingInfo);
  }
  void add_skillSlotInfos(flatbuffers::Offset<SkillSlot> skillSlotInfos) {
    fbb_.AddOffset(PcLoginDataNotify::VT_SKILLSLOTINFOS, skillSlotInfos);
  }
  void add_purseInfo(flatbuffers::Offset<PurseInfo> purseInfo) {
    fbb_.AddOffset(PcLoginDataNotify::VT_PURSEINFO, purseInfo);
  }
  void add_skillFeatureInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LoadedSkillFeatureInfo>>> skillFeatureInfos) {
    fbb_.AddOffset(PcLoginDataNotify::VT_SKILLFEATUREINFOS, skillFeatureInfos);
  }
  void add_curSkillPoint(int16_t curSkillPoint) {
    fbb_.AddElement<int16_t>(PcLoginDataNotify::VT_CURSKILLPOINT, curSkillPoint, 0);
  }
  void add_limitSkillPoint(int16_t limitSkillPoint) {
    fbb_.AddElement<int16_t>(PcLoginDataNotify::VT_LIMITSKILLPOINT, limitSkillPoint, 0);
  }
  void add_artifact(flatbuffers::Offset<ArtifactInfo> artifact) {
    fbb_.AddOffset(PcLoginDataNotify::VT_ARTIFACT, artifact);
  }
  void add_mail(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MailInfo>>> mail) {
    fbb_.AddOffset(PcLoginDataNotify::VT_MAIL, mail);
  }
  void add_influence(int64_t influence) {
    fbb_.AddElement<int64_t>(PcLoginDataNotify::VT_INFLUENCE, influence, 0);
  }
  void add_ticket(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TicketInfo>>> ticket) {
    fbb_.AddOffset(PcLoginDataNotify::VT_TICKET, ticket);
  }
  void add_isManualRechargable(bool isManualRechargable) {
    fbb_.AddElement<uint8_t>(PcLoginDataNotify::VT_ISMANUALRECHARGABLE, static_cast<uint8_t>(isManualRechargable), 0);
  }
  void add_pcGuildInfo(flatbuffers::Offset<PcGuildInfo> pcGuildInfo) {
    fbb_.AddOffset(PcLoginDataNotify::VT_PCGUILDINFO, pcGuildInfo);
  }
  void add_createTime(int64_t createTime) {
    fbb_.AddElement<int64_t>(PcLoginDataNotify::VT_CREATETIME, createTime, 0);
  }
  void add_accountCreateTime(int64_t accountCreateTime) {
    fbb_.AddElement<int64_t>(PcLoginDataNotify::VT_ACCOUNTCREATETIME, accountCreateTime, 0);
  }
  void add_worldId(int16_t worldId) {
    fbb_.AddElement<int16_t>(PcLoginDataNotify::VT_WORLDID, worldId, 0);
  }
  explicit PcLoginDataNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PcLoginDataNotifyBuilder &operator=(const PcLoginDataNotifyBuilder &);
  flatbuffers::Offset<PcLoginDataNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PcLoginDataNotify>(end);
    fbb_.Required(o, PcLoginDataNotify::VT_NAME);
    fbb_.Required(o, PcLoginDataNotify::VT_POS);
    fbb_.Required(o, PcLoginDataNotify::VT_CUSTOMIZINGINFO);
    fbb_.Required(o, PcLoginDataNotify::VT_SKILLSLOTINFOS);
    fbb_.Required(o, PcLoginDataNotify::VT_PURSEINFO);
    fbb_.Required(o, PcLoginDataNotify::VT_SKILLFEATUREINFOS);
    fbb_.Required(o, PcLoginDataNotify::VT_ARTIFACT);
    fbb_.Required(o, PcLoginDataNotify::VT_MAIL);
    fbb_.Required(o, PcLoginDataNotify::VT_TICKET);
    return o;
  }
};

inline flatbuffers::Offset<PcLoginDataNotify> CreatePcLoginDataNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int64_t pcDbId = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<Pos> pos = 0,
    int32_t iff = 0,
    int32_t classType = 0,
    int32_t level = 0,
    int64_t accumExp = 0,
    int64_t currentHp = 0,
    int32_t sceneId = 0,
    int16_t angle = 0,
    flatbuffers::Offset<CustomizeInfo> customizingInfo = 0,
    flatbuffers::Offset<SkillSlot> skillSlotInfos = 0,
    flatbuffers::Offset<PurseInfo> purseInfo = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LoadedSkillFeatureInfo>>> skillFeatureInfos = 0,
    int16_t curSkillPoint = 0,
    int16_t limitSkillPoint = 0,
    flatbuffers::Offset<ArtifactInfo> artifact = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MailInfo>>> mail = 0,
    int64_t influence = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TicketInfo>>> ticket = 0,
    bool isManualRechargable = false,
    flatbuffers::Offset<PcGuildInfo> pcGuildInfo = 0,
    int64_t createTime = 0,
    int64_t accountCreateTime = 0,
    int16_t worldId = 0) {
  PcLoginDataNotifyBuilder builder_(_fbb);
  builder_.add_accountCreateTime(accountCreateTime);
  builder_.add_createTime(createTime);
  builder_.add_influence(influence);
  builder_.add_currentHp(currentHp);
  builder_.add_accumExp(accumExp);
  builder_.add_pcDbId(pcDbId);
  builder_.add_objectId(objectId);
  builder_.add_pcGuildInfo(pcGuildInfo);
  builder_.add_ticket(ticket);
  builder_.add_mail(mail);
  builder_.add_artifact(artifact);
  builder_.add_skillFeatureInfos(skillFeatureInfos);
  builder_.add_purseInfo(purseInfo);
  builder_.add_skillSlotInfos(skillSlotInfos);
  builder_.add_customizingInfo(customizingInfo);
  builder_.add_sceneId(sceneId);
  builder_.add_level(level);
  builder_.add_classType(classType);
  builder_.add_iff(iff);
  builder_.add_pos(pos);
  builder_.add_name(name);
  builder_.add_worldId(worldId);
  builder_.add_limitSkillPoint(limitSkillPoint);
  builder_.add_curSkillPoint(curSkillPoint);
  builder_.add_angle(angle);
  builder_.add_isManualRechargable(isManualRechargable);
  return builder_.Finish();
}

inline flatbuffers::Offset<PcLoginDataNotify> CreatePcLoginDataNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int64_t pcDbId = 0,
    const char *name = nullptr,
    flatbuffers::Offset<Pos> pos = 0,
    int32_t iff = 0,
    int32_t classType = 0,
    int32_t level = 0,
    int64_t accumExp = 0,
    int64_t currentHp = 0,
    int32_t sceneId = 0,
    int16_t angle = 0,
    flatbuffers::Offset<CustomizeInfo> customizingInfo = 0,
    flatbuffers::Offset<SkillSlot> skillSlotInfos = 0,
    flatbuffers::Offset<PurseInfo> purseInfo = 0,
    const std::vector<flatbuffers::Offset<LoadedSkillFeatureInfo>> *skillFeatureInfos = nullptr,
    int16_t curSkillPoint = 0,
    int16_t limitSkillPoint = 0,
    flatbuffers::Offset<ArtifactInfo> artifact = 0,
    const std::vector<flatbuffers::Offset<MailInfo>> *mail = nullptr,
    int64_t influence = 0,
    const std::vector<flatbuffers::Offset<TicketInfo>> *ticket = nullptr,
    bool isManualRechargable = false,
    flatbuffers::Offset<PcGuildInfo> pcGuildInfo = 0,
    int64_t createTime = 0,
    int64_t accountCreateTime = 0,
    int16_t worldId = 0) {
  return LeanPacket::CreatePcLoginDataNotify(
      _fbb,
      objectId,
      pcDbId,
      name ? _fbb.CreateString(name) : 0,
      pos,
      iff,
      classType,
      level,
      accumExp,
      currentHp,
      sceneId,
      angle,
      customizingInfo,
      skillSlotInfos,
      purseInfo,
      skillFeatureInfos ? _fbb.CreateVector<flatbuffers::Offset<LoadedSkillFeatureInfo>>(*skillFeatureInfos) : 0,
      curSkillPoint,
      limitSkillPoint,
      artifact,
      mail ? _fbb.CreateVector<flatbuffers::Offset<MailInfo>>(*mail) : 0,
      influence,
      ticket ? _fbb.CreateVector<flatbuffers::Offset<TicketInfo>>(*ticket) : 0,
      isManualRechargable,
      pcGuildInfo,
      createTime,
      accountCreateTime,
      worldId);
}

struct StorageDataNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATAS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<StorageData>> *datas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<StorageData>> *>(VT_DATAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DATAS) &&
           verifier.VerifyVector(datas()) &&
           verifier.VerifyVectorOfTables(datas()) &&
           verifier.EndTable();
  }
};

struct StorageDataNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_datas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StorageData>>> datas) {
    fbb_.AddOffset(StorageDataNotify::VT_DATAS, datas);
  }
  explicit StorageDataNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StorageDataNotifyBuilder &operator=(const StorageDataNotifyBuilder &);
  flatbuffers::Offset<StorageDataNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StorageDataNotify>(end);
    fbb_.Required(o, StorageDataNotify::VT_DATAS);
    return o;
  }
};

inline flatbuffers::Offset<StorageDataNotify> CreateStorageDataNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StorageData>>> datas = 0) {
  StorageDataNotifyBuilder builder_(_fbb);
  builder_.add_datas(datas);
  return builder_.Finish();
}

inline flatbuffers::Offset<StorageDataNotify> CreateStorageDataNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<StorageData>> *datas = nullptr) {
  return LeanPacket::CreateStorageDataNotify(
      _fbb,
      datas ? _fbb.CreateVector<flatbuffers::Offset<StorageData>>(*datas) : 0);
}

struct StorageItemDataNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_DATAS = 6
  };
  int16_t type() const {
    return GetField<int16_t>(VT_TYPE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ClientLItem>> *datas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ClientLItem>> *>(VT_DATAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPE) &&
           VerifyOffsetRequired(verifier, VT_DATAS) &&
           verifier.VerifyVector(datas()) &&
           verifier.VerifyVectorOfTables(datas()) &&
           verifier.EndTable();
  }
};

struct StorageItemDataNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int16_t type) {
    fbb_.AddElement<int16_t>(StorageItemDataNotify::VT_TYPE, type, 0);
  }
  void add_datas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ClientLItem>>> datas) {
    fbb_.AddOffset(StorageItemDataNotify::VT_DATAS, datas);
  }
  explicit StorageItemDataNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StorageItemDataNotifyBuilder &operator=(const StorageItemDataNotifyBuilder &);
  flatbuffers::Offset<StorageItemDataNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StorageItemDataNotify>(end);
    fbb_.Required(o, StorageItemDataNotify::VT_DATAS);
    return o;
  }
};

inline flatbuffers::Offset<StorageItemDataNotify> CreateStorageItemDataNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ClientLItem>>> datas = 0) {
  StorageItemDataNotifyBuilder builder_(_fbb);
  builder_.add_datas(datas);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<StorageItemDataNotify> CreateStorageItemDataNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t type = 0,
    const std::vector<flatbuffers::Offset<ClientLItem>> *datas = nullptr) {
  return LeanPacket::CreateStorageItemDataNotify(
      _fbb,
      type,
      datas ? _fbb.CreateVector<flatbuffers::Offset<ClientLItem>>(*datas) : 0);
}

struct EquipDataNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRESETNO = 4,
    VT_COSTUMEPRESETNO = 6,
    VT_EQUIP = 8,
    VT_PRESET = 10,
    VT_COSTUME = 12,
    VT_COSTUMEPRESET = 14
  };
  int16_t presetNo() const {
    return GetField<int16_t>(VT_PRESETNO, 0);
  }
  int16_t costumePresetNo() const {
    return GetField<int16_t>(VT_COSTUMEPRESETNO, 0);
  }
  const EquipInfo *equip() const {
    return GetPointer<const EquipInfo *>(VT_EQUIP);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PresetInfo>> *preset() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PresetInfo>> *>(VT_PRESET);
  }
  const CostumeInfo *costume() const {
    return GetPointer<const CostumeInfo *>(VT_COSTUME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<CostumePresetInfo>> *costumePreset() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CostumePresetInfo>> *>(VT_COSTUMEPRESET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_PRESETNO) &&
           VerifyField<int16_t>(verifier, VT_COSTUMEPRESETNO) &&
           VerifyOffsetRequired(verifier, VT_EQUIP) &&
           verifier.VerifyTable(equip()) &&
           VerifyOffsetRequired(verifier, VT_PRESET) &&
           verifier.VerifyVector(preset()) &&
           verifier.VerifyVectorOfTables(preset()) &&
           VerifyOffsetRequired(verifier, VT_COSTUME) &&
           verifier.VerifyTable(costume()) &&
           VerifyOffsetRequired(verifier, VT_COSTUMEPRESET) &&
           verifier.VerifyVector(costumePreset()) &&
           verifier.VerifyVectorOfTables(costumePreset()) &&
           verifier.EndTable();
  }
};

struct EquipDataNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_presetNo(int16_t presetNo) {
    fbb_.AddElement<int16_t>(EquipDataNotify::VT_PRESETNO, presetNo, 0);
  }
  void add_costumePresetNo(int16_t costumePresetNo) {
    fbb_.AddElement<int16_t>(EquipDataNotify::VT_COSTUMEPRESETNO, costumePresetNo, 0);
  }
  void add_equip(flatbuffers::Offset<EquipInfo> equip) {
    fbb_.AddOffset(EquipDataNotify::VT_EQUIP, equip);
  }
  void add_preset(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PresetInfo>>> preset) {
    fbb_.AddOffset(EquipDataNotify::VT_PRESET, preset);
  }
  void add_costume(flatbuffers::Offset<CostumeInfo> costume) {
    fbb_.AddOffset(EquipDataNotify::VT_COSTUME, costume);
  }
  void add_costumePreset(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CostumePresetInfo>>> costumePreset) {
    fbb_.AddOffset(EquipDataNotify::VT_COSTUMEPRESET, costumePreset);
  }
  explicit EquipDataNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EquipDataNotifyBuilder &operator=(const EquipDataNotifyBuilder &);
  flatbuffers::Offset<EquipDataNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EquipDataNotify>(end);
    fbb_.Required(o, EquipDataNotify::VT_EQUIP);
    fbb_.Required(o, EquipDataNotify::VT_PRESET);
    fbb_.Required(o, EquipDataNotify::VT_COSTUME);
    fbb_.Required(o, EquipDataNotify::VT_COSTUMEPRESET);
    return o;
  }
};

inline flatbuffers::Offset<EquipDataNotify> CreateEquipDataNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t presetNo = 0,
    int16_t costumePresetNo = 0,
    flatbuffers::Offset<EquipInfo> equip = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PresetInfo>>> preset = 0,
    flatbuffers::Offset<CostumeInfo> costume = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CostumePresetInfo>>> costumePreset = 0) {
  EquipDataNotifyBuilder builder_(_fbb);
  builder_.add_costumePreset(costumePreset);
  builder_.add_costume(costume);
  builder_.add_preset(preset);
  builder_.add_equip(equip);
  builder_.add_costumePresetNo(costumePresetNo);
  builder_.add_presetNo(presetNo);
  return builder_.Finish();
}

inline flatbuffers::Offset<EquipDataNotify> CreateEquipDataNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t presetNo = 0,
    int16_t costumePresetNo = 0,
    flatbuffers::Offset<EquipInfo> equip = 0,
    const std::vector<flatbuffers::Offset<PresetInfo>> *preset = nullptr,
    flatbuffers::Offset<CostumeInfo> costume = 0,
    const std::vector<flatbuffers::Offset<CostumePresetInfo>> *costumePreset = nullptr) {
  return LeanPacket::CreateEquipDataNotify(
      _fbb,
      presetNo,
      costumePresetNo,
      equip,
      preset ? _fbb.CreateVector<flatbuffers::Offset<PresetInfo>>(*preset) : 0,
      costume,
      costumePreset ? _fbb.CreateVector<flatbuffers::Offset<CostumePresetInfo>>(*costumePreset) : 0);
}

struct SkillSlotNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ISSWITCHINGSUCCESS = 4,
    VT_OBJECTID = 6,
    VT_INFOS = 8,
    VT_MAINSKILLSLOTINDEX = 10
  };
  int8_t isSwitchingSuccess() const {
    return GetField<int8_t>(VT_ISSWITCHINGSUCCESS, 0);
  }
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SkillSlotInfo>> *infos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SkillSlotInfo>> *>(VT_INFOS);
  }
  int8_t mainSkillSlotIndex() const {
    return GetField<int8_t>(VT_MAINSKILLSLOTINDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ISSWITCHINGSUCCESS) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyOffset(verifier, VT_INFOS) &&
           verifier.VerifyVector(infos()) &&
           verifier.VerifyVectorOfTables(infos()) &&
           VerifyField<int8_t>(verifier, VT_MAINSKILLSLOTINDEX) &&
           verifier.EndTable();
  }
};

struct SkillSlotNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_isSwitchingSuccess(int8_t isSwitchingSuccess) {
    fbb_.AddElement<int8_t>(SkillSlotNotify::VT_ISSWITCHINGSUCCESS, isSwitchingSuccess, 0);
  }
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(SkillSlotNotify::VT_OBJECTID, objectId, 0);
  }
  void add_infos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SkillSlotInfo>>> infos) {
    fbb_.AddOffset(SkillSlotNotify::VT_INFOS, infos);
  }
  void add_mainSkillSlotIndex(int8_t mainSkillSlotIndex) {
    fbb_.AddElement<int8_t>(SkillSlotNotify::VT_MAINSKILLSLOTINDEX, mainSkillSlotIndex, 0);
  }
  explicit SkillSlotNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SkillSlotNotifyBuilder &operator=(const SkillSlotNotifyBuilder &);
  flatbuffers::Offset<SkillSlotNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkillSlotNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkillSlotNotify> CreateSkillSlotNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t isSwitchingSuccess = 0,
    int64_t objectId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SkillSlotInfo>>> infos = 0,
    int8_t mainSkillSlotIndex = 0) {
  SkillSlotNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_infos(infos);
  builder_.add_mainSkillSlotIndex(mainSkillSlotIndex);
  builder_.add_isSwitchingSuccess(isSwitchingSuccess);
  return builder_.Finish();
}

inline flatbuffers::Offset<SkillSlotNotify> CreateSkillSlotNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t isSwitchingSuccess = 0,
    int64_t objectId = 0,
    const std::vector<flatbuffers::Offset<SkillSlotInfo>> *infos = nullptr,
    int8_t mainSkillSlotIndex = 0) {
  return LeanPacket::CreateSkillSlotNotify(
      _fbb,
      isSwitchingSuccess,
      objectId,
      infos ? _fbb.CreateVector<flatbuffers::Offset<SkillSlotInfo>>(*infos) : 0,
      mainSkillSlotIndex);
}

/// SKILL_OPEN_SHIELD_NOTIFY
struct SkillOpenShieldNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_MAXSHIELD = 6,
    VT_REDUCETICK = 8,
    VT_ISAUTOREDUCE = 10,
    VT_ISPOSSIBLECANCEL = 12
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int32_t maxShield() const {
    return GetField<int32_t>(VT_MAXSHIELD, 0);
  }
  int32_t reduceTick() const {
    return GetField<int32_t>(VT_REDUCETICK, 0);
  }
  bool isAutoReduce() const {
    return GetField<uint8_t>(VT_ISAUTOREDUCE, 0) != 0;
  }
  bool isPossibleCancel() const {
    return GetField<uint8_t>(VT_ISPOSSIBLECANCEL, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int32_t>(verifier, VT_MAXSHIELD) &&
           VerifyField<int32_t>(verifier, VT_REDUCETICK) &&
           VerifyField<uint8_t>(verifier, VT_ISAUTOREDUCE) &&
           VerifyField<uint8_t>(verifier, VT_ISPOSSIBLECANCEL) &&
           verifier.EndTable();
  }
};

struct SkillOpenShieldNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(SkillOpenShieldNotify::VT_OBJECTID, objectId, 0);
  }
  void add_maxShield(int32_t maxShield) {
    fbb_.AddElement<int32_t>(SkillOpenShieldNotify::VT_MAXSHIELD, maxShield, 0);
  }
  void add_reduceTick(int32_t reduceTick) {
    fbb_.AddElement<int32_t>(SkillOpenShieldNotify::VT_REDUCETICK, reduceTick, 0);
  }
  void add_isAutoReduce(bool isAutoReduce) {
    fbb_.AddElement<uint8_t>(SkillOpenShieldNotify::VT_ISAUTOREDUCE, static_cast<uint8_t>(isAutoReduce), 0);
  }
  void add_isPossibleCancel(bool isPossibleCancel) {
    fbb_.AddElement<uint8_t>(SkillOpenShieldNotify::VT_ISPOSSIBLECANCEL, static_cast<uint8_t>(isPossibleCancel), 0);
  }
  explicit SkillOpenShieldNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SkillOpenShieldNotifyBuilder &operator=(const SkillOpenShieldNotifyBuilder &);
  flatbuffers::Offset<SkillOpenShieldNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkillOpenShieldNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkillOpenShieldNotify> CreateSkillOpenShieldNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int32_t maxShield = 0,
    int32_t reduceTick = 0,
    bool isAutoReduce = false,
    bool isPossibleCancel = false) {
  SkillOpenShieldNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_reduceTick(reduceTick);
  builder_.add_maxShield(maxShield);
  builder_.add_isPossibleCancel(isPossibleCancel);
  builder_.add_isAutoReduce(isAutoReduce);
  return builder_.Finish();
}

struct SkillClosedShieldNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           verifier.EndTable();
  }
};

struct SkillClosedShieldNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(SkillClosedShieldNotify::VT_OBJECTID, objectId, 0);
  }
  explicit SkillClosedShieldNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SkillClosedShieldNotifyBuilder &operator=(const SkillClosedShieldNotifyBuilder &);
  flatbuffers::Offset<SkillClosedShieldNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkillClosedShieldNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkillClosedShieldNotify> CreateSkillClosedShieldNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0) {
  SkillClosedShieldNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  return builder_.Finish();
}

/// SKILL_ERROR_NOTIFY
struct SkillErrorNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_SKILLID = 6,
    VT_REASON = 8,
    VT_POS = 10
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int32_t skillId() const {
    return GetField<int32_t>(VT_SKILLID, 0);
  }
  int32_t reason() const {
    return GetField<int32_t>(VT_REASON, 0);
  }
  const Pos *pos() const {
    return GetPointer<const Pos *>(VT_POS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int32_t>(verifier, VT_SKILLID) &&
           VerifyField<int32_t>(verifier, VT_REASON) &&
           VerifyOffset(verifier, VT_POS) &&
           verifier.VerifyTable(pos()) &&
           verifier.EndTable();
  }
};

struct SkillErrorNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(SkillErrorNotify::VT_OBJECTID, objectId, 0);
  }
  void add_skillId(int32_t skillId) {
    fbb_.AddElement<int32_t>(SkillErrorNotify::VT_SKILLID, skillId, 0);
  }
  void add_reason(int32_t reason) {
    fbb_.AddElement<int32_t>(SkillErrorNotify::VT_REASON, reason, 0);
  }
  void add_pos(flatbuffers::Offset<Pos> pos) {
    fbb_.AddOffset(SkillErrorNotify::VT_POS, pos);
  }
  explicit SkillErrorNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SkillErrorNotifyBuilder &operator=(const SkillErrorNotifyBuilder &);
  flatbuffers::Offset<SkillErrorNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkillErrorNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkillErrorNotify> CreateSkillErrorNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int32_t skillId = 0,
    int32_t reason = 0,
    flatbuffers::Offset<Pos> pos = 0) {
  SkillErrorNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_pos(pos);
  builder_.add_reason(reason);
  builder_.add_skillId(skillId);
  return builder_.Finish();
}

struct EnterStateNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_STATE = 6,
    VT_VALUE = 8
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int32_t state() const {
    return GetField<int32_t>(VT_STATE, 0);
  }
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int32_t>(verifier, VT_STATE) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct EnterStateNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(EnterStateNotify::VT_OBJECTID, objectId, 0);
  }
  void add_state(int32_t state) {
    fbb_.AddElement<int32_t>(EnterStateNotify::VT_STATE, state, 0);
  }
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(EnterStateNotify::VT_VALUE, value, 0);
  }
  explicit EnterStateNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EnterStateNotifyBuilder &operator=(const EnterStateNotifyBuilder &);
  flatbuffers::Offset<EnterStateNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EnterStateNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<EnterStateNotify> CreateEnterStateNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int32_t state = 0,
    int32_t value = 0) {
  EnterStateNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_value(value);
  builder_.add_state(state);
  return builder_.Finish();
}

struct LeaveStateNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_STATE = 6
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int32_t state() const {
    return GetField<int32_t>(VT_STATE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int32_t>(verifier, VT_STATE) &&
           verifier.EndTable();
  }
};

struct LeaveStateNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(LeaveStateNotify::VT_OBJECTID, objectId, 0);
  }
  void add_state(int32_t state) {
    fbb_.AddElement<int32_t>(LeaveStateNotify::VT_STATE, state, 0);
  }
  explicit LeaveStateNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LeaveStateNotifyBuilder &operator=(const LeaveStateNotifyBuilder &);
  flatbuffers::Offset<LeaveStateNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LeaveStateNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<LeaveStateNotify> CreateLeaveStateNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int32_t state = 0) {
  LeaveStateNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_state(state);
  return builder_.Finish();
}

struct LoadData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_PCNAME = 6,
    VT_CONTENTSTYPE = 8,
    VT_SCENEID = 10,
    VT_POS = 12,
    VT_EVENTSETID = 14
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  const flatbuffers::String *pcName() const {
    return GetPointer<const flatbuffers::String *>(VT_PCNAME);
  }
  ContentsType contentsType() const {
    return static_cast<ContentsType>(GetField<int32_t>(VT_CONTENTSTYPE, 0));
  }
  /// 이동 시뮬레이션을 위한 초기 세팅 정보
  int32_t sceneId() const {
    return GetField<int32_t>(VT_SCENEID, 0);
  }
  const Pos *pos() const {
    return GetPointer<const Pos *>(VT_POS);
  }
  int32_t eventSetId() const {
    return GetField<int32_t>(VT_EVENTSETID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyOffsetRequired(verifier, VT_PCNAME) &&
           verifier.VerifyString(pcName()) &&
           VerifyField<int32_t>(verifier, VT_CONTENTSTYPE) &&
           VerifyField<int32_t>(verifier, VT_SCENEID) &&
           VerifyOffsetRequired(verifier, VT_POS) &&
           verifier.VerifyTable(pos()) &&
           VerifyField<int32_t>(verifier, VT_EVENTSETID) &&
           verifier.EndTable();
  }
};

struct LoadDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(LoadData::VT_OBJECTID, objectId, 0);
  }
  void add_pcName(flatbuffers::Offset<flatbuffers::String> pcName) {
    fbb_.AddOffset(LoadData::VT_PCNAME, pcName);
  }
  void add_contentsType(ContentsType contentsType) {
    fbb_.AddElement<int32_t>(LoadData::VT_CONTENTSTYPE, static_cast<int32_t>(contentsType), 0);
  }
  void add_sceneId(int32_t sceneId) {
    fbb_.AddElement<int32_t>(LoadData::VT_SCENEID, sceneId, 0);
  }
  void add_pos(flatbuffers::Offset<Pos> pos) {
    fbb_.AddOffset(LoadData::VT_POS, pos);
  }
  void add_eventSetId(int32_t eventSetId) {
    fbb_.AddElement<int32_t>(LoadData::VT_EVENTSETID, eventSetId, 0);
  }
  explicit LoadDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LoadDataBuilder &operator=(const LoadDataBuilder &);
  flatbuffers::Offset<LoadData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LoadData>(end);
    fbb_.Required(o, LoadData::VT_PCNAME);
    fbb_.Required(o, LoadData::VT_POS);
    return o;
  }
};

inline flatbuffers::Offset<LoadData> CreateLoadData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    flatbuffers::Offset<flatbuffers::String> pcName = 0,
    ContentsType contentsType = ContentsType_CONTENTS_TYPE_NONE,
    int32_t sceneId = 0,
    flatbuffers::Offset<Pos> pos = 0,
    int32_t eventSetId = 0) {
  LoadDataBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_eventSetId(eventSetId);
  builder_.add_pos(pos);
  builder_.add_sceneId(sceneId);
  builder_.add_contentsType(contentsType);
  builder_.add_pcName(pcName);
  return builder_.Finish();
}

inline flatbuffers::Offset<LoadData> CreateLoadDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    const char *pcName = nullptr,
    ContentsType contentsType = ContentsType_CONTENTS_TYPE_NONE,
    int32_t sceneId = 0,
    flatbuffers::Offset<Pos> pos = 0,
    int32_t eventSetId = 0) {
  return LeanPacket::CreateLoadData(
      _fbb,
      objectId,
      pcName ? _fbb.CreateString(pcName) : 0,
      contentsType,
      sceneId,
      pos,
      eventSetId);
}

///- LOAD_DATA_REQUEST ----------
struct LoadDataRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LOADDATA = 4
  };
  const LoadData *loadData() const {
    return GetPointer<const LoadData *>(VT_LOADDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LOADDATA) &&
           verifier.VerifyTable(loadData()) &&
           verifier.EndTable();
  }
};

struct LoadDataRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_loadData(flatbuffers::Offset<LoadData> loadData) {
    fbb_.AddOffset(LoadDataRequest::VT_LOADDATA, loadData);
  }
  explicit LoadDataRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LoadDataRequestBuilder &operator=(const LoadDataRequestBuilder &);
  flatbuffers::Offset<LoadDataRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LoadDataRequest>(end);
    fbb_.Required(o, LoadDataRequest::VT_LOADDATA);
    return o;
  }
};

inline flatbuffers::Offset<LoadDataRequest> CreateLoadDataRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LoadData> loadData = 0) {
  LoadDataRequestBuilder builder_(_fbb);
  builder_.add_loadData(loadData);
  return builder_.Finish();
}

///- LOAD_DATA_RESPONSE ----------
struct LoadDataResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LoadDataResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LoadDataResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LoadDataResponseBuilder &operator=(const LoadDataResponseBuilder &);
  flatbuffers::Offset<LoadDataResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LoadDataResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<LoadDataResponse> CreateLoadDataResponse(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LoadDataResponseBuilder builder_(_fbb);
  return builder_.Finish();
}

///- WORLDOBJECT_DESPAWN_NOTIFY ----------
struct WorldObjectDespawnNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_POS = 6,
    VT_DESPAWNREASON = 8
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  const Pos *pos() const {
    return GetPointer<const Pos *>(VT_POS);
  }
  DespawnReason despawnReason() const {
    return static_cast<DespawnReason>(GetField<int32_t>(VT_DESPAWNREASON, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyOffsetRequired(verifier, VT_POS) &&
           verifier.VerifyTable(pos()) &&
           VerifyField<int32_t>(verifier, VT_DESPAWNREASON) &&
           verifier.EndTable();
  }
};

struct WorldObjectDespawnNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(WorldObjectDespawnNotify::VT_OBJECTID, objectId, 0);
  }
  void add_pos(flatbuffers::Offset<Pos> pos) {
    fbb_.AddOffset(WorldObjectDespawnNotify::VT_POS, pos);
  }
  void add_despawnReason(DespawnReason despawnReason) {
    fbb_.AddElement<int32_t>(WorldObjectDespawnNotify::VT_DESPAWNREASON, static_cast<int32_t>(despawnReason), 0);
  }
  explicit WorldObjectDespawnNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WorldObjectDespawnNotifyBuilder &operator=(const WorldObjectDespawnNotifyBuilder &);
  flatbuffers::Offset<WorldObjectDespawnNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WorldObjectDespawnNotify>(end);
    fbb_.Required(o, WorldObjectDespawnNotify::VT_POS);
    return o;
  }
};

inline flatbuffers::Offset<WorldObjectDespawnNotify> CreateWorldObjectDespawnNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    flatbuffers::Offset<Pos> pos = 0,
    DespawnReason despawnReason = DespawnReason_DP_ON_DESPAWNED) {
  WorldObjectDespawnNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_despawnReason(despawnReason);
  builder_.add_pos(pos);
  return builder_.Finish();
}

///- PC_SPAWN_NOTIFY ----------
struct PCSpawnNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCOBJECTID = 4,
    VT_NAME = 6,
    VT_IFF = 8,
    VT_CLASSTYPE = 10,
    VT_LEVEL = 12,
    VT_CURRENTSTATE = 14,
    VT_CURRENTHP = 16,
    VT_MAXHP = 18,
    VT_SCENEID = 20,
    VT_POS = 22,
    VT_ANGLE = 24,
    VT_CUSTOMIZINGINFO = 26,
    VT_EQUIPPARTSINFO = 28,
    VT_COSTUMEPARTSINFO = 30,
    VT_SPAWNREASON = 32,
    VT_JOBSKILL = 34,
    VT_TIER = 36,
    VT_TIERLEVEL = 38,
    VT_PCGUILDINFO = 40,
    VT_WORLDID = 42,
    VT_SUMMONEDPETLOOKID = 44,
    VT_KILLCOUNT = 46,
    VT_ASSISTCOUNT = 48
  };
  int64_t pcObjectId() const {
    return GetField<int64_t>(VT_PCOBJECTID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t iff() const {
    return GetField<int32_t>(VT_IFF, 0);
  }
  int32_t classType() const {
    return GetField<int32_t>(VT_CLASSTYPE, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int32_t currentState() const {
    return GetField<int32_t>(VT_CURRENTSTATE, 0);
  }
  int64_t currentHp() const {
    return GetField<int64_t>(VT_CURRENTHP, 0);
  }
  int64_t maxHp() const {
    return GetField<int64_t>(VT_MAXHP, 0);
  }
  /// 이동을 위해 스폰에 필요한 최소 정보
  int32_t sceneId() const {
    return GetField<int32_t>(VT_SCENEID, 0);
  }
  const Pos *pos() const {
    return GetPointer<const Pos *>(VT_POS);
  }
  int16_t angle() const {
    return GetField<int16_t>(VT_ANGLE, 0);
  }
  const CustomizeInfo *customizingInfo() const {
    return GetPointer<const CustomizeInfo *>(VT_CUSTOMIZINGINFO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ItemPartsInfo>> *equipPartsInfo() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ItemPartsInfo>> *>(VT_EQUIPPARTSINFO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<CostumePartsInfo>> *costumePartsInfo() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CostumePartsInfo>> *>(VT_COSTUMEPARTSINFO);
  }
  SpawnReason spawnReason() const {
    return static_cast<SpawnReason>(GetField<int32_t>(VT_SPAWNREASON, 0));
  }
  int32_t jobSkill() const {
    return GetField<int32_t>(VT_JOBSKILL, 0);
  }
  int32_t tier() const {
    return GetField<int32_t>(VT_TIER, 0);
  }
  int32_t tierLevel() const {
    return GetField<int32_t>(VT_TIERLEVEL, 0);
  }
  const PcGuildInfo *pcGuildInfo() const {
    return GetPointer<const PcGuildInfo *>(VT_PCGUILDINFO);
  }
  int16_t worldId() const {
    return GetField<int16_t>(VT_WORLDID, 0);
  }
  int32_t summonedPetLookId() const {
    return GetField<int32_t>(VT_SUMMONEDPETLOOKID, 0);
  }
  int32_t killCount() const {
    return GetField<int32_t>(VT_KILLCOUNT, 0);
  }
  int32_t assistCount() const {
    return GetField<int32_t>(VT_ASSISTCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PCOBJECTID) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_IFF) &&
           VerifyField<int32_t>(verifier, VT_CLASSTYPE) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_CURRENTSTATE) &&
           VerifyField<int64_t>(verifier, VT_CURRENTHP) &&
           VerifyField<int64_t>(verifier, VT_MAXHP) &&
           VerifyField<int32_t>(verifier, VT_SCENEID) &&
           VerifyOffsetRequired(verifier, VT_POS) &&
           verifier.VerifyTable(pos()) &&
           VerifyField<int16_t>(verifier, VT_ANGLE) &&
           VerifyOffsetRequired(verifier, VT_CUSTOMIZINGINFO) &&
           verifier.VerifyTable(customizingInfo()) &&
           VerifyOffsetRequired(verifier, VT_EQUIPPARTSINFO) &&
           verifier.VerifyVector(equipPartsInfo()) &&
           verifier.VerifyVectorOfTables(equipPartsInfo()) &&
           VerifyOffsetRequired(verifier, VT_COSTUMEPARTSINFO) &&
           verifier.VerifyVector(costumePartsInfo()) &&
           verifier.VerifyVectorOfTables(costumePartsInfo()) &&
           VerifyField<int32_t>(verifier, VT_SPAWNREASON) &&
           VerifyField<int32_t>(verifier, VT_JOBSKILL) &&
           VerifyField<int32_t>(verifier, VT_TIER) &&
           VerifyField<int32_t>(verifier, VT_TIERLEVEL) &&
           VerifyOffset(verifier, VT_PCGUILDINFO) &&
           verifier.VerifyTable(pcGuildInfo()) &&
           VerifyField<int16_t>(verifier, VT_WORLDID) &&
           VerifyField<int32_t>(verifier, VT_SUMMONEDPETLOOKID) &&
           VerifyField<int32_t>(verifier, VT_KILLCOUNT) &&
           VerifyField<int32_t>(verifier, VT_ASSISTCOUNT) &&
           verifier.EndTable();
  }
};

struct PCSpawnNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcObjectId(int64_t pcObjectId) {
    fbb_.AddElement<int64_t>(PCSpawnNotify::VT_PCOBJECTID, pcObjectId, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(PCSpawnNotify::VT_NAME, name);
  }
  void add_iff(int32_t iff) {
    fbb_.AddElement<int32_t>(PCSpawnNotify::VT_IFF, iff, 0);
  }
  void add_classType(int32_t classType) {
    fbb_.AddElement<int32_t>(PCSpawnNotify::VT_CLASSTYPE, classType, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(PCSpawnNotify::VT_LEVEL, level, 0);
  }
  void add_currentState(int32_t currentState) {
    fbb_.AddElement<int32_t>(PCSpawnNotify::VT_CURRENTSTATE, currentState, 0);
  }
  void add_currentHp(int64_t currentHp) {
    fbb_.AddElement<int64_t>(PCSpawnNotify::VT_CURRENTHP, currentHp, 0);
  }
  void add_maxHp(int64_t maxHp) {
    fbb_.AddElement<int64_t>(PCSpawnNotify::VT_MAXHP, maxHp, 0);
  }
  void add_sceneId(int32_t sceneId) {
    fbb_.AddElement<int32_t>(PCSpawnNotify::VT_SCENEID, sceneId, 0);
  }
  void add_pos(flatbuffers::Offset<Pos> pos) {
    fbb_.AddOffset(PCSpawnNotify::VT_POS, pos);
  }
  void add_angle(int16_t angle) {
    fbb_.AddElement<int16_t>(PCSpawnNotify::VT_ANGLE, angle, 0);
  }
  void add_customizingInfo(flatbuffers::Offset<CustomizeInfo> customizingInfo) {
    fbb_.AddOffset(PCSpawnNotify::VT_CUSTOMIZINGINFO, customizingInfo);
  }
  void add_equipPartsInfo(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ItemPartsInfo>>> equipPartsInfo) {
    fbb_.AddOffset(PCSpawnNotify::VT_EQUIPPARTSINFO, equipPartsInfo);
  }
  void add_costumePartsInfo(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CostumePartsInfo>>> costumePartsInfo) {
    fbb_.AddOffset(PCSpawnNotify::VT_COSTUMEPARTSINFO, costumePartsInfo);
  }
  void add_spawnReason(SpawnReason spawnReason) {
    fbb_.AddElement<int32_t>(PCSpawnNotify::VT_SPAWNREASON, static_cast<int32_t>(spawnReason), 0);
  }
  void add_jobSkill(int32_t jobSkill) {
    fbb_.AddElement<int32_t>(PCSpawnNotify::VT_JOBSKILL, jobSkill, 0);
  }
  void add_tier(int32_t tier) {
    fbb_.AddElement<int32_t>(PCSpawnNotify::VT_TIER, tier, 0);
  }
  void add_tierLevel(int32_t tierLevel) {
    fbb_.AddElement<int32_t>(PCSpawnNotify::VT_TIERLEVEL, tierLevel, 0);
  }
  void add_pcGuildInfo(flatbuffers::Offset<PcGuildInfo> pcGuildInfo) {
    fbb_.AddOffset(PCSpawnNotify::VT_PCGUILDINFO, pcGuildInfo);
  }
  void add_worldId(int16_t worldId) {
    fbb_.AddElement<int16_t>(PCSpawnNotify::VT_WORLDID, worldId, 0);
  }
  void add_summonedPetLookId(int32_t summonedPetLookId) {
    fbb_.AddElement<int32_t>(PCSpawnNotify::VT_SUMMONEDPETLOOKID, summonedPetLookId, 0);
  }
  void add_killCount(int32_t killCount) {
    fbb_.AddElement<int32_t>(PCSpawnNotify::VT_KILLCOUNT, killCount, 0);
  }
  void add_assistCount(int32_t assistCount) {
    fbb_.AddElement<int32_t>(PCSpawnNotify::VT_ASSISTCOUNT, assistCount, 0);
  }
  explicit PCSpawnNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PCSpawnNotifyBuilder &operator=(const PCSpawnNotifyBuilder &);
  flatbuffers::Offset<PCSpawnNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PCSpawnNotify>(end);
    fbb_.Required(o, PCSpawnNotify::VT_NAME);
    fbb_.Required(o, PCSpawnNotify::VT_POS);
    fbb_.Required(o, PCSpawnNotify::VT_CUSTOMIZINGINFO);
    fbb_.Required(o, PCSpawnNotify::VT_EQUIPPARTSINFO);
    fbb_.Required(o, PCSpawnNotify::VT_COSTUMEPARTSINFO);
    return o;
  }
};

inline flatbuffers::Offset<PCSpawnNotify> CreatePCSpawnNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcObjectId = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t iff = 0,
    int32_t classType = 0,
    int32_t level = 0,
    int32_t currentState = 0,
    int64_t currentHp = 0,
    int64_t maxHp = 0,
    int32_t sceneId = 0,
    flatbuffers::Offset<Pos> pos = 0,
    int16_t angle = 0,
    flatbuffers::Offset<CustomizeInfo> customizingInfo = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ItemPartsInfo>>> equipPartsInfo = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CostumePartsInfo>>> costumePartsInfo = 0,
    SpawnReason spawnReason = SpawnReason_SP_ON_SPAWNED,
    int32_t jobSkill = 0,
    int32_t tier = 0,
    int32_t tierLevel = 0,
    flatbuffers::Offset<PcGuildInfo> pcGuildInfo = 0,
    int16_t worldId = 0,
    int32_t summonedPetLookId = 0,
    int32_t killCount = 0,
    int32_t assistCount = 0) {
  PCSpawnNotifyBuilder builder_(_fbb);
  builder_.add_maxHp(maxHp);
  builder_.add_currentHp(currentHp);
  builder_.add_pcObjectId(pcObjectId);
  builder_.add_assistCount(assistCount);
  builder_.add_killCount(killCount);
  builder_.add_summonedPetLookId(summonedPetLookId);
  builder_.add_pcGuildInfo(pcGuildInfo);
  builder_.add_tierLevel(tierLevel);
  builder_.add_tier(tier);
  builder_.add_jobSkill(jobSkill);
  builder_.add_spawnReason(spawnReason);
  builder_.add_costumePartsInfo(costumePartsInfo);
  builder_.add_equipPartsInfo(equipPartsInfo);
  builder_.add_customizingInfo(customizingInfo);
  builder_.add_pos(pos);
  builder_.add_sceneId(sceneId);
  builder_.add_currentState(currentState);
  builder_.add_level(level);
  builder_.add_classType(classType);
  builder_.add_iff(iff);
  builder_.add_name(name);
  builder_.add_worldId(worldId);
  builder_.add_angle(angle);
  return builder_.Finish();
}

inline flatbuffers::Offset<PCSpawnNotify> CreatePCSpawnNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcObjectId = 0,
    const char *name = nullptr,
    int32_t iff = 0,
    int32_t classType = 0,
    int32_t level = 0,
    int32_t currentState = 0,
    int64_t currentHp = 0,
    int64_t maxHp = 0,
    int32_t sceneId = 0,
    flatbuffers::Offset<Pos> pos = 0,
    int16_t angle = 0,
    flatbuffers::Offset<CustomizeInfo> customizingInfo = 0,
    const std::vector<flatbuffers::Offset<ItemPartsInfo>> *equipPartsInfo = nullptr,
    const std::vector<flatbuffers::Offset<CostumePartsInfo>> *costumePartsInfo = nullptr,
    SpawnReason spawnReason = SpawnReason_SP_ON_SPAWNED,
    int32_t jobSkill = 0,
    int32_t tier = 0,
    int32_t tierLevel = 0,
    flatbuffers::Offset<PcGuildInfo> pcGuildInfo = 0,
    int16_t worldId = 0,
    int32_t summonedPetLookId = 0,
    int32_t killCount = 0,
    int32_t assistCount = 0) {
  return LeanPacket::CreatePCSpawnNotify(
      _fbb,
      pcObjectId,
      name ? _fbb.CreateString(name) : 0,
      iff,
      classType,
      level,
      currentState,
      currentHp,
      maxHp,
      sceneId,
      pos,
      angle,
      customizingInfo,
      equipPartsInfo ? _fbb.CreateVector<flatbuffers::Offset<ItemPartsInfo>>(*equipPartsInfo) : 0,
      costumePartsInfo ? _fbb.CreateVector<flatbuffers::Offset<CostumePartsInfo>>(*costumePartsInfo) : 0,
      spawnReason,
      jobSkill,
      tier,
      tierLevel,
      pcGuildInfo,
      worldId,
      summonedPetLookId,
      killCount,
      assistCount);
}

///- UPC_SPAWN_NOTIFY ----------
struct UPCSpawnNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_UPCOBJECTID = 4,
    VT_UPCTYPE = 6,
    VT_NAME = 8,
    VT_IFF = 10,
    VT_CLASSTYPE = 12,
    VT_LEVEL = 14,
    VT_CURRENTSTATE = 16,
    VT_CURRENTHP = 18,
    VT_MAXHP = 20,
    VT_SCENEID = 22,
    VT_POS = 24,
    VT_ANGLE = 26,
    VT_CUSTOMIZINGINFO = 28,
    VT_EQUIPPARTSINFO = 30,
    VT_SPAWNREASON = 32,
    VT_JOBSKILL = 34,
    VT_TIER = 36,
    VT_TIERLEVEL = 38
  };
  int64_t upcObjectId() const {
    return GetField<int64_t>(VT_UPCOBJECTID, 0);
  }
  UpcType upcType() const {
    return static_cast<UpcType>(GetField<int16_t>(VT_UPCTYPE, 0));
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t iff() const {
    return GetField<int32_t>(VT_IFF, 0);
  }
  int32_t classType() const {
    return GetField<int32_t>(VT_CLASSTYPE, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int32_t currentState() const {
    return GetField<int32_t>(VT_CURRENTSTATE, 0);
  }
  int64_t currentHp() const {
    return GetField<int64_t>(VT_CURRENTHP, 0);
  }
  int64_t maxHp() const {
    return GetField<int64_t>(VT_MAXHP, 0);
  }
  int32_t sceneId() const {
    return GetField<int32_t>(VT_SCENEID, 0);
  }
  const Pos *pos() const {
    return GetPointer<const Pos *>(VT_POS);
  }
  int16_t angle() const {
    return GetField<int16_t>(VT_ANGLE, 0);
  }
  const CustomizeInfo *customizingInfo() const {
    return GetPointer<const CustomizeInfo *>(VT_CUSTOMIZINGINFO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ItemPartsInfo>> *equipPartsInfo() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ItemPartsInfo>> *>(VT_EQUIPPARTSINFO);
  }
  SpawnReason spawnReason() const {
    return static_cast<SpawnReason>(GetField<int32_t>(VT_SPAWNREASON, 0));
  }
  int32_t jobSkill() const {
    return GetField<int32_t>(VT_JOBSKILL, 0);
  }
  int32_t tier() const {
    return GetField<int32_t>(VT_TIER, 0);
  }
  int32_t tierLevel() const {
    return GetField<int32_t>(VT_TIERLEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_UPCOBJECTID) &&
           VerifyField<int16_t>(verifier, VT_UPCTYPE) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_IFF) &&
           VerifyField<int32_t>(verifier, VT_CLASSTYPE) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_CURRENTSTATE) &&
           VerifyField<int64_t>(verifier, VT_CURRENTHP) &&
           VerifyField<int64_t>(verifier, VT_MAXHP) &&
           VerifyField<int32_t>(verifier, VT_SCENEID) &&
           VerifyOffsetRequired(verifier, VT_POS) &&
           verifier.VerifyTable(pos()) &&
           VerifyField<int16_t>(verifier, VT_ANGLE) &&
           VerifyOffsetRequired(verifier, VT_CUSTOMIZINGINFO) &&
           verifier.VerifyTable(customizingInfo()) &&
           VerifyOffsetRequired(verifier, VT_EQUIPPARTSINFO) &&
           verifier.VerifyVector(equipPartsInfo()) &&
           verifier.VerifyVectorOfTables(equipPartsInfo()) &&
           VerifyField<int32_t>(verifier, VT_SPAWNREASON) &&
           VerifyField<int32_t>(verifier, VT_JOBSKILL) &&
           VerifyField<int32_t>(verifier, VT_TIER) &&
           VerifyField<int32_t>(verifier, VT_TIERLEVEL) &&
           verifier.EndTable();
  }
};

struct UPCSpawnNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_upcObjectId(int64_t upcObjectId) {
    fbb_.AddElement<int64_t>(UPCSpawnNotify::VT_UPCOBJECTID, upcObjectId, 0);
  }
  void add_upcType(UpcType upcType) {
    fbb_.AddElement<int16_t>(UPCSpawnNotify::VT_UPCTYPE, static_cast<int16_t>(upcType), 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(UPCSpawnNotify::VT_NAME, name);
  }
  void add_iff(int32_t iff) {
    fbb_.AddElement<int32_t>(UPCSpawnNotify::VT_IFF, iff, 0);
  }
  void add_classType(int32_t classType) {
    fbb_.AddElement<int32_t>(UPCSpawnNotify::VT_CLASSTYPE, classType, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(UPCSpawnNotify::VT_LEVEL, level, 0);
  }
  void add_currentState(int32_t currentState) {
    fbb_.AddElement<int32_t>(UPCSpawnNotify::VT_CURRENTSTATE, currentState, 0);
  }
  void add_currentHp(int64_t currentHp) {
    fbb_.AddElement<int64_t>(UPCSpawnNotify::VT_CURRENTHP, currentHp, 0);
  }
  void add_maxHp(int64_t maxHp) {
    fbb_.AddElement<int64_t>(UPCSpawnNotify::VT_MAXHP, maxHp, 0);
  }
  void add_sceneId(int32_t sceneId) {
    fbb_.AddElement<int32_t>(UPCSpawnNotify::VT_SCENEID, sceneId, 0);
  }
  void add_pos(flatbuffers::Offset<Pos> pos) {
    fbb_.AddOffset(UPCSpawnNotify::VT_POS, pos);
  }
  void add_angle(int16_t angle) {
    fbb_.AddElement<int16_t>(UPCSpawnNotify::VT_ANGLE, angle, 0);
  }
  void add_customizingInfo(flatbuffers::Offset<CustomizeInfo> customizingInfo) {
    fbb_.AddOffset(UPCSpawnNotify::VT_CUSTOMIZINGINFO, customizingInfo);
  }
  void add_equipPartsInfo(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ItemPartsInfo>>> equipPartsInfo) {
    fbb_.AddOffset(UPCSpawnNotify::VT_EQUIPPARTSINFO, equipPartsInfo);
  }
  void add_spawnReason(SpawnReason spawnReason) {
    fbb_.AddElement<int32_t>(UPCSpawnNotify::VT_SPAWNREASON, static_cast<int32_t>(spawnReason), 0);
  }
  void add_jobSkill(int32_t jobSkill) {
    fbb_.AddElement<int32_t>(UPCSpawnNotify::VT_JOBSKILL, jobSkill, 0);
  }
  void add_tier(int32_t tier) {
    fbb_.AddElement<int32_t>(UPCSpawnNotify::VT_TIER, tier, 0);
  }
  void add_tierLevel(int32_t tierLevel) {
    fbb_.AddElement<int32_t>(UPCSpawnNotify::VT_TIERLEVEL, tierLevel, 0);
  }
  explicit UPCSpawnNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UPCSpawnNotifyBuilder &operator=(const UPCSpawnNotifyBuilder &);
  flatbuffers::Offset<UPCSpawnNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UPCSpawnNotify>(end);
    fbb_.Required(o, UPCSpawnNotify::VT_NAME);
    fbb_.Required(o, UPCSpawnNotify::VT_POS);
    fbb_.Required(o, UPCSpawnNotify::VT_CUSTOMIZINGINFO);
    fbb_.Required(o, UPCSpawnNotify::VT_EQUIPPARTSINFO);
    return o;
  }
};

inline flatbuffers::Offset<UPCSpawnNotify> CreateUPCSpawnNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t upcObjectId = 0,
    UpcType upcType = UpcType_UPC_TYPE_ARENA,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t iff = 0,
    int32_t classType = 0,
    int32_t level = 0,
    int32_t currentState = 0,
    int64_t currentHp = 0,
    int64_t maxHp = 0,
    int32_t sceneId = 0,
    flatbuffers::Offset<Pos> pos = 0,
    int16_t angle = 0,
    flatbuffers::Offset<CustomizeInfo> customizingInfo = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ItemPartsInfo>>> equipPartsInfo = 0,
    SpawnReason spawnReason = SpawnReason_SP_ON_SPAWNED,
    int32_t jobSkill = 0,
    int32_t tier = 0,
    int32_t tierLevel = 0) {
  UPCSpawnNotifyBuilder builder_(_fbb);
  builder_.add_maxHp(maxHp);
  builder_.add_currentHp(currentHp);
  builder_.add_upcObjectId(upcObjectId);
  builder_.add_tierLevel(tierLevel);
  builder_.add_tier(tier);
  builder_.add_jobSkill(jobSkill);
  builder_.add_spawnReason(spawnReason);
  builder_.add_equipPartsInfo(equipPartsInfo);
  builder_.add_customizingInfo(customizingInfo);
  builder_.add_pos(pos);
  builder_.add_sceneId(sceneId);
  builder_.add_currentState(currentState);
  builder_.add_level(level);
  builder_.add_classType(classType);
  builder_.add_iff(iff);
  builder_.add_name(name);
  builder_.add_angle(angle);
  builder_.add_upcType(upcType);
  return builder_.Finish();
}

inline flatbuffers::Offset<UPCSpawnNotify> CreateUPCSpawnNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t upcObjectId = 0,
    UpcType upcType = UpcType_UPC_TYPE_ARENA,
    const char *name = nullptr,
    int32_t iff = 0,
    int32_t classType = 0,
    int32_t level = 0,
    int32_t currentState = 0,
    int64_t currentHp = 0,
    int64_t maxHp = 0,
    int32_t sceneId = 0,
    flatbuffers::Offset<Pos> pos = 0,
    int16_t angle = 0,
    flatbuffers::Offset<CustomizeInfo> customizingInfo = 0,
    const std::vector<flatbuffers::Offset<ItemPartsInfo>> *equipPartsInfo = nullptr,
    SpawnReason spawnReason = SpawnReason_SP_ON_SPAWNED,
    int32_t jobSkill = 0,
    int32_t tier = 0,
    int32_t tierLevel = 0) {
  return LeanPacket::CreateUPCSpawnNotify(
      _fbb,
      upcObjectId,
      upcType,
      name ? _fbb.CreateString(name) : 0,
      iff,
      classType,
      level,
      currentState,
      currentHp,
      maxHp,
      sceneId,
      pos,
      angle,
      customizingInfo,
      equipPartsInfo ? _fbb.CreateVector<flatbuffers::Offset<ItemPartsInfo>>(*equipPartsInfo) : 0,
      spawnReason,
      jobSkill,
      tier,
      tierLevel);
}

///- NPC_SPAWN_NOTIFY ----------
struct NPCSpawnNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_NPCID = 6,
    VT_IFF = 8,
    VT_CURRENTSTATE = 10,
    VT_CURRENTHP = 12,
    VT_MAXHP = 14,
    VT_SCENEID = 16,
    VT_POS = 18,
    VT_ANGLE = 20,
    VT_ISFIXEDHEIGHT = 22,
    VT_ISEVENTNPC = 24,
    VT_LOOKATTARGETID = 26,
    VT_SPAWNREASON = 28
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int32_t npcId() const {
    return GetField<int32_t>(VT_NPCID, 0);
  }
  int32_t iff() const {
    return GetField<int32_t>(VT_IFF, 0);
  }
  int32_t currentState() const {
    return GetField<int32_t>(VT_CURRENTSTATE, 0);
  }
  int64_t currentHp() const {
    return GetField<int64_t>(VT_CURRENTHP, 0);
  }
  int64_t maxHp() const {
    return GetField<int64_t>(VT_MAXHP, 0);
  }
  int32_t sceneId() const {
    return GetField<int32_t>(VT_SCENEID, 0);
  }
  const Pos *pos() const {
    return GetPointer<const Pos *>(VT_POS);
  }
  int16_t angle() const {
    return GetField<int16_t>(VT_ANGLE, 0);
  }
  bool isfixedHeight() const {
    return GetField<uint8_t>(VT_ISFIXEDHEIGHT, 0) != 0;
  }
  bool isEventNpc() const {
    return GetField<uint8_t>(VT_ISEVENTNPC, 0) != 0;
  }
  int64_t lookAtTargetId() const {
    return GetField<int64_t>(VT_LOOKATTARGETID, 0);
  }
  SpawnReason spawnReason() const {
    return static_cast<SpawnReason>(GetField<int32_t>(VT_SPAWNREASON, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int32_t>(verifier, VT_NPCID) &&
           VerifyField<int32_t>(verifier, VT_IFF) &&
           VerifyField<int32_t>(verifier, VT_CURRENTSTATE) &&
           VerifyField<int64_t>(verifier, VT_CURRENTHP) &&
           VerifyField<int64_t>(verifier, VT_MAXHP) &&
           VerifyField<int32_t>(verifier, VT_SCENEID) &&
           VerifyOffsetRequired(verifier, VT_POS) &&
           verifier.VerifyTable(pos()) &&
           VerifyField<int16_t>(verifier, VT_ANGLE) &&
           VerifyField<uint8_t>(verifier, VT_ISFIXEDHEIGHT) &&
           VerifyField<uint8_t>(verifier, VT_ISEVENTNPC) &&
           VerifyField<int64_t>(verifier, VT_LOOKATTARGETID) &&
           VerifyField<int32_t>(verifier, VT_SPAWNREASON) &&
           verifier.EndTable();
  }
};

struct NPCSpawnNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(NPCSpawnNotify::VT_OBJECTID, objectId, 0);
  }
  void add_npcId(int32_t npcId) {
    fbb_.AddElement<int32_t>(NPCSpawnNotify::VT_NPCID, npcId, 0);
  }
  void add_iff(int32_t iff) {
    fbb_.AddElement<int32_t>(NPCSpawnNotify::VT_IFF, iff, 0);
  }
  void add_currentState(int32_t currentState) {
    fbb_.AddElement<int32_t>(NPCSpawnNotify::VT_CURRENTSTATE, currentState, 0);
  }
  void add_currentHp(int64_t currentHp) {
    fbb_.AddElement<int64_t>(NPCSpawnNotify::VT_CURRENTHP, currentHp, 0);
  }
  void add_maxHp(int64_t maxHp) {
    fbb_.AddElement<int64_t>(NPCSpawnNotify::VT_MAXHP, maxHp, 0);
  }
  void add_sceneId(int32_t sceneId) {
    fbb_.AddElement<int32_t>(NPCSpawnNotify::VT_SCENEID, sceneId, 0);
  }
  void add_pos(flatbuffers::Offset<Pos> pos) {
    fbb_.AddOffset(NPCSpawnNotify::VT_POS, pos);
  }
  void add_angle(int16_t angle) {
    fbb_.AddElement<int16_t>(NPCSpawnNotify::VT_ANGLE, angle, 0);
  }
  void add_isfixedHeight(bool isfixedHeight) {
    fbb_.AddElement<uint8_t>(NPCSpawnNotify::VT_ISFIXEDHEIGHT, static_cast<uint8_t>(isfixedHeight), 0);
  }
  void add_isEventNpc(bool isEventNpc) {
    fbb_.AddElement<uint8_t>(NPCSpawnNotify::VT_ISEVENTNPC, static_cast<uint8_t>(isEventNpc), 0);
  }
  void add_lookAtTargetId(int64_t lookAtTargetId) {
    fbb_.AddElement<int64_t>(NPCSpawnNotify::VT_LOOKATTARGETID, lookAtTargetId, 0);
  }
  void add_spawnReason(SpawnReason spawnReason) {
    fbb_.AddElement<int32_t>(NPCSpawnNotify::VT_SPAWNREASON, static_cast<int32_t>(spawnReason), 0);
  }
  explicit NPCSpawnNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NPCSpawnNotifyBuilder &operator=(const NPCSpawnNotifyBuilder &);
  flatbuffers::Offset<NPCSpawnNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NPCSpawnNotify>(end);
    fbb_.Required(o, NPCSpawnNotify::VT_POS);
    return o;
  }
};

inline flatbuffers::Offset<NPCSpawnNotify> CreateNPCSpawnNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int32_t npcId = 0,
    int32_t iff = 0,
    int32_t currentState = 0,
    int64_t currentHp = 0,
    int64_t maxHp = 0,
    int32_t sceneId = 0,
    flatbuffers::Offset<Pos> pos = 0,
    int16_t angle = 0,
    bool isfixedHeight = false,
    bool isEventNpc = false,
    int64_t lookAtTargetId = 0,
    SpawnReason spawnReason = SpawnReason_SP_ON_SPAWNED) {
  NPCSpawnNotifyBuilder builder_(_fbb);
  builder_.add_lookAtTargetId(lookAtTargetId);
  builder_.add_maxHp(maxHp);
  builder_.add_currentHp(currentHp);
  builder_.add_objectId(objectId);
  builder_.add_spawnReason(spawnReason);
  builder_.add_pos(pos);
  builder_.add_sceneId(sceneId);
  builder_.add_currentState(currentState);
  builder_.add_iff(iff);
  builder_.add_npcId(npcId);
  builder_.add_angle(angle);
  builder_.add_isEventNpc(isEventNpc);
  builder_.add_isfixedHeight(isfixedHeight);
  return builder_.Finish();
}

///- PROJECTILE_SPAWN_NOTIFY ----------
struct ProjectileSpawnNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_SHOOTERID = 6,
    VT_PROJECTILEID = 8,
    VT_IFF = 10,
    VT_SCENEID = 12,
    VT_POS = 14,
    VT_ANGLE = 16,
    VT_SPAWNREASON = 18,
    VT_DESPAWNCHECKERTYPE = 20
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int64_t shooterId() const {
    return GetField<int64_t>(VT_SHOOTERID, 0);
  }
  int32_t projectileId() const {
    return GetField<int32_t>(VT_PROJECTILEID, 0);
  }
  int32_t iff() const {
    return GetField<int32_t>(VT_IFF, 0);
  }
  int32_t sceneId() const {
    return GetField<int32_t>(VT_SCENEID, 0);
  }
  const Pos *pos() const {
    return GetPointer<const Pos *>(VT_POS);
  }
  int16_t angle() const {
    return GetField<int16_t>(VT_ANGLE, 0);
  }
  SpawnReason spawnReason() const {
    return static_cast<SpawnReason>(GetField<int32_t>(VT_SPAWNREASON, 0));
  }
  int8_t despawnCheckerType() const {
    return GetField<int8_t>(VT_DESPAWNCHECKERTYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int64_t>(verifier, VT_SHOOTERID) &&
           VerifyField<int32_t>(verifier, VT_PROJECTILEID) &&
           VerifyField<int32_t>(verifier, VT_IFF) &&
           VerifyField<int32_t>(verifier, VT_SCENEID) &&
           VerifyOffsetRequired(verifier, VT_POS) &&
           verifier.VerifyTable(pos()) &&
           VerifyField<int16_t>(verifier, VT_ANGLE) &&
           VerifyField<int32_t>(verifier, VT_SPAWNREASON) &&
           VerifyField<int8_t>(verifier, VT_DESPAWNCHECKERTYPE) &&
           verifier.EndTable();
  }
};

struct ProjectileSpawnNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(ProjectileSpawnNotify::VT_OBJECTID, objectId, 0);
  }
  void add_shooterId(int64_t shooterId) {
    fbb_.AddElement<int64_t>(ProjectileSpawnNotify::VT_SHOOTERID, shooterId, 0);
  }
  void add_projectileId(int32_t projectileId) {
    fbb_.AddElement<int32_t>(ProjectileSpawnNotify::VT_PROJECTILEID, projectileId, 0);
  }
  void add_iff(int32_t iff) {
    fbb_.AddElement<int32_t>(ProjectileSpawnNotify::VT_IFF, iff, 0);
  }
  void add_sceneId(int32_t sceneId) {
    fbb_.AddElement<int32_t>(ProjectileSpawnNotify::VT_SCENEID, sceneId, 0);
  }
  void add_pos(flatbuffers::Offset<Pos> pos) {
    fbb_.AddOffset(ProjectileSpawnNotify::VT_POS, pos);
  }
  void add_angle(int16_t angle) {
    fbb_.AddElement<int16_t>(ProjectileSpawnNotify::VT_ANGLE, angle, 0);
  }
  void add_spawnReason(SpawnReason spawnReason) {
    fbb_.AddElement<int32_t>(ProjectileSpawnNotify::VT_SPAWNREASON, static_cast<int32_t>(spawnReason), 0);
  }
  void add_despawnCheckerType(int8_t despawnCheckerType) {
    fbb_.AddElement<int8_t>(ProjectileSpawnNotify::VT_DESPAWNCHECKERTYPE, despawnCheckerType, 0);
  }
  explicit ProjectileSpawnNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProjectileSpawnNotifyBuilder &operator=(const ProjectileSpawnNotifyBuilder &);
  flatbuffers::Offset<ProjectileSpawnNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProjectileSpawnNotify>(end);
    fbb_.Required(o, ProjectileSpawnNotify::VT_POS);
    return o;
  }
};

inline flatbuffers::Offset<ProjectileSpawnNotify> CreateProjectileSpawnNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int64_t shooterId = 0,
    int32_t projectileId = 0,
    int32_t iff = 0,
    int32_t sceneId = 0,
    flatbuffers::Offset<Pos> pos = 0,
    int16_t angle = 0,
    SpawnReason spawnReason = SpawnReason_SP_ON_SPAWNED,
    int8_t despawnCheckerType = 0) {
  ProjectileSpawnNotifyBuilder builder_(_fbb);
  builder_.add_shooterId(shooterId);
  builder_.add_objectId(objectId);
  builder_.add_spawnReason(spawnReason);
  builder_.add_pos(pos);
  builder_.add_sceneId(sceneId);
  builder_.add_iff(iff);
  builder_.add_projectileId(projectileId);
  builder_.add_angle(angle);
  builder_.add_despawnCheckerType(despawnCheckerType);
  return builder_.Finish();
}

///- PROJECTILE_EFFECT_NOTIFY ----------
struct ProjectileEffectNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CASTERID = 4,
    VT_SCENEID = 6,
    VT_SKILLID = 8,
    VT_EFFECTID = 10,
    VT_TARGETIDS = 12,
    VT_POS = 14,
    VT_ANGLE = 16,
    VT_ATTACKSPEEDRATE = 18,
    VT_MOVESPEEDRATE = 20,
    VT_FINISHED = 22
  };
  int64_t casterId() const {
    return GetField<int64_t>(VT_CASTERID, 0);
  }
  int32_t sceneId() const {
    return GetField<int32_t>(VT_SCENEID, 0);
  }
  int32_t skillId() const {
    return GetField<int32_t>(VT_SKILLID, 0);
  }
  const flatbuffers::Vector<int32_t> *effectId() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_EFFECTID);
  }
  const flatbuffers::Vector<int64_t> *targetIds() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_TARGETIDS);
  }
  const Pos *pos() const {
    return GetPointer<const Pos *>(VT_POS);
  }
  int16_t angle() const {
    return GetField<int16_t>(VT_ANGLE, 0);
  }
  float attackSpeedRate() const {
    return GetField<float>(VT_ATTACKSPEEDRATE, 0.0f);
  }
  float moveSpeedRate() const {
    return GetField<float>(VT_MOVESPEEDRATE, 0.0f);
  }
  bool finished() const {
    return GetField<uint8_t>(VT_FINISHED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_CASTERID) &&
           VerifyField<int32_t>(verifier, VT_SCENEID) &&
           VerifyField<int32_t>(verifier, VT_SKILLID) &&
           VerifyOffsetRequired(verifier, VT_EFFECTID) &&
           verifier.VerifyVector(effectId()) &&
           VerifyOffset(verifier, VT_TARGETIDS) &&
           verifier.VerifyVector(targetIds()) &&
           VerifyOffsetRequired(verifier, VT_POS) &&
           verifier.VerifyTable(pos()) &&
           VerifyField<int16_t>(verifier, VT_ANGLE) &&
           VerifyField<float>(verifier, VT_ATTACKSPEEDRATE) &&
           VerifyField<float>(verifier, VT_MOVESPEEDRATE) &&
           VerifyField<uint8_t>(verifier, VT_FINISHED) &&
           verifier.EndTable();
  }
};

struct ProjectileEffectNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_casterId(int64_t casterId) {
    fbb_.AddElement<int64_t>(ProjectileEffectNotify::VT_CASTERID, casterId, 0);
  }
  void add_sceneId(int32_t sceneId) {
    fbb_.AddElement<int32_t>(ProjectileEffectNotify::VT_SCENEID, sceneId, 0);
  }
  void add_skillId(int32_t skillId) {
    fbb_.AddElement<int32_t>(ProjectileEffectNotify::VT_SKILLID, skillId, 0);
  }
  void add_effectId(flatbuffers::Offset<flatbuffers::Vector<int32_t>> effectId) {
    fbb_.AddOffset(ProjectileEffectNotify::VT_EFFECTID, effectId);
  }
  void add_targetIds(flatbuffers::Offset<flatbuffers::Vector<int64_t>> targetIds) {
    fbb_.AddOffset(ProjectileEffectNotify::VT_TARGETIDS, targetIds);
  }
  void add_pos(flatbuffers::Offset<Pos> pos) {
    fbb_.AddOffset(ProjectileEffectNotify::VT_POS, pos);
  }
  void add_angle(int16_t angle) {
    fbb_.AddElement<int16_t>(ProjectileEffectNotify::VT_ANGLE, angle, 0);
  }
  void add_attackSpeedRate(float attackSpeedRate) {
    fbb_.AddElement<float>(ProjectileEffectNotify::VT_ATTACKSPEEDRATE, attackSpeedRate, 0.0f);
  }
  void add_moveSpeedRate(float moveSpeedRate) {
    fbb_.AddElement<float>(ProjectileEffectNotify::VT_MOVESPEEDRATE, moveSpeedRate, 0.0f);
  }
  void add_finished(bool finished) {
    fbb_.AddElement<uint8_t>(ProjectileEffectNotify::VT_FINISHED, static_cast<uint8_t>(finished), 0);
  }
  explicit ProjectileEffectNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProjectileEffectNotifyBuilder &operator=(const ProjectileEffectNotifyBuilder &);
  flatbuffers::Offset<ProjectileEffectNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProjectileEffectNotify>(end);
    fbb_.Required(o, ProjectileEffectNotify::VT_EFFECTID);
    fbb_.Required(o, ProjectileEffectNotify::VT_POS);
    return o;
  }
};

inline flatbuffers::Offset<ProjectileEffectNotify> CreateProjectileEffectNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t casterId = 0,
    int32_t sceneId = 0,
    int32_t skillId = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> effectId = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> targetIds = 0,
    flatbuffers::Offset<Pos> pos = 0,
    int16_t angle = 0,
    float attackSpeedRate = 0.0f,
    float moveSpeedRate = 0.0f,
    bool finished = false) {
  ProjectileEffectNotifyBuilder builder_(_fbb);
  builder_.add_casterId(casterId);
  builder_.add_moveSpeedRate(moveSpeedRate);
  builder_.add_attackSpeedRate(attackSpeedRate);
  builder_.add_pos(pos);
  builder_.add_targetIds(targetIds);
  builder_.add_effectId(effectId);
  builder_.add_skillId(skillId);
  builder_.add_sceneId(sceneId);
  builder_.add_angle(angle);
  builder_.add_finished(finished);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProjectileEffectNotify> CreateProjectileEffectNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t casterId = 0,
    int32_t sceneId = 0,
    int32_t skillId = 0,
    const std::vector<int32_t> *effectId = nullptr,
    const std::vector<int64_t> *targetIds = nullptr,
    flatbuffers::Offset<Pos> pos = 0,
    int16_t angle = 0,
    float attackSpeedRate = 0.0f,
    float moveSpeedRate = 0.0f,
    bool finished = false) {
  return LeanPacket::CreateProjectileEffectNotify(
      _fbb,
      casterId,
      sceneId,
      skillId,
      effectId ? _fbb.CreateVector<int32_t>(*effectId) : 0,
      targetIds ? _fbb.CreateVector<int64_t>(*targetIds) : 0,
      pos,
      angle,
      attackSpeedRate,
      moveSpeedRate,
      finished);
}

struct ReactionEnterNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_ATTACKERID = 6,
    VT_REACTIONTYPE = 8,
    VT_STARTPOS = 10,
    VT_STARTANGLE = 12,
    VT_ENDPOS = 14,
    VT_ENDANGLE = 16,
    VT_DURATION = 18,
    VT_KEY = 20,
    VT_PLACEOFORIGIN = 22,
    VT_REACTIONLEVEL = 24
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int64_t attackerId() const {
    return GetField<int64_t>(VT_ATTACKERID, 0);
  }
  int16_t reactionType() const {
    return GetField<int16_t>(VT_REACTIONTYPE, 0);
  }
  const Pos *startPos() const {
    return GetPointer<const Pos *>(VT_STARTPOS);
  }
  int16_t startAngle() const {
    return GetField<int16_t>(VT_STARTANGLE, 0);
  }
  const Pos *endPos() const {
    return GetPointer<const Pos *>(VT_ENDPOS);
  }
  int16_t endAngle() const {
    return GetField<int16_t>(VT_ENDANGLE, 0);
  }
  int32_t duration() const {
    return GetField<int32_t>(VT_DURATION, 0);
  }
  int32_t key() const {
    return GetField<int32_t>(VT_KEY, 0);
  }
  fromReaction placeOfOrigin() const {
    return static_cast<fromReaction>(GetField<int32_t>(VT_PLACEOFORIGIN, 0));
  }
  int16_t reactionLevel() const {
    return GetField<int16_t>(VT_REACTIONLEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int64_t>(verifier, VT_ATTACKERID) &&
           VerifyField<int16_t>(verifier, VT_REACTIONTYPE) &&
           VerifyOffsetRequired(verifier, VT_STARTPOS) &&
           verifier.VerifyTable(startPos()) &&
           VerifyField<int16_t>(verifier, VT_STARTANGLE) &&
           VerifyOffsetRequired(verifier, VT_ENDPOS) &&
           verifier.VerifyTable(endPos()) &&
           VerifyField<int16_t>(verifier, VT_ENDANGLE) &&
           VerifyField<int32_t>(verifier, VT_DURATION) &&
           VerifyField<int32_t>(verifier, VT_KEY) &&
           VerifyField<int32_t>(verifier, VT_PLACEOFORIGIN) &&
           VerifyField<int16_t>(verifier, VT_REACTIONLEVEL) &&
           verifier.EndTable();
  }
};

struct ReactionEnterNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(ReactionEnterNotify::VT_OBJECTID, objectId, 0);
  }
  void add_attackerId(int64_t attackerId) {
    fbb_.AddElement<int64_t>(ReactionEnterNotify::VT_ATTACKERID, attackerId, 0);
  }
  void add_reactionType(int16_t reactionType) {
    fbb_.AddElement<int16_t>(ReactionEnterNotify::VT_REACTIONTYPE, reactionType, 0);
  }
  void add_startPos(flatbuffers::Offset<Pos> startPos) {
    fbb_.AddOffset(ReactionEnterNotify::VT_STARTPOS, startPos);
  }
  void add_startAngle(int16_t startAngle) {
    fbb_.AddElement<int16_t>(ReactionEnterNotify::VT_STARTANGLE, startAngle, 0);
  }
  void add_endPos(flatbuffers::Offset<Pos> endPos) {
    fbb_.AddOffset(ReactionEnterNotify::VT_ENDPOS, endPos);
  }
  void add_endAngle(int16_t endAngle) {
    fbb_.AddElement<int16_t>(ReactionEnterNotify::VT_ENDANGLE, endAngle, 0);
  }
  void add_duration(int32_t duration) {
    fbb_.AddElement<int32_t>(ReactionEnterNotify::VT_DURATION, duration, 0);
  }
  void add_key(int32_t key) {
    fbb_.AddElement<int32_t>(ReactionEnterNotify::VT_KEY, key, 0);
  }
  void add_placeOfOrigin(fromReaction placeOfOrigin) {
    fbb_.AddElement<int32_t>(ReactionEnterNotify::VT_PLACEOFORIGIN, static_cast<int32_t>(placeOfOrigin), 0);
  }
  void add_reactionLevel(int16_t reactionLevel) {
    fbb_.AddElement<int16_t>(ReactionEnterNotify::VT_REACTIONLEVEL, reactionLevel, 0);
  }
  explicit ReactionEnterNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReactionEnterNotifyBuilder &operator=(const ReactionEnterNotifyBuilder &);
  flatbuffers::Offset<ReactionEnterNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReactionEnterNotify>(end);
    fbb_.Required(o, ReactionEnterNotify::VT_STARTPOS);
    fbb_.Required(o, ReactionEnterNotify::VT_ENDPOS);
    return o;
  }
};

inline flatbuffers::Offset<ReactionEnterNotify> CreateReactionEnterNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int64_t attackerId = 0,
    int16_t reactionType = 0,
    flatbuffers::Offset<Pos> startPos = 0,
    int16_t startAngle = 0,
    flatbuffers::Offset<Pos> endPos = 0,
    int16_t endAngle = 0,
    int32_t duration = 0,
    int32_t key = 0,
    fromReaction placeOfOrigin = fromReaction_FROM_REACTION_NONE,
    int16_t reactionLevel = 0) {
  ReactionEnterNotifyBuilder builder_(_fbb);
  builder_.add_attackerId(attackerId);
  builder_.add_objectId(objectId);
  builder_.add_placeOfOrigin(placeOfOrigin);
  builder_.add_key(key);
  builder_.add_duration(duration);
  builder_.add_endPos(endPos);
  builder_.add_startPos(startPos);
  builder_.add_reactionLevel(reactionLevel);
  builder_.add_endAngle(endAngle);
  builder_.add_startAngle(startAngle);
  builder_.add_reactionType(reactionType);
  return builder_.Finish();
}

struct ReactionLeaveNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_ATTACKERID = 6,
    VT_ENDPOS = 8,
    VT_ENDANGLE = 10,
    VT_KEY = 12
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int64_t attackerId() const {
    return GetField<int64_t>(VT_ATTACKERID, 0);
  }
  const Pos *endPos() const {
    return GetPointer<const Pos *>(VT_ENDPOS);
  }
  int16_t endAngle() const {
    return GetField<int16_t>(VT_ENDANGLE, 0);
  }
  int32_t key() const {
    return GetField<int32_t>(VT_KEY, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int64_t>(verifier, VT_ATTACKERID) &&
           VerifyOffsetRequired(verifier, VT_ENDPOS) &&
           verifier.VerifyTable(endPos()) &&
           VerifyField<int16_t>(verifier, VT_ENDANGLE) &&
           VerifyField<int32_t>(verifier, VT_KEY) &&
           verifier.EndTable();
  }
};

struct ReactionLeaveNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(ReactionLeaveNotify::VT_OBJECTID, objectId, 0);
  }
  void add_attackerId(int64_t attackerId) {
    fbb_.AddElement<int64_t>(ReactionLeaveNotify::VT_ATTACKERID, attackerId, 0);
  }
  void add_endPos(flatbuffers::Offset<Pos> endPos) {
    fbb_.AddOffset(ReactionLeaveNotify::VT_ENDPOS, endPos);
  }
  void add_endAngle(int16_t endAngle) {
    fbb_.AddElement<int16_t>(ReactionLeaveNotify::VT_ENDANGLE, endAngle, 0);
  }
  void add_key(int32_t key) {
    fbb_.AddElement<int32_t>(ReactionLeaveNotify::VT_KEY, key, 0);
  }
  explicit ReactionLeaveNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReactionLeaveNotifyBuilder &operator=(const ReactionLeaveNotifyBuilder &);
  flatbuffers::Offset<ReactionLeaveNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReactionLeaveNotify>(end);
    fbb_.Required(o, ReactionLeaveNotify::VT_ENDPOS);
    return o;
  }
};

inline flatbuffers::Offset<ReactionLeaveNotify> CreateReactionLeaveNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int64_t attackerId = 0,
    flatbuffers::Offset<Pos> endPos = 0,
    int16_t endAngle = 0,
    int32_t key = 0) {
  ReactionLeaveNotifyBuilder builder_(_fbb);
  builder_.add_attackerId(attackerId);
  builder_.add_objectId(objectId);
  builder_.add_key(key);
  builder_.add_endPos(endPos);
  builder_.add_endAngle(endAngle);
  return builder_.Finish();
}

struct ReactionUpdateNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_ATTACKERID = 6,
    VT_REACTIONTYPE = 8,
    VT_CURPOS = 10,
    VT_CURANGLE = 12,
    VT_ENDPOS = 14,
    VT_ENDANGLE = 16,
    VT_DURATION = 18
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int64_t attackerId() const {
    return GetField<int64_t>(VT_ATTACKERID, 0);
  }
  int16_t reactionType() const {
    return GetField<int16_t>(VT_REACTIONTYPE, 0);
  }
  const Pos *curPos() const {
    return GetPointer<const Pos *>(VT_CURPOS);
  }
  int16_t curAngle() const {
    return GetField<int16_t>(VT_CURANGLE, 0);
  }
  const Pos *endPos() const {
    return GetPointer<const Pos *>(VT_ENDPOS);
  }
  int16_t endAngle() const {
    return GetField<int16_t>(VT_ENDANGLE, 0);
  }
  int32_t duration() const {
    return GetField<int32_t>(VT_DURATION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int64_t>(verifier, VT_ATTACKERID) &&
           VerifyField<int16_t>(verifier, VT_REACTIONTYPE) &&
           VerifyOffsetRequired(verifier, VT_CURPOS) &&
           verifier.VerifyTable(curPos()) &&
           VerifyField<int16_t>(verifier, VT_CURANGLE) &&
           VerifyOffsetRequired(verifier, VT_ENDPOS) &&
           verifier.VerifyTable(endPos()) &&
           VerifyField<int16_t>(verifier, VT_ENDANGLE) &&
           VerifyField<int32_t>(verifier, VT_DURATION) &&
           verifier.EndTable();
  }
};

struct ReactionUpdateNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(ReactionUpdateNotify::VT_OBJECTID, objectId, 0);
  }
  void add_attackerId(int64_t attackerId) {
    fbb_.AddElement<int64_t>(ReactionUpdateNotify::VT_ATTACKERID, attackerId, 0);
  }
  void add_reactionType(int16_t reactionType) {
    fbb_.AddElement<int16_t>(ReactionUpdateNotify::VT_REACTIONTYPE, reactionType, 0);
  }
  void add_curPos(flatbuffers::Offset<Pos> curPos) {
    fbb_.AddOffset(ReactionUpdateNotify::VT_CURPOS, curPos);
  }
  void add_curAngle(int16_t curAngle) {
    fbb_.AddElement<int16_t>(ReactionUpdateNotify::VT_CURANGLE, curAngle, 0);
  }
  void add_endPos(flatbuffers::Offset<Pos> endPos) {
    fbb_.AddOffset(ReactionUpdateNotify::VT_ENDPOS, endPos);
  }
  void add_endAngle(int16_t endAngle) {
    fbb_.AddElement<int16_t>(ReactionUpdateNotify::VT_ENDANGLE, endAngle, 0);
  }
  void add_duration(int32_t duration) {
    fbb_.AddElement<int32_t>(ReactionUpdateNotify::VT_DURATION, duration, 0);
  }
  explicit ReactionUpdateNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReactionUpdateNotifyBuilder &operator=(const ReactionUpdateNotifyBuilder &);
  flatbuffers::Offset<ReactionUpdateNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReactionUpdateNotify>(end);
    fbb_.Required(o, ReactionUpdateNotify::VT_CURPOS);
    fbb_.Required(o, ReactionUpdateNotify::VT_ENDPOS);
    return o;
  }
};

inline flatbuffers::Offset<ReactionUpdateNotify> CreateReactionUpdateNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int64_t attackerId = 0,
    int16_t reactionType = 0,
    flatbuffers::Offset<Pos> curPos = 0,
    int16_t curAngle = 0,
    flatbuffers::Offset<Pos> endPos = 0,
    int16_t endAngle = 0,
    int32_t duration = 0) {
  ReactionUpdateNotifyBuilder builder_(_fbb);
  builder_.add_attackerId(attackerId);
  builder_.add_objectId(objectId);
  builder_.add_duration(duration);
  builder_.add_endPos(endPos);
  builder_.add_curPos(curPos);
  builder_.add_endAngle(endAngle);
  builder_.add_curAngle(curAngle);
  builder_.add_reactionType(reactionType);
  return builder_.Finish();
}

///- INSTANTSHOT_SPAWN_NOTIFY ----------
struct InstantShotSpawnNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_SHOOTERID = 6,
    VT_PROJECTILEID = 8,
    VT_SCENEID = 10,
    VT_POS = 12,
    VT_ANGLE = 14,
    VT_TARGETID = 16,
    VT_DURATION = 18,
    VT_DESPAWNCHECKERTYPE = 20
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int64_t shooterId() const {
    return GetField<int64_t>(VT_SHOOTERID, 0);
  }
  int32_t projectileId() const {
    return GetField<int32_t>(VT_PROJECTILEID, 0);
  }
  int32_t sceneId() const {
    return GetField<int32_t>(VT_SCENEID, 0);
  }
  const Pos *pos() const {
    return GetPointer<const Pos *>(VT_POS);
  }
  int16_t angle() const {
    return GetField<int16_t>(VT_ANGLE, 0);
  }
  int64_t targetId() const {
    return GetField<int64_t>(VT_TARGETID, 0);
  }
  int64_t duration() const {
    return GetField<int64_t>(VT_DURATION, 0);
  }
  int8_t despawnCheckerType() const {
    return GetField<int8_t>(VT_DESPAWNCHECKERTYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int64_t>(verifier, VT_SHOOTERID) &&
           VerifyField<int32_t>(verifier, VT_PROJECTILEID) &&
           VerifyField<int32_t>(verifier, VT_SCENEID) &&
           VerifyOffsetRequired(verifier, VT_POS) &&
           verifier.VerifyTable(pos()) &&
           VerifyField<int16_t>(verifier, VT_ANGLE) &&
           VerifyField<int64_t>(verifier, VT_TARGETID) &&
           VerifyField<int64_t>(verifier, VT_DURATION) &&
           VerifyField<int8_t>(verifier, VT_DESPAWNCHECKERTYPE) &&
           verifier.EndTable();
  }
};

struct InstantShotSpawnNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(InstantShotSpawnNotify::VT_OBJECTID, objectId, 0);
  }
  void add_shooterId(int64_t shooterId) {
    fbb_.AddElement<int64_t>(InstantShotSpawnNotify::VT_SHOOTERID, shooterId, 0);
  }
  void add_projectileId(int32_t projectileId) {
    fbb_.AddElement<int32_t>(InstantShotSpawnNotify::VT_PROJECTILEID, projectileId, 0);
  }
  void add_sceneId(int32_t sceneId) {
    fbb_.AddElement<int32_t>(InstantShotSpawnNotify::VT_SCENEID, sceneId, 0);
  }
  void add_pos(flatbuffers::Offset<Pos> pos) {
    fbb_.AddOffset(InstantShotSpawnNotify::VT_POS, pos);
  }
  void add_angle(int16_t angle) {
    fbb_.AddElement<int16_t>(InstantShotSpawnNotify::VT_ANGLE, angle, 0);
  }
  void add_targetId(int64_t targetId) {
    fbb_.AddElement<int64_t>(InstantShotSpawnNotify::VT_TARGETID, targetId, 0);
  }
  void add_duration(int64_t duration) {
    fbb_.AddElement<int64_t>(InstantShotSpawnNotify::VT_DURATION, duration, 0);
  }
  void add_despawnCheckerType(int8_t despawnCheckerType) {
    fbb_.AddElement<int8_t>(InstantShotSpawnNotify::VT_DESPAWNCHECKERTYPE, despawnCheckerType, 0);
  }
  explicit InstantShotSpawnNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InstantShotSpawnNotifyBuilder &operator=(const InstantShotSpawnNotifyBuilder &);
  flatbuffers::Offset<InstantShotSpawnNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InstantShotSpawnNotify>(end);
    fbb_.Required(o, InstantShotSpawnNotify::VT_POS);
    return o;
  }
};

inline flatbuffers::Offset<InstantShotSpawnNotify> CreateInstantShotSpawnNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int64_t shooterId = 0,
    int32_t projectileId = 0,
    int32_t sceneId = 0,
    flatbuffers::Offset<Pos> pos = 0,
    int16_t angle = 0,
    int64_t targetId = 0,
    int64_t duration = 0,
    int8_t despawnCheckerType = 0) {
  InstantShotSpawnNotifyBuilder builder_(_fbb);
  builder_.add_duration(duration);
  builder_.add_targetId(targetId);
  builder_.add_shooterId(shooterId);
  builder_.add_objectId(objectId);
  builder_.add_pos(pos);
  builder_.add_sceneId(sceneId);
  builder_.add_projectileId(projectileId);
  builder_.add_angle(angle);
  builder_.add_despawnCheckerType(despawnCheckerType);
  return builder_.Finish();
}

///- INSTANTSHOT_DESPAWN_NOTIFY ----------
struct InstantShotDespawnNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           verifier.EndTable();
  }
};

struct InstantShotDespawnNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(InstantShotDespawnNotify::VT_OBJECTID, objectId, 0);
  }
  explicit InstantShotDespawnNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InstantShotDespawnNotifyBuilder &operator=(const InstantShotDespawnNotifyBuilder &);
  flatbuffers::Offset<InstantShotDespawnNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InstantShotDespawnNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<InstantShotDespawnNotify> CreateInstantShotDespawnNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0) {
  InstantShotDespawnNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  return builder_.Finish();
}

///- USE_SKILL_REQUEST ----------- client -> game
struct UseSkillRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_SKILLID = 6,
    VT_CASTINGPOS = 8,
    VT_CASTINGANGLE = 10,
    VT_TARGETOBJIDS = 12,
    VT_CLIENTTICK = 14
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int32_t skillId() const {
    return GetField<int32_t>(VT_SKILLID, 0);
  }
  const Pos *castingPos() const {
    return GetPointer<const Pos *>(VT_CASTINGPOS);
  }
  int16_t castingAngle() const {
    return GetField<int16_t>(VT_CASTINGANGLE, 0);
  }
  const flatbuffers::Vector<int64_t> *targetObjIds() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_TARGETOBJIDS);
  }
  int64_t clientTick() const {
    return GetField<int64_t>(VT_CLIENTTICK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int32_t>(verifier, VT_SKILLID) &&
           VerifyOffsetRequired(verifier, VT_CASTINGPOS) &&
           verifier.VerifyTable(castingPos()) &&
           VerifyField<int16_t>(verifier, VT_CASTINGANGLE) &&
           VerifyOffset(verifier, VT_TARGETOBJIDS) &&
           verifier.VerifyVector(targetObjIds()) &&
           VerifyField<int64_t>(verifier, VT_CLIENTTICK) &&
           verifier.EndTable();
  }
};

struct UseSkillRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(UseSkillRequest::VT_OBJECTID, objectId, 0);
  }
  void add_skillId(int32_t skillId) {
    fbb_.AddElement<int32_t>(UseSkillRequest::VT_SKILLID, skillId, 0);
  }
  void add_castingPos(flatbuffers::Offset<Pos> castingPos) {
    fbb_.AddOffset(UseSkillRequest::VT_CASTINGPOS, castingPos);
  }
  void add_castingAngle(int16_t castingAngle) {
    fbb_.AddElement<int16_t>(UseSkillRequest::VT_CASTINGANGLE, castingAngle, 0);
  }
  void add_targetObjIds(flatbuffers::Offset<flatbuffers::Vector<int64_t>> targetObjIds) {
    fbb_.AddOffset(UseSkillRequest::VT_TARGETOBJIDS, targetObjIds);
  }
  void add_clientTick(int64_t clientTick) {
    fbb_.AddElement<int64_t>(UseSkillRequest::VT_CLIENTTICK, clientTick, 0);
  }
  explicit UseSkillRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UseSkillRequestBuilder &operator=(const UseSkillRequestBuilder &);
  flatbuffers::Offset<UseSkillRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UseSkillRequest>(end);
    fbb_.Required(o, UseSkillRequest::VT_CASTINGPOS);
    return o;
  }
};

inline flatbuffers::Offset<UseSkillRequest> CreateUseSkillRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int32_t skillId = 0,
    flatbuffers::Offset<Pos> castingPos = 0,
    int16_t castingAngle = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> targetObjIds = 0,
    int64_t clientTick = 0) {
  UseSkillRequestBuilder builder_(_fbb);
  builder_.add_clientTick(clientTick);
  builder_.add_objectId(objectId);
  builder_.add_targetObjIds(targetObjIds);
  builder_.add_castingPos(castingPos);
  builder_.add_skillId(skillId);
  builder_.add_castingAngle(castingAngle);
  return builder_.Finish();
}

inline flatbuffers::Offset<UseSkillRequest> CreateUseSkillRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int32_t skillId = 0,
    flatbuffers::Offset<Pos> castingPos = 0,
    int16_t castingAngle = 0,
    const std::vector<int64_t> *targetObjIds = nullptr,
    int64_t clientTick = 0) {
  return LeanPacket::CreateUseSkillRequest(
      _fbb,
      objectId,
      skillId,
      castingPos,
      castingAngle,
      targetObjIds ? _fbb.CreateVector<int64_t>(*targetObjIds) : 0,
      clientTick);
}

///- START_SKILL_NOTIFY ----------
struct StartSkillNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_SKILLID = 6,
    VT_CASTINGPOS = 8,
    VT_CASTINGANGLE = 10,
    VT_TARGETOBJIDS = 12,
    VT_FEATUREINFOS = 14,
    VT_ISPENALTYSKILL = 16
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int32_t skillId() const {
    return GetField<int32_t>(VT_SKILLID, 0);
  }
  const Pos *castingPos() const {
    return GetPointer<const Pos *>(VT_CASTINGPOS);
  }
  int16_t castingAngle() const {
    return GetField<int16_t>(VT_CASTINGANGLE, 0);
  }
  const flatbuffers::Vector<int64_t> *targetObjIds() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_TARGETOBJIDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FeatureInfo>> *featureInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FeatureInfo>> *>(VT_FEATUREINFOS);
  }
  bool isPenaltySkill() const {
    return GetField<uint8_t>(VT_ISPENALTYSKILL, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int32_t>(verifier, VT_SKILLID) &&
           VerifyOffsetRequired(verifier, VT_CASTINGPOS) &&
           verifier.VerifyTable(castingPos()) &&
           VerifyField<int16_t>(verifier, VT_CASTINGANGLE) &&
           VerifyOffsetRequired(verifier, VT_TARGETOBJIDS) &&
           verifier.VerifyVector(targetObjIds()) &&
           VerifyOffsetRequired(verifier, VT_FEATUREINFOS) &&
           verifier.VerifyVector(featureInfos()) &&
           verifier.VerifyVectorOfTables(featureInfos()) &&
           VerifyField<uint8_t>(verifier, VT_ISPENALTYSKILL) &&
           verifier.EndTable();
  }
};

struct StartSkillNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(StartSkillNotify::VT_OBJECTID, objectId, 0);
  }
  void add_skillId(int32_t skillId) {
    fbb_.AddElement<int32_t>(StartSkillNotify::VT_SKILLID, skillId, 0);
  }
  void add_castingPos(flatbuffers::Offset<Pos> castingPos) {
    fbb_.AddOffset(StartSkillNotify::VT_CASTINGPOS, castingPos);
  }
  void add_castingAngle(int16_t castingAngle) {
    fbb_.AddElement<int16_t>(StartSkillNotify::VT_CASTINGANGLE, castingAngle, 0);
  }
  void add_targetObjIds(flatbuffers::Offset<flatbuffers::Vector<int64_t>> targetObjIds) {
    fbb_.AddOffset(StartSkillNotify::VT_TARGETOBJIDS, targetObjIds);
  }
  void add_featureInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FeatureInfo>>> featureInfos) {
    fbb_.AddOffset(StartSkillNotify::VT_FEATUREINFOS, featureInfos);
  }
  void add_isPenaltySkill(bool isPenaltySkill) {
    fbb_.AddElement<uint8_t>(StartSkillNotify::VT_ISPENALTYSKILL, static_cast<uint8_t>(isPenaltySkill), 0);
  }
  explicit StartSkillNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StartSkillNotifyBuilder &operator=(const StartSkillNotifyBuilder &);
  flatbuffers::Offset<StartSkillNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StartSkillNotify>(end);
    fbb_.Required(o, StartSkillNotify::VT_CASTINGPOS);
    fbb_.Required(o, StartSkillNotify::VT_TARGETOBJIDS);
    fbb_.Required(o, StartSkillNotify::VT_FEATUREINFOS);
    return o;
  }
};

inline flatbuffers::Offset<StartSkillNotify> CreateStartSkillNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int32_t skillId = 0,
    flatbuffers::Offset<Pos> castingPos = 0,
    int16_t castingAngle = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> targetObjIds = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FeatureInfo>>> featureInfos = 0,
    bool isPenaltySkill = false) {
  StartSkillNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_featureInfos(featureInfos);
  builder_.add_targetObjIds(targetObjIds);
  builder_.add_castingPos(castingPos);
  builder_.add_skillId(skillId);
  builder_.add_castingAngle(castingAngle);
  builder_.add_isPenaltySkill(isPenaltySkill);
  return builder_.Finish();
}

inline flatbuffers::Offset<StartSkillNotify> CreateStartSkillNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int32_t skillId = 0,
    flatbuffers::Offset<Pos> castingPos = 0,
    int16_t castingAngle = 0,
    const std::vector<int64_t> *targetObjIds = nullptr,
    const std::vector<flatbuffers::Offset<FeatureInfo>> *featureInfos = nullptr,
    bool isPenaltySkill = false) {
  return LeanPacket::CreateStartSkillNotify(
      _fbb,
      objectId,
      skillId,
      castingPos,
      castingAngle,
      targetObjIds ? _fbb.CreateVector<int64_t>(*targetObjIds) : 0,
      featureInfos ? _fbb.CreateVector<flatbuffers::Offset<FeatureInfo>>(*featureInfos) : 0,
      isPenaltySkill);
}

///- END_SKILL_NOTIFY -------------
struct EndSkillNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_SKILLID = 6,
    VT_ENDPOS = 8,
    VT_ENDANGLE = 10,
    VT_ENDREASON = 12,
    VT_COOLTIME = 14
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int32_t skillId() const {
    return GetField<int32_t>(VT_SKILLID, 0);
  }
  const Pos *endPos() const {
    return GetPointer<const Pos *>(VT_ENDPOS);
  }
  int16_t endAngle() const {
    return GetField<int16_t>(VT_ENDANGLE, 0);
  }
  int16_t endReason() const {
    return GetField<int16_t>(VT_ENDREASON, 0);
  }
  int32_t coolTime() const {
    return GetField<int32_t>(VT_COOLTIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int32_t>(verifier, VT_SKILLID) &&
           VerifyOffsetRequired(verifier, VT_ENDPOS) &&
           verifier.VerifyTable(endPos()) &&
           VerifyField<int16_t>(verifier, VT_ENDANGLE) &&
           VerifyField<int16_t>(verifier, VT_ENDREASON) &&
           VerifyField<int32_t>(verifier, VT_COOLTIME) &&
           verifier.EndTable();
  }
};

struct EndSkillNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(EndSkillNotify::VT_OBJECTID, objectId, 0);
  }
  void add_skillId(int32_t skillId) {
    fbb_.AddElement<int32_t>(EndSkillNotify::VT_SKILLID, skillId, 0);
  }
  void add_endPos(flatbuffers::Offset<Pos> endPos) {
    fbb_.AddOffset(EndSkillNotify::VT_ENDPOS, endPos);
  }
  void add_endAngle(int16_t endAngle) {
    fbb_.AddElement<int16_t>(EndSkillNotify::VT_ENDANGLE, endAngle, 0);
  }
  void add_endReason(int16_t endReason) {
    fbb_.AddElement<int16_t>(EndSkillNotify::VT_ENDREASON, endReason, 0);
  }
  void add_coolTime(int32_t coolTime) {
    fbb_.AddElement<int32_t>(EndSkillNotify::VT_COOLTIME, coolTime, 0);
  }
  explicit EndSkillNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EndSkillNotifyBuilder &operator=(const EndSkillNotifyBuilder &);
  flatbuffers::Offset<EndSkillNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EndSkillNotify>(end);
    fbb_.Required(o, EndSkillNotify::VT_ENDPOS);
    return o;
  }
};

inline flatbuffers::Offset<EndSkillNotify> CreateEndSkillNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int32_t skillId = 0,
    flatbuffers::Offset<Pos> endPos = 0,
    int16_t endAngle = 0,
    int16_t endReason = 0,
    int32_t coolTime = 0) {
  EndSkillNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_coolTime(coolTime);
  builder_.add_endPos(endPos);
  builder_.add_skillId(skillId);
  builder_.add_endReason(endReason);
  builder_.add_endAngle(endAngle);
  return builder_.Finish();
}

///- SKILL_EFFECT_NOTIFY -------------
struct SkillEffectNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_SKILLID = 6,
    VT_EFFECTID = 8,
    VT_TARGETINGIDX = 10,
    VT_POS = 12,
    VT_ANGLE = 14,
    VT_TARGETS = 16,
    VT_ATTACKSPEEDRATE = 18,
    VT_MOVESPEEDRATE = 20,
    VT_CLIENTTICK = 22
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int32_t skillId() const {
    return GetField<int32_t>(VT_SKILLID, 0);
  }
  int32_t effectId() const {
    return GetField<int32_t>(VT_EFFECTID, 0);
  }
  int32_t targetingIdx() const {
    return GetField<int32_t>(VT_TARGETINGIDX, 0);
  }
  const Pos *pos() const {
    return GetPointer<const Pos *>(VT_POS);
  }
  int16_t angle() const {
    return GetField<int16_t>(VT_ANGLE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<EffectTargetInfo>> *targets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EffectTargetInfo>> *>(VT_TARGETS);
  }
  float attackSpeedRate() const {
    return GetField<float>(VT_ATTACKSPEEDRATE, 0.0f);
  }
  float moveSpeedRate() const {
    return GetField<float>(VT_MOVESPEEDRATE, 0.0f);
  }
  int64_t clientTick() const {
    return GetField<int64_t>(VT_CLIENTTICK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int32_t>(verifier, VT_SKILLID) &&
           VerifyField<int32_t>(verifier, VT_EFFECTID) &&
           VerifyField<int32_t>(verifier, VT_TARGETINGIDX) &&
           VerifyOffsetRequired(verifier, VT_POS) &&
           verifier.VerifyTable(pos()) &&
           VerifyField<int16_t>(verifier, VT_ANGLE) &&
           VerifyOffsetRequired(verifier, VT_TARGETS) &&
           verifier.VerifyVector(targets()) &&
           verifier.VerifyVectorOfTables(targets()) &&
           VerifyField<float>(verifier, VT_ATTACKSPEEDRATE) &&
           VerifyField<float>(verifier, VT_MOVESPEEDRATE) &&
           VerifyField<int64_t>(verifier, VT_CLIENTTICK) &&
           verifier.EndTable();
  }
};

struct SkillEffectNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(SkillEffectNotify::VT_OBJECTID, objectId, 0);
  }
  void add_skillId(int32_t skillId) {
    fbb_.AddElement<int32_t>(SkillEffectNotify::VT_SKILLID, skillId, 0);
  }
  void add_effectId(int32_t effectId) {
    fbb_.AddElement<int32_t>(SkillEffectNotify::VT_EFFECTID, effectId, 0);
  }
  void add_targetingIdx(int32_t targetingIdx) {
    fbb_.AddElement<int32_t>(SkillEffectNotify::VT_TARGETINGIDX, targetingIdx, 0);
  }
  void add_pos(flatbuffers::Offset<Pos> pos) {
    fbb_.AddOffset(SkillEffectNotify::VT_POS, pos);
  }
  void add_angle(int16_t angle) {
    fbb_.AddElement<int16_t>(SkillEffectNotify::VT_ANGLE, angle, 0);
  }
  void add_targets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EffectTargetInfo>>> targets) {
    fbb_.AddOffset(SkillEffectNotify::VT_TARGETS, targets);
  }
  void add_attackSpeedRate(float attackSpeedRate) {
    fbb_.AddElement<float>(SkillEffectNotify::VT_ATTACKSPEEDRATE, attackSpeedRate, 0.0f);
  }
  void add_moveSpeedRate(float moveSpeedRate) {
    fbb_.AddElement<float>(SkillEffectNotify::VT_MOVESPEEDRATE, moveSpeedRate, 0.0f);
  }
  void add_clientTick(int64_t clientTick) {
    fbb_.AddElement<int64_t>(SkillEffectNotify::VT_CLIENTTICK, clientTick, 0);
  }
  explicit SkillEffectNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SkillEffectNotifyBuilder &operator=(const SkillEffectNotifyBuilder &);
  flatbuffers::Offset<SkillEffectNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkillEffectNotify>(end);
    fbb_.Required(o, SkillEffectNotify::VT_POS);
    fbb_.Required(o, SkillEffectNotify::VT_TARGETS);
    return o;
  }
};

inline flatbuffers::Offset<SkillEffectNotify> CreateSkillEffectNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int32_t skillId = 0,
    int32_t effectId = 0,
    int32_t targetingIdx = 0,
    flatbuffers::Offset<Pos> pos = 0,
    int16_t angle = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EffectTargetInfo>>> targets = 0,
    float attackSpeedRate = 0.0f,
    float moveSpeedRate = 0.0f,
    int64_t clientTick = 0) {
  SkillEffectNotifyBuilder builder_(_fbb);
  builder_.add_clientTick(clientTick);
  builder_.add_objectId(objectId);
  builder_.add_moveSpeedRate(moveSpeedRate);
  builder_.add_attackSpeedRate(attackSpeedRate);
  builder_.add_targets(targets);
  builder_.add_pos(pos);
  builder_.add_targetingIdx(targetingIdx);
  builder_.add_effectId(effectId);
  builder_.add_skillId(skillId);
  builder_.add_angle(angle);
  return builder_.Finish();
}

inline flatbuffers::Offset<SkillEffectNotify> CreateSkillEffectNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int32_t skillId = 0,
    int32_t effectId = 0,
    int32_t targetingIdx = 0,
    flatbuffers::Offset<Pos> pos = 0,
    int16_t angle = 0,
    const std::vector<flatbuffers::Offset<EffectTargetInfo>> *targets = nullptr,
    float attackSpeedRate = 0.0f,
    float moveSpeedRate = 0.0f,
    int64_t clientTick = 0) {
  return LeanPacket::CreateSkillEffectNotify(
      _fbb,
      objectId,
      skillId,
      effectId,
      targetingIdx,
      pos,
      angle,
      targets ? _fbb.CreateVector<flatbuffers::Offset<EffectTargetInfo>>(*targets) : 0,
      attackSpeedRate,
      moveSpeedRate,
      clientTick);
}

struct DamageResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EFFECTID = 4,
    VT_OBJECTID = 6,
    VT_DAMAGETYPE = 8,
    VT_DAMAGE = 10,
    VT_SHIELD = 12,
    VT_TRUEDAMAGE = 14,
    VT_REFLECTIONDAMAGE = 16,
    VT_DOUBLECRITICAL = 18,
    VT_TRIPLECRITICAL = 20,
    VT_PENTACRITICAL = 22
  };
  int32_t effectId() const {
    return GetField<int32_t>(VT_EFFECTID, 0);
  }
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int32_t damageType() const {
    return GetField<int32_t>(VT_DAMAGETYPE, 0);
  }
  int64_t damage() const {
    return GetField<int64_t>(VT_DAMAGE, 0);
  }
  int64_t shield() const {
    return GetField<int64_t>(VT_SHIELD, 0);
  }
  int64_t trueDamage() const {
    return GetField<int64_t>(VT_TRUEDAMAGE, 0);
  }
  int64_t reflectionDamage() const {
    return GetField<int64_t>(VT_REFLECTIONDAMAGE, 0);
  }
  bool doubleCritical() const {
    return GetField<uint8_t>(VT_DOUBLECRITICAL, 0) != 0;
  }
  bool tripleCritical() const {
    return GetField<uint8_t>(VT_TRIPLECRITICAL, 0) != 0;
  }
  bool pentaCritical() const {
    return GetField<uint8_t>(VT_PENTACRITICAL, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_EFFECTID) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int32_t>(verifier, VT_DAMAGETYPE) &&
           VerifyField<int64_t>(verifier, VT_DAMAGE) &&
           VerifyField<int64_t>(verifier, VT_SHIELD) &&
           VerifyField<int64_t>(verifier, VT_TRUEDAMAGE) &&
           VerifyField<int64_t>(verifier, VT_REFLECTIONDAMAGE) &&
           VerifyField<uint8_t>(verifier, VT_DOUBLECRITICAL) &&
           VerifyField<uint8_t>(verifier, VT_TRIPLECRITICAL) &&
           VerifyField<uint8_t>(verifier, VT_PENTACRITICAL) &&
           verifier.EndTable();
  }
};

struct DamageResultBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_effectId(int32_t effectId) {
    fbb_.AddElement<int32_t>(DamageResult::VT_EFFECTID, effectId, 0);
  }
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(DamageResult::VT_OBJECTID, objectId, 0);
  }
  void add_damageType(int32_t damageType) {
    fbb_.AddElement<int32_t>(DamageResult::VT_DAMAGETYPE, damageType, 0);
  }
  void add_damage(int64_t damage) {
    fbb_.AddElement<int64_t>(DamageResult::VT_DAMAGE, damage, 0);
  }
  void add_shield(int64_t shield) {
    fbb_.AddElement<int64_t>(DamageResult::VT_SHIELD, shield, 0);
  }
  void add_trueDamage(int64_t trueDamage) {
    fbb_.AddElement<int64_t>(DamageResult::VT_TRUEDAMAGE, trueDamage, 0);
  }
  void add_reflectionDamage(int64_t reflectionDamage) {
    fbb_.AddElement<int64_t>(DamageResult::VT_REFLECTIONDAMAGE, reflectionDamage, 0);
  }
  void add_doubleCritical(bool doubleCritical) {
    fbb_.AddElement<uint8_t>(DamageResult::VT_DOUBLECRITICAL, static_cast<uint8_t>(doubleCritical), 0);
  }
  void add_tripleCritical(bool tripleCritical) {
    fbb_.AddElement<uint8_t>(DamageResult::VT_TRIPLECRITICAL, static_cast<uint8_t>(tripleCritical), 0);
  }
  void add_pentaCritical(bool pentaCritical) {
    fbb_.AddElement<uint8_t>(DamageResult::VT_PENTACRITICAL, static_cast<uint8_t>(pentaCritical), 0);
  }
  explicit DamageResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DamageResultBuilder &operator=(const DamageResultBuilder &);
  flatbuffers::Offset<DamageResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DamageResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<DamageResult> CreateDamageResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t effectId = 0,
    int64_t objectId = 0,
    int32_t damageType = 0,
    int64_t damage = 0,
    int64_t shield = 0,
    int64_t trueDamage = 0,
    int64_t reflectionDamage = 0,
    bool doubleCritical = false,
    bool tripleCritical = false,
    bool pentaCritical = false) {
  DamageResultBuilder builder_(_fbb);
  builder_.add_reflectionDamage(reflectionDamage);
  builder_.add_trueDamage(trueDamage);
  builder_.add_shield(shield);
  builder_.add_damage(damage);
  builder_.add_objectId(objectId);
  builder_.add_damageType(damageType);
  builder_.add_effectId(effectId);
  builder_.add_pentaCritical(pentaCritical);
  builder_.add_tripleCritical(tripleCritical);
  builder_.add_doubleCritical(doubleCritical);
  return builder_.Finish();
}

struct HealResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EFFECTID = 4,
    VT_OBJECTID = 6,
    VT_HEAL = 8,
    VT_CRITICAL = 10
  };
  int32_t effectId() const {
    return GetField<int32_t>(VT_EFFECTID, 0);
  }
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int32_t heal() const {
    return GetField<int32_t>(VT_HEAL, 0);
  }
  bool critical() const {
    return GetField<uint8_t>(VT_CRITICAL, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_EFFECTID) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int32_t>(verifier, VT_HEAL) &&
           VerifyField<uint8_t>(verifier, VT_CRITICAL) &&
           verifier.EndTable();
  }
};

struct HealResultBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_effectId(int32_t effectId) {
    fbb_.AddElement<int32_t>(HealResult::VT_EFFECTID, effectId, 0);
  }
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(HealResult::VT_OBJECTID, objectId, 0);
  }
  void add_heal(int32_t heal) {
    fbb_.AddElement<int32_t>(HealResult::VT_HEAL, heal, 0);
  }
  void add_critical(bool critical) {
    fbb_.AddElement<uint8_t>(HealResult::VT_CRITICAL, static_cast<uint8_t>(critical), 0);
  }
  explicit HealResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HealResultBuilder &operator=(const HealResultBuilder &);
  flatbuffers::Offset<HealResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HealResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<HealResult> CreateHealResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t effectId = 0,
    int64_t objectId = 0,
    int32_t heal = 0,
    bool critical = false) {
  HealResultBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_heal(heal);
  builder_.add_effectId(effectId);
  builder_.add_critical(critical);
  return builder_.Finish();
}

struct ReactionResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EFFECTID = 4,
    VT_OBJECTID = 6,
    VT_TYPE = 8,
    VT_X = 10,
    VT_Y = 12,
    VT_Z = 14,
    VT_ANGLE = 16,
    VT_DURATION = 18
  };
  int32_t effectId() const {
    return GetField<int32_t>(VT_EFFECTID, 0);
  }
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  ///pos : Pos;
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  float z() const {
    return GetField<float>(VT_Z, 0.0f);
  }
  int16_t angle() const {
    return GetField<int16_t>(VT_ANGLE, 0);
  }
  int32_t duration() const {
    return GetField<int32_t>(VT_DURATION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_EFFECTID) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<float>(verifier, VT_X) &&
           VerifyField<float>(verifier, VT_Y) &&
           VerifyField<float>(verifier, VT_Z) &&
           VerifyField<int16_t>(verifier, VT_ANGLE) &&
           VerifyField<int32_t>(verifier, VT_DURATION) &&
           verifier.EndTable();
  }
};

struct ReactionResultBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_effectId(int32_t effectId) {
    fbb_.AddElement<int32_t>(ReactionResult::VT_EFFECTID, effectId, 0);
  }
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(ReactionResult::VT_OBJECTID, objectId, 0);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(ReactionResult::VT_TYPE, type, 0);
  }
  void add_x(float x) {
    fbb_.AddElement<float>(ReactionResult::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(ReactionResult::VT_Y, y, 0.0f);
  }
  void add_z(float z) {
    fbb_.AddElement<float>(ReactionResult::VT_Z, z, 0.0f);
  }
  void add_angle(int16_t angle) {
    fbb_.AddElement<int16_t>(ReactionResult::VT_ANGLE, angle, 0);
  }
  void add_duration(int32_t duration) {
    fbb_.AddElement<int32_t>(ReactionResult::VT_DURATION, duration, 0);
  }
  explicit ReactionResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReactionResultBuilder &operator=(const ReactionResultBuilder &);
  flatbuffers::Offset<ReactionResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReactionResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReactionResult> CreateReactionResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t effectId = 0,
    int64_t objectId = 0,
    int32_t type = 0,
    float x = 0.0f,
    float y = 0.0f,
    float z = 0.0f,
    int16_t angle = 0,
    int32_t duration = 0) {
  ReactionResultBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_duration(duration);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_type(type);
  builder_.add_effectId(effectId);
  builder_.add_angle(angle);
  return builder_.Finish();
}

struct HpDrainResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EFFECTID = 4,
    VT_OBJECTID = 6,
    VT_DRAIN = 8
  };
  int32_t effectId() const {
    return GetField<int32_t>(VT_EFFECTID, 0);
  }
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int64_t drain() const {
    return GetField<int64_t>(VT_DRAIN, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_EFFECTID) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int64_t>(verifier, VT_DRAIN) &&
           verifier.EndTable();
  }
};

struct HpDrainResultBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_effectId(int32_t effectId) {
    fbb_.AddElement<int32_t>(HpDrainResult::VT_EFFECTID, effectId, 0);
  }
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(HpDrainResult::VT_OBJECTID, objectId, 0);
  }
  void add_drain(int64_t drain) {
    fbb_.AddElement<int64_t>(HpDrainResult::VT_DRAIN, drain, 0);
  }
  explicit HpDrainResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HpDrainResultBuilder &operator=(const HpDrainResultBuilder &);
  flatbuffers::Offset<HpDrainResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HpDrainResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<HpDrainResult> CreateHpDrainResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t effectId = 0,
    int64_t objectId = 0,
    int64_t drain = 0) {
  HpDrainResultBuilder builder_(_fbb);
  builder_.add_drain(drain);
  builder_.add_objectId(objectId);
  builder_.add_effectId(effectId);
  return builder_.Finish();
}

struct SkillEffectResultNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ATTACKERID = 4,
    VT_PARENTOBJECTID = 6,
    VT_SKILLID = 8,
    VT_TARGETINGIDX = 10,
    VT_DAMAGE = 12,
    VT_HEAL = 14,
    VT_REACTION = 16
  };
  int64_t attackerId() const {
    return GetField<int64_t>(VT_ATTACKERID, 0);
  }
  int64_t parentObjectId() const {
    return GetField<int64_t>(VT_PARENTOBJECTID, 0);
  }
  int32_t skillId() const {
    return GetField<int32_t>(VT_SKILLID, 0);
  }
  int32_t targetingIdx() const {
    return GetField<int32_t>(VT_TARGETINGIDX, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<DamageResult>> *damage() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DamageResult>> *>(VT_DAMAGE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<HealResult>> *heal() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<HealResult>> *>(VT_HEAL);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ReactionResult>> *reaction() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ReactionResult>> *>(VT_REACTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ATTACKERID) &&
           VerifyField<int64_t>(verifier, VT_PARENTOBJECTID) &&
           VerifyField<int32_t>(verifier, VT_SKILLID) &&
           VerifyField<int32_t>(verifier, VT_TARGETINGIDX) &&
           VerifyOffsetRequired(verifier, VT_DAMAGE) &&
           verifier.VerifyVector(damage()) &&
           verifier.VerifyVectorOfTables(damage()) &&
           VerifyOffsetRequired(verifier, VT_HEAL) &&
           verifier.VerifyVector(heal()) &&
           verifier.VerifyVectorOfTables(heal()) &&
           VerifyOffsetRequired(verifier, VT_REACTION) &&
           verifier.VerifyVector(reaction()) &&
           verifier.VerifyVectorOfTables(reaction()) &&
           verifier.EndTable();
  }
};

struct SkillEffectResultNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_attackerId(int64_t attackerId) {
    fbb_.AddElement<int64_t>(SkillEffectResultNotify::VT_ATTACKERID, attackerId, 0);
  }
  void add_parentObjectId(int64_t parentObjectId) {
    fbb_.AddElement<int64_t>(SkillEffectResultNotify::VT_PARENTOBJECTID, parentObjectId, 0);
  }
  void add_skillId(int32_t skillId) {
    fbb_.AddElement<int32_t>(SkillEffectResultNotify::VT_SKILLID, skillId, 0);
  }
  void add_targetingIdx(int32_t targetingIdx) {
    fbb_.AddElement<int32_t>(SkillEffectResultNotify::VT_TARGETINGIDX, targetingIdx, 0);
  }
  void add_damage(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DamageResult>>> damage) {
    fbb_.AddOffset(SkillEffectResultNotify::VT_DAMAGE, damage);
  }
  void add_heal(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HealResult>>> heal) {
    fbb_.AddOffset(SkillEffectResultNotify::VT_HEAL, heal);
  }
  void add_reaction(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ReactionResult>>> reaction) {
    fbb_.AddOffset(SkillEffectResultNotify::VT_REACTION, reaction);
  }
  explicit SkillEffectResultNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SkillEffectResultNotifyBuilder &operator=(const SkillEffectResultNotifyBuilder &);
  flatbuffers::Offset<SkillEffectResultNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkillEffectResultNotify>(end);
    fbb_.Required(o, SkillEffectResultNotify::VT_DAMAGE);
    fbb_.Required(o, SkillEffectResultNotify::VT_HEAL);
    fbb_.Required(o, SkillEffectResultNotify::VT_REACTION);
    return o;
  }
};

inline flatbuffers::Offset<SkillEffectResultNotify> CreateSkillEffectResultNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t attackerId = 0,
    int64_t parentObjectId = 0,
    int32_t skillId = 0,
    int32_t targetingIdx = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DamageResult>>> damage = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HealResult>>> heal = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ReactionResult>>> reaction = 0) {
  SkillEffectResultNotifyBuilder builder_(_fbb);
  builder_.add_parentObjectId(parentObjectId);
  builder_.add_attackerId(attackerId);
  builder_.add_reaction(reaction);
  builder_.add_heal(heal);
  builder_.add_damage(damage);
  builder_.add_targetingIdx(targetingIdx);
  builder_.add_skillId(skillId);
  return builder_.Finish();
}

inline flatbuffers::Offset<SkillEffectResultNotify> CreateSkillEffectResultNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t attackerId = 0,
    int64_t parentObjectId = 0,
    int32_t skillId = 0,
    int32_t targetingIdx = 0,
    const std::vector<flatbuffers::Offset<DamageResult>> *damage = nullptr,
    const std::vector<flatbuffers::Offset<HealResult>> *heal = nullptr,
    const std::vector<flatbuffers::Offset<ReactionResult>> *reaction = nullptr) {
  return LeanPacket::CreateSkillEffectResultNotify(
      _fbb,
      attackerId,
      parentObjectId,
      skillId,
      targetingIdx,
      damage ? _fbb.CreateVector<flatbuffers::Offset<DamageResult>>(*damage) : 0,
      heal ? _fbb.CreateVector<flatbuffers::Offset<HealResult>>(*heal) : 0,
      reaction ? _fbb.CreateVector<flatbuffers::Offset<ReactionResult>>(*reaction) : 0);
}

///- EFFECT_RESULT_DAMAGE_NOTIFY --------------
struct EffectResultDamageNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DEFENCERID = 4,
    VT_ATTACKERID = 6,
    VT_SKILLID = 8,
    VT_EFFECTID = 10,
    VT_TARGETINGINDEX = 12,
    VT_DAMAGETYPE = 14,
    VT_CRITICAL = 16,
    VT_ONSWIFTGUARD = 18,
    VT_FINALDAMAGE = 20,
    VT_MULTISTRIKEDAMAGE = 22,
    VT_SHIELD = 24
  };
  int64_t defencerId() const {
    return GetField<int64_t>(VT_DEFENCERID, 0);
  }
  int64_t attackerId() const {
    return GetField<int64_t>(VT_ATTACKERID, 0);
  }
  int32_t skillId() const {
    return GetField<int32_t>(VT_SKILLID, 0);
  }
  int32_t effectId() const {
    return GetField<int32_t>(VT_EFFECTID, 0);
  }
  int32_t targetingIndex() const {
    return GetField<int32_t>(VT_TARGETINGINDEX, 0);
  }
  int32_t damageType() const {
    return GetField<int32_t>(VT_DAMAGETYPE, 0);
  }
  bool critical() const {
    return GetField<uint8_t>(VT_CRITICAL, 0) != 0;
  }
  bool onSwiftGuard() const {
    return GetField<uint8_t>(VT_ONSWIFTGUARD, 0) != 0;
  }
  int32_t finalDamage() const {
    return GetField<int32_t>(VT_FINALDAMAGE, 0);
  }
  int32_t multistrikeDamage() const {
    return GetField<int32_t>(VT_MULTISTRIKEDAMAGE, 0);
  }
  int32_t shield() const {
    return GetField<int32_t>(VT_SHIELD, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_DEFENCERID) &&
           VerifyField<int64_t>(verifier, VT_ATTACKERID) &&
           VerifyField<int32_t>(verifier, VT_SKILLID) &&
           VerifyField<int32_t>(verifier, VT_EFFECTID) &&
           VerifyField<int32_t>(verifier, VT_TARGETINGINDEX) &&
           VerifyField<int32_t>(verifier, VT_DAMAGETYPE) &&
           VerifyField<uint8_t>(verifier, VT_CRITICAL) &&
           VerifyField<uint8_t>(verifier, VT_ONSWIFTGUARD) &&
           VerifyField<int32_t>(verifier, VT_FINALDAMAGE) &&
           VerifyField<int32_t>(verifier, VT_MULTISTRIKEDAMAGE) &&
           VerifyField<int32_t>(verifier, VT_SHIELD) &&
           verifier.EndTable();
  }
};

struct EffectResultDamageNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_defencerId(int64_t defencerId) {
    fbb_.AddElement<int64_t>(EffectResultDamageNotify::VT_DEFENCERID, defencerId, 0);
  }
  void add_attackerId(int64_t attackerId) {
    fbb_.AddElement<int64_t>(EffectResultDamageNotify::VT_ATTACKERID, attackerId, 0);
  }
  void add_skillId(int32_t skillId) {
    fbb_.AddElement<int32_t>(EffectResultDamageNotify::VT_SKILLID, skillId, 0);
  }
  void add_effectId(int32_t effectId) {
    fbb_.AddElement<int32_t>(EffectResultDamageNotify::VT_EFFECTID, effectId, 0);
  }
  void add_targetingIndex(int32_t targetingIndex) {
    fbb_.AddElement<int32_t>(EffectResultDamageNotify::VT_TARGETINGINDEX, targetingIndex, 0);
  }
  void add_damageType(int32_t damageType) {
    fbb_.AddElement<int32_t>(EffectResultDamageNotify::VT_DAMAGETYPE, damageType, 0);
  }
  void add_critical(bool critical) {
    fbb_.AddElement<uint8_t>(EffectResultDamageNotify::VT_CRITICAL, static_cast<uint8_t>(critical), 0);
  }
  void add_onSwiftGuard(bool onSwiftGuard) {
    fbb_.AddElement<uint8_t>(EffectResultDamageNotify::VT_ONSWIFTGUARD, static_cast<uint8_t>(onSwiftGuard), 0);
  }
  void add_finalDamage(int32_t finalDamage) {
    fbb_.AddElement<int32_t>(EffectResultDamageNotify::VT_FINALDAMAGE, finalDamage, 0);
  }
  void add_multistrikeDamage(int32_t multistrikeDamage) {
    fbb_.AddElement<int32_t>(EffectResultDamageNotify::VT_MULTISTRIKEDAMAGE, multistrikeDamage, 0);
  }
  void add_shield(int32_t shield) {
    fbb_.AddElement<int32_t>(EffectResultDamageNotify::VT_SHIELD, shield, 0);
  }
  explicit EffectResultDamageNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EffectResultDamageNotifyBuilder &operator=(const EffectResultDamageNotifyBuilder &);
  flatbuffers::Offset<EffectResultDamageNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EffectResultDamageNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<EffectResultDamageNotify> CreateEffectResultDamageNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t defencerId = 0,
    int64_t attackerId = 0,
    int32_t skillId = 0,
    int32_t effectId = 0,
    int32_t targetingIndex = 0,
    int32_t damageType = 0,
    bool critical = false,
    bool onSwiftGuard = false,
    int32_t finalDamage = 0,
    int32_t multistrikeDamage = 0,
    int32_t shield = 0) {
  EffectResultDamageNotifyBuilder builder_(_fbb);
  builder_.add_attackerId(attackerId);
  builder_.add_defencerId(defencerId);
  builder_.add_shield(shield);
  builder_.add_multistrikeDamage(multistrikeDamage);
  builder_.add_finalDamage(finalDamage);
  builder_.add_damageType(damageType);
  builder_.add_targetingIndex(targetingIndex);
  builder_.add_effectId(effectId);
  builder_.add_skillId(skillId);
  builder_.add_onSwiftGuard(onSwiftGuard);
  builder_.add_critical(critical);
  return builder_.Finish();
}

struct EffectResultReactionNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ATTACKERID = 4,
    VT_ATTACKEEID = 6,
    VT_SKILLID = 8,
    VT_EFFECTID = 10,
    VT_TARGETINGINDEX = 12,
    VT_REATIONTYPE = 14,
    VT_POS = 16,
    VT_ANGLE = 18,
    VT_DURATION = 20
  };
  int64_t attackerId() const {
    return GetField<int64_t>(VT_ATTACKERID, 0);
  }
  int64_t attackeeId() const {
    return GetField<int64_t>(VT_ATTACKEEID, 0);
  }
  int32_t skillId() const {
    return GetField<int32_t>(VT_SKILLID, 0);
  }
  int32_t effectId() const {
    return GetField<int32_t>(VT_EFFECTID, 0);
  }
  int32_t targetingIndex() const {
    return GetField<int32_t>(VT_TARGETINGINDEX, 0);
  }
  int32_t reationType() const {
    return GetField<int32_t>(VT_REATIONTYPE, 0);
  }
  const Pos *pos() const {
    return GetPointer<const Pos *>(VT_POS);
  }
  int16_t angle() const {
    return GetField<int16_t>(VT_ANGLE, 0);
  }
  int32_t duration() const {
    return GetField<int32_t>(VT_DURATION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ATTACKERID) &&
           VerifyField<int64_t>(verifier, VT_ATTACKEEID) &&
           VerifyField<int32_t>(verifier, VT_SKILLID) &&
           VerifyField<int32_t>(verifier, VT_EFFECTID) &&
           VerifyField<int32_t>(verifier, VT_TARGETINGINDEX) &&
           VerifyField<int32_t>(verifier, VT_REATIONTYPE) &&
           VerifyOffsetRequired(verifier, VT_POS) &&
           verifier.VerifyTable(pos()) &&
           VerifyField<int16_t>(verifier, VT_ANGLE) &&
           VerifyField<int32_t>(verifier, VT_DURATION) &&
           verifier.EndTable();
  }
};

struct EffectResultReactionNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_attackerId(int64_t attackerId) {
    fbb_.AddElement<int64_t>(EffectResultReactionNotify::VT_ATTACKERID, attackerId, 0);
  }
  void add_attackeeId(int64_t attackeeId) {
    fbb_.AddElement<int64_t>(EffectResultReactionNotify::VT_ATTACKEEID, attackeeId, 0);
  }
  void add_skillId(int32_t skillId) {
    fbb_.AddElement<int32_t>(EffectResultReactionNotify::VT_SKILLID, skillId, 0);
  }
  void add_effectId(int32_t effectId) {
    fbb_.AddElement<int32_t>(EffectResultReactionNotify::VT_EFFECTID, effectId, 0);
  }
  void add_targetingIndex(int32_t targetingIndex) {
    fbb_.AddElement<int32_t>(EffectResultReactionNotify::VT_TARGETINGINDEX, targetingIndex, 0);
  }
  void add_reationType(int32_t reationType) {
    fbb_.AddElement<int32_t>(EffectResultReactionNotify::VT_REATIONTYPE, reationType, 0);
  }
  void add_pos(flatbuffers::Offset<Pos> pos) {
    fbb_.AddOffset(EffectResultReactionNotify::VT_POS, pos);
  }
  void add_angle(int16_t angle) {
    fbb_.AddElement<int16_t>(EffectResultReactionNotify::VT_ANGLE, angle, 0);
  }
  void add_duration(int32_t duration) {
    fbb_.AddElement<int32_t>(EffectResultReactionNotify::VT_DURATION, duration, 0);
  }
  explicit EffectResultReactionNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EffectResultReactionNotifyBuilder &operator=(const EffectResultReactionNotifyBuilder &);
  flatbuffers::Offset<EffectResultReactionNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EffectResultReactionNotify>(end);
    fbb_.Required(o, EffectResultReactionNotify::VT_POS);
    return o;
  }
};

inline flatbuffers::Offset<EffectResultReactionNotify> CreateEffectResultReactionNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t attackerId = 0,
    int64_t attackeeId = 0,
    int32_t skillId = 0,
    int32_t effectId = 0,
    int32_t targetingIndex = 0,
    int32_t reationType = 0,
    flatbuffers::Offset<Pos> pos = 0,
    int16_t angle = 0,
    int32_t duration = 0) {
  EffectResultReactionNotifyBuilder builder_(_fbb);
  builder_.add_attackeeId(attackeeId);
  builder_.add_attackerId(attackerId);
  builder_.add_duration(duration);
  builder_.add_pos(pos);
  builder_.add_reationType(reationType);
  builder_.add_targetingIndex(targetingIndex);
  builder_.add_effectId(effectId);
  builder_.add_skillId(skillId);
  builder_.add_angle(angle);
  return builder_.Finish();
}

///- EFFECT_RESULT_HEAL_NOTIFY -----------------
struct EffectResultHealNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TARGETID = 4,
    VT_CASTERID = 6,
    VT_SKILLID = 8,
    VT_EFFECTID = 10,
    VT_HEALVALUE = 12
  };
  int64_t targetId() const {
    return GetField<int64_t>(VT_TARGETID, 0);
  }
  int64_t casterId() const {
    return GetField<int64_t>(VT_CASTERID, 0);
  }
  int32_t skillId() const {
    return GetField<int32_t>(VT_SKILLID, 0);
  }
  int32_t effectId() const {
    return GetField<int32_t>(VT_EFFECTID, 0);
  }
  int32_t healValue() const {
    return GetField<int32_t>(VT_HEALVALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TARGETID) &&
           VerifyField<int64_t>(verifier, VT_CASTERID) &&
           VerifyField<int32_t>(verifier, VT_SKILLID) &&
           VerifyField<int32_t>(verifier, VT_EFFECTID) &&
           VerifyField<int32_t>(verifier, VT_HEALVALUE) &&
           verifier.EndTable();
  }
};

struct EffectResultHealNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_targetId(int64_t targetId) {
    fbb_.AddElement<int64_t>(EffectResultHealNotify::VT_TARGETID, targetId, 0);
  }
  void add_casterId(int64_t casterId) {
    fbb_.AddElement<int64_t>(EffectResultHealNotify::VT_CASTERID, casterId, 0);
  }
  void add_skillId(int32_t skillId) {
    fbb_.AddElement<int32_t>(EffectResultHealNotify::VT_SKILLID, skillId, 0);
  }
  void add_effectId(int32_t effectId) {
    fbb_.AddElement<int32_t>(EffectResultHealNotify::VT_EFFECTID, effectId, 0);
  }
  void add_healValue(int32_t healValue) {
    fbb_.AddElement<int32_t>(EffectResultHealNotify::VT_HEALVALUE, healValue, 0);
  }
  explicit EffectResultHealNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EffectResultHealNotifyBuilder &operator=(const EffectResultHealNotifyBuilder &);
  flatbuffers::Offset<EffectResultHealNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EffectResultHealNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<EffectResultHealNotify> CreateEffectResultHealNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t targetId = 0,
    int64_t casterId = 0,
    int32_t skillId = 0,
    int32_t effectId = 0,
    int32_t healValue = 0) {
  EffectResultHealNotifyBuilder builder_(_fbb);
  builder_.add_casterId(casterId);
  builder_.add_targetId(targetId);
  builder_.add_healValue(healValue);
  builder_.add_effectId(effectId);
  builder_.add_skillId(skillId);
  return builder_.Finish();
}

///- ADD_BUFF_NOTIFY --------------
struct AddBuffNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_BUFFOBJECTID = 6,
    VT_CASTERID = 8,
    VT_BUFFID = 10,
    VT_LEVEL = 12,
    VT_REMAINTICK = 14,
    VT_STACKCOUNT = 16,
    VT_INFINITY = 18
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int64_t buffObjectId() const {
    return GetField<int64_t>(VT_BUFFOBJECTID, 0);
  }
  int64_t casterId() const {
    return GetField<int64_t>(VT_CASTERID, 0);
  }
  int32_t buffId() const {
    return GetField<int32_t>(VT_BUFFID, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int64_t remainTick() const {
    return GetField<int64_t>(VT_REMAINTICK, 0);
  }
  int32_t stackCount() const {
    return GetField<int32_t>(VT_STACKCOUNT, 0);
  }
  bool infinity() const {
    return GetField<uint8_t>(VT_INFINITY, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int64_t>(verifier, VT_BUFFOBJECTID) &&
           VerifyField<int64_t>(verifier, VT_CASTERID) &&
           VerifyField<int32_t>(verifier, VT_BUFFID) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int64_t>(verifier, VT_REMAINTICK) &&
           VerifyField<int32_t>(verifier, VT_STACKCOUNT) &&
           VerifyField<uint8_t>(verifier, VT_INFINITY) &&
           verifier.EndTable();
  }
};

struct AddBuffNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(AddBuffNotify::VT_OBJECTID, objectId, 0);
  }
  void add_buffObjectId(int64_t buffObjectId) {
    fbb_.AddElement<int64_t>(AddBuffNotify::VT_BUFFOBJECTID, buffObjectId, 0);
  }
  void add_casterId(int64_t casterId) {
    fbb_.AddElement<int64_t>(AddBuffNotify::VT_CASTERID, casterId, 0);
  }
  void add_buffId(int32_t buffId) {
    fbb_.AddElement<int32_t>(AddBuffNotify::VT_BUFFID, buffId, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(AddBuffNotify::VT_LEVEL, level, 0);
  }
  void add_remainTick(int64_t remainTick) {
    fbb_.AddElement<int64_t>(AddBuffNotify::VT_REMAINTICK, remainTick, 0);
  }
  void add_stackCount(int32_t stackCount) {
    fbb_.AddElement<int32_t>(AddBuffNotify::VT_STACKCOUNT, stackCount, 0);
  }
  void add_infinity(bool infinity) {
    fbb_.AddElement<uint8_t>(AddBuffNotify::VT_INFINITY, static_cast<uint8_t>(infinity), 0);
  }
  explicit AddBuffNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddBuffNotifyBuilder &operator=(const AddBuffNotifyBuilder &);
  flatbuffers::Offset<AddBuffNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddBuffNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddBuffNotify> CreateAddBuffNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int64_t buffObjectId = 0,
    int64_t casterId = 0,
    int32_t buffId = 0,
    int32_t level = 0,
    int64_t remainTick = 0,
    int32_t stackCount = 0,
    bool infinity = false) {
  AddBuffNotifyBuilder builder_(_fbb);
  builder_.add_remainTick(remainTick);
  builder_.add_casterId(casterId);
  builder_.add_buffObjectId(buffObjectId);
  builder_.add_objectId(objectId);
  builder_.add_stackCount(stackCount);
  builder_.add_level(level);
  builder_.add_buffId(buffId);
  builder_.add_infinity(infinity);
  return builder_.Finish();
}

///- UPDATE_BUFF_NOTIFY --------------
struct UpdateBuffNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_BUFFOBJECTID = 6,
    VT_CASTERID = 8,
    VT_BUFFID = 10,
    VT_LEVEL = 12,
    VT_REMAINTICK = 14,
    VT_STACKCOUNT = 16,
    VT_INFINITY = 18
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int64_t buffObjectId() const {
    return GetField<int64_t>(VT_BUFFOBJECTID, 0);
  }
  int64_t casterId() const {
    return GetField<int64_t>(VT_CASTERID, 0);
  }
  int32_t buffId() const {
    return GetField<int32_t>(VT_BUFFID, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int64_t remainTick() const {
    return GetField<int64_t>(VT_REMAINTICK, 0);
  }
  int32_t stackCount() const {
    return GetField<int32_t>(VT_STACKCOUNT, 0);
  }
  bool infinity() const {
    return GetField<uint8_t>(VT_INFINITY, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int64_t>(verifier, VT_BUFFOBJECTID) &&
           VerifyField<int64_t>(verifier, VT_CASTERID) &&
           VerifyField<int32_t>(verifier, VT_BUFFID) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int64_t>(verifier, VT_REMAINTICK) &&
           VerifyField<int32_t>(verifier, VT_STACKCOUNT) &&
           VerifyField<uint8_t>(verifier, VT_INFINITY) &&
           verifier.EndTable();
  }
};

struct UpdateBuffNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(UpdateBuffNotify::VT_OBJECTID, objectId, 0);
  }
  void add_buffObjectId(int64_t buffObjectId) {
    fbb_.AddElement<int64_t>(UpdateBuffNotify::VT_BUFFOBJECTID, buffObjectId, 0);
  }
  void add_casterId(int64_t casterId) {
    fbb_.AddElement<int64_t>(UpdateBuffNotify::VT_CASTERID, casterId, 0);
  }
  void add_buffId(int32_t buffId) {
    fbb_.AddElement<int32_t>(UpdateBuffNotify::VT_BUFFID, buffId, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(UpdateBuffNotify::VT_LEVEL, level, 0);
  }
  void add_remainTick(int64_t remainTick) {
    fbb_.AddElement<int64_t>(UpdateBuffNotify::VT_REMAINTICK, remainTick, 0);
  }
  void add_stackCount(int32_t stackCount) {
    fbb_.AddElement<int32_t>(UpdateBuffNotify::VT_STACKCOUNT, stackCount, 0);
  }
  void add_infinity(bool infinity) {
    fbb_.AddElement<uint8_t>(UpdateBuffNotify::VT_INFINITY, static_cast<uint8_t>(infinity), 0);
  }
  explicit UpdateBuffNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UpdateBuffNotifyBuilder &operator=(const UpdateBuffNotifyBuilder &);
  flatbuffers::Offset<UpdateBuffNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UpdateBuffNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<UpdateBuffNotify> CreateUpdateBuffNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int64_t buffObjectId = 0,
    int64_t casterId = 0,
    int32_t buffId = 0,
    int32_t level = 0,
    int64_t remainTick = 0,
    int32_t stackCount = 0,
    bool infinity = false) {
  UpdateBuffNotifyBuilder builder_(_fbb);
  builder_.add_remainTick(remainTick);
  builder_.add_casterId(casterId);
  builder_.add_buffObjectId(buffObjectId);
  builder_.add_objectId(objectId);
  builder_.add_stackCount(stackCount);
  builder_.add_level(level);
  builder_.add_buffId(buffId);
  builder_.add_infinity(infinity);
  return builder_.Finish();
}

/// CREATURE_HP_CHANGE_NOTIFY
struct CreatureHpChangeNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_CURRENTHP = 6,
    VT_MAXHP = 8
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int64_t currentHp() const {
    return GetField<int64_t>(VT_CURRENTHP, 0);
  }
  int64_t maxHp() const {
    return GetField<int64_t>(VT_MAXHP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int64_t>(verifier, VT_CURRENTHP) &&
           VerifyField<int64_t>(verifier, VT_MAXHP) &&
           verifier.EndTable();
  }
};

struct CreatureHpChangeNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(CreatureHpChangeNotify::VT_OBJECTID, objectId, 0);
  }
  void add_currentHp(int64_t currentHp) {
    fbb_.AddElement<int64_t>(CreatureHpChangeNotify::VT_CURRENTHP, currentHp, 0);
  }
  void add_maxHp(int64_t maxHp) {
    fbb_.AddElement<int64_t>(CreatureHpChangeNotify::VT_MAXHP, maxHp, 0);
  }
  explicit CreatureHpChangeNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CreatureHpChangeNotifyBuilder &operator=(const CreatureHpChangeNotifyBuilder &);
  flatbuffers::Offset<CreatureHpChangeNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CreatureHpChangeNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<CreatureHpChangeNotify> CreateCreatureHpChangeNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int64_t currentHp = 0,
    int64_t maxHp = 0) {
  CreatureHpChangeNotifyBuilder builder_(_fbb);
  builder_.add_maxHp(maxHp);
  builder_.add_currentHp(currentHp);
  builder_.add_objectId(objectId);
  return builder_.Finish();
}

/// NPC_AGGRO_TIMER_NOTIFY
struct NpcAggroTimerNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_CURRENTTICK = 6,
    VT_INTERVALTICK = 8
  };
  /// 해당 Npc
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  /// 경과된 현재 틱(예 - 1500(1.5초 경과))
  int32_t currentTick() const {
    return GetField<int32_t>(VT_CURRENTTICK, 0);
  }
  /// 어그로 초기화 주기 틱(예 - 5000(5초))
  int32_t intervalTick() const {
    return GetField<int32_t>(VT_INTERVALTICK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int32_t>(verifier, VT_CURRENTTICK) &&
           VerifyField<int32_t>(verifier, VT_INTERVALTICK) &&
           verifier.EndTable();
  }
};

struct NpcAggroTimerNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(NpcAggroTimerNotify::VT_OBJECTID, objectId, 0);
  }
  void add_currentTick(int32_t currentTick) {
    fbb_.AddElement<int32_t>(NpcAggroTimerNotify::VT_CURRENTTICK, currentTick, 0);
  }
  void add_intervalTick(int32_t intervalTick) {
    fbb_.AddElement<int32_t>(NpcAggroTimerNotify::VT_INTERVALTICK, intervalTick, 0);
  }
  explicit NpcAggroTimerNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NpcAggroTimerNotifyBuilder &operator=(const NpcAggroTimerNotifyBuilder &);
  flatbuffers::Offset<NpcAggroTimerNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NpcAggroTimerNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<NpcAggroTimerNotify> CreateNpcAggroTimerNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int32_t currentTick = 0,
    int32_t intervalTick = 0) {
  NpcAggroTimerNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_intervalTick(intervalTick);
  builder_.add_currentTick(currentTick);
  return builder_.Finish();
}

/// CREATURE_TARGETED_NOTIFY
struct CreatureTargetedNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_TARGETID = 6
  };
  /// 타겟을 잡은 오브젝트의 아이디
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  /// 타겟된 오브젝트의 아이디
  int64_t targetId() const {
    return GetField<int64_t>(VT_TARGETID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int64_t>(verifier, VT_TARGETID) &&
           verifier.EndTable();
  }
};

struct CreatureTargetedNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(CreatureTargetedNotify::VT_OBJECTID, objectId, 0);
  }
  void add_targetId(int64_t targetId) {
    fbb_.AddElement<int64_t>(CreatureTargetedNotify::VT_TARGETID, targetId, 0);
  }
  explicit CreatureTargetedNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CreatureTargetedNotifyBuilder &operator=(const CreatureTargetedNotifyBuilder &);
  flatbuffers::Offset<CreatureTargetedNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CreatureTargetedNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<CreatureTargetedNotify> CreateCreatureTargetedNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int64_t targetId = 0) {
  CreatureTargetedNotifyBuilder builder_(_fbb);
  builder_.add_targetId(targetId);
  builder_.add_objectId(objectId);
  return builder_.Finish();
}

/// NPC_RETURN_WARNING_NOTIFY
struct NpcReturnWarningNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_ON = 6
  };
  /// 해당 Npc 오브젝트 아이디
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  /// 회기 알림 on/off 플래그
  bool on() const {
    return GetField<uint8_t>(VT_ON, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<uint8_t>(verifier, VT_ON) &&
           verifier.EndTable();
  }
};

struct NpcReturnWarningNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(NpcReturnWarningNotify::VT_OBJECTID, objectId, 0);
  }
  void add_on(bool on) {
    fbb_.AddElement<uint8_t>(NpcReturnWarningNotify::VT_ON, static_cast<uint8_t>(on), 0);
  }
  explicit NpcReturnWarningNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NpcReturnWarningNotifyBuilder &operator=(const NpcReturnWarningNotifyBuilder &);
  flatbuffers::Offset<NpcReturnWarningNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NpcReturnWarningNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<NpcReturnWarningNotify> CreateNpcReturnWarningNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    bool on = false) {
  NpcReturnWarningNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_on(on);
  return builder_.Finish();
}

/// [ITEM]
///- INSERT_ITEM_REQUEST --------------
/// 프로토콜 아이템 주입은 없다.
/// 컨텐츠, 운영툴을 통한 주입만 가능하다.
///table InsertItemRequest
///{
///	/// PC
///	pcObjectId : ulong;
///	toStorageType : short;
///	itemIds : [int];
///}
///- INSERT_ITEM_RESPONSE --------------
struct InsertItemResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_TOSTORAGETYPE = 6,
    VT_CLIENTLITEMS = 8
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  int16_t toStorageType() const {
    return GetField<int16_t>(VT_TOSTORAGETYPE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ClientLItem>> *clientLItems() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ClientLItem>> *>(VT_CLIENTLITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int16_t>(verifier, VT_TOSTORAGETYPE) &&
           VerifyOffset(verifier, VT_CLIENTLITEMS) &&
           verifier.VerifyVector(clientLItems()) &&
           verifier.VerifyVectorOfTables(clientLItems()) &&
           verifier.EndTable();
  }
};

struct InsertItemResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(InsertItemResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_toStorageType(int16_t toStorageType) {
    fbb_.AddElement<int16_t>(InsertItemResponse::VT_TOSTORAGETYPE, toStorageType, 0);
  }
  void add_clientLItems(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ClientLItem>>> clientLItems) {
    fbb_.AddOffset(InsertItemResponse::VT_CLIENTLITEMS, clientLItems);
  }
  explicit InsertItemResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InsertItemResponseBuilder &operator=(const InsertItemResponseBuilder &);
  flatbuffers::Offset<InsertItemResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InsertItemResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<InsertItemResponse> CreateInsertItemResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    int16_t toStorageType = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ClientLItem>>> clientLItems = 0) {
  InsertItemResponseBuilder builder_(_fbb);
  builder_.add_clientLItems(clientLItems);
  builder_.add_errorCode(errorCode);
  builder_.add_toStorageType(toStorageType);
  return builder_.Finish();
}

inline flatbuffers::Offset<InsertItemResponse> CreateInsertItemResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    int16_t toStorageType = 0,
    const std::vector<flatbuffers::Offset<ClientLItem>> *clientLItems = nullptr) {
  return LeanPacket::CreateInsertItemResponse(
      _fbb,
      errorCode,
      toStorageType,
      clientLItems ? _fbb.CreateVector<flatbuffers::Offset<ClientLItem>>(*clientLItems) : 0);
}

///- DELETE_ITEM_REQUEST --------------
struct DeleteItemRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCOBJECTID = 4,
    VT_FROMSTORAGETYPE = 6,
    VT_DELETEITEMOBJECTID = 8
  };
  uint64_t pcObjectId() const {
    return GetField<uint64_t>(VT_PCOBJECTID, 0);
  }
  int16_t fromStorageType() const {
    return GetField<int16_t>(VT_FROMSTORAGETYPE, 0);
  }
  const flatbuffers::Vector<uint64_t> *deleteItemObjectId() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_DELETEITEMOBJECTID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PCOBJECTID) &&
           VerifyField<int16_t>(verifier, VT_FROMSTORAGETYPE) &&
           VerifyOffsetRequired(verifier, VT_DELETEITEMOBJECTID) &&
           verifier.VerifyVector(deleteItemObjectId()) &&
           verifier.EndTable();
  }
};

struct DeleteItemRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcObjectId(uint64_t pcObjectId) {
    fbb_.AddElement<uint64_t>(DeleteItemRequest::VT_PCOBJECTID, pcObjectId, 0);
  }
  void add_fromStorageType(int16_t fromStorageType) {
    fbb_.AddElement<int16_t>(DeleteItemRequest::VT_FROMSTORAGETYPE, fromStorageType, 0);
  }
  void add_deleteItemObjectId(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> deleteItemObjectId) {
    fbb_.AddOffset(DeleteItemRequest::VT_DELETEITEMOBJECTID, deleteItemObjectId);
  }
  explicit DeleteItemRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeleteItemRequestBuilder &operator=(const DeleteItemRequestBuilder &);
  flatbuffers::Offset<DeleteItemRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeleteItemRequest>(end);
    fbb_.Required(o, DeleteItemRequest::VT_DELETEITEMOBJECTID);
    return o;
  }
};

inline flatbuffers::Offset<DeleteItemRequest> CreateDeleteItemRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t pcObjectId = 0,
    int16_t fromStorageType = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> deleteItemObjectId = 0) {
  DeleteItemRequestBuilder builder_(_fbb);
  builder_.add_pcObjectId(pcObjectId);
  builder_.add_deleteItemObjectId(deleteItemObjectId);
  builder_.add_fromStorageType(fromStorageType);
  return builder_.Finish();
}

inline flatbuffers::Offset<DeleteItemRequest> CreateDeleteItemRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t pcObjectId = 0,
    int16_t fromStorageType = 0,
    const std::vector<uint64_t> *deleteItemObjectId = nullptr) {
  return LeanPacket::CreateDeleteItemRequest(
      _fbb,
      pcObjectId,
      fromStorageType,
      deleteItemObjectId ? _fbb.CreateVector<uint64_t>(*deleteItemObjectId) : 0);
}

///- DELETE_ITEM_RESPONSE --------------
struct DeleteItemResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_FROMSTORAGETYPE = 6,
    VT_DELETEITEMOBJECTID = 8
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  int16_t fromStorageType() const {
    return GetField<int16_t>(VT_FROMSTORAGETYPE, 0);
  }
  const flatbuffers::Vector<uint64_t> *deleteItemObjectId() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_DELETEITEMOBJECTID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int16_t>(verifier, VT_FROMSTORAGETYPE) &&
           VerifyOffset(verifier, VT_DELETEITEMOBJECTID) &&
           verifier.VerifyVector(deleteItemObjectId()) &&
           verifier.EndTable();
  }
};

struct DeleteItemResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(DeleteItemResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_fromStorageType(int16_t fromStorageType) {
    fbb_.AddElement<int16_t>(DeleteItemResponse::VT_FROMSTORAGETYPE, fromStorageType, 0);
  }
  void add_deleteItemObjectId(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> deleteItemObjectId) {
    fbb_.AddOffset(DeleteItemResponse::VT_DELETEITEMOBJECTID, deleteItemObjectId);
  }
  explicit DeleteItemResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeleteItemResponseBuilder &operator=(const DeleteItemResponseBuilder &);
  flatbuffers::Offset<DeleteItemResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeleteItemResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeleteItemResponse> CreateDeleteItemResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    int16_t fromStorageType = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> deleteItemObjectId = 0) {
  DeleteItemResponseBuilder builder_(_fbb);
  builder_.add_deleteItemObjectId(deleteItemObjectId);
  builder_.add_errorCode(errorCode);
  builder_.add_fromStorageType(fromStorageType);
  return builder_.Finish();
}

inline flatbuffers::Offset<DeleteItemResponse> CreateDeleteItemResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    int16_t fromStorageType = 0,
    const std::vector<uint64_t> *deleteItemObjectId = nullptr) {
  return LeanPacket::CreateDeleteItemResponse(
      _fbb,
      errorCode,
      fromStorageType,
      deleteItemObjectId ? _fbb.CreateVector<uint64_t>(*deleteItemObjectId) : 0);
}

///- EQUIP_ITEM_RECOMMENDATION_REQUEST --------------
struct EquipItemRecommendationRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCOBJECTID = 4,
    VT_EQUIPSLOT = 6,
    VT_FROMSTORAGETYPE = 8,
    VT_TOSTORAGETYPE = 10
  };
  uint64_t pcObjectId() const {
    return GetField<uint64_t>(VT_PCOBJECTID, 0);
  }
  int8_t equipSlot() const {
    return GetField<int8_t>(VT_EQUIPSLOT, 0);
  }
  int16_t fromStorageType() const {
    return GetField<int16_t>(VT_FROMSTORAGETYPE, 0);
  }
  int16_t toStorageType() const {
    return GetField<int16_t>(VT_TOSTORAGETYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PCOBJECTID) &&
           VerifyField<int8_t>(verifier, VT_EQUIPSLOT) &&
           VerifyField<int16_t>(verifier, VT_FROMSTORAGETYPE) &&
           VerifyField<int16_t>(verifier, VT_TOSTORAGETYPE) &&
           verifier.EndTable();
  }
};

struct EquipItemRecommendationRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcObjectId(uint64_t pcObjectId) {
    fbb_.AddElement<uint64_t>(EquipItemRecommendationRequest::VT_PCOBJECTID, pcObjectId, 0);
  }
  void add_equipSlot(int8_t equipSlot) {
    fbb_.AddElement<int8_t>(EquipItemRecommendationRequest::VT_EQUIPSLOT, equipSlot, 0);
  }
  void add_fromStorageType(int16_t fromStorageType) {
    fbb_.AddElement<int16_t>(EquipItemRecommendationRequest::VT_FROMSTORAGETYPE, fromStorageType, 0);
  }
  void add_toStorageType(int16_t toStorageType) {
    fbb_.AddElement<int16_t>(EquipItemRecommendationRequest::VT_TOSTORAGETYPE, toStorageType, 0);
  }
  explicit EquipItemRecommendationRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EquipItemRecommendationRequestBuilder &operator=(const EquipItemRecommendationRequestBuilder &);
  flatbuffers::Offset<EquipItemRecommendationRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EquipItemRecommendationRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<EquipItemRecommendationRequest> CreateEquipItemRecommendationRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t pcObjectId = 0,
    int8_t equipSlot = 0,
    int16_t fromStorageType = 0,
    int16_t toStorageType = 0) {
  EquipItemRecommendationRequestBuilder builder_(_fbb);
  builder_.add_pcObjectId(pcObjectId);
  builder_.add_toStorageType(toStorageType);
  builder_.add_fromStorageType(fromStorageType);
  builder_.add_equipSlot(equipSlot);
  return builder_.Finish();
}

///- EQUIP_ITEM_OBJECT_REQUEST --------------
struct EquipItemObjectRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCOBJECTID = 4,
    VT_ITEMOBJECTID = 6
  };
  uint64_t pcObjectId() const {
    return GetField<uint64_t>(VT_PCOBJECTID, 0);
  }
  uint64_t itemObjectId() const {
    return GetField<uint64_t>(VT_ITEMOBJECTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PCOBJECTID) &&
           VerifyField<uint64_t>(verifier, VT_ITEMOBJECTID) &&
           verifier.EndTable();
  }
};

struct EquipItemObjectRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcObjectId(uint64_t pcObjectId) {
    fbb_.AddElement<uint64_t>(EquipItemObjectRequest::VT_PCOBJECTID, pcObjectId, 0);
  }
  void add_itemObjectId(uint64_t itemObjectId) {
    fbb_.AddElement<uint64_t>(EquipItemObjectRequest::VT_ITEMOBJECTID, itemObjectId, 0);
  }
  explicit EquipItemObjectRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EquipItemObjectRequestBuilder &operator=(const EquipItemObjectRequestBuilder &);
  flatbuffers::Offset<EquipItemObjectRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EquipItemObjectRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<EquipItemObjectRequest> CreateEquipItemObjectRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t pcObjectId = 0,
    uint64_t itemObjectId = 0) {
  EquipItemObjectRequestBuilder builder_(_fbb);
  builder_.add_itemObjectId(itemObjectId);
  builder_.add_pcObjectId(pcObjectId);
  return builder_.Finish();
}

///- EQUIP_ITEM_RESPONSE --------------
struct EquipItemResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_ITEMOBJECTID = 6,
    VT_EQUIPSLOT = 8,
    VT_PCOBJECTID = 10,
    VT_EQUIPITEMPARTS = 12
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  uint64_t itemObjectId() const {
    return GetField<uint64_t>(VT_ITEMOBJECTID, 0);
  }
  int16_t equipSlot() const {
    return GetField<int16_t>(VT_EQUIPSLOT, 0);
  }
  uint64_t pcObjectId() const {
    return GetField<uint64_t>(VT_PCOBJECTID, 0);
  }
  const ItemPartsInfo *equipItemParts() const {
    return GetPointer<const ItemPartsInfo *>(VT_EQUIPITEMPARTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<uint64_t>(verifier, VT_ITEMOBJECTID) &&
           VerifyField<int16_t>(verifier, VT_EQUIPSLOT) &&
           VerifyField<uint64_t>(verifier, VT_PCOBJECTID) &&
           VerifyOffset(verifier, VT_EQUIPITEMPARTS) &&
           verifier.VerifyTable(equipItemParts()) &&
           verifier.EndTable();
  }
};

struct EquipItemResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(EquipItemResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_itemObjectId(uint64_t itemObjectId) {
    fbb_.AddElement<uint64_t>(EquipItemResponse::VT_ITEMOBJECTID, itemObjectId, 0);
  }
  void add_equipSlot(int16_t equipSlot) {
    fbb_.AddElement<int16_t>(EquipItemResponse::VT_EQUIPSLOT, equipSlot, 0);
  }
  void add_pcObjectId(uint64_t pcObjectId) {
    fbb_.AddElement<uint64_t>(EquipItemResponse::VT_PCOBJECTID, pcObjectId, 0);
  }
  void add_equipItemParts(flatbuffers::Offset<ItemPartsInfo> equipItemParts) {
    fbb_.AddOffset(EquipItemResponse::VT_EQUIPITEMPARTS, equipItemParts);
  }
  explicit EquipItemResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EquipItemResponseBuilder &operator=(const EquipItemResponseBuilder &);
  flatbuffers::Offset<EquipItemResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EquipItemResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<EquipItemResponse> CreateEquipItemResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    uint64_t itemObjectId = 0,
    int16_t equipSlot = 0,
    uint64_t pcObjectId = 0,
    flatbuffers::Offset<ItemPartsInfo> equipItemParts = 0) {
  EquipItemResponseBuilder builder_(_fbb);
  builder_.add_pcObjectId(pcObjectId);
  builder_.add_itemObjectId(itemObjectId);
  builder_.add_equipItemParts(equipItemParts);
  builder_.add_errorCode(errorCode);
  builder_.add_equipSlot(equipSlot);
  return builder_.Finish();
}

///- UNEQUIP_ITEM_REQUEST --------------
struct UnequipItemRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCOBJECTID = 4,
    VT_UNEQUIPSLOT = 6
  };
  uint64_t pcObjectId() const {
    return GetField<uint64_t>(VT_PCOBJECTID, 0);
  }
  int8_t unequipSlot() const {
    return GetField<int8_t>(VT_UNEQUIPSLOT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PCOBJECTID) &&
           VerifyField<int8_t>(verifier, VT_UNEQUIPSLOT) &&
           verifier.EndTable();
  }
};

struct UnequipItemRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcObjectId(uint64_t pcObjectId) {
    fbb_.AddElement<uint64_t>(UnequipItemRequest::VT_PCOBJECTID, pcObjectId, 0);
  }
  void add_unequipSlot(int8_t unequipSlot) {
    fbb_.AddElement<int8_t>(UnequipItemRequest::VT_UNEQUIPSLOT, unequipSlot, 0);
  }
  explicit UnequipItemRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnequipItemRequestBuilder &operator=(const UnequipItemRequestBuilder &);
  flatbuffers::Offset<UnequipItemRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnequipItemRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnequipItemRequest> CreateUnequipItemRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t pcObjectId = 0,
    int8_t unequipSlot = 0) {
  UnequipItemRequestBuilder builder_(_fbb);
  builder_.add_pcObjectId(pcObjectId);
  builder_.add_unequipSlot(unequipSlot);
  return builder_.Finish();
}

///- UNEQUIP_ITEM_RESPONSE --------------
struct UnequipItemResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_UNEQUIPSLOT = 6,
    VT_PCOBJECTID = 8
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  int16_t unequipSlot() const {
    return GetField<int16_t>(VT_UNEQUIPSLOT, 0);
  }
  uint64_t pcObjectId() const {
    return GetField<uint64_t>(VT_PCOBJECTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int16_t>(verifier, VT_UNEQUIPSLOT) &&
           VerifyField<uint64_t>(verifier, VT_PCOBJECTID) &&
           verifier.EndTable();
  }
};

struct UnequipItemResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(UnequipItemResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_unequipSlot(int16_t unequipSlot) {
    fbb_.AddElement<int16_t>(UnequipItemResponse::VT_UNEQUIPSLOT, unequipSlot, 0);
  }
  void add_pcObjectId(uint64_t pcObjectId) {
    fbb_.AddElement<uint64_t>(UnequipItemResponse::VT_PCOBJECTID, pcObjectId, 0);
  }
  explicit UnequipItemResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnequipItemResponseBuilder &operator=(const UnequipItemResponseBuilder &);
  flatbuffers::Offset<UnequipItemResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnequipItemResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnequipItemResponse> CreateUnequipItemResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    int16_t unequipSlot = 0,
    uint64_t pcObjectId = 0) {
  UnequipItemResponseBuilder builder_(_fbb);
  builder_.add_pcObjectId(pcObjectId);
  builder_.add_errorCode(errorCode);
  builder_.add_unequipSlot(unequipSlot);
  return builder_.Finish();
}

///- REFRESH_INVEN_REQUEST --------------
struct RefreshInvenRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RefreshInvenRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RefreshInvenRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RefreshInvenRequestBuilder &operator=(const RefreshInvenRequestBuilder &);
  flatbuffers::Offset<RefreshInvenRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RefreshInvenRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RefreshInvenRequest> CreateRefreshInvenRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RefreshInvenRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

///- REFRESH_INVEN_RESPONSE --------------
struct RefreshInvenResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           verifier.EndTable();
  }
};

struct RefreshInvenResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(RefreshInvenResponse::VT_ERRORCODE, errorCode, 0);
  }
  explicit RefreshInvenResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RefreshInvenResponseBuilder &operator=(const RefreshInvenResponseBuilder &);
  flatbuffers::Offset<RefreshInvenResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RefreshInvenResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<RefreshInvenResponse> CreateRefreshInvenResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0) {
  RefreshInvenResponseBuilder builder_(_fbb);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

///- SERVER_TIME_REQUEST --------------
struct ServerTimeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ServerTimeRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ServerTimeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerTimeRequestBuilder &operator=(const ServerTimeRequestBuilder &);
  flatbuffers::Offset<ServerTimeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerTimeRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerTimeRequest> CreateServerTimeRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ServerTimeRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

///- SERVER_TIME_RESPONSE --------------
struct ServerTimeResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_SERVERABSDATETIME = 6
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  int64_t serverAbsDatetime() const {
    return GetField<int64_t>(VT_SERVERABSDATETIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int64_t>(verifier, VT_SERVERABSDATETIME) &&
           verifier.EndTable();
  }
};

struct ServerTimeResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(ServerTimeResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_serverAbsDatetime(int64_t serverAbsDatetime) {
    fbb_.AddElement<int64_t>(ServerTimeResponse::VT_SERVERABSDATETIME, serverAbsDatetime, 0);
  }
  explicit ServerTimeResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerTimeResponseBuilder &operator=(const ServerTimeResponseBuilder &);
  flatbuffers::Offset<ServerTimeResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerTimeResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerTimeResponse> CreateServerTimeResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    int64_t serverAbsDatetime = 0) {
  ServerTimeResponseBuilder builder_(_fbb);
  builder_.add_serverAbsDatetime(serverAbsDatetime);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

///- UPDATE_ITEM_NOTIFY --------------
struct UpdateItemNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CLIENTLITEMS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<ClientLItem>> *clientLItems() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ClientLItem>> *>(VT_CLIENTLITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CLIENTLITEMS) &&
           verifier.VerifyVector(clientLItems()) &&
           verifier.VerifyVectorOfTables(clientLItems()) &&
           verifier.EndTable();
  }
};

struct UpdateItemNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_clientLItems(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ClientLItem>>> clientLItems) {
    fbb_.AddOffset(UpdateItemNotify::VT_CLIENTLITEMS, clientLItems);
  }
  explicit UpdateItemNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UpdateItemNotifyBuilder &operator=(const UpdateItemNotifyBuilder &);
  flatbuffers::Offset<UpdateItemNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UpdateItemNotify>(end);
    fbb_.Required(o, UpdateItemNotify::VT_CLIENTLITEMS);
    return o;
  }
};

inline flatbuffers::Offset<UpdateItemNotify> CreateUpdateItemNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ClientLItem>>> clientLItems = 0) {
  UpdateItemNotifyBuilder builder_(_fbb);
  builder_.add_clientLItems(clientLItems);
  return builder_.Finish();
}

inline flatbuffers::Offset<UpdateItemNotify> CreateUpdateItemNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<ClientLItem>> *clientLItems = nullptr) {
  return LeanPacket::CreateUpdateItemNotify(
      _fbb,
      clientLItems ? _fbb.CreateVector<flatbuffers::Offset<ClientLItem>>(*clientLItems) : 0);
}

///- TOGGLE_SAFE_GUARD_REQUEST --------------
struct ToggleSafeGuardRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCOBJECTID = 4,
    VT_SAFEGUARDITEMOBJECTID = 6,
    VT_ISDEPOT = 8
  };
  uint64_t pcObjectId() const {
    return GetField<uint64_t>(VT_PCOBJECTID, 0);
  }
  uint64_t safeguardItemObjectId() const {
    return GetField<uint64_t>(VT_SAFEGUARDITEMOBJECTID, 0);
  }
  bool isDepot() const {
    return GetField<uint8_t>(VT_ISDEPOT, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PCOBJECTID) &&
           VerifyField<uint64_t>(verifier, VT_SAFEGUARDITEMOBJECTID) &&
           VerifyField<uint8_t>(verifier, VT_ISDEPOT) &&
           verifier.EndTable();
  }
};

struct ToggleSafeGuardRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcObjectId(uint64_t pcObjectId) {
    fbb_.AddElement<uint64_t>(ToggleSafeGuardRequest::VT_PCOBJECTID, pcObjectId, 0);
  }
  void add_safeguardItemObjectId(uint64_t safeguardItemObjectId) {
    fbb_.AddElement<uint64_t>(ToggleSafeGuardRequest::VT_SAFEGUARDITEMOBJECTID, safeguardItemObjectId, 0);
  }
  void add_isDepot(bool isDepot) {
    fbb_.AddElement<uint8_t>(ToggleSafeGuardRequest::VT_ISDEPOT, static_cast<uint8_t>(isDepot), 0);
  }
  explicit ToggleSafeGuardRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ToggleSafeGuardRequestBuilder &operator=(const ToggleSafeGuardRequestBuilder &);
  flatbuffers::Offset<ToggleSafeGuardRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ToggleSafeGuardRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ToggleSafeGuardRequest> CreateToggleSafeGuardRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t pcObjectId = 0,
    uint64_t safeguardItemObjectId = 0,
    bool isDepot = false) {
  ToggleSafeGuardRequestBuilder builder_(_fbb);
  builder_.add_safeguardItemObjectId(safeguardItemObjectId);
  builder_.add_pcObjectId(pcObjectId);
  builder_.add_isDepot(isDepot);
  return builder_.Finish();
}

/// TOGGLE_SAFE_GUARD_RESPONSE --------------
struct ToggleSafeGuardResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_SAFEGUARDITEMOBJECTID = 6,
    VT_SAFEGUARDED = 8,
    VT_ISDEPOT = 10
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  uint64_t safeguardItemObjectId() const {
    return GetField<uint64_t>(VT_SAFEGUARDITEMOBJECTID, 0);
  }
  int8_t safeguarded() const {
    return GetField<int8_t>(VT_SAFEGUARDED, 0);
  }
  bool isDepot() const {
    return GetField<uint8_t>(VT_ISDEPOT, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<uint64_t>(verifier, VT_SAFEGUARDITEMOBJECTID) &&
           VerifyField<int8_t>(verifier, VT_SAFEGUARDED) &&
           VerifyField<uint8_t>(verifier, VT_ISDEPOT) &&
           verifier.EndTable();
  }
};

struct ToggleSafeGuardResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(ToggleSafeGuardResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_safeguardItemObjectId(uint64_t safeguardItemObjectId) {
    fbb_.AddElement<uint64_t>(ToggleSafeGuardResponse::VT_SAFEGUARDITEMOBJECTID, safeguardItemObjectId, 0);
  }
  void add_safeguarded(int8_t safeguarded) {
    fbb_.AddElement<int8_t>(ToggleSafeGuardResponse::VT_SAFEGUARDED, safeguarded, 0);
  }
  void add_isDepot(bool isDepot) {
    fbb_.AddElement<uint8_t>(ToggleSafeGuardResponse::VT_ISDEPOT, static_cast<uint8_t>(isDepot), 0);
  }
  explicit ToggleSafeGuardResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ToggleSafeGuardResponseBuilder &operator=(const ToggleSafeGuardResponseBuilder &);
  flatbuffers::Offset<ToggleSafeGuardResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ToggleSafeGuardResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ToggleSafeGuardResponse> CreateToggleSafeGuardResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    uint64_t safeguardItemObjectId = 0,
    int8_t safeguarded = 0,
    bool isDepot = false) {
  ToggleSafeGuardResponseBuilder builder_(_fbb);
  builder_.add_safeguardItemObjectId(safeguardItemObjectId);
  builder_.add_errorCode(errorCode);
  builder_.add_isDepot(isDepot);
  builder_.add_safeguarded(safeguarded);
  return builder_.Finish();
}

///- USE_ITEM_REQUEST --------------
struct UseItemRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCOBJECTID = 4,
    VT_ITEMOBJECTID = 6,
    VT_USECOUNT = 8
  };
  uint64_t pcObjectId() const {
    return GetField<uint64_t>(VT_PCOBJECTID, 0);
  }
  uint64_t itemObjectId() const {
    return GetField<uint64_t>(VT_ITEMOBJECTID, 0);
  }
  int32_t useCount() const {
    return GetField<int32_t>(VT_USECOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PCOBJECTID) &&
           VerifyField<uint64_t>(verifier, VT_ITEMOBJECTID) &&
           VerifyField<int32_t>(verifier, VT_USECOUNT) &&
           verifier.EndTable();
  }
};

struct UseItemRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcObjectId(uint64_t pcObjectId) {
    fbb_.AddElement<uint64_t>(UseItemRequest::VT_PCOBJECTID, pcObjectId, 0);
  }
  void add_itemObjectId(uint64_t itemObjectId) {
    fbb_.AddElement<uint64_t>(UseItemRequest::VT_ITEMOBJECTID, itemObjectId, 0);
  }
  void add_useCount(int32_t useCount) {
    fbb_.AddElement<int32_t>(UseItemRequest::VT_USECOUNT, useCount, 0);
  }
  explicit UseItemRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UseItemRequestBuilder &operator=(const UseItemRequestBuilder &);
  flatbuffers::Offset<UseItemRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UseItemRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<UseItemRequest> CreateUseItemRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t pcObjectId = 0,
    uint64_t itemObjectId = 0,
    int32_t useCount = 0) {
  UseItemRequestBuilder builder_(_fbb);
  builder_.add_itemObjectId(itemObjectId);
  builder_.add_pcObjectId(pcObjectId);
  builder_.add_useCount(useCount);
  return builder_.Finish();
}

///- USE_ITEM_RESPONSE --------------
struct UseItemResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FIRERR = 4,
    VT_SUBERR = 6,
    VT_ITEMOBJECTID = 8,
    VT_REWARD = 10
  };
  int32_t firErr() const {
    return GetField<int32_t>(VT_FIRERR, 0);
  }
  int32_t subErr() const {
    return GetField<int32_t>(VT_SUBERR, 0);
  }
  uint64_t itemObjectId() const {
    return GetField<uint64_t>(VT_ITEMOBJECTID, 0);
  }
  const BundleRewardInfo *reward() const {
    return GetPointer<const BundleRewardInfo *>(VT_REWARD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FIRERR) &&
           VerifyField<int32_t>(verifier, VT_SUBERR) &&
           VerifyField<uint64_t>(verifier, VT_ITEMOBJECTID) &&
           VerifyOffset(verifier, VT_REWARD) &&
           verifier.VerifyTable(reward()) &&
           verifier.EndTable();
  }
};

struct UseItemResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_firErr(int32_t firErr) {
    fbb_.AddElement<int32_t>(UseItemResponse::VT_FIRERR, firErr, 0);
  }
  void add_subErr(int32_t subErr) {
    fbb_.AddElement<int32_t>(UseItemResponse::VT_SUBERR, subErr, 0);
  }
  void add_itemObjectId(uint64_t itemObjectId) {
    fbb_.AddElement<uint64_t>(UseItemResponse::VT_ITEMOBJECTID, itemObjectId, 0);
  }
  void add_reward(flatbuffers::Offset<BundleRewardInfo> reward) {
    fbb_.AddOffset(UseItemResponse::VT_REWARD, reward);
  }
  explicit UseItemResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UseItemResponseBuilder &operator=(const UseItemResponseBuilder &);
  flatbuffers::Offset<UseItemResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UseItemResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<UseItemResponse> CreateUseItemResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t firErr = 0,
    int32_t subErr = 0,
    uint64_t itemObjectId = 0,
    flatbuffers::Offset<BundleRewardInfo> reward = 0) {
  UseItemResponseBuilder builder_(_fbb);
  builder_.add_itemObjectId(itemObjectId);
  builder_.add_reward(reward);
  builder_.add_subErr(subErr);
  builder_.add_firErr(firErr);
  return builder_.Finish();
}

///-ITEM_BOUND_STATE_UPDATE_NOTIFY-------
struct ItemBoundStateUpdateNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMOBJECTIDS = 4,
    VT_BOUNDSTATE = 6
  };
  const flatbuffers::Vector<int64_t> *itemObjectIds() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_ITEMOBJECTIDS);
  }
  int8_t boundState() const {
    return GetField<int8_t>(VT_BOUNDSTATE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ITEMOBJECTIDS) &&
           verifier.VerifyVector(itemObjectIds()) &&
           VerifyField<int8_t>(verifier, VT_BOUNDSTATE) &&
           verifier.EndTable();
  }
};

struct ItemBoundStateUpdateNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemObjectIds(flatbuffers::Offset<flatbuffers::Vector<int64_t>> itemObjectIds) {
    fbb_.AddOffset(ItemBoundStateUpdateNotify::VT_ITEMOBJECTIDS, itemObjectIds);
  }
  void add_boundState(int8_t boundState) {
    fbb_.AddElement<int8_t>(ItemBoundStateUpdateNotify::VT_BOUNDSTATE, boundState, 0);
  }
  explicit ItemBoundStateUpdateNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ItemBoundStateUpdateNotifyBuilder &operator=(const ItemBoundStateUpdateNotifyBuilder &);
  flatbuffers::Offset<ItemBoundStateUpdateNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ItemBoundStateUpdateNotify>(end);
    fbb_.Required(o, ItemBoundStateUpdateNotify::VT_ITEMOBJECTIDS);
    return o;
  }
};

inline flatbuffers::Offset<ItemBoundStateUpdateNotify> CreateItemBoundStateUpdateNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> itemObjectIds = 0,
    int8_t boundState = 0) {
  ItemBoundStateUpdateNotifyBuilder builder_(_fbb);
  builder_.add_itemObjectIds(itemObjectIds);
  builder_.add_boundState(boundState);
  return builder_.Finish();
}

inline flatbuffers::Offset<ItemBoundStateUpdateNotify> CreateItemBoundStateUpdateNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *itemObjectIds = nullptr,
    int8_t boundState = 0) {
  return LeanPacket::CreateItemBoundStateUpdateNotify(
      _fbb,
      itemObjectIds ? _fbb.CreateVector<int64_t>(*itemObjectIds) : 0,
      boundState);
}

///-ADD_ITEM_NOTIFY--------------
struct AddItemNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEM = 4
  };
  const ClientLItem *item() const {
    return GetPointer<const ClientLItem *>(VT_ITEM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ITEM) &&
           verifier.VerifyTable(item()) &&
           verifier.EndTable();
  }
};

struct AddItemNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_item(flatbuffers::Offset<ClientLItem> item) {
    fbb_.AddOffset(AddItemNotify::VT_ITEM, item);
  }
  explicit AddItemNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddItemNotifyBuilder &operator=(const AddItemNotifyBuilder &);
  flatbuffers::Offset<AddItemNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddItemNotify>(end);
    fbb_.Required(o, AddItemNotify::VT_ITEM);
    return o;
  }
};

inline flatbuffers::Offset<AddItemNotify> CreateAddItemNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ClientLItem> item = 0) {
  AddItemNotifyBuilder builder_(_fbb);
  builder_.add_item(item);
  return builder_.Finish();
}

///-REMOVE_ITEM_NOTIFY--------------
struct RemoveItemNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMOBJECTID = 4
  };
  uint64_t itemObjectId() const {
    return GetField<uint64_t>(VT_ITEMOBJECTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ITEMOBJECTID) &&
           verifier.EndTable();
  }
};

struct RemoveItemNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemObjectId(uint64_t itemObjectId) {
    fbb_.AddElement<uint64_t>(RemoveItemNotify::VT_ITEMOBJECTID, itemObjectId, 0);
  }
  explicit RemoveItemNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RemoveItemNotifyBuilder &operator=(const RemoveItemNotifyBuilder &);
  flatbuffers::Offset<RemoveItemNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RemoveItemNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<RemoveItemNotify> CreateRemoveItemNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t itemObjectId = 0) {
  RemoveItemNotifyBuilder builder_(_fbb);
  builder_.add_itemObjectId(itemObjectId);
  return builder_.Finish();
}

struct ArtifactInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LEVEL = 4,
    VT_EXP = 6
  };
  int16_t level() const {
    return GetField<int16_t>(VT_LEVEL, 0);
  }
  int32_t exp() const {
    return GetField<int32_t>(VT_EXP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_EXP) &&
           verifier.EndTable();
  }
};

struct ArtifactInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_level(int16_t level) {
    fbb_.AddElement<int16_t>(ArtifactInfo::VT_LEVEL, level, 0);
  }
  void add_exp(int32_t exp) {
    fbb_.AddElement<int32_t>(ArtifactInfo::VT_EXP, exp, 0);
  }
  explicit ArtifactInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArtifactInfoBuilder &operator=(const ArtifactInfoBuilder &);
  flatbuffers::Offset<ArtifactInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArtifactInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArtifactInfo> CreateArtifactInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t level = 0,
    int32_t exp = 0) {
  ArtifactInfoBuilder builder_(_fbb);
  builder_.add_exp(exp);
  builder_.add_level(level);
  return builder_.Finish();
}

///UPDATE_ARTIFACT_NOTIFY
struct UpdateArtifactNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INFO = 4
  };
  const ArtifactInfo *info() const {
    return GetPointer<const ArtifactInfo *>(VT_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           verifier.EndTable();
  }
};

struct UpdateArtifactNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_info(flatbuffers::Offset<ArtifactInfo> info) {
    fbb_.AddOffset(UpdateArtifactNotify::VT_INFO, info);
  }
  explicit UpdateArtifactNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UpdateArtifactNotifyBuilder &operator=(const UpdateArtifactNotifyBuilder &);
  flatbuffers::Offset<UpdateArtifactNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UpdateArtifactNotify>(end);
    fbb_.Required(o, UpdateArtifactNotify::VT_INFO);
    return o;
  }
};

inline flatbuffers::Offset<UpdateArtifactNotify> CreateUpdateArtifactNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ArtifactInfo> info = 0) {
  UpdateArtifactNotifyBuilder builder_(_fbb);
  builder_.add_info(info);
  return builder_.Finish();
}

///-CHANGE_ITEM_STACK_COUNT_NOTIFY--------------
struct ChangeItemStackCountNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMOBJECTID = 4,
    VT_COUNT = 6
  };
  uint64_t itemObjectId() const {
    return GetField<uint64_t>(VT_ITEMOBJECTID, 0);
  }
  int32_t count() const {
    return GetField<int32_t>(VT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ITEMOBJECTID) &&
           VerifyField<int32_t>(verifier, VT_COUNT) &&
           verifier.EndTable();
  }
};

struct ChangeItemStackCountNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemObjectId(uint64_t itemObjectId) {
    fbb_.AddElement<uint64_t>(ChangeItemStackCountNotify::VT_ITEMOBJECTID, itemObjectId, 0);
  }
  void add_count(int32_t count) {
    fbb_.AddElement<int32_t>(ChangeItemStackCountNotify::VT_COUNT, count, 0);
  }
  explicit ChangeItemStackCountNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChangeItemStackCountNotifyBuilder &operator=(const ChangeItemStackCountNotifyBuilder &);
  flatbuffers::Offset<ChangeItemStackCountNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChangeItemStackCountNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChangeItemStackCountNotify> CreateChangeItemStackCountNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t itemObjectId = 0,
    int32_t count = 0) {
  ChangeItemStackCountNotifyBuilder builder_(_fbb);
  builder_.add_itemObjectId(itemObjectId);
  builder_.add_count(count);
  return builder_.Finish();
}

/// MOVE_ITEM_NOTIFY
struct MoveItemNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMOBJECTID = 4,
    VT_FROMSTORAGE = 6,
    VT_TOSTORAGE = 8
  };
  uint64_t itemObjectId() const {
    return GetField<uint64_t>(VT_ITEMOBJECTID, 0);
  }
  int16_t fromStorage() const {
    return GetField<int16_t>(VT_FROMSTORAGE, 0);
  }
  int16_t toStorage() const {
    return GetField<int16_t>(VT_TOSTORAGE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ITEMOBJECTID) &&
           VerifyField<int16_t>(verifier, VT_FROMSTORAGE) &&
           VerifyField<int16_t>(verifier, VT_TOSTORAGE) &&
           verifier.EndTable();
  }
};

struct MoveItemNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemObjectId(uint64_t itemObjectId) {
    fbb_.AddElement<uint64_t>(MoveItemNotify::VT_ITEMOBJECTID, itemObjectId, 0);
  }
  void add_fromStorage(int16_t fromStorage) {
    fbb_.AddElement<int16_t>(MoveItemNotify::VT_FROMSTORAGE, fromStorage, 0);
  }
  void add_toStorage(int16_t toStorage) {
    fbb_.AddElement<int16_t>(MoveItemNotify::VT_TOSTORAGE, toStorage, 0);
  }
  explicit MoveItemNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MoveItemNotifyBuilder &operator=(const MoveItemNotifyBuilder &);
  flatbuffers::Offset<MoveItemNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MoveItemNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<MoveItemNotify> CreateMoveItemNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t itemObjectId = 0,
    int16_t fromStorage = 0,
    int16_t toStorage = 0) {
  MoveItemNotifyBuilder builder_(_fbb);
  builder_.add_itemObjectId(itemObjectId);
  builder_.add_toStorage(toStorage);
  builder_.add_fromStorage(fromStorage);
  return builder_.Finish();
}

///-----------------------------------------------------------------------------
///- ENCHANT : Client <-> Game
///-----------------------------------------------------------------------------
///- DISENCHANT_ITEM_REQUEST : ClientSItem ----------
struct ClientSItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMOBJECTID = 4,
    VT_ITEMSTACKCOUNT = 6
  };
  uint64_t itemObjectId() const {
    return GetField<uint64_t>(VT_ITEMOBJECTID, 0);
  }
  int32_t itemStackCount() const {
    return GetField<int32_t>(VT_ITEMSTACKCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ITEMOBJECTID) &&
           VerifyField<int32_t>(verifier, VT_ITEMSTACKCOUNT) &&
           verifier.EndTable();
  }
};

struct ClientSItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemObjectId(uint64_t itemObjectId) {
    fbb_.AddElement<uint64_t>(ClientSItem::VT_ITEMOBJECTID, itemObjectId, 0);
  }
  void add_itemStackCount(int32_t itemStackCount) {
    fbb_.AddElement<int32_t>(ClientSItem::VT_ITEMSTACKCOUNT, itemStackCount, 0);
  }
  explicit ClientSItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClientSItemBuilder &operator=(const ClientSItemBuilder &);
  flatbuffers::Offset<ClientSItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientSItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClientSItem> CreateClientSItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t itemObjectId = 0,
    int32_t itemStackCount = 0) {
  ClientSItemBuilder builder_(_fbb);
  builder_.add_itemObjectId(itemObjectId);
  builder_.add_itemStackCount(itemStackCount);
  return builder_.Finish();
}

///- DISENCHANT_ITEM_REQUEST --------------
struct DisenchantItemRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCOBJECTID = 4,
    VT_STORAGETYPE = 6,
    VT_DISENCHANTITEMS = 8
  };
  uint64_t pcObjectId() const {
    return GetField<uint64_t>(VT_PCOBJECTID, 0);
  }
  int16_t storageType() const {
    return GetField<int16_t>(VT_STORAGETYPE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ClientSItem>> *disenchantItems() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ClientSItem>> *>(VT_DISENCHANTITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PCOBJECTID) &&
           VerifyField<int16_t>(verifier, VT_STORAGETYPE) &&
           VerifyOffsetRequired(verifier, VT_DISENCHANTITEMS) &&
           verifier.VerifyVector(disenchantItems()) &&
           verifier.VerifyVectorOfTables(disenchantItems()) &&
           verifier.EndTable();
  }
};

struct DisenchantItemRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcObjectId(uint64_t pcObjectId) {
    fbb_.AddElement<uint64_t>(DisenchantItemRequest::VT_PCOBJECTID, pcObjectId, 0);
  }
  void add_storageType(int16_t storageType) {
    fbb_.AddElement<int16_t>(DisenchantItemRequest::VT_STORAGETYPE, storageType, 0);
  }
  void add_disenchantItems(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ClientSItem>>> disenchantItems) {
    fbb_.AddOffset(DisenchantItemRequest::VT_DISENCHANTITEMS, disenchantItems);
  }
  explicit DisenchantItemRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DisenchantItemRequestBuilder &operator=(const DisenchantItemRequestBuilder &);
  flatbuffers::Offset<DisenchantItemRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DisenchantItemRequest>(end);
    fbb_.Required(o, DisenchantItemRequest::VT_DISENCHANTITEMS);
    return o;
  }
};

inline flatbuffers::Offset<DisenchantItemRequest> CreateDisenchantItemRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t pcObjectId = 0,
    int16_t storageType = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ClientSItem>>> disenchantItems = 0) {
  DisenchantItemRequestBuilder builder_(_fbb);
  builder_.add_pcObjectId(pcObjectId);
  builder_.add_disenchantItems(disenchantItems);
  builder_.add_storageType(storageType);
  return builder_.Finish();
}

inline flatbuffers::Offset<DisenchantItemRequest> CreateDisenchantItemRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t pcObjectId = 0,
    int16_t storageType = 0,
    const std::vector<flatbuffers::Offset<ClientSItem>> *disenchantItems = nullptr) {
  return LeanPacket::CreateDisenchantItemRequest(
      _fbb,
      pcObjectId,
      storageType,
      disenchantItems ? _fbb.CreateVector<flatbuffers::Offset<ClientSItem>>(*disenchantItems) : 0);
}

///- DISENCHANT_ITEM_RESPONSE --------------
struct DisenchantItemResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_OUTPUTITEMS = 6
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ClientItemResultInfo>> *outputItems() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ClientItemResultInfo>> *>(VT_OUTPUTITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyOffset(verifier, VT_OUTPUTITEMS) &&
           verifier.VerifyVector(outputItems()) &&
           verifier.VerifyVectorOfTables(outputItems()) &&
           verifier.EndTable();
  }
};

struct DisenchantItemResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(DisenchantItemResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_outputItems(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ClientItemResultInfo>>> outputItems) {
    fbb_.AddOffset(DisenchantItemResponse::VT_OUTPUTITEMS, outputItems);
  }
  explicit DisenchantItemResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DisenchantItemResponseBuilder &operator=(const DisenchantItemResponseBuilder &);
  flatbuffers::Offset<DisenchantItemResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DisenchantItemResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<DisenchantItemResponse> CreateDisenchantItemResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ClientItemResultInfo>>> outputItems = 0) {
  DisenchantItemResponseBuilder builder_(_fbb);
  builder_.add_outputItems(outputItems);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

inline flatbuffers::Offset<DisenchantItemResponse> CreateDisenchantItemResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    const std::vector<flatbuffers::Offset<ClientItemResultInfo>> *outputItems = nullptr) {
  return LeanPacket::CreateDisenchantItemResponse(
      _fbb,
      errorCode,
      outputItems ? _fbb.CreateVector<flatbuffers::Offset<ClientItemResultInfo>>(*outputItems) : 0);
}

///- ENCHANT_ITEM_REQUEST --------------
struct EnchantItemRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCOBJECTID = 4,
    VT_ENCHANTITEMOBJECTID = 6,
    VT_COUNT = 8
  };
  uint64_t pcObjectId() const {
    return GetField<uint64_t>(VT_PCOBJECTID, 0);
  }
  uint64_t enchantItemObjectId() const {
    return GetField<uint64_t>(VT_ENCHANTITEMOBJECTID, 0);
  }
  int32_t count() const {
    return GetField<int32_t>(VT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PCOBJECTID) &&
           VerifyField<uint64_t>(verifier, VT_ENCHANTITEMOBJECTID) &&
           VerifyField<int32_t>(verifier, VT_COUNT) &&
           verifier.EndTable();
  }
};

struct EnchantItemRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcObjectId(uint64_t pcObjectId) {
    fbb_.AddElement<uint64_t>(EnchantItemRequest::VT_PCOBJECTID, pcObjectId, 0);
  }
  void add_enchantItemObjectId(uint64_t enchantItemObjectId) {
    fbb_.AddElement<uint64_t>(EnchantItemRequest::VT_ENCHANTITEMOBJECTID, enchantItemObjectId, 0);
  }
  void add_count(int32_t count) {
    fbb_.AddElement<int32_t>(EnchantItemRequest::VT_COUNT, count, 0);
  }
  explicit EnchantItemRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EnchantItemRequestBuilder &operator=(const EnchantItemRequestBuilder &);
  flatbuffers::Offset<EnchantItemRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EnchantItemRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<EnchantItemRequest> CreateEnchantItemRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t pcObjectId = 0,
    uint64_t enchantItemObjectId = 0,
    int32_t count = 0) {
  EnchantItemRequestBuilder builder_(_fbb);
  builder_.add_enchantItemObjectId(enchantItemObjectId);
  builder_.add_pcObjectId(pcObjectId);
  builder_.add_count(count);
  return builder_.Finish();
}

///- ENCHANT_ITEM_RESPONSE --------------
struct EnchantItemResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_BASEENCHANTEXP = 6,
    VT_BONUSENCHANTEXP = 8,
    VT_ENCHANTEXP = 10,
    VT_LEVEL = 12,
    VT_ITEMOBJECTID = 14
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  int32_t baseEnchantExp() const {
    return GetField<int32_t>(VT_BASEENCHANTEXP, 0);
  }
  int32_t bonusEnchantExp() const {
    return GetField<int32_t>(VT_BONUSENCHANTEXP, 0);
  }
  int32_t enchantExp() const {
    return GetField<int32_t>(VT_ENCHANTEXP, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  uint64_t itemObjectId() const {
    return GetField<uint64_t>(VT_ITEMOBJECTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int32_t>(verifier, VT_BASEENCHANTEXP) &&
           VerifyField<int32_t>(verifier, VT_BONUSENCHANTEXP) &&
           VerifyField<int32_t>(verifier, VT_ENCHANTEXP) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<uint64_t>(verifier, VT_ITEMOBJECTID) &&
           verifier.EndTable();
  }
};

struct EnchantItemResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(EnchantItemResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_baseEnchantExp(int32_t baseEnchantExp) {
    fbb_.AddElement<int32_t>(EnchantItemResponse::VT_BASEENCHANTEXP, baseEnchantExp, 0);
  }
  void add_bonusEnchantExp(int32_t bonusEnchantExp) {
    fbb_.AddElement<int32_t>(EnchantItemResponse::VT_BONUSENCHANTEXP, bonusEnchantExp, 0);
  }
  void add_enchantExp(int32_t enchantExp) {
    fbb_.AddElement<int32_t>(EnchantItemResponse::VT_ENCHANTEXP, enchantExp, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(EnchantItemResponse::VT_LEVEL, level, 0);
  }
  void add_itemObjectId(uint64_t itemObjectId) {
    fbb_.AddElement<uint64_t>(EnchantItemResponse::VT_ITEMOBJECTID, itemObjectId, 0);
  }
  explicit EnchantItemResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EnchantItemResponseBuilder &operator=(const EnchantItemResponseBuilder &);
  flatbuffers::Offset<EnchantItemResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EnchantItemResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<EnchantItemResponse> CreateEnchantItemResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    int32_t baseEnchantExp = 0,
    int32_t bonusEnchantExp = 0,
    int32_t enchantExp = 0,
    int32_t level = 0,
    uint64_t itemObjectId = 0) {
  EnchantItemResponseBuilder builder_(_fbb);
  builder_.add_itemObjectId(itemObjectId);
  builder_.add_level(level);
  builder_.add_enchantExp(enchantExp);
  builder_.add_bonusEnchantExp(bonusEnchantExp);
  builder_.add_baseEnchantExp(baseEnchantExp);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

///- EQUIPMENT_TRANSMUTATION_REQUEST --------------
struct EquipmentTransmutationRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCOBJECTID = 4,
    VT_TRANSITEMOBJECTID = 6,
    VT_STORAGETYPE = 8
  };
  uint64_t pcObjectId() const {
    return GetField<uint64_t>(VT_PCOBJECTID, 0);
  }
  uint64_t transItemObjectId() const {
    return GetField<uint64_t>(VT_TRANSITEMOBJECTID, 0);
  }
  int16_t storageType() const {
    return GetField<int16_t>(VT_STORAGETYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PCOBJECTID) &&
           VerifyField<uint64_t>(verifier, VT_TRANSITEMOBJECTID) &&
           VerifyField<int16_t>(verifier, VT_STORAGETYPE) &&
           verifier.EndTable();
  }
};

struct EquipmentTransmutationRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcObjectId(uint64_t pcObjectId) {
    fbb_.AddElement<uint64_t>(EquipmentTransmutationRequest::VT_PCOBJECTID, pcObjectId, 0);
  }
  void add_transItemObjectId(uint64_t transItemObjectId) {
    fbb_.AddElement<uint64_t>(EquipmentTransmutationRequest::VT_TRANSITEMOBJECTID, transItemObjectId, 0);
  }
  void add_storageType(int16_t storageType) {
    fbb_.AddElement<int16_t>(EquipmentTransmutationRequest::VT_STORAGETYPE, storageType, 0);
  }
  explicit EquipmentTransmutationRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EquipmentTransmutationRequestBuilder &operator=(const EquipmentTransmutationRequestBuilder &);
  flatbuffers::Offset<EquipmentTransmutationRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EquipmentTransmutationRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<EquipmentTransmutationRequest> CreateEquipmentTransmutationRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t pcObjectId = 0,
    uint64_t transItemObjectId = 0,
    int16_t storageType = 0) {
  EquipmentTransmutationRequestBuilder builder_(_fbb);
  builder_.add_transItemObjectId(transItemObjectId);
  builder_.add_pcObjectId(pcObjectId);
  builder_.add_storageType(storageType);
  return builder_.Finish();
}

///- EQUIPMENT_TRANSMUTATION_RESPONSE --------------
struct EquipmentTransmutationResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_TRANSITEMOBJECTID = 6,
    VT_TRANSITEMSTACKCOUNT = 8,
    VT_STORAGETYPE = 10
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  uint64_t transItemObjectId() const {
    return GetField<uint64_t>(VT_TRANSITEMOBJECTID, 0);
  }
  int16_t transItemStackCount() const {
    return GetField<int16_t>(VT_TRANSITEMSTACKCOUNT, 0);
  }
  int16_t storageType() const {
    return GetField<int16_t>(VT_STORAGETYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<uint64_t>(verifier, VT_TRANSITEMOBJECTID) &&
           VerifyField<int16_t>(verifier, VT_TRANSITEMSTACKCOUNT) &&
           VerifyField<int16_t>(verifier, VT_STORAGETYPE) &&
           verifier.EndTable();
  }
};

struct EquipmentTransmutationResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(EquipmentTransmutationResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_transItemObjectId(uint64_t transItemObjectId) {
    fbb_.AddElement<uint64_t>(EquipmentTransmutationResponse::VT_TRANSITEMOBJECTID, transItemObjectId, 0);
  }
  void add_transItemStackCount(int16_t transItemStackCount) {
    fbb_.AddElement<int16_t>(EquipmentTransmutationResponse::VT_TRANSITEMSTACKCOUNT, transItemStackCount, 0);
  }
  void add_storageType(int16_t storageType) {
    fbb_.AddElement<int16_t>(EquipmentTransmutationResponse::VT_STORAGETYPE, storageType, 0);
  }
  explicit EquipmentTransmutationResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EquipmentTransmutationResponseBuilder &operator=(const EquipmentTransmutationResponseBuilder &);
  flatbuffers::Offset<EquipmentTransmutationResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EquipmentTransmutationResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<EquipmentTransmutationResponse> CreateEquipmentTransmutationResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    uint64_t transItemObjectId = 0,
    int16_t transItemStackCount = 0,
    int16_t storageType = 0) {
  EquipmentTransmutationResponseBuilder builder_(_fbb);
  builder_.add_transItemObjectId(transItemObjectId);
  builder_.add_errorCode(errorCode);
  builder_.add_storageType(storageType);
  builder_.add_transItemStackCount(transItemStackCount);
  return builder_.Finish();
}

///- UPGRADE_ITEM_REQUEST --------------
struct UpgradeItemRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCOBJECTID = 4,
    VT_UPGRADEITEMOBJECTID = 6
  };
  uint64_t pcObjectId() const {
    return GetField<uint64_t>(VT_PCOBJECTID, 0);
  }
  uint64_t upgradeItemObjectId() const {
    return GetField<uint64_t>(VT_UPGRADEITEMOBJECTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PCOBJECTID) &&
           VerifyField<uint64_t>(verifier, VT_UPGRADEITEMOBJECTID) &&
           verifier.EndTable();
  }
};

struct UpgradeItemRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcObjectId(uint64_t pcObjectId) {
    fbb_.AddElement<uint64_t>(UpgradeItemRequest::VT_PCOBJECTID, pcObjectId, 0);
  }
  void add_upgradeItemObjectId(uint64_t upgradeItemObjectId) {
    fbb_.AddElement<uint64_t>(UpgradeItemRequest::VT_UPGRADEITEMOBJECTID, upgradeItemObjectId, 0);
  }
  explicit UpgradeItemRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UpgradeItemRequestBuilder &operator=(const UpgradeItemRequestBuilder &);
  flatbuffers::Offset<UpgradeItemRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UpgradeItemRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<UpgradeItemRequest> CreateUpgradeItemRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t pcObjectId = 0,
    uint64_t upgradeItemObjectId = 0) {
  UpgradeItemRequestBuilder builder_(_fbb);
  builder_.add_upgradeItemObjectId(upgradeItemObjectId);
  builder_.add_pcObjectId(pcObjectId);
  return builder_.Finish();
}

///- UPGRADE_ITEM_RESPONSE --------------
struct UpgradeItemResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_GRADE = 6,
    VT_LEVEL = 8,
    VT_EXP = 10,
    VT_ITEMOBJECTID = 12
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  int16_t grade() const {
    return GetField<int16_t>(VT_GRADE, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int32_t exp() const {
    return GetField<int32_t>(VT_EXP, 0);
  }
  uint64_t itemObjectId() const {
    return GetField<uint64_t>(VT_ITEMOBJECTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int16_t>(verifier, VT_GRADE) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_EXP) &&
           VerifyField<uint64_t>(verifier, VT_ITEMOBJECTID) &&
           verifier.EndTable();
  }
};

struct UpgradeItemResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(UpgradeItemResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_grade(int16_t grade) {
    fbb_.AddElement<int16_t>(UpgradeItemResponse::VT_GRADE, grade, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(UpgradeItemResponse::VT_LEVEL, level, 0);
  }
  void add_exp(int32_t exp) {
    fbb_.AddElement<int32_t>(UpgradeItemResponse::VT_EXP, exp, 0);
  }
  void add_itemObjectId(uint64_t itemObjectId) {
    fbb_.AddElement<uint64_t>(UpgradeItemResponse::VT_ITEMOBJECTID, itemObjectId, 0);
  }
  explicit UpgradeItemResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UpgradeItemResponseBuilder &operator=(const UpgradeItemResponseBuilder &);
  flatbuffers::Offset<UpgradeItemResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UpgradeItemResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<UpgradeItemResponse> CreateUpgradeItemResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    int16_t grade = 0,
    int32_t level = 0,
    int32_t exp = 0,
    uint64_t itemObjectId = 0) {
  UpgradeItemResponseBuilder builder_(_fbb);
  builder_.add_itemObjectId(itemObjectId);
  builder_.add_exp(exp);
  builder_.add_level(level);
  builder_.add_errorCode(errorCode);
  builder_.add_grade(grade);
  return builder_.Finish();
}

///-----------------------------------------------------------------------------
///- PROGRESSION : Client <-> Game
///-----------------------------------------------------------------------------
///- PC_LEVEL_UP_EXP_NOTIFY --------------
struct PcLevelupExpNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCOBJECTID = 4,
    VT_FROMLEVEL = 6,
    VT_TOLEVEL = 8,
    VT_EXP = 10
  };
  uint64_t pcObjectId() const {
    return GetField<uint64_t>(VT_PCOBJECTID, 0);
  }
  int32_t fromLevel() const {
    return GetField<int32_t>(VT_FROMLEVEL, 0);
  }
  int32_t toLevel() const {
    return GetField<int32_t>(VT_TOLEVEL, 0);
  }
  int32_t exp() const {
    return GetField<int32_t>(VT_EXP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PCOBJECTID) &&
           VerifyField<int32_t>(verifier, VT_FROMLEVEL) &&
           VerifyField<int32_t>(verifier, VT_TOLEVEL) &&
           VerifyField<int32_t>(verifier, VT_EXP) &&
           verifier.EndTable();
  }
};

struct PcLevelupExpNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcObjectId(uint64_t pcObjectId) {
    fbb_.AddElement<uint64_t>(PcLevelupExpNotify::VT_PCOBJECTID, pcObjectId, 0);
  }
  void add_fromLevel(int32_t fromLevel) {
    fbb_.AddElement<int32_t>(PcLevelupExpNotify::VT_FROMLEVEL, fromLevel, 0);
  }
  void add_toLevel(int32_t toLevel) {
    fbb_.AddElement<int32_t>(PcLevelupExpNotify::VT_TOLEVEL, toLevel, 0);
  }
  void add_exp(int32_t exp) {
    fbb_.AddElement<int32_t>(PcLevelupExpNotify::VT_EXP, exp, 0);
  }
  explicit PcLevelupExpNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PcLevelupExpNotifyBuilder &operator=(const PcLevelupExpNotifyBuilder &);
  flatbuffers::Offset<PcLevelupExpNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PcLevelupExpNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<PcLevelupExpNotify> CreatePcLevelupExpNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t pcObjectId = 0,
    int32_t fromLevel = 0,
    int32_t toLevel = 0,
    int32_t exp = 0) {
  PcLevelupExpNotifyBuilder builder_(_fbb);
  builder_.add_pcObjectId(pcObjectId);
  builder_.add_exp(exp);
  builder_.add_toLevel(toLevel);
  builder_.add_fromLevel(fromLevel);
  return builder_.Finish();
}

///- PC_EXP_UP_NOTIFY --------------
struct PcExpUpNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ADDEXP = 4,
    VT_RESULTEXP = 6,
    VT_LEVEL = 8
  };
  int32_t addExp() const {
    return GetField<int32_t>(VT_ADDEXP, 0);
  }
  int32_t resultExp() const {
    return GetField<int32_t>(VT_RESULTEXP, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ADDEXP) &&
           VerifyField<int32_t>(verifier, VT_RESULTEXP) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           verifier.EndTable();
  }
};

struct PcExpUpNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_addExp(int32_t addExp) {
    fbb_.AddElement<int32_t>(PcExpUpNotify::VT_ADDEXP, addExp, 0);
  }
  void add_resultExp(int32_t resultExp) {
    fbb_.AddElement<int32_t>(PcExpUpNotify::VT_RESULTEXP, resultExp, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(PcExpUpNotify::VT_LEVEL, level, 0);
  }
  explicit PcExpUpNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PcExpUpNotifyBuilder &operator=(const PcExpUpNotifyBuilder &);
  flatbuffers::Offset<PcExpUpNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PcExpUpNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<PcExpUpNotify> CreatePcExpUpNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t addExp = 0,
    int32_t resultExp = 0,
    int32_t level = 0) {
  PcExpUpNotifyBuilder builder_(_fbb);
  builder_.add_level(level);
  builder_.add_resultExp(resultExp);
  builder_.add_addExp(addExp);
  return builder_.Finish();
}

///- DROP_REWARD_NOTIFY --------------
struct DropRewardNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_REWARDOBJID = 4,
    VT_REWARDINFO = 6,
    VT_BUBBLEPOINT = 8,
    VT_XPOS = 10,
    VT_YPOS = 12,
    VT_ZPOS = 14
  };
  /// 몬스터, 채집물 등 보상이 나오는 오브젝트
  uint64_t rewardObjId() const {
    return GetField<uint64_t>(VT_REWARDOBJID, 0);
  }
  const RewardInfo *rewardInfo() const {
    return GetPointer<const RewardInfo *>(VT_REWARDINFO);
  }
  int32_t bubblePoint() const {
    return GetField<int32_t>(VT_BUBBLEPOINT, 0);
  }
  float xPos() const {
    return GetField<float>(VT_XPOS, 0.0f);
  }
  float yPos() const {
    return GetField<float>(VT_YPOS, 0.0f);
  }
  float zPos() const {
    return GetField<float>(VT_ZPOS, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_REWARDOBJID) &&
           VerifyOffsetRequired(verifier, VT_REWARDINFO) &&
           verifier.VerifyTable(rewardInfo()) &&
           VerifyField<int32_t>(verifier, VT_BUBBLEPOINT) &&
           VerifyField<float>(verifier, VT_XPOS) &&
           VerifyField<float>(verifier, VT_YPOS) &&
           VerifyField<float>(verifier, VT_ZPOS) &&
           verifier.EndTable();
  }
};

struct DropRewardNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rewardObjId(uint64_t rewardObjId) {
    fbb_.AddElement<uint64_t>(DropRewardNotify::VT_REWARDOBJID, rewardObjId, 0);
  }
  void add_rewardInfo(flatbuffers::Offset<RewardInfo> rewardInfo) {
    fbb_.AddOffset(DropRewardNotify::VT_REWARDINFO, rewardInfo);
  }
  void add_bubblePoint(int32_t bubblePoint) {
    fbb_.AddElement<int32_t>(DropRewardNotify::VT_BUBBLEPOINT, bubblePoint, 0);
  }
  void add_xPos(float xPos) {
    fbb_.AddElement<float>(DropRewardNotify::VT_XPOS, xPos, 0.0f);
  }
  void add_yPos(float yPos) {
    fbb_.AddElement<float>(DropRewardNotify::VT_YPOS, yPos, 0.0f);
  }
  void add_zPos(float zPos) {
    fbb_.AddElement<float>(DropRewardNotify::VT_ZPOS, zPos, 0.0f);
  }
  explicit DropRewardNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DropRewardNotifyBuilder &operator=(const DropRewardNotifyBuilder &);
  flatbuffers::Offset<DropRewardNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DropRewardNotify>(end);
    fbb_.Required(o, DropRewardNotify::VT_REWARDINFO);
    return o;
  }
};

inline flatbuffers::Offset<DropRewardNotify> CreateDropRewardNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t rewardObjId = 0,
    flatbuffers::Offset<RewardInfo> rewardInfo = 0,
    int32_t bubblePoint = 0,
    float xPos = 0.0f,
    float yPos = 0.0f,
    float zPos = 0.0f) {
  DropRewardNotifyBuilder builder_(_fbb);
  builder_.add_rewardObjId(rewardObjId);
  builder_.add_zPos(zPos);
  builder_.add_yPos(yPos);
  builder_.add_xPos(xPos);
  builder_.add_bubblePoint(bubblePoint);
  builder_.add_rewardInfo(rewardInfo);
  return builder_.Finish();
}

///-----------------------------------------------------------------------------
/// - STORE : Client <-> Game
///-----------------------------------------------------------------------------
struct ClientItemStackInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMID = 4,
    VT_STACKCOUNT = 6
  };
  int32_t itemId() const {
    return GetField<int32_t>(VT_ITEMID, 0);
  }
  int32_t stackCount() const {
    return GetField<int32_t>(VT_STACKCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ITEMID) &&
           VerifyField<int32_t>(verifier, VT_STACKCOUNT) &&
           verifier.EndTable();
  }
};

struct ClientItemStackInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemId(int32_t itemId) {
    fbb_.AddElement<int32_t>(ClientItemStackInfo::VT_ITEMID, itemId, 0);
  }
  void add_stackCount(int32_t stackCount) {
    fbb_.AddElement<int32_t>(ClientItemStackInfo::VT_STACKCOUNT, stackCount, 0);
  }
  explicit ClientItemStackInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClientItemStackInfoBuilder &operator=(const ClientItemStackInfoBuilder &);
  flatbuffers::Offset<ClientItemStackInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientItemStackInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClientItemStackInfo> CreateClientItemStackInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t itemId = 0,
    int32_t stackCount = 0) {
  ClientItemStackInfoBuilder builder_(_fbb);
  builder_.add_stackCount(stackCount);
  builder_.add_itemId(itemId);
  return builder_.Finish();
}

///- ITEM_SALE_REQUEST --------------
struct SaleItemRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCOBJECTID = 4,
    VT_SALEITEMS = 6
  };
  uint64_t pcObjectId() const {
    return GetField<uint64_t>(VT_PCOBJECTID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ClientSItem>> *saleItems() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ClientSItem>> *>(VT_SALEITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PCOBJECTID) &&
           VerifyOffsetRequired(verifier, VT_SALEITEMS) &&
           verifier.VerifyVector(saleItems()) &&
           verifier.VerifyVectorOfTables(saleItems()) &&
           verifier.EndTable();
  }
};

struct SaleItemRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcObjectId(uint64_t pcObjectId) {
    fbb_.AddElement<uint64_t>(SaleItemRequest::VT_PCOBJECTID, pcObjectId, 0);
  }
  void add_saleItems(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ClientSItem>>> saleItems) {
    fbb_.AddOffset(SaleItemRequest::VT_SALEITEMS, saleItems);
  }
  explicit SaleItemRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SaleItemRequestBuilder &operator=(const SaleItemRequestBuilder &);
  flatbuffers::Offset<SaleItemRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SaleItemRequest>(end);
    fbb_.Required(o, SaleItemRequest::VT_SALEITEMS);
    return o;
  }
};

inline flatbuffers::Offset<SaleItemRequest> CreateSaleItemRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t pcObjectId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ClientSItem>>> saleItems = 0) {
  SaleItemRequestBuilder builder_(_fbb);
  builder_.add_pcObjectId(pcObjectId);
  builder_.add_saleItems(saleItems);
  return builder_.Finish();
}

inline flatbuffers::Offset<SaleItemRequest> CreateSaleItemRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t pcObjectId = 0,
    const std::vector<flatbuffers::Offset<ClientSItem>> *saleItems = nullptr) {
  return LeanPacket::CreateSaleItemRequest(
      _fbb,
      pcObjectId,
      saleItems ? _fbb.CreateVector<flatbuffers::Offset<ClientSItem>>(*saleItems) : 0);
}

///- ITEM_SALE_RESPONSE --------------
struct SaleItemResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_TOTALSALEVALUE = 6
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  int64_t totalSaleValue() const {
    return GetField<int64_t>(VT_TOTALSALEVALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int64_t>(verifier, VT_TOTALSALEVALUE) &&
           verifier.EndTable();
  }
};

struct SaleItemResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(SaleItemResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_totalSaleValue(int64_t totalSaleValue) {
    fbb_.AddElement<int64_t>(SaleItemResponse::VT_TOTALSALEVALUE, totalSaleValue, 0);
  }
  explicit SaleItemResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SaleItemResponseBuilder &operator=(const SaleItemResponseBuilder &);
  flatbuffers::Offset<SaleItemResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SaleItemResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<SaleItemResponse> CreateSaleItemResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    int64_t totalSaleValue = 0) {
  SaleItemResponseBuilder builder_(_fbb);
  builder_.add_totalSaleValue(totalSaleValue);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

///- UPDATE_PURSE_NOTIFY -----
struct UpdatePurseNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PURSEINFO = 4
  };
  const PurseInfo *purseInfo() const {
    return GetPointer<const PurseInfo *>(VT_PURSEINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PURSEINFO) &&
           verifier.VerifyTable(purseInfo()) &&
           verifier.EndTable();
  }
};

struct UpdatePurseNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_purseInfo(flatbuffers::Offset<PurseInfo> purseInfo) {
    fbb_.AddOffset(UpdatePurseNotify::VT_PURSEINFO, purseInfo);
  }
  explicit UpdatePurseNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UpdatePurseNotifyBuilder &operator=(const UpdatePurseNotifyBuilder &);
  flatbuffers::Offset<UpdatePurseNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UpdatePurseNotify>(end);
    fbb_.Required(o, UpdatePurseNotify::VT_PURSEINFO);
    return o;
  }
};

inline flatbuffers::Offset<UpdatePurseNotify> CreateUpdatePurseNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<PurseInfo> purseInfo = 0) {
  UpdatePurseNotifyBuilder builder_(_fbb);
  builder_.add_purseInfo(purseInfo);
  return builder_.Finish();
}

///- WORKOBJECT_SPAWN_NOTIFY --------------
/// 워크 오브젝트 스폰
struct WorkObjectSpawnNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_NPCID = 6,
    VT_SCENEID = 8,
    VT_POS = 10,
    VT_ANGLE = 12,
    VT_ISFIXEDHEIGHT = 14,
    VT_WORKSTATE = 16,
    VT_EVENTID = 18,
    VT_SPAWNREASON = 20
  };
  /// 워크 오브젝트 아이디
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int32_t npcId() const {
    return GetField<int32_t>(VT_NPCID, 0);
  }
  int32_t sceneId() const {
    return GetField<int32_t>(VT_SCENEID, 0);
  }
  const Pos *pos() const {
    return GetPointer<const Pos *>(VT_POS);
  }
  int16_t angle() const {
    return GetField<int16_t>(VT_ANGLE, 0);
  }
  bool isfixedHeight() const {
    return GetField<uint8_t>(VT_ISFIXEDHEIGHT, 0) != 0;
  }
  /// 워크오브젝트 타입별 상태
  int32_t workState() const {
    return GetField<int32_t>(VT_WORKSTATE, 0);
  }
  int32_t eventId() const {
    return GetField<int32_t>(VT_EVENTID, 0);
  }
  SpawnReason spawnReason() const {
    return static_cast<SpawnReason>(GetField<int32_t>(VT_SPAWNREASON, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int32_t>(verifier, VT_NPCID) &&
           VerifyField<int32_t>(verifier, VT_SCENEID) &&
           VerifyOffsetRequired(verifier, VT_POS) &&
           verifier.VerifyTable(pos()) &&
           VerifyField<int16_t>(verifier, VT_ANGLE) &&
           VerifyField<uint8_t>(verifier, VT_ISFIXEDHEIGHT) &&
           VerifyField<int32_t>(verifier, VT_WORKSTATE) &&
           VerifyField<int32_t>(verifier, VT_EVENTID) &&
           VerifyField<int32_t>(verifier, VT_SPAWNREASON) &&
           verifier.EndTable();
  }
};

struct WorkObjectSpawnNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(WorkObjectSpawnNotify::VT_OBJECTID, objectId, 0);
  }
  void add_npcId(int32_t npcId) {
    fbb_.AddElement<int32_t>(WorkObjectSpawnNotify::VT_NPCID, npcId, 0);
  }
  void add_sceneId(int32_t sceneId) {
    fbb_.AddElement<int32_t>(WorkObjectSpawnNotify::VT_SCENEID, sceneId, 0);
  }
  void add_pos(flatbuffers::Offset<Pos> pos) {
    fbb_.AddOffset(WorkObjectSpawnNotify::VT_POS, pos);
  }
  void add_angle(int16_t angle) {
    fbb_.AddElement<int16_t>(WorkObjectSpawnNotify::VT_ANGLE, angle, 0);
  }
  void add_isfixedHeight(bool isfixedHeight) {
    fbb_.AddElement<uint8_t>(WorkObjectSpawnNotify::VT_ISFIXEDHEIGHT, static_cast<uint8_t>(isfixedHeight), 0);
  }
  void add_workState(int32_t workState) {
    fbb_.AddElement<int32_t>(WorkObjectSpawnNotify::VT_WORKSTATE, workState, 0);
  }
  void add_eventId(int32_t eventId) {
    fbb_.AddElement<int32_t>(WorkObjectSpawnNotify::VT_EVENTID, eventId, 0);
  }
  void add_spawnReason(SpawnReason spawnReason) {
    fbb_.AddElement<int32_t>(WorkObjectSpawnNotify::VT_SPAWNREASON, static_cast<int32_t>(spawnReason), 0);
  }
  explicit WorkObjectSpawnNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WorkObjectSpawnNotifyBuilder &operator=(const WorkObjectSpawnNotifyBuilder &);
  flatbuffers::Offset<WorkObjectSpawnNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WorkObjectSpawnNotify>(end);
    fbb_.Required(o, WorkObjectSpawnNotify::VT_POS);
    return o;
  }
};

inline flatbuffers::Offset<WorkObjectSpawnNotify> CreateWorkObjectSpawnNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int32_t npcId = 0,
    int32_t sceneId = 0,
    flatbuffers::Offset<Pos> pos = 0,
    int16_t angle = 0,
    bool isfixedHeight = false,
    int32_t workState = 0,
    int32_t eventId = 0,
    SpawnReason spawnReason = SpawnReason_SP_ON_SPAWNED) {
  WorkObjectSpawnNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_spawnReason(spawnReason);
  builder_.add_eventId(eventId);
  builder_.add_workState(workState);
  builder_.add_pos(pos);
  builder_.add_sceneId(sceneId);
  builder_.add_npcId(npcId);
  builder_.add_angle(angle);
  builder_.add_isfixedHeight(isfixedHeight);
  return builder_.Finish();
}

///- WORKOBJECT_UPDATE_NOTIFY --------------
/// 워크 오브젝트 상태 갱신
struct WorkObjectUpdateNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_WORKSTATE = 6
  };
  /// 워크 오브젝트 아이디
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  /// 워크오브젝트 타입별 상태
  int32_t workState() const {
    return GetField<int32_t>(VT_WORKSTATE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int32_t>(verifier, VT_WORKSTATE) &&
           verifier.EndTable();
  }
};

struct WorkObjectUpdateNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(WorkObjectUpdateNotify::VT_OBJECTID, objectId, 0);
  }
  void add_workState(int32_t workState) {
    fbb_.AddElement<int32_t>(WorkObjectUpdateNotify::VT_WORKSTATE, workState, 0);
  }
  explicit WorkObjectUpdateNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WorkObjectUpdateNotifyBuilder &operator=(const WorkObjectUpdateNotifyBuilder &);
  flatbuffers::Offset<WorkObjectUpdateNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WorkObjectUpdateNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<WorkObjectUpdateNotify> CreateWorkObjectUpdateNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int32_t workState = 0) {
  WorkObjectUpdateNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_workState(workState);
  return builder_.Finish();
}

///- INTERACTION_STATE_NOTIFY -------------------
struct InteractionStateNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_NPCTYPE = 6,
    VT_INTERACTIONSTATE = 8
  };
  /// 대상 오브젝트 아이디
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  /// 오브젝트의 Npc 타입
  int32_t npcType() const {
    return GetField<int32_t>(VT_NPCTYPE, 0);
  }
  /// 인터랙션 상태
  InteractionState interactionState() const {
    return static_cast<InteractionState>(GetField<int32_t>(VT_INTERACTIONSTATE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int32_t>(verifier, VT_NPCTYPE) &&
           VerifyField<int32_t>(verifier, VT_INTERACTIONSTATE) &&
           verifier.EndTable();
  }
};

struct InteractionStateNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(InteractionStateNotify::VT_OBJECTID, objectId, 0);
  }
  void add_npcType(int32_t npcType) {
    fbb_.AddElement<int32_t>(InteractionStateNotify::VT_NPCTYPE, npcType, 0);
  }
  void add_interactionState(InteractionState interactionState) {
    fbb_.AddElement<int32_t>(InteractionStateNotify::VT_INTERACTIONSTATE, static_cast<int32_t>(interactionState), 0);
  }
  explicit InteractionStateNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InteractionStateNotifyBuilder &operator=(const InteractionStateNotifyBuilder &);
  flatbuffers::Offset<InteractionStateNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InteractionStateNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<InteractionStateNotify> CreateInteractionStateNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int32_t npcType = 0,
    InteractionState interactionState = InteractionState_GT_CANNOT_INTERACTION) {
  InteractionStateNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_interactionState(interactionState);
  builder_.add_npcType(npcType);
  return builder_.Finish();
}

///- START_INTERACTION_REQUEST --------------
struct StartInteractionRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCOBJECTID = 4,
    VT_INTERACTIONTYPE = 6,
    VT_OBJECTID = 8,
    VT_CURPOS = 10,
    VT_MOVETYPE = 12
  };
  /// 채집을 하는 PC or UPC 오브젝트 아이디
  int64_t pcObjectId() const {
    return GetField<int64_t>(VT_PCOBJECTID, 0);
  }
  /// 인터렉션 타입(Interaction 테이블의 type 값)
  int8_t interactionType() const {
    return GetField<int8_t>(VT_INTERACTIONTYPE, 0);
  }
  /// 인터렉션 할 오브젝트 아이디
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  const Pos *curPos() const {
    return GetPointer<const Pos *>(VT_CURPOS);
  }
  int32_t moveType() const {
    return GetField<int32_t>(VT_MOVETYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PCOBJECTID) &&
           VerifyField<int8_t>(verifier, VT_INTERACTIONTYPE) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyOffsetRequired(verifier, VT_CURPOS) &&
           verifier.VerifyTable(curPos()) &&
           VerifyField<int32_t>(verifier, VT_MOVETYPE) &&
           verifier.EndTable();
  }
};

struct StartInteractionRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcObjectId(int64_t pcObjectId) {
    fbb_.AddElement<int64_t>(StartInteractionRequest::VT_PCOBJECTID, pcObjectId, 0);
  }
  void add_interactionType(int8_t interactionType) {
    fbb_.AddElement<int8_t>(StartInteractionRequest::VT_INTERACTIONTYPE, interactionType, 0);
  }
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(StartInteractionRequest::VT_OBJECTID, objectId, 0);
  }
  void add_curPos(flatbuffers::Offset<Pos> curPos) {
    fbb_.AddOffset(StartInteractionRequest::VT_CURPOS, curPos);
  }
  void add_moveType(int32_t moveType) {
    fbb_.AddElement<int32_t>(StartInteractionRequest::VT_MOVETYPE, moveType, 0);
  }
  explicit StartInteractionRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StartInteractionRequestBuilder &operator=(const StartInteractionRequestBuilder &);
  flatbuffers::Offset<StartInteractionRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StartInteractionRequest>(end);
    fbb_.Required(o, StartInteractionRequest::VT_CURPOS);
    return o;
  }
};

inline flatbuffers::Offset<StartInteractionRequest> CreateStartInteractionRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcObjectId = 0,
    int8_t interactionType = 0,
    int64_t objectId = 0,
    flatbuffers::Offset<Pos> curPos = 0,
    int32_t moveType = 0) {
  StartInteractionRequestBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_pcObjectId(pcObjectId);
  builder_.add_moveType(moveType);
  builder_.add_curPos(curPos);
  builder_.add_interactionType(interactionType);
  return builder_.Finish();
}

///- START_MINIGAME_INTERACTION_NOTIFY --------------
struct StartMiniGameInteractionNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCOBJECTID = 4,
    VT_OBJECTID = 6,
    VT_INTERACTIONTYPE = 8,
    VT_RUNMINIGAME = 10,
    VT_REMAINTICK = 12
  };
  /// 채집을 하는 PC or UPC 오브젝트 아이디
  int64_t pcObjectId() const {
    return GetField<int64_t>(VT_PCOBJECTID, 0);
  }
  /// 인터렉션 할 오브젝트 아이디
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  /// 인터렉션 타입(Interaction 테이블의 type 값)
  int8_t interactionType() const {
    return GetField<int8_t>(VT_INTERACTIONTYPE, 0);
  }
  /// 미니게임을 해야 하는지
  bool runMiniGame() const {
    return GetField<uint8_t>(VT_RUNMINIGAME, 0) != 0;
  }
  /// 인터렉션에 남은 시간(ms)
  int32_t remainTick() const {
    return GetField<int32_t>(VT_REMAINTICK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PCOBJECTID) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int8_t>(verifier, VT_INTERACTIONTYPE) &&
           VerifyField<uint8_t>(verifier, VT_RUNMINIGAME) &&
           VerifyField<int32_t>(verifier, VT_REMAINTICK) &&
           verifier.EndTable();
  }
};

struct StartMiniGameInteractionNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcObjectId(int64_t pcObjectId) {
    fbb_.AddElement<int64_t>(StartMiniGameInteractionNotify::VT_PCOBJECTID, pcObjectId, 0);
  }
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(StartMiniGameInteractionNotify::VT_OBJECTID, objectId, 0);
  }
  void add_interactionType(int8_t interactionType) {
    fbb_.AddElement<int8_t>(StartMiniGameInteractionNotify::VT_INTERACTIONTYPE, interactionType, 0);
  }
  void add_runMiniGame(bool runMiniGame) {
    fbb_.AddElement<uint8_t>(StartMiniGameInteractionNotify::VT_RUNMINIGAME, static_cast<uint8_t>(runMiniGame), 0);
  }
  void add_remainTick(int32_t remainTick) {
    fbb_.AddElement<int32_t>(StartMiniGameInteractionNotify::VT_REMAINTICK, remainTick, 0);
  }
  explicit StartMiniGameInteractionNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StartMiniGameInteractionNotifyBuilder &operator=(const StartMiniGameInteractionNotifyBuilder &);
  flatbuffers::Offset<StartMiniGameInteractionNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StartMiniGameInteractionNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<StartMiniGameInteractionNotify> CreateStartMiniGameInteractionNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcObjectId = 0,
    int64_t objectId = 0,
    int8_t interactionType = 0,
    bool runMiniGame = false,
    int32_t remainTick = 0) {
  StartMiniGameInteractionNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_pcObjectId(pcObjectId);
  builder_.add_remainTick(remainTick);
  builder_.add_runMiniGame(runMiniGame);
  builder_.add_interactionType(interactionType);
  return builder_.Finish();
}

struct StartDialogInteractionNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCOBJECTID = 4,
    VT_OBJECTID = 6,
    VT_INTERACTIONTYPE = 8,
    VT_DIALOGGROUPID = 10,
    VT_MAINSTREAMID = 12
  };
  /// 채집을 하는 PC or UPC 오브젝트 아이디
  int64_t pcObjectId() const {
    return GetField<int64_t>(VT_PCOBJECTID, 0);
  }
  /// 인터렉션 할 오브젝트 아이디
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  /// 인터렉션 타입(Interaction 테이블의 type 값)
  int8_t interactionType() const {
    return GetField<int8_t>(VT_INTERACTIONTYPE, 0);
  }
  /// 다이얼로그 그룹아이디
  int32_t dialogGroupId() const {
    return GetField<int32_t>(VT_DIALOGGROUPID, 0);
  }
  /// 진행 메인 스트림ID
  int32_t mainStreamId() const {
    return GetField<int32_t>(VT_MAINSTREAMID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PCOBJECTID) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int8_t>(verifier, VT_INTERACTIONTYPE) &&
           VerifyField<int32_t>(verifier, VT_DIALOGGROUPID) &&
           VerifyField<int32_t>(verifier, VT_MAINSTREAMID) &&
           verifier.EndTable();
  }
};

struct StartDialogInteractionNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcObjectId(int64_t pcObjectId) {
    fbb_.AddElement<int64_t>(StartDialogInteractionNotify::VT_PCOBJECTID, pcObjectId, 0);
  }
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(StartDialogInteractionNotify::VT_OBJECTID, objectId, 0);
  }
  void add_interactionType(int8_t interactionType) {
    fbb_.AddElement<int8_t>(StartDialogInteractionNotify::VT_INTERACTIONTYPE, interactionType, 0);
  }
  void add_dialogGroupId(int32_t dialogGroupId) {
    fbb_.AddElement<int32_t>(StartDialogInteractionNotify::VT_DIALOGGROUPID, dialogGroupId, 0);
  }
  void add_mainStreamId(int32_t mainStreamId) {
    fbb_.AddElement<int32_t>(StartDialogInteractionNotify::VT_MAINSTREAMID, mainStreamId, 0);
  }
  explicit StartDialogInteractionNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StartDialogInteractionNotifyBuilder &operator=(const StartDialogInteractionNotifyBuilder &);
  flatbuffers::Offset<StartDialogInteractionNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StartDialogInteractionNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<StartDialogInteractionNotify> CreateStartDialogInteractionNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcObjectId = 0,
    int64_t objectId = 0,
    int8_t interactionType = 0,
    int32_t dialogGroupId = 0,
    int32_t mainStreamId = 0) {
  StartDialogInteractionNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_pcObjectId(pcObjectId);
  builder_.add_mainStreamId(mainStreamId);
  builder_.add_dialogGroupId(dialogGroupId);
  builder_.add_interactionType(interactionType);
  return builder_.Finish();
}

///- OTHER_PC_START_INTERACTION_NOTIFY --------------
struct OtherPcStartInteractionNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_TARGETID = 6,
    VT_NPCTYPE = 8,
    VT_INTERACTIONTYPE = 10
  };
  /// 인터렉션 하는 오브젝트의 아이디
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  /// 인터렉션 당하는 오브젝트의 아이디
  int64_t targetId() const {
    return GetField<int64_t>(VT_TARGETID, 0);
  }
  /// 인터렉션 당하는 오브젝트의 Npc 타입
  int32_t npcType() const {
    return GetField<int32_t>(VT_NPCTYPE, 0);
  }
  /// 인터렉션 타입(Interaction 테이블의 type 값)
  int8_t interactionType() const {
    return GetField<int8_t>(VT_INTERACTIONTYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int64_t>(verifier, VT_TARGETID) &&
           VerifyField<int32_t>(verifier, VT_NPCTYPE) &&
           VerifyField<int8_t>(verifier, VT_INTERACTIONTYPE) &&
           verifier.EndTable();
  }
};

struct OtherPcStartInteractionNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(OtherPcStartInteractionNotify::VT_OBJECTID, objectId, 0);
  }
  void add_targetId(int64_t targetId) {
    fbb_.AddElement<int64_t>(OtherPcStartInteractionNotify::VT_TARGETID, targetId, 0);
  }
  void add_npcType(int32_t npcType) {
    fbb_.AddElement<int32_t>(OtherPcStartInteractionNotify::VT_NPCTYPE, npcType, 0);
  }
  void add_interactionType(int8_t interactionType) {
    fbb_.AddElement<int8_t>(OtherPcStartInteractionNotify::VT_INTERACTIONTYPE, interactionType, 0);
  }
  explicit OtherPcStartInteractionNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OtherPcStartInteractionNotifyBuilder &operator=(const OtherPcStartInteractionNotifyBuilder &);
  flatbuffers::Offset<OtherPcStartInteractionNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OtherPcStartInteractionNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<OtherPcStartInteractionNotify> CreateOtherPcStartInteractionNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int64_t targetId = 0,
    int32_t npcType = 0,
    int8_t interactionType = 0) {
  OtherPcStartInteractionNotifyBuilder builder_(_fbb);
  builder_.add_targetId(targetId);
  builder_.add_objectId(objectId);
  builder_.add_npcType(npcType);
  builder_.add_interactionType(interactionType);
  return builder_.Finish();
}

///- MINIGAME_INTERACTION_RESULT_NOTIFY --------------
struct MiniGameInteractionResultNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCOBJECTID = 4,
    VT_RANK = 6,
    VT_GAUGEPOINT = 8
  };
  int64_t pcObjectId() const {
    return GetField<int64_t>(VT_PCOBJECTID, 0);
  }
  /// 미니게임 판정 결과
  MiniGameRankType rank() const {
    return static_cast<MiniGameRankType>(GetField<int32_t>(VT_RANK, 0));
  }
  /// 유저가 터치한 게이지 시점
  int32_t gaugePoint() const {
    return GetField<int32_t>(VT_GAUGEPOINT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PCOBJECTID) &&
           VerifyField<int32_t>(verifier, VT_RANK) &&
           VerifyField<int32_t>(verifier, VT_GAUGEPOINT) &&
           verifier.EndTable();
  }
};

struct MiniGameInteractionResultNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcObjectId(int64_t pcObjectId) {
    fbb_.AddElement<int64_t>(MiniGameInteractionResultNotify::VT_PCOBJECTID, pcObjectId, 0);
  }
  void add_rank(MiniGameRankType rank) {
    fbb_.AddElement<int32_t>(MiniGameInteractionResultNotify::VT_RANK, static_cast<int32_t>(rank), 0);
  }
  void add_gaugePoint(int32_t gaugePoint) {
    fbb_.AddElement<int32_t>(MiniGameInteractionResultNotify::VT_GAUGEPOINT, gaugePoint, 0);
  }
  explicit MiniGameInteractionResultNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MiniGameInteractionResultNotifyBuilder &operator=(const MiniGameInteractionResultNotifyBuilder &);
  flatbuffers::Offset<MiniGameInteractionResultNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MiniGameInteractionResultNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<MiniGameInteractionResultNotify> CreateMiniGameInteractionResultNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcObjectId = 0,
    MiniGameRankType rank = MiniGameRankType_MGRT_NONE,
    int32_t gaugePoint = 0) {
  MiniGameInteractionResultNotifyBuilder builder_(_fbb);
  builder_.add_pcObjectId(pcObjectId);
  builder_.add_gaugePoint(gaugePoint);
  builder_.add_rank(rank);
  return builder_.Finish();
}

///- CANCEL_INTERACTION_NOTIFY --------------
struct CancelInteractionNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCOBJECTID = 4
  };
  int64_t pcObjectId() const {
    return GetField<int64_t>(VT_PCOBJECTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PCOBJECTID) &&
           verifier.EndTable();
  }
};

struct CancelInteractionNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcObjectId(int64_t pcObjectId) {
    fbb_.AddElement<int64_t>(CancelInteractionNotify::VT_PCOBJECTID, pcObjectId, 0);
  }
  explicit CancelInteractionNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CancelInteractionNotifyBuilder &operator=(const CancelInteractionNotifyBuilder &);
  flatbuffers::Offset<CancelInteractionNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CancelInteractionNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<CancelInteractionNotify> CreateCancelInteractionNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcObjectId = 0) {
  CancelInteractionNotifyBuilder builder_(_fbb);
  builder_.add_pcObjectId(pcObjectId);
  return builder_.Finish();
}

///- END_INTERACTION_NOTIFY --------------
struct EndInteractionNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCOBJECTID = 4,
    VT_RESULT = 6,
    VT_REWARDTYPE = 8,
    VT_TARGETOBJECTID = 10
  };
  /// 채집을 하는 PC or UPC 오브젝트 아이디
  int64_t pcObjectId() const {
    return GetField<int64_t>(VT_PCOBJECTID, 0);
  }
  ErrorCode result() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_RESULT, 0));
  }
  InteractionRewardType rewardType() const {
    return static_cast<InteractionRewardType>(GetField<int32_t>(VT_REWARDTYPE, 0));
  }
  int64_t targetObjectId() const {
    return GetField<int64_t>(VT_TARGETOBJECTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PCOBJECTID) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           VerifyField<int32_t>(verifier, VT_REWARDTYPE) &&
           VerifyField<int64_t>(verifier, VT_TARGETOBJECTID) &&
           verifier.EndTable();
  }
};

struct EndInteractionNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcObjectId(int64_t pcObjectId) {
    fbb_.AddElement<int64_t>(EndInteractionNotify::VT_PCOBJECTID, pcObjectId, 0);
  }
  void add_result(ErrorCode result) {
    fbb_.AddElement<int32_t>(EndInteractionNotify::VT_RESULT, static_cast<int32_t>(result), 0);
  }
  void add_rewardType(InteractionRewardType rewardType) {
    fbb_.AddElement<int32_t>(EndInteractionNotify::VT_REWARDTYPE, static_cast<int32_t>(rewardType), 0);
  }
  void add_targetObjectId(int64_t targetObjectId) {
    fbb_.AddElement<int64_t>(EndInteractionNotify::VT_TARGETOBJECTID, targetObjectId, 0);
  }
  explicit EndInteractionNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EndInteractionNotifyBuilder &operator=(const EndInteractionNotifyBuilder &);
  flatbuffers::Offset<EndInteractionNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EndInteractionNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<EndInteractionNotify> CreateEndInteractionNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcObjectId = 0,
    ErrorCode result = ErrorCode_NONE,
    InteractionRewardType rewardType = InteractionRewardType_IRT_NONE,
    int64_t targetObjectId = 0) {
  EndInteractionNotifyBuilder builder_(_fbb);
  builder_.add_targetObjectId(targetObjectId);
  builder_.add_pcObjectId(pcObjectId);
  builder_.add_rewardType(rewardType);
  builder_.add_result(result);
  return builder_.Finish();
}

///- OTHER_PC_END_INTERACTION_NOTIFY --------------
struct OtherPcEndInteractionNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4
  };
  /// 인테렉션 하는 오브젝트의 아이디
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           verifier.EndTable();
  }
};

struct OtherPcEndInteractionNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(OtherPcEndInteractionNotify::VT_OBJECTID, objectId, 0);
  }
  explicit OtherPcEndInteractionNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OtherPcEndInteractionNotifyBuilder &operator=(const OtherPcEndInteractionNotifyBuilder &);
  flatbuffers::Offset<OtherPcEndInteractionNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OtherPcEndInteractionNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<OtherPcEndInteractionNotify> CreateOtherPcEndInteractionNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0) {
  OtherPcEndInteractionNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  return builder_.Finish();
}

/// 연출 카메라 시작
/// CAMERA_OBJECT_START_NOTIFY
struct CameraObjectStartNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_POS = 4,
    VT_LIFETICK = 6
  };
  const Pos *pos() const {
    return GetPointer<const Pos *>(VT_POS);
  }
  int32_t lifeTick() const {
    return GetField<int32_t>(VT_LIFETICK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_POS) &&
           verifier.VerifyTable(pos()) &&
           VerifyField<int32_t>(verifier, VT_LIFETICK) &&
           verifier.EndTable();
  }
};

struct CameraObjectStartNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pos(flatbuffers::Offset<Pos> pos) {
    fbb_.AddOffset(CameraObjectStartNotify::VT_POS, pos);
  }
  void add_lifeTick(int32_t lifeTick) {
    fbb_.AddElement<int32_t>(CameraObjectStartNotify::VT_LIFETICK, lifeTick, 0);
  }
  explicit CameraObjectStartNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CameraObjectStartNotifyBuilder &operator=(const CameraObjectStartNotifyBuilder &);
  flatbuffers::Offset<CameraObjectStartNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CameraObjectStartNotify>(end);
    fbb_.Required(o, CameraObjectStartNotify::VT_POS);
    return o;
  }
};

inline flatbuffers::Offset<CameraObjectStartNotify> CreateCameraObjectStartNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Pos> pos = 0,
    int32_t lifeTick = 0) {
  CameraObjectStartNotifyBuilder builder_(_fbb);
  builder_.add_lifeTick(lifeTick);
  builder_.add_pos(pos);
  return builder_.Finish();
}

/// 연출 카메라 종료
/// CAMERA_OBJECT_END_NOTIFY
struct CameraObjectEndNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CameraObjectEndNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CameraObjectEndNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CameraObjectEndNotifyBuilder &operator=(const CameraObjectEndNotifyBuilder &);
  flatbuffers::Offset<CameraObjectEndNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CameraObjectEndNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<CameraObjectEndNotify> CreateCameraObjectEndNotify(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CameraObjectEndNotifyBuilder builder_(_fbb);
  return builder_.Finish();
}

/// 연출 카메라 이동
/// CAMERA_OBJECT_MOVE_NOTIFY
struct CameraObjectMoveNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_POS = 4
  };
  const Pos *pos() const {
    return GetPointer<const Pos *>(VT_POS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_POS) &&
           verifier.VerifyTable(pos()) &&
           verifier.EndTable();
  }
};

struct CameraObjectMoveNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pos(flatbuffers::Offset<Pos> pos) {
    fbb_.AddOffset(CameraObjectMoveNotify::VT_POS, pos);
  }
  explicit CameraObjectMoveNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CameraObjectMoveNotifyBuilder &operator=(const CameraObjectMoveNotifyBuilder &);
  flatbuffers::Offset<CameraObjectMoveNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CameraObjectMoveNotify>(end);
    fbb_.Required(o, CameraObjectMoveNotify::VT_POS);
    return o;
  }
};

inline flatbuffers::Offset<CameraObjectMoveNotify> CreateCameraObjectMoveNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Pos> pos = 0) {
  CameraObjectMoveNotifyBuilder builder_(_fbb);
  builder_.add_pos(pos);
  return builder_.Finish();
}

struct Stats FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PHYSICALATTACK = 4,
    VT_MAGICATTACK = 6,
    VT_CRITICALSTRIKECHANCE = 8,
    VT_ATTACKSPEEDRATE = 10,
    VT_PHYSICALATTACKDAMAGERATE = 12,
    VT_MAGICATTACKDAMAGERATE = 14,
    VT_ARMORPENETRATIONRATE = 16,
    VT_MAGICARMORPENETRATIONRATE = 18,
    VT_DAMAGEREFLECTION = 20,
    VT_TRIPLEDAMAGECHANCE = 22,
    VT_PENTADAMAGECHANCE = 24,
    VT_TRUEDAMAGERATE = 26,
    VT_AFTERSKILLDAMAGEBOOSTRATE = 28,
    VT_PVPPENETRATIONRATE = 30,
    VT_PVETRUEDAMAGE = 32,
    VT_BOSSPENETRATIONRATE = 34,
    VT_HEALTH = 36,
    VT_ARMOR = 38,
    VT_MAGICARMOR = 40,
    VT_LIFEREGENERATEPERSECOND = 42,
    VT_PHYSICALDAMAGEREDUCTION = 44,
    VT_MAGICDAMAGEREDUCTION = 46,
    VT_CRITICALSTRIKEREDUCTION = 48,
    VT_CRITICALDAMAGEREDUCTION = 50,
    VT_POISONRESISTENCE = 52,
    VT_ICERESISTENCE = 54,
    VT_FIRERESISTENCE = 56,
    VT_ALLRESISTENCE = 58,
    VT_LIFESTEALRATE = 60,
    VT_PVPDAMAGEREDUCTION = 62,
    VT_PVEDAMAGEIGNORANCE = 64,
    VT_BOSSDAMAGERESISTANCE = 66,
    VT_MOVESPEEDRATE = 68,
    VT_TENACITY = 70,
    VT_COOLDOWNREDUCTIONRATE = 72,
    VT_ADDVITALENERGY = 74,
    VT_ADDEXP = 76,
    VT_ADDGOLD = 78,
    VT_ADDDROPCHANCE = 80
  };
  int32_t physicalAttack() const {
    return GetField<int32_t>(VT_PHYSICALATTACK, 0);
  }
  int32_t magicAttack() const {
    return GetField<int32_t>(VT_MAGICATTACK, 0);
  }
  int32_t criticalStrikeChance() const {
    return GetField<int32_t>(VT_CRITICALSTRIKECHANCE, 0);
  }
  int32_t attackSpeedRate() const {
    return GetField<int32_t>(VT_ATTACKSPEEDRATE, 0);
  }
  int32_t physicalAttackDamageRate() const {
    return GetField<int32_t>(VT_PHYSICALATTACKDAMAGERATE, 0);
  }
  int32_t magicAttackDamageRate() const {
    return GetField<int32_t>(VT_MAGICATTACKDAMAGERATE, 0);
  }
  int32_t armorPenetrationRate() const {
    return GetField<int32_t>(VT_ARMORPENETRATIONRATE, 0);
  }
  int32_t magicArmorPenetrationRate() const {
    return GetField<int32_t>(VT_MAGICARMORPENETRATIONRATE, 0);
  }
  int32_t damageReflection() const {
    return GetField<int32_t>(VT_DAMAGEREFLECTION, 0);
  }
  int32_t tripleDamageChance() const {
    return GetField<int32_t>(VT_TRIPLEDAMAGECHANCE, 0);
  }
  int32_t pentaDamageChance() const {
    return GetField<int32_t>(VT_PENTADAMAGECHANCE, 0);
  }
  int32_t trueDamageRate() const {
    return GetField<int32_t>(VT_TRUEDAMAGERATE, 0);
  }
  int32_t afterSkillDamageBoostRate() const {
    return GetField<int32_t>(VT_AFTERSKILLDAMAGEBOOSTRATE, 0);
  }
  int32_t pvpPenetrationRate() const {
    return GetField<int32_t>(VT_PVPPENETRATIONRATE, 0);
  }
  int32_t pveTrueDamage() const {
    return GetField<int32_t>(VT_PVETRUEDAMAGE, 0);
  }
  int32_t bossPenetrationRate() const {
    return GetField<int32_t>(VT_BOSSPENETRATIONRATE, 0);
  }
  int32_t health() const {
    return GetField<int32_t>(VT_HEALTH, 0);
  }
  int32_t armor() const {
    return GetField<int32_t>(VT_ARMOR, 0);
  }
  int32_t magicArmor() const {
    return GetField<int32_t>(VT_MAGICARMOR, 0);
  }
  int32_t lifeRegeneratePerSecond() const {
    return GetField<int32_t>(VT_LIFEREGENERATEPERSECOND, 0);
  }
  int32_t physicalDamageReduction() const {
    return GetField<int32_t>(VT_PHYSICALDAMAGEREDUCTION, 0);
  }
  int32_t magicDamageReduction() const {
    return GetField<int32_t>(VT_MAGICDAMAGEREDUCTION, 0);
  }
  int32_t criticalStrikeReduction() const {
    return GetField<int32_t>(VT_CRITICALSTRIKEREDUCTION, 0);
  }
  int32_t criticalDamageReduction() const {
    return GetField<int32_t>(VT_CRITICALDAMAGEREDUCTION, 0);
  }
  int32_t poisonResistence() const {
    return GetField<int32_t>(VT_POISONRESISTENCE, 0);
  }
  int32_t iceResistence() const {
    return GetField<int32_t>(VT_ICERESISTENCE, 0);
  }
  int32_t fireResistence() const {
    return GetField<int32_t>(VT_FIRERESISTENCE, 0);
  }
  int32_t allResistence() const {
    return GetField<int32_t>(VT_ALLRESISTENCE, 0);
  }
  int32_t lifeStealRate() const {
    return GetField<int32_t>(VT_LIFESTEALRATE, 0);
  }
  int32_t pvpDamageReduction() const {
    return GetField<int32_t>(VT_PVPDAMAGEREDUCTION, 0);
  }
  int32_t pveDamageIgnorance() const {
    return GetField<int32_t>(VT_PVEDAMAGEIGNORANCE, 0);
  }
  int32_t bossDamageResistance() const {
    return GetField<int32_t>(VT_BOSSDAMAGERESISTANCE, 0);
  }
  int32_t moveSpeedRate() const {
    return GetField<int32_t>(VT_MOVESPEEDRATE, 0);
  }
  int32_t tenacity() const {
    return GetField<int32_t>(VT_TENACITY, 0);
  }
  int32_t cooldownReductionRate() const {
    return GetField<int32_t>(VT_COOLDOWNREDUCTIONRATE, 0);
  }
  int32_t addVitalEnergy() const {
    return GetField<int32_t>(VT_ADDVITALENERGY, 0);
  }
  int32_t addExp() const {
    return GetField<int32_t>(VT_ADDEXP, 0);
  }
  int32_t addGold() const {
    return GetField<int32_t>(VT_ADDGOLD, 0);
  }
  int32_t addDropChance() const {
    return GetField<int32_t>(VT_ADDDROPCHANCE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PHYSICALATTACK) &&
           VerifyField<int32_t>(verifier, VT_MAGICATTACK) &&
           VerifyField<int32_t>(verifier, VT_CRITICALSTRIKECHANCE) &&
           VerifyField<int32_t>(verifier, VT_ATTACKSPEEDRATE) &&
           VerifyField<int32_t>(verifier, VT_PHYSICALATTACKDAMAGERATE) &&
           VerifyField<int32_t>(verifier, VT_MAGICATTACKDAMAGERATE) &&
           VerifyField<int32_t>(verifier, VT_ARMORPENETRATIONRATE) &&
           VerifyField<int32_t>(verifier, VT_MAGICARMORPENETRATIONRATE) &&
           VerifyField<int32_t>(verifier, VT_DAMAGEREFLECTION) &&
           VerifyField<int32_t>(verifier, VT_TRIPLEDAMAGECHANCE) &&
           VerifyField<int32_t>(verifier, VT_PENTADAMAGECHANCE) &&
           VerifyField<int32_t>(verifier, VT_TRUEDAMAGERATE) &&
           VerifyField<int32_t>(verifier, VT_AFTERSKILLDAMAGEBOOSTRATE) &&
           VerifyField<int32_t>(verifier, VT_PVPPENETRATIONRATE) &&
           VerifyField<int32_t>(verifier, VT_PVETRUEDAMAGE) &&
           VerifyField<int32_t>(verifier, VT_BOSSPENETRATIONRATE) &&
           VerifyField<int32_t>(verifier, VT_HEALTH) &&
           VerifyField<int32_t>(verifier, VT_ARMOR) &&
           VerifyField<int32_t>(verifier, VT_MAGICARMOR) &&
           VerifyField<int32_t>(verifier, VT_LIFEREGENERATEPERSECOND) &&
           VerifyField<int32_t>(verifier, VT_PHYSICALDAMAGEREDUCTION) &&
           VerifyField<int32_t>(verifier, VT_MAGICDAMAGEREDUCTION) &&
           VerifyField<int32_t>(verifier, VT_CRITICALSTRIKEREDUCTION) &&
           VerifyField<int32_t>(verifier, VT_CRITICALDAMAGEREDUCTION) &&
           VerifyField<int32_t>(verifier, VT_POISONRESISTENCE) &&
           VerifyField<int32_t>(verifier, VT_ICERESISTENCE) &&
           VerifyField<int32_t>(verifier, VT_FIRERESISTENCE) &&
           VerifyField<int32_t>(verifier, VT_ALLRESISTENCE) &&
           VerifyField<int32_t>(verifier, VT_LIFESTEALRATE) &&
           VerifyField<int32_t>(verifier, VT_PVPDAMAGEREDUCTION) &&
           VerifyField<int32_t>(verifier, VT_PVEDAMAGEIGNORANCE) &&
           VerifyField<int32_t>(verifier, VT_BOSSDAMAGERESISTANCE) &&
           VerifyField<int32_t>(verifier, VT_MOVESPEEDRATE) &&
           VerifyField<int32_t>(verifier, VT_TENACITY) &&
           VerifyField<int32_t>(verifier, VT_COOLDOWNREDUCTIONRATE) &&
           VerifyField<int32_t>(verifier, VT_ADDVITALENERGY) &&
           VerifyField<int32_t>(verifier, VT_ADDEXP) &&
           VerifyField<int32_t>(verifier, VT_ADDGOLD) &&
           VerifyField<int32_t>(verifier, VT_ADDDROPCHANCE) &&
           verifier.EndTable();
  }
};

struct StatsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_physicalAttack(int32_t physicalAttack) {
    fbb_.AddElement<int32_t>(Stats::VT_PHYSICALATTACK, physicalAttack, 0);
  }
  void add_magicAttack(int32_t magicAttack) {
    fbb_.AddElement<int32_t>(Stats::VT_MAGICATTACK, magicAttack, 0);
  }
  void add_criticalStrikeChance(int32_t criticalStrikeChance) {
    fbb_.AddElement<int32_t>(Stats::VT_CRITICALSTRIKECHANCE, criticalStrikeChance, 0);
  }
  void add_attackSpeedRate(int32_t attackSpeedRate) {
    fbb_.AddElement<int32_t>(Stats::VT_ATTACKSPEEDRATE, attackSpeedRate, 0);
  }
  void add_physicalAttackDamageRate(int32_t physicalAttackDamageRate) {
    fbb_.AddElement<int32_t>(Stats::VT_PHYSICALATTACKDAMAGERATE, physicalAttackDamageRate, 0);
  }
  void add_magicAttackDamageRate(int32_t magicAttackDamageRate) {
    fbb_.AddElement<int32_t>(Stats::VT_MAGICATTACKDAMAGERATE, magicAttackDamageRate, 0);
  }
  void add_armorPenetrationRate(int32_t armorPenetrationRate) {
    fbb_.AddElement<int32_t>(Stats::VT_ARMORPENETRATIONRATE, armorPenetrationRate, 0);
  }
  void add_magicArmorPenetrationRate(int32_t magicArmorPenetrationRate) {
    fbb_.AddElement<int32_t>(Stats::VT_MAGICARMORPENETRATIONRATE, magicArmorPenetrationRate, 0);
  }
  void add_damageReflection(int32_t damageReflection) {
    fbb_.AddElement<int32_t>(Stats::VT_DAMAGEREFLECTION, damageReflection, 0);
  }
  void add_tripleDamageChance(int32_t tripleDamageChance) {
    fbb_.AddElement<int32_t>(Stats::VT_TRIPLEDAMAGECHANCE, tripleDamageChance, 0);
  }
  void add_pentaDamageChance(int32_t pentaDamageChance) {
    fbb_.AddElement<int32_t>(Stats::VT_PENTADAMAGECHANCE, pentaDamageChance, 0);
  }
  void add_trueDamageRate(int32_t trueDamageRate) {
    fbb_.AddElement<int32_t>(Stats::VT_TRUEDAMAGERATE, trueDamageRate, 0);
  }
  void add_afterSkillDamageBoostRate(int32_t afterSkillDamageBoostRate) {
    fbb_.AddElement<int32_t>(Stats::VT_AFTERSKILLDAMAGEBOOSTRATE, afterSkillDamageBoostRate, 0);
  }
  void add_pvpPenetrationRate(int32_t pvpPenetrationRate) {
    fbb_.AddElement<int32_t>(Stats::VT_PVPPENETRATIONRATE, pvpPenetrationRate, 0);
  }
  void add_pveTrueDamage(int32_t pveTrueDamage) {
    fbb_.AddElement<int32_t>(Stats::VT_PVETRUEDAMAGE, pveTrueDamage, 0);
  }
  void add_bossPenetrationRate(int32_t bossPenetrationRate) {
    fbb_.AddElement<int32_t>(Stats::VT_BOSSPENETRATIONRATE, bossPenetrationRate, 0);
  }
  void add_health(int32_t health) {
    fbb_.AddElement<int32_t>(Stats::VT_HEALTH, health, 0);
  }
  void add_armor(int32_t armor) {
    fbb_.AddElement<int32_t>(Stats::VT_ARMOR, armor, 0);
  }
  void add_magicArmor(int32_t magicArmor) {
    fbb_.AddElement<int32_t>(Stats::VT_MAGICARMOR, magicArmor, 0);
  }
  void add_lifeRegeneratePerSecond(int32_t lifeRegeneratePerSecond) {
    fbb_.AddElement<int32_t>(Stats::VT_LIFEREGENERATEPERSECOND, lifeRegeneratePerSecond, 0);
  }
  void add_physicalDamageReduction(int32_t physicalDamageReduction) {
    fbb_.AddElement<int32_t>(Stats::VT_PHYSICALDAMAGEREDUCTION, physicalDamageReduction, 0);
  }
  void add_magicDamageReduction(int32_t magicDamageReduction) {
    fbb_.AddElement<int32_t>(Stats::VT_MAGICDAMAGEREDUCTION, magicDamageReduction, 0);
  }
  void add_criticalStrikeReduction(int32_t criticalStrikeReduction) {
    fbb_.AddElement<int32_t>(Stats::VT_CRITICALSTRIKEREDUCTION, criticalStrikeReduction, 0);
  }
  void add_criticalDamageReduction(int32_t criticalDamageReduction) {
    fbb_.AddElement<int32_t>(Stats::VT_CRITICALDAMAGEREDUCTION, criticalDamageReduction, 0);
  }
  void add_poisonResistence(int32_t poisonResistence) {
    fbb_.AddElement<int32_t>(Stats::VT_POISONRESISTENCE, poisonResistence, 0);
  }
  void add_iceResistence(int32_t iceResistence) {
    fbb_.AddElement<int32_t>(Stats::VT_ICERESISTENCE, iceResistence, 0);
  }
  void add_fireResistence(int32_t fireResistence) {
    fbb_.AddElement<int32_t>(Stats::VT_FIRERESISTENCE, fireResistence, 0);
  }
  void add_allResistence(int32_t allResistence) {
    fbb_.AddElement<int32_t>(Stats::VT_ALLRESISTENCE, allResistence, 0);
  }
  void add_lifeStealRate(int32_t lifeStealRate) {
    fbb_.AddElement<int32_t>(Stats::VT_LIFESTEALRATE, lifeStealRate, 0);
  }
  void add_pvpDamageReduction(int32_t pvpDamageReduction) {
    fbb_.AddElement<int32_t>(Stats::VT_PVPDAMAGEREDUCTION, pvpDamageReduction, 0);
  }
  void add_pveDamageIgnorance(int32_t pveDamageIgnorance) {
    fbb_.AddElement<int32_t>(Stats::VT_PVEDAMAGEIGNORANCE, pveDamageIgnorance, 0);
  }
  void add_bossDamageResistance(int32_t bossDamageResistance) {
    fbb_.AddElement<int32_t>(Stats::VT_BOSSDAMAGERESISTANCE, bossDamageResistance, 0);
  }
  void add_moveSpeedRate(int32_t moveSpeedRate) {
    fbb_.AddElement<int32_t>(Stats::VT_MOVESPEEDRATE, moveSpeedRate, 0);
  }
  void add_tenacity(int32_t tenacity) {
    fbb_.AddElement<int32_t>(Stats::VT_TENACITY, tenacity, 0);
  }
  void add_cooldownReductionRate(int32_t cooldownReductionRate) {
    fbb_.AddElement<int32_t>(Stats::VT_COOLDOWNREDUCTIONRATE, cooldownReductionRate, 0);
  }
  void add_addVitalEnergy(int32_t addVitalEnergy) {
    fbb_.AddElement<int32_t>(Stats::VT_ADDVITALENERGY, addVitalEnergy, 0);
  }
  void add_addExp(int32_t addExp) {
    fbb_.AddElement<int32_t>(Stats::VT_ADDEXP, addExp, 0);
  }
  void add_addGold(int32_t addGold) {
    fbb_.AddElement<int32_t>(Stats::VT_ADDGOLD, addGold, 0);
  }
  void add_addDropChance(int32_t addDropChance) {
    fbb_.AddElement<int32_t>(Stats::VT_ADDDROPCHANCE, addDropChance, 0);
  }
  explicit StatsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StatsBuilder &operator=(const StatsBuilder &);
  flatbuffers::Offset<Stats> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Stats>(end);
    return o;
  }
};

inline flatbuffers::Offset<Stats> CreateStats(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t physicalAttack = 0,
    int32_t magicAttack = 0,
    int32_t criticalStrikeChance = 0,
    int32_t attackSpeedRate = 0,
    int32_t physicalAttackDamageRate = 0,
    int32_t magicAttackDamageRate = 0,
    int32_t armorPenetrationRate = 0,
    int32_t magicArmorPenetrationRate = 0,
    int32_t damageReflection = 0,
    int32_t tripleDamageChance = 0,
    int32_t pentaDamageChance = 0,
    int32_t trueDamageRate = 0,
    int32_t afterSkillDamageBoostRate = 0,
    int32_t pvpPenetrationRate = 0,
    int32_t pveTrueDamage = 0,
    int32_t bossPenetrationRate = 0,
    int32_t health = 0,
    int32_t armor = 0,
    int32_t magicArmor = 0,
    int32_t lifeRegeneratePerSecond = 0,
    int32_t physicalDamageReduction = 0,
    int32_t magicDamageReduction = 0,
    int32_t criticalStrikeReduction = 0,
    int32_t criticalDamageReduction = 0,
    int32_t poisonResistence = 0,
    int32_t iceResistence = 0,
    int32_t fireResistence = 0,
    int32_t allResistence = 0,
    int32_t lifeStealRate = 0,
    int32_t pvpDamageReduction = 0,
    int32_t pveDamageIgnorance = 0,
    int32_t bossDamageResistance = 0,
    int32_t moveSpeedRate = 0,
    int32_t tenacity = 0,
    int32_t cooldownReductionRate = 0,
    int32_t addVitalEnergy = 0,
    int32_t addExp = 0,
    int32_t addGold = 0,
    int32_t addDropChance = 0) {
  StatsBuilder builder_(_fbb);
  builder_.add_addDropChance(addDropChance);
  builder_.add_addGold(addGold);
  builder_.add_addExp(addExp);
  builder_.add_addVitalEnergy(addVitalEnergy);
  builder_.add_cooldownReductionRate(cooldownReductionRate);
  builder_.add_tenacity(tenacity);
  builder_.add_moveSpeedRate(moveSpeedRate);
  builder_.add_bossDamageResistance(bossDamageResistance);
  builder_.add_pveDamageIgnorance(pveDamageIgnorance);
  builder_.add_pvpDamageReduction(pvpDamageReduction);
  builder_.add_lifeStealRate(lifeStealRate);
  builder_.add_allResistence(allResistence);
  builder_.add_fireResistence(fireResistence);
  builder_.add_iceResistence(iceResistence);
  builder_.add_poisonResistence(poisonResistence);
  builder_.add_criticalDamageReduction(criticalDamageReduction);
  builder_.add_criticalStrikeReduction(criticalStrikeReduction);
  builder_.add_magicDamageReduction(magicDamageReduction);
  builder_.add_physicalDamageReduction(physicalDamageReduction);
  builder_.add_lifeRegeneratePerSecond(lifeRegeneratePerSecond);
  builder_.add_magicArmor(magicArmor);
  builder_.add_armor(armor);
  builder_.add_health(health);
  builder_.add_bossPenetrationRate(bossPenetrationRate);
  builder_.add_pveTrueDamage(pveTrueDamage);
  builder_.add_pvpPenetrationRate(pvpPenetrationRate);
  builder_.add_afterSkillDamageBoostRate(afterSkillDamageBoostRate);
  builder_.add_trueDamageRate(trueDamageRate);
  builder_.add_pentaDamageChance(pentaDamageChance);
  builder_.add_tripleDamageChance(tripleDamageChance);
  builder_.add_damageReflection(damageReflection);
  builder_.add_magicArmorPenetrationRate(magicArmorPenetrationRate);
  builder_.add_armorPenetrationRate(armorPenetrationRate);
  builder_.add_magicAttackDamageRate(magicAttackDamageRate);
  builder_.add_physicalAttackDamageRate(physicalAttackDamageRate);
  builder_.add_attackSpeedRate(attackSpeedRate);
  builder_.add_criticalStrikeChance(criticalStrikeChance);
  builder_.add_magicAttack(magicAttack);
  builder_.add_physicalAttack(physicalAttack);
  return builder_.Finish();
}

/// STAT_UPDATE_NOTIFY
struct StatUpdateNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_STATS = 6,
    VT_COMBATPOWER = 8,
    VT_DPS = 10,
    VT_EHP = 12,
    VT_BUFFCOMBATPOWER = 14,
    VT_PCSTATHARDCAPDATAS = 16
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  const Stats *stats() const {
    return GetPointer<const Stats *>(VT_STATS);
  }
  int32_t combatPower() const {
    return GetField<int32_t>(VT_COMBATPOWER, 0);
  }
  int32_t dps() const {
    return GetField<int32_t>(VT_DPS, 0);
  }
  int32_t ehp() const {
    return GetField<int32_t>(VT_EHP, 0);
  }
  int32_t buffCombatPower() const {
    return GetField<int32_t>(VT_BUFFCOMBATPOWER, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PcStatHardCapData>> *PcStatHardCapDatas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PcStatHardCapData>> *>(VT_PCSTATHARDCAPDATAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyOffsetRequired(verifier, VT_STATS) &&
           verifier.VerifyTable(stats()) &&
           VerifyField<int32_t>(verifier, VT_COMBATPOWER) &&
           VerifyField<int32_t>(verifier, VT_DPS) &&
           VerifyField<int32_t>(verifier, VT_EHP) &&
           VerifyField<int32_t>(verifier, VT_BUFFCOMBATPOWER) &&
           VerifyOffset(verifier, VT_PCSTATHARDCAPDATAS) &&
           verifier.VerifyVector(PcStatHardCapDatas()) &&
           verifier.VerifyVectorOfTables(PcStatHardCapDatas()) &&
           verifier.EndTable();
  }
};

struct StatUpdateNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(StatUpdateNotify::VT_OBJECTID, objectId, 0);
  }
  void add_stats(flatbuffers::Offset<Stats> stats) {
    fbb_.AddOffset(StatUpdateNotify::VT_STATS, stats);
  }
  void add_combatPower(int32_t combatPower) {
    fbb_.AddElement<int32_t>(StatUpdateNotify::VT_COMBATPOWER, combatPower, 0);
  }
  void add_dps(int32_t dps) {
    fbb_.AddElement<int32_t>(StatUpdateNotify::VT_DPS, dps, 0);
  }
  void add_ehp(int32_t ehp) {
    fbb_.AddElement<int32_t>(StatUpdateNotify::VT_EHP, ehp, 0);
  }
  void add_buffCombatPower(int32_t buffCombatPower) {
    fbb_.AddElement<int32_t>(StatUpdateNotify::VT_BUFFCOMBATPOWER, buffCombatPower, 0);
  }
  void add_PcStatHardCapDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PcStatHardCapData>>> PcStatHardCapDatas) {
    fbb_.AddOffset(StatUpdateNotify::VT_PCSTATHARDCAPDATAS, PcStatHardCapDatas);
  }
  explicit StatUpdateNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StatUpdateNotifyBuilder &operator=(const StatUpdateNotifyBuilder &);
  flatbuffers::Offset<StatUpdateNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StatUpdateNotify>(end);
    fbb_.Required(o, StatUpdateNotify::VT_STATS);
    return o;
  }
};

inline flatbuffers::Offset<StatUpdateNotify> CreateStatUpdateNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    flatbuffers::Offset<Stats> stats = 0,
    int32_t combatPower = 0,
    int32_t dps = 0,
    int32_t ehp = 0,
    int32_t buffCombatPower = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PcStatHardCapData>>> PcStatHardCapDatas = 0) {
  StatUpdateNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_PcStatHardCapDatas(PcStatHardCapDatas);
  builder_.add_buffCombatPower(buffCombatPower);
  builder_.add_ehp(ehp);
  builder_.add_dps(dps);
  builder_.add_combatPower(combatPower);
  builder_.add_stats(stats);
  return builder_.Finish();
}

inline flatbuffers::Offset<StatUpdateNotify> CreateStatUpdateNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    flatbuffers::Offset<Stats> stats = 0,
    int32_t combatPower = 0,
    int32_t dps = 0,
    int32_t ehp = 0,
    int32_t buffCombatPower = 0,
    const std::vector<flatbuffers::Offset<PcStatHardCapData>> *PcStatHardCapDatas = nullptr) {
  return LeanPacket::CreateStatUpdateNotify(
      _fbb,
      objectId,
      stats,
      combatPower,
      dps,
      ehp,
      buffCombatPower,
      PcStatHardCapDatas ? _fbb.CreateVector<flatbuffers::Offset<PcStatHardCapData>>(*PcStatHardCapDatas) : 0);
}

/// AI_ACTION_START_NOTIFY
struct AiActionStartNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_GROUPID = 6,
    VT_ACTIONID = 8
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int32_t groupId() const {
    return GetField<int32_t>(VT_GROUPID, 0);
  }
  int32_t actionId() const {
    return GetField<int32_t>(VT_ACTIONID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int32_t>(verifier, VT_GROUPID) &&
           VerifyField<int32_t>(verifier, VT_ACTIONID) &&
           verifier.EndTable();
  }
};

struct AiActionStartNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(AiActionStartNotify::VT_OBJECTID, objectId, 0);
  }
  void add_groupId(int32_t groupId) {
    fbb_.AddElement<int32_t>(AiActionStartNotify::VT_GROUPID, groupId, 0);
  }
  void add_actionId(int32_t actionId) {
    fbb_.AddElement<int32_t>(AiActionStartNotify::VT_ACTIONID, actionId, 0);
  }
  explicit AiActionStartNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AiActionStartNotifyBuilder &operator=(const AiActionStartNotifyBuilder &);
  flatbuffers::Offset<AiActionStartNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AiActionStartNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<AiActionStartNotify> CreateAiActionStartNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int32_t groupId = 0,
    int32_t actionId = 0) {
  AiActionStartNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_actionId(actionId);
  builder_.add_groupId(groupId);
  return builder_.Finish();
}

/// AI_ACTION_END_NOTIFY
struct AiActionEndNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_GROUPID = 6,
    VT_ACTIONID = 8
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int32_t groupId() const {
    return GetField<int32_t>(VT_GROUPID, 0);
  }
  int32_t actionId() const {
    return GetField<int32_t>(VT_ACTIONID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int32_t>(verifier, VT_GROUPID) &&
           VerifyField<int32_t>(verifier, VT_ACTIONID) &&
           verifier.EndTable();
  }
};

struct AiActionEndNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(AiActionEndNotify::VT_OBJECTID, objectId, 0);
  }
  void add_groupId(int32_t groupId) {
    fbb_.AddElement<int32_t>(AiActionEndNotify::VT_GROUPID, groupId, 0);
  }
  void add_actionId(int32_t actionId) {
    fbb_.AddElement<int32_t>(AiActionEndNotify::VT_ACTIONID, actionId, 0);
  }
  explicit AiActionEndNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AiActionEndNotifyBuilder &operator=(const AiActionEndNotifyBuilder &);
  flatbuffers::Offset<AiActionEndNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AiActionEndNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<AiActionEndNotify> CreateAiActionEndNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int32_t groupId = 0,
    int32_t actionId = 0) {
  AiActionEndNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_actionId(actionId);
  builder_.add_groupId(groupId);
  return builder_.Finish();
}

/// PLAYER_REVIVE_REQUEST
struct PlayerReviveRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_REVIVETYPE = 4
  };
  int32_t reviveType() const {
    return GetField<int32_t>(VT_REVIVETYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_REVIVETYPE) &&
           verifier.EndTable();
  }
};

struct PlayerReviveRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_reviveType(int32_t reviveType) {
    fbb_.AddElement<int32_t>(PlayerReviveRequest::VT_REVIVETYPE, reviveType, 0);
  }
  explicit PlayerReviveRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlayerReviveRequestBuilder &operator=(const PlayerReviveRequestBuilder &);
  flatbuffers::Offset<PlayerReviveRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlayerReviveRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<PlayerReviveRequest> CreatePlayerReviveRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t reviveType = 0) {
  PlayerReviveRequestBuilder builder_(_fbb);
  builder_.add_reviveType(reviveType);
  return builder_.Finish();
}

/// PLAYER_REVIVE_RESPONSE
struct PlayerReviveResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULT = 4,
    VT_OBJECTID = 6
  };
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           verifier.EndTable();
  }
};

struct PlayerReviveResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(PlayerReviveResponse::VT_RESULT, result, 0);
  }
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(PlayerReviveResponse::VT_OBJECTID, objectId, 0);
  }
  explicit PlayerReviveResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlayerReviveResponseBuilder &operator=(const PlayerReviveResponseBuilder &);
  flatbuffers::Offset<PlayerReviveResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlayerReviveResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<PlayerReviveResponse> CreatePlayerReviveResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    int64_t objectId = 0) {
  PlayerReviveResponseBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_result(result);
  return builder_.Finish();
}

/// CHANGED_SUPER_ARMOR_GAUGE_NOTIFY
struct ChangedSuperArmorGaugeNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_ID = 6,
    VT_CURGAUGE = 8,
    VT_MAXGAUGE = 10,
    VT_STATE = 12,
    VT_TAKETIME = 14,
    VT_RECOVERYTIME = 16
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int64_t curGauge() const {
    return GetField<int64_t>(VT_CURGAUGE, 0);
  }
  int64_t maxGauge() const {
    return GetField<int64_t>(VT_MAXGAUGE, 0);
  }
  int32_t state() const {
    return GetField<int32_t>(VT_STATE, 0);
  }
  int32_t takeTime() const {
    return GetField<int32_t>(VT_TAKETIME, 0);
  }
  int32_t recoveryTime() const {
    return GetField<int32_t>(VT_RECOVERYTIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<int64_t>(verifier, VT_CURGAUGE) &&
           VerifyField<int64_t>(verifier, VT_MAXGAUGE) &&
           VerifyField<int32_t>(verifier, VT_STATE) &&
           VerifyField<int32_t>(verifier, VT_TAKETIME) &&
           VerifyField<int32_t>(verifier, VT_RECOVERYTIME) &&
           verifier.EndTable();
  }
};

struct ChangedSuperArmorGaugeNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(ChangedSuperArmorGaugeNotify::VT_OBJECTID, objectId, 0);
  }
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(ChangedSuperArmorGaugeNotify::VT_ID, id, 0);
  }
  void add_curGauge(int64_t curGauge) {
    fbb_.AddElement<int64_t>(ChangedSuperArmorGaugeNotify::VT_CURGAUGE, curGauge, 0);
  }
  void add_maxGauge(int64_t maxGauge) {
    fbb_.AddElement<int64_t>(ChangedSuperArmorGaugeNotify::VT_MAXGAUGE, maxGauge, 0);
  }
  void add_state(int32_t state) {
    fbb_.AddElement<int32_t>(ChangedSuperArmorGaugeNotify::VT_STATE, state, 0);
  }
  void add_takeTime(int32_t takeTime) {
    fbb_.AddElement<int32_t>(ChangedSuperArmorGaugeNotify::VT_TAKETIME, takeTime, 0);
  }
  void add_recoveryTime(int32_t recoveryTime) {
    fbb_.AddElement<int32_t>(ChangedSuperArmorGaugeNotify::VT_RECOVERYTIME, recoveryTime, 0);
  }
  explicit ChangedSuperArmorGaugeNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChangedSuperArmorGaugeNotifyBuilder &operator=(const ChangedSuperArmorGaugeNotifyBuilder &);
  flatbuffers::Offset<ChangedSuperArmorGaugeNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChangedSuperArmorGaugeNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChangedSuperArmorGaugeNotify> CreateChangedSuperArmorGaugeNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int32_t id = 0,
    int64_t curGauge = 0,
    int64_t maxGauge = 0,
    int32_t state = 0,
    int32_t takeTime = 0,
    int32_t recoveryTime = 0) {
  ChangedSuperArmorGaugeNotifyBuilder builder_(_fbb);
  builder_.add_maxGauge(maxGauge);
  builder_.add_curGauge(curGauge);
  builder_.add_objectId(objectId);
  builder_.add_recoveryTime(recoveryTime);
  builder_.add_takeTime(takeTime);
  builder_.add_state(state);
  builder_.add_id(id);
  return builder_.Finish();
}

/// Penalty_Skill_Notify
struct PenaltySkillNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_TAKETIME = 6,
    VT_MAXTIME = 8,
    VT_AIACTIONID = 10
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int32_t takeTime() const {
    return GetField<int32_t>(VT_TAKETIME, 0);
  }
  int32_t maxTime() const {
    return GetField<int32_t>(VT_MAXTIME, 0);
  }
  int32_t aiActionId() const {
    return GetField<int32_t>(VT_AIACTIONID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int32_t>(verifier, VT_TAKETIME) &&
           VerifyField<int32_t>(verifier, VT_MAXTIME) &&
           VerifyField<int32_t>(verifier, VT_AIACTIONID) &&
           verifier.EndTable();
  }
};

struct PenaltySkillNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(PenaltySkillNotify::VT_OBJECTID, objectId, 0);
  }
  void add_takeTime(int32_t takeTime) {
    fbb_.AddElement<int32_t>(PenaltySkillNotify::VT_TAKETIME, takeTime, 0);
  }
  void add_maxTime(int32_t maxTime) {
    fbb_.AddElement<int32_t>(PenaltySkillNotify::VT_MAXTIME, maxTime, 0);
  }
  void add_aiActionId(int32_t aiActionId) {
    fbb_.AddElement<int32_t>(PenaltySkillNotify::VT_AIACTIONID, aiActionId, 0);
  }
  explicit PenaltySkillNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PenaltySkillNotifyBuilder &operator=(const PenaltySkillNotifyBuilder &);
  flatbuffers::Offset<PenaltySkillNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PenaltySkillNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<PenaltySkillNotify> CreatePenaltySkillNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int32_t takeTime = 0,
    int32_t maxTime = 0,
    int32_t aiActionId = 0) {
  PenaltySkillNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_aiActionId(aiActionId);
  builder_.add_maxTime(maxTime);
  builder_.add_takeTime(takeTime);
  return builder_.Finish();
}

struct PenaltySkillCancelNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_SKILLID = 6
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int32_t skillId() const {
    return GetField<int32_t>(VT_SKILLID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int32_t>(verifier, VT_SKILLID) &&
           verifier.EndTable();
  }
};

struct PenaltySkillCancelNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(PenaltySkillCancelNotify::VT_OBJECTID, objectId, 0);
  }
  void add_skillId(int32_t skillId) {
    fbb_.AddElement<int32_t>(PenaltySkillCancelNotify::VT_SKILLID, skillId, 0);
  }
  explicit PenaltySkillCancelNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PenaltySkillCancelNotifyBuilder &operator=(const PenaltySkillCancelNotifyBuilder &);
  flatbuffers::Offset<PenaltySkillCancelNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PenaltySkillCancelNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<PenaltySkillCancelNotify> CreatePenaltySkillCancelNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int32_t skillId = 0) {
  PenaltySkillCancelNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_skillId(skillId);
  return builder_.Finish();
}

/// ADMIN_COMMAND_NOTIFY
struct AdminCommandNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_KEYWORD = 6,
    VT_ARGUMENT = 8
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  const flatbuffers::String *keyword() const {
    return GetPointer<const flatbuffers::String *>(VT_KEYWORD);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *argument() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ARGUMENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyOffsetRequired(verifier, VT_KEYWORD) &&
           verifier.VerifyString(keyword()) &&
           VerifyOffsetRequired(verifier, VT_ARGUMENT) &&
           verifier.VerifyVector(argument()) &&
           verifier.VerifyVectorOfStrings(argument()) &&
           verifier.EndTable();
  }
};

struct AdminCommandNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(AdminCommandNotify::VT_OBJECTID, objectId, 0);
  }
  void add_keyword(flatbuffers::Offset<flatbuffers::String> keyword) {
    fbb_.AddOffset(AdminCommandNotify::VT_KEYWORD, keyword);
  }
  void add_argument(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> argument) {
    fbb_.AddOffset(AdminCommandNotify::VT_ARGUMENT, argument);
  }
  explicit AdminCommandNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AdminCommandNotifyBuilder &operator=(const AdminCommandNotifyBuilder &);
  flatbuffers::Offset<AdminCommandNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AdminCommandNotify>(end);
    fbb_.Required(o, AdminCommandNotify::VT_KEYWORD);
    fbb_.Required(o, AdminCommandNotify::VT_ARGUMENT);
    return o;
  }
};

inline flatbuffers::Offset<AdminCommandNotify> CreateAdminCommandNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    flatbuffers::Offset<flatbuffers::String> keyword = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> argument = 0) {
  AdminCommandNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_argument(argument);
  builder_.add_keyword(keyword);
  return builder_.Finish();
}

inline flatbuffers::Offset<AdminCommandNotify> CreateAdminCommandNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    const char *keyword = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *argument = nullptr) {
  return LeanPacket::CreateAdminCommandNotify(
      _fbb,
      objectId,
      keyword ? _fbb.CreateString(keyword) : 0,
      argument ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*argument) : 0);
}

/// SYSTEM_DEBUG_MESSAGE
struct SystemDebugMessageNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_MESSAGE = 6
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyOffsetRequired(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct SystemDebugMessageNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(SystemDebugMessageNotify::VT_OBJECTID, objectId, 0);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(SystemDebugMessageNotify::VT_MESSAGE, message);
  }
  explicit SystemDebugMessageNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SystemDebugMessageNotifyBuilder &operator=(const SystemDebugMessageNotifyBuilder &);
  flatbuffers::Offset<SystemDebugMessageNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SystemDebugMessageNotify>(end);
    fbb_.Required(o, SystemDebugMessageNotify::VT_MESSAGE);
    return o;
  }
};

inline flatbuffers::Offset<SystemDebugMessageNotify> CreateSystemDebugMessageNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  SystemDebugMessageNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_message(message);
  return builder_.Finish();
}

inline flatbuffers::Offset<SystemDebugMessageNotify> CreateSystemDebugMessageNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    const char *message = nullptr) {
  return LeanPacket::CreateSystemDebugMessageNotify(
      _fbb,
      objectId,
      message ? _fbb.CreateString(message) : 0);
}

/// SKILL_SLOT_PLACE_REQUEST
struct SkillSlotPlaceRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_PRESETNO = 6,
    VT_SKILLID = 8
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int32_t presetNo() const {
    return GetField<int32_t>(VT_PRESETNO, 0);
  }
  int32_t skillId() const {
    return GetField<int32_t>(VT_SKILLID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int32_t>(verifier, VT_PRESETNO) &&
           VerifyField<int32_t>(verifier, VT_SKILLID) &&
           verifier.EndTable();
  }
};

struct SkillSlotPlaceRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(SkillSlotPlaceRequest::VT_OBJECTID, objectId, 0);
  }
  void add_presetNo(int32_t presetNo) {
    fbb_.AddElement<int32_t>(SkillSlotPlaceRequest::VT_PRESETNO, presetNo, 0);
  }
  void add_skillId(int32_t skillId) {
    fbb_.AddElement<int32_t>(SkillSlotPlaceRequest::VT_SKILLID, skillId, 0);
  }
  explicit SkillSlotPlaceRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SkillSlotPlaceRequestBuilder &operator=(const SkillSlotPlaceRequestBuilder &);
  flatbuffers::Offset<SkillSlotPlaceRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkillSlotPlaceRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkillSlotPlaceRequest> CreateSkillSlotPlaceRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int32_t presetNo = 0,
    int32_t skillId = 0) {
  SkillSlotPlaceRequestBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_skillId(skillId);
  builder_.add_presetNo(presetNo);
  return builder_.Finish();
}

/// SKILL_SLOT_PLACE_RESPONSE
struct SkillSlotPlaceResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULT = 4,
    VT_OBJECTID = 6,
    VT_PRESETNO = 8,
    VT_CHANGEDSKILLID = 10
  };
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int32_t presetNo() const {
    return GetField<int32_t>(VT_PRESETNO, 0);
  }
  int32_t changedSkillId() const {
    return GetField<int32_t>(VT_CHANGEDSKILLID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int32_t>(verifier, VT_PRESETNO) &&
           VerifyField<int32_t>(verifier, VT_CHANGEDSKILLID) &&
           verifier.EndTable();
  }
};

struct SkillSlotPlaceResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(SkillSlotPlaceResponse::VT_RESULT, result, 0);
  }
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(SkillSlotPlaceResponse::VT_OBJECTID, objectId, 0);
  }
  void add_presetNo(int32_t presetNo) {
    fbb_.AddElement<int32_t>(SkillSlotPlaceResponse::VT_PRESETNO, presetNo, 0);
  }
  void add_changedSkillId(int32_t changedSkillId) {
    fbb_.AddElement<int32_t>(SkillSlotPlaceResponse::VT_CHANGEDSKILLID, changedSkillId, 0);
  }
  explicit SkillSlotPlaceResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SkillSlotPlaceResponseBuilder &operator=(const SkillSlotPlaceResponseBuilder &);
  flatbuffers::Offset<SkillSlotPlaceResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkillSlotPlaceResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkillSlotPlaceResponse> CreateSkillSlotPlaceResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    int64_t objectId = 0,
    int32_t presetNo = 0,
    int32_t changedSkillId = 0) {
  SkillSlotPlaceResponseBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_changedSkillId(changedSkillId);
  builder_.add_presetNo(presetNo);
  builder_.add_result(result);
  return builder_.Finish();
}

struct SkillLevelUpInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SKILLID = 4,
    VT_FEATUREID = 6,
    VT_COUNTOFLEVELUP = 8,
    VT_CURLEVEL = 10,
    VT_CHANGELEVEL = 12,
    VT_USEDSP = 14
  };
  int32_t skillId() const {
    return GetField<int32_t>(VT_SKILLID, 0);
  }
  int16_t featureId() const {
    return GetField<int16_t>(VT_FEATUREID, 0);
  }
  int16_t countOfLevelup() const {
    return GetField<int16_t>(VT_COUNTOFLEVELUP, 0);
  }
  int16_t curLevel() const {
    return GetField<int16_t>(VT_CURLEVEL, 0);
  }
  int16_t changeLevel() const {
    return GetField<int16_t>(VT_CHANGELEVEL, 0);
  }
  int16_t usedSp() const {
    return GetField<int16_t>(VT_USEDSP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SKILLID) &&
           VerifyField<int16_t>(verifier, VT_FEATUREID) &&
           VerifyField<int16_t>(verifier, VT_COUNTOFLEVELUP) &&
           VerifyField<int16_t>(verifier, VT_CURLEVEL) &&
           VerifyField<int16_t>(verifier, VT_CHANGELEVEL) &&
           VerifyField<int16_t>(verifier, VT_USEDSP) &&
           verifier.EndTable();
  }
};

struct SkillLevelUpInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_skillId(int32_t skillId) {
    fbb_.AddElement<int32_t>(SkillLevelUpInfo::VT_SKILLID, skillId, 0);
  }
  void add_featureId(int16_t featureId) {
    fbb_.AddElement<int16_t>(SkillLevelUpInfo::VT_FEATUREID, featureId, 0);
  }
  void add_countOfLevelup(int16_t countOfLevelup) {
    fbb_.AddElement<int16_t>(SkillLevelUpInfo::VT_COUNTOFLEVELUP, countOfLevelup, 0);
  }
  void add_curLevel(int16_t curLevel) {
    fbb_.AddElement<int16_t>(SkillLevelUpInfo::VT_CURLEVEL, curLevel, 0);
  }
  void add_changeLevel(int16_t changeLevel) {
    fbb_.AddElement<int16_t>(SkillLevelUpInfo::VT_CHANGELEVEL, changeLevel, 0);
  }
  void add_usedSp(int16_t usedSp) {
    fbb_.AddElement<int16_t>(SkillLevelUpInfo::VT_USEDSP, usedSp, 0);
  }
  explicit SkillLevelUpInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SkillLevelUpInfoBuilder &operator=(const SkillLevelUpInfoBuilder &);
  flatbuffers::Offset<SkillLevelUpInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkillLevelUpInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkillLevelUpInfo> CreateSkillLevelUpInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t skillId = 0,
    int16_t featureId = 0,
    int16_t countOfLevelup = 0,
    int16_t curLevel = 0,
    int16_t changeLevel = 0,
    int16_t usedSp = 0) {
  SkillLevelUpInfoBuilder builder_(_fbb);
  builder_.add_skillId(skillId);
  builder_.add_usedSp(usedSp);
  builder_.add_changeLevel(changeLevel);
  builder_.add_curLevel(curLevel);
  builder_.add_countOfLevelup(countOfLevelup);
  builder_.add_featureId(featureId);
  return builder_.Finish();
}

/// SKILL_LEVEL_UP_REQUEST
struct SkillLevelUpRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_SKILLLEVELUPINFOS = 6
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SkillLevelUpInfo>> *SkillLevelUpInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SkillLevelUpInfo>> *>(VT_SKILLLEVELUPINFOS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyOffsetRequired(verifier, VT_SKILLLEVELUPINFOS) &&
           verifier.VerifyVector(SkillLevelUpInfos()) &&
           verifier.VerifyVectorOfTables(SkillLevelUpInfos()) &&
           verifier.EndTable();
  }
};

struct SkillLevelUpRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(SkillLevelUpRequest::VT_OBJECTID, objectId, 0);
  }
  void add_SkillLevelUpInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SkillLevelUpInfo>>> SkillLevelUpInfos) {
    fbb_.AddOffset(SkillLevelUpRequest::VT_SKILLLEVELUPINFOS, SkillLevelUpInfos);
  }
  explicit SkillLevelUpRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SkillLevelUpRequestBuilder &operator=(const SkillLevelUpRequestBuilder &);
  flatbuffers::Offset<SkillLevelUpRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkillLevelUpRequest>(end);
    fbb_.Required(o, SkillLevelUpRequest::VT_SKILLLEVELUPINFOS);
    return o;
  }
};

inline flatbuffers::Offset<SkillLevelUpRequest> CreateSkillLevelUpRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SkillLevelUpInfo>>> SkillLevelUpInfos = 0) {
  SkillLevelUpRequestBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_SkillLevelUpInfos(SkillLevelUpInfos);
  return builder_.Finish();
}

inline flatbuffers::Offset<SkillLevelUpRequest> CreateSkillLevelUpRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    const std::vector<flatbuffers::Offset<SkillLevelUpInfo>> *SkillLevelUpInfos = nullptr) {
  return LeanPacket::CreateSkillLevelUpRequest(
      _fbb,
      objectId,
      SkillLevelUpInfos ? _fbb.CreateVector<flatbuffers::Offset<SkillLevelUpInfo>>(*SkillLevelUpInfos) : 0);
}

/// SKILL_LEVEL_UP_RESPONSE
struct SkillLevelUpResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULT = 4,
    VT_OBJECTID = 6,
    VT_SKILLLEVELUPINFOS = 8
  };
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SkillLevelUpInfo>> *SkillLevelUpInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SkillLevelUpInfo>> *>(VT_SKILLLEVELUPINFOS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyOffset(verifier, VT_SKILLLEVELUPINFOS) &&
           verifier.VerifyVector(SkillLevelUpInfos()) &&
           verifier.VerifyVectorOfTables(SkillLevelUpInfos()) &&
           verifier.EndTable();
  }
};

struct SkillLevelUpResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(SkillLevelUpResponse::VT_RESULT, result, 0);
  }
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(SkillLevelUpResponse::VT_OBJECTID, objectId, 0);
  }
  void add_SkillLevelUpInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SkillLevelUpInfo>>> SkillLevelUpInfos) {
    fbb_.AddOffset(SkillLevelUpResponse::VT_SKILLLEVELUPINFOS, SkillLevelUpInfos);
  }
  explicit SkillLevelUpResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SkillLevelUpResponseBuilder &operator=(const SkillLevelUpResponseBuilder &);
  flatbuffers::Offset<SkillLevelUpResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkillLevelUpResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkillLevelUpResponse> CreateSkillLevelUpResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    int64_t objectId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SkillLevelUpInfo>>> SkillLevelUpInfos = 0) {
  SkillLevelUpResponseBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_SkillLevelUpInfos(SkillLevelUpInfos);
  builder_.add_result(result);
  return builder_.Finish();
}

inline flatbuffers::Offset<SkillLevelUpResponse> CreateSkillLevelUpResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    int64_t objectId = 0,
    const std::vector<flatbuffers::Offset<SkillLevelUpInfo>> *SkillLevelUpInfos = nullptr) {
  return LeanPacket::CreateSkillLevelUpResponse(
      _fbb,
      result,
      objectId,
      SkillLevelUpInfos ? _fbb.CreateVector<flatbuffers::Offset<SkillLevelUpInfo>>(*SkillLevelUpInfos) : 0);
}

/// CHANGE_IFF_NOTIFY
struct ChangeIffNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_IFF = 6
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int32_t iff() const {
    return GetField<int32_t>(VT_IFF, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int32_t>(verifier, VT_IFF) &&
           verifier.EndTable();
  }
};

struct ChangeIffNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(ChangeIffNotify::VT_OBJECTID, objectId, 0);
  }
  void add_iff(int32_t iff) {
    fbb_.AddElement<int32_t>(ChangeIffNotify::VT_IFF, iff, 0);
  }
  explicit ChangeIffNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChangeIffNotifyBuilder &operator=(const ChangeIffNotifyBuilder &);
  flatbuffers::Offset<ChangeIffNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChangeIffNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChangeIffNotify> CreateChangeIffNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int32_t iff = 0) {
  ChangeIffNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_iff(iff);
  return builder_.Finish();
}

/// UPDATE_ENERGYPOINT_NOTIFY
struct UpdateEnergyPointNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_ACQUIREENERGYPOINT = 6,
    VT_CURRENTENERGYPOINT = 8
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int32_t acquireEnergyPoint() const {
    return GetField<int32_t>(VT_ACQUIREENERGYPOINT, 0);
  }
  int32_t currentEnergyPoint() const {
    return GetField<int32_t>(VT_CURRENTENERGYPOINT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int32_t>(verifier, VT_ACQUIREENERGYPOINT) &&
           VerifyField<int32_t>(verifier, VT_CURRENTENERGYPOINT) &&
           verifier.EndTable();
  }
};

struct UpdateEnergyPointNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(UpdateEnergyPointNotify::VT_OBJECTID, objectId, 0);
  }
  void add_acquireEnergyPoint(int32_t acquireEnergyPoint) {
    fbb_.AddElement<int32_t>(UpdateEnergyPointNotify::VT_ACQUIREENERGYPOINT, acquireEnergyPoint, 0);
  }
  void add_currentEnergyPoint(int32_t currentEnergyPoint) {
    fbb_.AddElement<int32_t>(UpdateEnergyPointNotify::VT_CURRENTENERGYPOINT, currentEnergyPoint, 0);
  }
  explicit UpdateEnergyPointNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UpdateEnergyPointNotifyBuilder &operator=(const UpdateEnergyPointNotifyBuilder &);
  flatbuffers::Offset<UpdateEnergyPointNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UpdateEnergyPointNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<UpdateEnergyPointNotify> CreateUpdateEnergyPointNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int32_t acquireEnergyPoint = 0,
    int32_t currentEnergyPoint = 0) {
  UpdateEnergyPointNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_currentEnergyPoint(currentEnergyPoint);
  builder_.add_acquireEnergyPoint(acquireEnergyPoint);
  return builder_.Finish();
}

/// 장착 정보
struct EquipInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SLOTS = 4
  };
  const flatbuffers::Vector<uint64_t> *slots() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_SLOTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SLOTS) &&
           verifier.VerifyVector(slots()) &&
           verifier.EndTable();
  }
};

struct EquipInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slots(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> slots) {
    fbb_.AddOffset(EquipInfo::VT_SLOTS, slots);
  }
  explicit EquipInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EquipInfoBuilder &operator=(const EquipInfoBuilder &);
  flatbuffers::Offset<EquipInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EquipInfo>(end);
    fbb_.Required(o, EquipInfo::VT_SLOTS);
    return o;
  }
};

inline flatbuffers::Offset<EquipInfo> CreateEquipInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> slots = 0) {
  EquipInfoBuilder builder_(_fbb);
  builder_.add_slots(slots);
  return builder_.Finish();
}

inline flatbuffers::Offset<EquipInfo> CreateEquipInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint64_t> *slots = nullptr) {
  return LeanPacket::CreateEquipInfo(
      _fbb,
      slots ? _fbb.CreateVector<uint64_t>(*slots) : 0);
}

/// 외형장비 장착 정보
struct CostumeSlotInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMOBJECTID = 4,
    VT_ISVISIVLE = 6
  };
  uint64_t itemObjectId() const {
    return GetField<uint64_t>(VT_ITEMOBJECTID, 0);
  }
  bool isVisivle() const {
    return GetField<uint8_t>(VT_ISVISIVLE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ITEMOBJECTID) &&
           VerifyField<uint8_t>(verifier, VT_ISVISIVLE) &&
           verifier.EndTable();
  }
};

struct CostumeSlotInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemObjectId(uint64_t itemObjectId) {
    fbb_.AddElement<uint64_t>(CostumeSlotInfo::VT_ITEMOBJECTID, itemObjectId, 0);
  }
  void add_isVisivle(bool isVisivle) {
    fbb_.AddElement<uint8_t>(CostumeSlotInfo::VT_ISVISIVLE, static_cast<uint8_t>(isVisivle), 0);
  }
  explicit CostumeSlotInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CostumeSlotInfoBuilder &operator=(const CostumeSlotInfoBuilder &);
  flatbuffers::Offset<CostumeSlotInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CostumeSlotInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<CostumeSlotInfo> CreateCostumeSlotInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t itemObjectId = 0,
    bool isVisivle = false) {
  CostumeSlotInfoBuilder builder_(_fbb);
  builder_.add_itemObjectId(itemObjectId);
  builder_.add_isVisivle(isVisivle);
  return builder_.Finish();
}

struct CostumeInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SLOTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<CostumeSlotInfo>> *slots() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CostumeSlotInfo>> *>(VT_SLOTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SLOTS) &&
           verifier.VerifyVector(slots()) &&
           verifier.VerifyVectorOfTables(slots()) &&
           verifier.EndTable();
  }
};

struct CostumeInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slots(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CostumeSlotInfo>>> slots) {
    fbb_.AddOffset(CostumeInfo::VT_SLOTS, slots);
  }
  explicit CostumeInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CostumeInfoBuilder &operator=(const CostumeInfoBuilder &);
  flatbuffers::Offset<CostumeInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CostumeInfo>(end);
    fbb_.Required(o, CostumeInfo::VT_SLOTS);
    return o;
  }
};

inline flatbuffers::Offset<CostumeInfo> CreateCostumeInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CostumeSlotInfo>>> slots = 0) {
  CostumeInfoBuilder builder_(_fbb);
  builder_.add_slots(slots);
  return builder_.Finish();
}

inline flatbuffers::Offset<CostumeInfo> CreateCostumeInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<CostumeSlotInfo>> *slots = nullptr) {
  return LeanPacket::CreateCostumeInfo(
      _fbb,
      slots ? _fbb.CreateVector<flatbuffers::Offset<CostumeSlotInfo>>(*slots) : 0);
}

/// NOTIFY_EVENT_COUNTER_INFO
struct EventCounterInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_CURRENTVALUE = 6,
    VT_MAXVALUE = 8,
    VT_COUNTERTYPE = 10,
    VT_COUNTERSTATE = 12,
    VT_CONTERNAMEID = 14,
    VT_AUTOPROGRESSID = 16,
    VT_HIDECOUNT = 18
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int32_t currentValue() const {
    return GetField<int32_t>(VT_CURRENTVALUE, 0);
  }
  int32_t maxValue() const {
    return GetField<int32_t>(VT_MAXVALUE, 0);
  }
  EventCounterType counterType() const {
    return static_cast<EventCounterType>(GetField<int32_t>(VT_COUNTERTYPE, 0));
  }
  EventCounterStateType counterState() const {
    return static_cast<EventCounterStateType>(GetField<int32_t>(VT_COUNTERSTATE, 0));
  }
  int32_t conterNameId() const {
    return GetField<int32_t>(VT_CONTERNAMEID, 0);
  }
  int32_t autoProgressId() const {
    return GetField<int32_t>(VT_AUTOPROGRESSID, 0);
  }
  bool hideCount() const {
    return GetField<uint8_t>(VT_HIDECOUNT, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int32_t>(verifier, VT_CURRENTVALUE) &&
           VerifyField<int32_t>(verifier, VT_MAXVALUE) &&
           VerifyField<int32_t>(verifier, VT_COUNTERTYPE) &&
           VerifyField<int32_t>(verifier, VT_COUNTERSTATE) &&
           VerifyField<int32_t>(verifier, VT_CONTERNAMEID) &&
           VerifyField<int32_t>(verifier, VT_AUTOPROGRESSID) &&
           VerifyField<uint8_t>(verifier, VT_HIDECOUNT) &&
           verifier.EndTable();
  }
};

struct EventCounterInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(EventCounterInfo::VT_OBJECTID, objectId, 0);
  }
  void add_currentValue(int32_t currentValue) {
    fbb_.AddElement<int32_t>(EventCounterInfo::VT_CURRENTVALUE, currentValue, 0);
  }
  void add_maxValue(int32_t maxValue) {
    fbb_.AddElement<int32_t>(EventCounterInfo::VT_MAXVALUE, maxValue, 0);
  }
  void add_counterType(EventCounterType counterType) {
    fbb_.AddElement<int32_t>(EventCounterInfo::VT_COUNTERTYPE, static_cast<int32_t>(counterType), 0);
  }
  void add_counterState(EventCounterStateType counterState) {
    fbb_.AddElement<int32_t>(EventCounterInfo::VT_COUNTERSTATE, static_cast<int32_t>(counterState), 0);
  }
  void add_conterNameId(int32_t conterNameId) {
    fbb_.AddElement<int32_t>(EventCounterInfo::VT_CONTERNAMEID, conterNameId, 0);
  }
  void add_autoProgressId(int32_t autoProgressId) {
    fbb_.AddElement<int32_t>(EventCounterInfo::VT_AUTOPROGRESSID, autoProgressId, 0);
  }
  void add_hideCount(bool hideCount) {
    fbb_.AddElement<uint8_t>(EventCounterInfo::VT_HIDECOUNT, static_cast<uint8_t>(hideCount), 0);
  }
  explicit EventCounterInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EventCounterInfoBuilder &operator=(const EventCounterInfoBuilder &);
  flatbuffers::Offset<EventCounterInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EventCounterInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<EventCounterInfo> CreateEventCounterInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int32_t currentValue = 0,
    int32_t maxValue = 0,
    EventCounterType counterType = EventCounterType_EVENT_COUNTER_TYPE_NONE,
    EventCounterStateType counterState = EventCounterStateType_EVENT_COUNTER_STATE_TYPE_NONE,
    int32_t conterNameId = 0,
    int32_t autoProgressId = 0,
    bool hideCount = false) {
  EventCounterInfoBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_autoProgressId(autoProgressId);
  builder_.add_conterNameId(conterNameId);
  builder_.add_counterState(counterState);
  builder_.add_counterType(counterType);
  builder_.add_maxValue(maxValue);
  builder_.add_currentValue(currentValue);
  builder_.add_hideCount(hideCount);
  return builder_.Finish();
}

/// NOTIFY_EVENT_COUNTER_PROGRESS_INFO
struct EventCounterProgressInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EVENTSETID = 4,
    VT_EVENTID = 6,
    VT_EVENTSTATE = 8,
    VT_REMAINTIME = 10,
    VT_MAXTIME = 12
  };
  int32_t eventSetId() const {
    return GetField<int32_t>(VT_EVENTSETID, 0);
  }
  int32_t eventId() const {
    return GetField<int32_t>(VT_EVENTID, 0);
  }
  EventStateType eventState() const {
    return static_cast<EventStateType>(GetField<int32_t>(VT_EVENTSTATE, 0));
  }
  int32_t remainTime() const {
    return GetField<int32_t>(VT_REMAINTIME, 0);
  }
  int32_t maxTime() const {
    return GetField<int32_t>(VT_MAXTIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_EVENTSETID) &&
           VerifyField<int32_t>(verifier, VT_EVENTID) &&
           VerifyField<int32_t>(verifier, VT_EVENTSTATE) &&
           VerifyField<int32_t>(verifier, VT_REMAINTIME) &&
           VerifyField<int32_t>(verifier, VT_MAXTIME) &&
           verifier.EndTable();
  }
};

struct EventCounterProgressInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eventSetId(int32_t eventSetId) {
    fbb_.AddElement<int32_t>(EventCounterProgressInfo::VT_EVENTSETID, eventSetId, 0);
  }
  void add_eventId(int32_t eventId) {
    fbb_.AddElement<int32_t>(EventCounterProgressInfo::VT_EVENTID, eventId, 0);
  }
  void add_eventState(EventStateType eventState) {
    fbb_.AddElement<int32_t>(EventCounterProgressInfo::VT_EVENTSTATE, static_cast<int32_t>(eventState), 0);
  }
  void add_remainTime(int32_t remainTime) {
    fbb_.AddElement<int32_t>(EventCounterProgressInfo::VT_REMAINTIME, remainTime, 0);
  }
  void add_maxTime(int32_t maxTime) {
    fbb_.AddElement<int32_t>(EventCounterProgressInfo::VT_MAXTIME, maxTime, 0);
  }
  explicit EventCounterProgressInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EventCounterProgressInfoBuilder &operator=(const EventCounterProgressInfoBuilder &);
  flatbuffers::Offset<EventCounterProgressInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EventCounterProgressInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<EventCounterProgressInfo> CreateEventCounterProgressInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t eventSetId = 0,
    int32_t eventId = 0,
    EventStateType eventState = EventStateType_EVENT_STATE_TYPE_NONE,
    int32_t remainTime = 0,
    int32_t maxTime = 0) {
  EventCounterProgressInfoBuilder builder_(_fbb);
  builder_.add_maxTime(maxTime);
  builder_.add_remainTime(remainTime);
  builder_.add_eventState(eventState);
  builder_.add_eventId(eventId);
  builder_.add_eventSetId(eventSetId);
  return builder_.Finish();
}

/// NOTIFY_EVENT_HIDDEN_CONTENTS_START
struct EventHiddenContentsStart FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_REMAINTIME = 6
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int32_t remainTime() const {
    return GetField<int32_t>(VT_REMAINTIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int32_t>(verifier, VT_REMAINTIME) &&
           verifier.EndTable();
  }
};

struct EventHiddenContentsStartBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(EventHiddenContentsStart::VT_OBJECTID, objectId, 0);
  }
  void add_remainTime(int32_t remainTime) {
    fbb_.AddElement<int32_t>(EventHiddenContentsStart::VT_REMAINTIME, remainTime, 0);
  }
  explicit EventHiddenContentsStartBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EventHiddenContentsStartBuilder &operator=(const EventHiddenContentsStartBuilder &);
  flatbuffers::Offset<EventHiddenContentsStart> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EventHiddenContentsStart>(end);
    return o;
  }
};

inline flatbuffers::Offset<EventHiddenContentsStart> CreateEventHiddenContentsStart(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int32_t remainTime = 0) {
  EventHiddenContentsStartBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_remainTime(remainTime);
  return builder_.Finish();
}

/// NOTIFY_EVENT_HIDDEN_CONTENTS_END
struct EventHiddenContentsEnd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           verifier.EndTable();
  }
};

struct EventHiddenContentsEndBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(EventHiddenContentsEnd::VT_OBJECTID, objectId, 0);
  }
  explicit EventHiddenContentsEndBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EventHiddenContentsEndBuilder &operator=(const EventHiddenContentsEndBuilder &);
  flatbuffers::Offset<EventHiddenContentsEnd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EventHiddenContentsEnd>(end);
    return o;
  }
};

inline flatbuffers::Offset<EventHiddenContentsEnd> CreateEventHiddenContentsEnd(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0) {
  EventHiddenContentsEndBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  return builder_.Finish();
}

/// NOTIFY_EVENT_HIDDEN_GATHERING_COLLECTED
struct EventHiddenGatheringCollected FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_NAME = 6
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct EventHiddenGatheringCollectedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(EventHiddenGatheringCollected::VT_OBJECTID, objectId, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(EventHiddenGatheringCollected::VT_NAME, name);
  }
  explicit EventHiddenGatheringCollectedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EventHiddenGatheringCollectedBuilder &operator=(const EventHiddenGatheringCollectedBuilder &);
  flatbuffers::Offset<EventHiddenGatheringCollected> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EventHiddenGatheringCollected>(end);
    fbb_.Required(o, EventHiddenGatheringCollected::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<EventHiddenGatheringCollected> CreateEventHiddenGatheringCollected(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  EventHiddenGatheringCollectedBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<EventHiddenGatheringCollected> CreateEventHiddenGatheringCollectedDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    const char *name = nullptr) {
  return LeanPacket::CreateEventHiddenGatheringCollected(
      _fbb,
      objectId,
      name ? _fbb.CreateString(name) : 0);
}

/// EVENT_OUT_OF_PLAY_NOTIFY
struct EventOutOfPlayNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EVENTSETID = 4,
    VT_EVENTID = 6
  };
  int32_t eventsetId() const {
    return GetField<int32_t>(VT_EVENTSETID, 0);
  }
  int32_t eventId() const {
    return GetField<int32_t>(VT_EVENTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_EVENTSETID) &&
           VerifyField<int32_t>(verifier, VT_EVENTID) &&
           verifier.EndTable();
  }
};

struct EventOutOfPlayNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eventsetId(int32_t eventsetId) {
    fbb_.AddElement<int32_t>(EventOutOfPlayNotify::VT_EVENTSETID, eventsetId, 0);
  }
  void add_eventId(int32_t eventId) {
    fbb_.AddElement<int32_t>(EventOutOfPlayNotify::VT_EVENTID, eventId, 0);
  }
  explicit EventOutOfPlayNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EventOutOfPlayNotifyBuilder &operator=(const EventOutOfPlayNotifyBuilder &);
  flatbuffers::Offset<EventOutOfPlayNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EventOutOfPlayNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<EventOutOfPlayNotify> CreateEventOutOfPlayNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t eventsetId = 0,
    int32_t eventId = 0) {
  EventOutOfPlayNotifyBuilder builder_(_fbb);
  builder_.add_eventId(eventId);
  builder_.add_eventsetId(eventsetId);
  return builder_.Finish();
}

/// EVENT_MIDDLE_NOTIFY 
struct EventMiddleNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EVENTSETID = 4,
    VT_EVENTID = 6,
    VT_REMAINTIME = 8,
    VT_IDLETIME = 10,
    VT_PREVIGNOREEVENT = 12,
    VT_CURIGNOREEVENT = 14
  };
  int32_t eventSetId() const {
    return GetField<int32_t>(VT_EVENTSETID, 0);
  }
  int32_t eventId() const {
    return GetField<int32_t>(VT_EVENTID, 0);
  }
  int32_t remainTime() const {
    return GetField<int32_t>(VT_REMAINTIME, 0);
  }
  int32_t idleTime() const {
    return GetField<int32_t>(VT_IDLETIME, 0);
  }
  bool prevIgnoreEvent() const {
    return GetField<uint8_t>(VT_PREVIGNOREEVENT, 0) != 0;
  }
  bool curIgnoreEvent() const {
    return GetField<uint8_t>(VT_CURIGNOREEVENT, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_EVENTSETID) &&
           VerifyField<int32_t>(verifier, VT_EVENTID) &&
           VerifyField<int32_t>(verifier, VT_REMAINTIME) &&
           VerifyField<int32_t>(verifier, VT_IDLETIME) &&
           VerifyField<uint8_t>(verifier, VT_PREVIGNOREEVENT) &&
           VerifyField<uint8_t>(verifier, VT_CURIGNOREEVENT) &&
           verifier.EndTable();
  }
};

struct EventMiddleNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eventSetId(int32_t eventSetId) {
    fbb_.AddElement<int32_t>(EventMiddleNotify::VT_EVENTSETID, eventSetId, 0);
  }
  void add_eventId(int32_t eventId) {
    fbb_.AddElement<int32_t>(EventMiddleNotify::VT_EVENTID, eventId, 0);
  }
  void add_remainTime(int32_t remainTime) {
    fbb_.AddElement<int32_t>(EventMiddleNotify::VT_REMAINTIME, remainTime, 0);
  }
  void add_idleTime(int32_t idleTime) {
    fbb_.AddElement<int32_t>(EventMiddleNotify::VT_IDLETIME, idleTime, 0);
  }
  void add_prevIgnoreEvent(bool prevIgnoreEvent) {
    fbb_.AddElement<uint8_t>(EventMiddleNotify::VT_PREVIGNOREEVENT, static_cast<uint8_t>(prevIgnoreEvent), 0);
  }
  void add_curIgnoreEvent(bool curIgnoreEvent) {
    fbb_.AddElement<uint8_t>(EventMiddleNotify::VT_CURIGNOREEVENT, static_cast<uint8_t>(curIgnoreEvent), 0);
  }
  explicit EventMiddleNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EventMiddleNotifyBuilder &operator=(const EventMiddleNotifyBuilder &);
  flatbuffers::Offset<EventMiddleNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EventMiddleNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<EventMiddleNotify> CreateEventMiddleNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t eventSetId = 0,
    int32_t eventId = 0,
    int32_t remainTime = 0,
    int32_t idleTime = 0,
    bool prevIgnoreEvent = false,
    bool curIgnoreEvent = false) {
  EventMiddleNotifyBuilder builder_(_fbb);
  builder_.add_idleTime(idleTime);
  builder_.add_remainTime(remainTime);
  builder_.add_eventId(eventId);
  builder_.add_eventSetId(eventSetId);
  builder_.add_curIgnoreEvent(curIgnoreEvent);
  builder_.add_prevIgnoreEvent(prevIgnoreEvent);
  return builder_.Finish();
}

/// QUEST_REWARD_NOTIFY
struct QuestRewardNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_QUESTID = 4,
    VT_REWARDID = 6,
    VT_ORIGNREWARDINFO = 8,
    VT_GIVEREWARDINFO = 10
  };
  int32_t questId() const {
    return GetField<int32_t>(VT_QUESTID, 0);
  }
  int32_t rewardId() const {
    return GetField<int32_t>(VT_REWARDID, 0);
  }
  const RewardInfo *orignRewardInfo() const {
    return GetPointer<const RewardInfo *>(VT_ORIGNREWARDINFO);
  }
  const RewardInfo *giveRewardInfo() const {
    return GetPointer<const RewardInfo *>(VT_GIVEREWARDINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_QUESTID) &&
           VerifyField<int32_t>(verifier, VT_REWARDID) &&
           VerifyOffsetRequired(verifier, VT_ORIGNREWARDINFO) &&
           verifier.VerifyTable(orignRewardInfo()) &&
           VerifyOffsetRequired(verifier, VT_GIVEREWARDINFO) &&
           verifier.VerifyTable(giveRewardInfo()) &&
           verifier.EndTable();
  }
};

struct QuestRewardNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_questId(int32_t questId) {
    fbb_.AddElement<int32_t>(QuestRewardNotify::VT_QUESTID, questId, 0);
  }
  void add_rewardId(int32_t rewardId) {
    fbb_.AddElement<int32_t>(QuestRewardNotify::VT_REWARDID, rewardId, 0);
  }
  void add_orignRewardInfo(flatbuffers::Offset<RewardInfo> orignRewardInfo) {
    fbb_.AddOffset(QuestRewardNotify::VT_ORIGNREWARDINFO, orignRewardInfo);
  }
  void add_giveRewardInfo(flatbuffers::Offset<RewardInfo> giveRewardInfo) {
    fbb_.AddOffset(QuestRewardNotify::VT_GIVEREWARDINFO, giveRewardInfo);
  }
  explicit QuestRewardNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuestRewardNotifyBuilder &operator=(const QuestRewardNotifyBuilder &);
  flatbuffers::Offset<QuestRewardNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuestRewardNotify>(end);
    fbb_.Required(o, QuestRewardNotify::VT_ORIGNREWARDINFO);
    fbb_.Required(o, QuestRewardNotify::VT_GIVEREWARDINFO);
    return o;
  }
};

inline flatbuffers::Offset<QuestRewardNotify> CreateQuestRewardNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t questId = 0,
    int32_t rewardId = 0,
    flatbuffers::Offset<RewardInfo> orignRewardInfo = 0,
    flatbuffers::Offset<RewardInfo> giveRewardInfo = 0) {
  QuestRewardNotifyBuilder builder_(_fbb);
  builder_.add_giveRewardInfo(giveRewardInfo);
  builder_.add_orignRewardInfo(orignRewardInfo);
  builder_.add_rewardId(rewardId);
  builder_.add_questId(questId);
  return builder_.Finish();
}

/// QUEST_RECEIVE_REWARD_RESPONSE
struct QuestReceiveRewardResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_QUESTID = 4,
    VT_ERRORCODE = 6
  };
  int32_t questId() const {
    return GetField<int32_t>(VT_QUESTID, 0);
  }
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_QUESTID) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           verifier.EndTable();
  }
};

struct QuestReceiveRewardResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_questId(int32_t questId) {
    fbb_.AddElement<int32_t>(QuestReceiveRewardResponse::VT_QUESTID, questId, 0);
  }
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(QuestReceiveRewardResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  explicit QuestReceiveRewardResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuestReceiveRewardResponseBuilder &operator=(const QuestReceiveRewardResponseBuilder &);
  flatbuffers::Offset<QuestReceiveRewardResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuestReceiveRewardResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuestReceiveRewardResponse> CreateQuestReceiveRewardResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t questId = 0,
    ErrorCode errorCode = ErrorCode_NONE) {
  QuestReceiveRewardResponseBuilder builder_(_fbb);
  builder_.add_errorCode(errorCode);
  builder_.add_questId(questId);
  return builder_.Finish();
}

/// QUEST_CONTEXT_DATA_SET_NOTIFY 1
struct QuestCountData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TARGETTYPE = 4,
    VT_TARGETID = 6,
    VT_COUNT = 8
  };
  QuestTargetType targetType() const {
    return static_cast<QuestTargetType>(GetField<int32_t>(VT_TARGETTYPE, 0));
  }
  int32_t targetId() const {
    return GetField<int32_t>(VT_TARGETID, 0);
  }
  int32_t count() const {
    return GetField<int32_t>(VT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TARGETTYPE) &&
           VerifyField<int32_t>(verifier, VT_TARGETID) &&
           VerifyField<int32_t>(verifier, VT_COUNT) &&
           verifier.EndTable();
  }
};

struct QuestCountDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_targetType(QuestTargetType targetType) {
    fbb_.AddElement<int32_t>(QuestCountData::VT_TARGETTYPE, static_cast<int32_t>(targetType), 0);
  }
  void add_targetId(int32_t targetId) {
    fbb_.AddElement<int32_t>(QuestCountData::VT_TARGETID, targetId, 0);
  }
  void add_count(int32_t count) {
    fbb_.AddElement<int32_t>(QuestCountData::VT_COUNT, count, 0);
  }
  explicit QuestCountDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuestCountDataBuilder &operator=(const QuestCountDataBuilder &);
  flatbuffers::Offset<QuestCountData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuestCountData>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuestCountData> CreateQuestCountData(
    flatbuffers::FlatBufferBuilder &_fbb,
    QuestTargetType targetType = QuestTargetType_QTT_TYPE_NONE,
    int32_t targetId = 0,
    int32_t count = 0) {
  QuestCountDataBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_targetId(targetId);
  builder_.add_targetType(targetType);
  return builder_.Finish();
}

/// QUEST_CONTEXT_DATA_SET_NOTIFY 2
struct QuestContextData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_QUESTID = 4,
    VT_COUNTDATASET = 6,
    VT_CLEARCOUNT = 8,
    VT_POINT = 10
  };
  int32_t questId() const {
    return GetField<int32_t>(VT_QUESTID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<QuestCountData>> *countDataSet() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<QuestCountData>> *>(VT_COUNTDATASET);
  }
  int32_t clearCount() const {
    return GetField<int32_t>(VT_CLEARCOUNT, 0);
  }
  int32_t point() const {
    return GetField<int32_t>(VT_POINT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_QUESTID) &&
           VerifyOffsetRequired(verifier, VT_COUNTDATASET) &&
           verifier.VerifyVector(countDataSet()) &&
           verifier.VerifyVectorOfTables(countDataSet()) &&
           VerifyField<int32_t>(verifier, VT_CLEARCOUNT) &&
           VerifyField<int32_t>(verifier, VT_POINT) &&
           verifier.EndTable();
  }
};

struct QuestContextDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_questId(int32_t questId) {
    fbb_.AddElement<int32_t>(QuestContextData::VT_QUESTID, questId, 0);
  }
  void add_countDataSet(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<QuestCountData>>> countDataSet) {
    fbb_.AddOffset(QuestContextData::VT_COUNTDATASET, countDataSet);
  }
  void add_clearCount(int32_t clearCount) {
    fbb_.AddElement<int32_t>(QuestContextData::VT_CLEARCOUNT, clearCount, 0);
  }
  void add_point(int32_t point) {
    fbb_.AddElement<int32_t>(QuestContextData::VT_POINT, point, 0);
  }
  explicit QuestContextDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuestContextDataBuilder &operator=(const QuestContextDataBuilder &);
  flatbuffers::Offset<QuestContextData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuestContextData>(end);
    fbb_.Required(o, QuestContextData::VT_COUNTDATASET);
    return o;
  }
};

inline flatbuffers::Offset<QuestContextData> CreateQuestContextData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t questId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<QuestCountData>>> countDataSet = 0,
    int32_t clearCount = 0,
    int32_t point = 0) {
  QuestContextDataBuilder builder_(_fbb);
  builder_.add_point(point);
  builder_.add_clearCount(clearCount);
  builder_.add_countDataSet(countDataSet);
  builder_.add_questId(questId);
  return builder_.Finish();
}

inline flatbuffers::Offset<QuestContextData> CreateQuestContextDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t questId = 0,
    const std::vector<flatbuffers::Offset<QuestCountData>> *countDataSet = nullptr,
    int32_t clearCount = 0,
    int32_t point = 0) {
  return LeanPacket::CreateQuestContextData(
      _fbb,
      questId,
      countDataSet ? _fbb.CreateVector<flatbuffers::Offset<QuestCountData>>(*countDataSet) : 0,
      clearCount,
      point);
}

/// QUEST_CONTEXT_DATA_SET_NOTIFY 3
struct QuestContextDataSetNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONTEXTDATASET = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<QuestContextData>> *contextDataSet() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<QuestContextData>> *>(VT_CONTEXTDATASET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CONTEXTDATASET) &&
           verifier.VerifyVector(contextDataSet()) &&
           verifier.VerifyVectorOfTables(contextDataSet()) &&
           verifier.EndTable();
  }
};

struct QuestContextDataSetNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_contextDataSet(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<QuestContextData>>> contextDataSet) {
    fbb_.AddOffset(QuestContextDataSetNotify::VT_CONTEXTDATASET, contextDataSet);
  }
  explicit QuestContextDataSetNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuestContextDataSetNotifyBuilder &operator=(const QuestContextDataSetNotifyBuilder &);
  flatbuffers::Offset<QuestContextDataSetNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuestContextDataSetNotify>(end);
    fbb_.Required(o, QuestContextDataSetNotify::VT_CONTEXTDATASET);
    return o;
  }
};

inline flatbuffers::Offset<QuestContextDataSetNotify> CreateQuestContextDataSetNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<QuestContextData>>> contextDataSet = 0) {
  QuestContextDataSetNotifyBuilder builder_(_fbb);
  builder_.add_contextDataSet(contextDataSet);
  return builder_.Finish();
}

inline flatbuffers::Offset<QuestContextDataSetNotify> CreateQuestContextDataSetNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<QuestContextData>> *contextDataSet = nullptr) {
  return LeanPacket::CreateQuestContextDataSetNotify(
      _fbb,
      contextDataSet ? _fbb.CreateVector<flatbuffers::Offset<QuestContextData>>(*contextDataSet) : 0);
}

/// QUEST_CONTEXT_DATA_NOTIFY
struct QuestContextDataNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONTEXTDATA = 4
  };
  const QuestContextData *contextData() const {
    return GetPointer<const QuestContextData *>(VT_CONTEXTDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CONTEXTDATA) &&
           verifier.VerifyTable(contextData()) &&
           verifier.EndTable();
  }
};

struct QuestContextDataNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_contextData(flatbuffers::Offset<QuestContextData> contextData) {
    fbb_.AddOffset(QuestContextDataNotify::VT_CONTEXTDATA, contextData);
  }
  explicit QuestContextDataNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuestContextDataNotifyBuilder &operator=(const QuestContextDataNotifyBuilder &);
  flatbuffers::Offset<QuestContextDataNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuestContextDataNotify>(end);
    fbb_.Required(o, QuestContextDataNotify::VT_CONTEXTDATA);
    return o;
  }
};

inline flatbuffers::Offset<QuestContextDataNotify> CreateQuestContextDataNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<QuestContextData> contextData = 0) {
  QuestContextDataNotifyBuilder builder_(_fbb);
  builder_.add_contextData(contextData);
  return builder_.Finish();
}

/// MAIN_STREAM_EVENT_JOIN_SWITCH_STATE_NOTIFY
struct MainStreamEventJoinSwitchStateNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SWITCHSTATE = 4
  };
  bool switchState() const {
    return GetField<uint8_t>(VT_SWITCHSTATE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SWITCHSTATE) &&
           verifier.EndTable();
  }
};

struct MainStreamEventJoinSwitchStateNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_switchState(bool switchState) {
    fbb_.AddElement<uint8_t>(MainStreamEventJoinSwitchStateNotify::VT_SWITCHSTATE, static_cast<uint8_t>(switchState), 0);
  }
  explicit MainStreamEventJoinSwitchStateNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MainStreamEventJoinSwitchStateNotifyBuilder &operator=(const MainStreamEventJoinSwitchStateNotifyBuilder &);
  flatbuffers::Offset<MainStreamEventJoinSwitchStateNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MainStreamEventJoinSwitchStateNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<MainStreamEventJoinSwitchStateNotify> CreateMainStreamEventJoinSwitchStateNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool switchState = false) {
  MainStreamEventJoinSwitchStateNotifyBuilder builder_(_fbb);
  builder_.add_switchState(switchState);
  return builder_.Finish();
}

/// MAIN_STREAM_EVENT_JOIN_SWITCH_REQUEST
struct MainStreamEventJoinSwitchRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SETSWITCH = 4
  };
  bool setSwitch() const {
    return GetField<uint8_t>(VT_SETSWITCH, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SETSWITCH) &&
           verifier.EndTable();
  }
};

struct MainStreamEventJoinSwitchRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_setSwitch(bool setSwitch) {
    fbb_.AddElement<uint8_t>(MainStreamEventJoinSwitchRequest::VT_SETSWITCH, static_cast<uint8_t>(setSwitch), 0);
  }
  explicit MainStreamEventJoinSwitchRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MainStreamEventJoinSwitchRequestBuilder &operator=(const MainStreamEventJoinSwitchRequestBuilder &);
  flatbuffers::Offset<MainStreamEventJoinSwitchRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MainStreamEventJoinSwitchRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<MainStreamEventJoinSwitchRequest> CreateMainStreamEventJoinSwitchRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool setSwitch = false) {
  MainStreamEventJoinSwitchRequestBuilder builder_(_fbb);
  builder_.add_setSwitch(setSwitch);
  return builder_.Finish();
}

/// MAIN_STREAM_EVENT_JOIN_SWITCH_RESPONSE
struct MainStreamEventJoinSwitchResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SWITCHSTATE = 4,
    VT_ERRCODE = 6
  };
  bool switchState() const {
    return GetField<uint8_t>(VT_SWITCHSTATE, 0) != 0;
  }
  ErrorCode errCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SWITCHSTATE) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           verifier.EndTable();
  }
};

struct MainStreamEventJoinSwitchResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_switchState(bool switchState) {
    fbb_.AddElement<uint8_t>(MainStreamEventJoinSwitchResponse::VT_SWITCHSTATE, static_cast<uint8_t>(switchState), 0);
  }
  void add_errCode(ErrorCode errCode) {
    fbb_.AddElement<int32_t>(MainStreamEventJoinSwitchResponse::VT_ERRCODE, static_cast<int32_t>(errCode), 0);
  }
  explicit MainStreamEventJoinSwitchResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MainStreamEventJoinSwitchResponseBuilder &operator=(const MainStreamEventJoinSwitchResponseBuilder &);
  flatbuffers::Offset<MainStreamEventJoinSwitchResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MainStreamEventJoinSwitchResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<MainStreamEventJoinSwitchResponse> CreateMainStreamEventJoinSwitchResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool switchState = false,
    ErrorCode errCode = ErrorCode_NONE) {
  MainStreamEventJoinSwitchResponseBuilder builder_(_fbb);
  builder_.add_errCode(errCode);
  builder_.add_switchState(switchState);
  return builder_.Finish();
}

/// MAINSTREAM_STATE_NOTIFY
struct MainStreamStateNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MAINSTREAMID = 4,
    VT_CHAPTERINDEX = 6,
    VT_STATE = 8
  };
  int32_t mainStreamId() const {
    return GetField<int32_t>(VT_MAINSTREAMID, 0);
  }
  int32_t chapterIndex() const {
    return GetField<int32_t>(VT_CHAPTERINDEX, 0);
  }
  MainStreamStateType state() const {
    return static_cast<MainStreamStateType>(GetField<int32_t>(VT_STATE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MAINSTREAMID) &&
           VerifyField<int32_t>(verifier, VT_CHAPTERINDEX) &&
           VerifyField<int32_t>(verifier, VT_STATE) &&
           verifier.EndTable();
  }
};

struct MainStreamStateNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mainStreamId(int32_t mainStreamId) {
    fbb_.AddElement<int32_t>(MainStreamStateNotify::VT_MAINSTREAMID, mainStreamId, 0);
  }
  void add_chapterIndex(int32_t chapterIndex) {
    fbb_.AddElement<int32_t>(MainStreamStateNotify::VT_CHAPTERINDEX, chapterIndex, 0);
  }
  void add_state(MainStreamStateType state) {
    fbb_.AddElement<int32_t>(MainStreamStateNotify::VT_STATE, static_cast<int32_t>(state), 0);
  }
  explicit MainStreamStateNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MainStreamStateNotifyBuilder &operator=(const MainStreamStateNotifyBuilder &);
  flatbuffers::Offset<MainStreamStateNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MainStreamStateNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<MainStreamStateNotify> CreateMainStreamStateNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t mainStreamId = 0,
    int32_t chapterIndex = 0,
    MainStreamStateType state = MainStreamStateType_MAIN_STREAM_STATE_NONE) {
  MainStreamStateNotifyBuilder builder_(_fbb);
  builder_.add_state(state);
  builder_.add_chapterIndex(chapterIndex);
  builder_.add_mainStreamId(mainStreamId);
  return builder_.Finish();
}

/// MAIN_STREAM_DATA
struct MainStreamData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MAINSTREAMID = 4,
    VT_COUNT = 6,
    VT_STATE = 8
  };
  int32_t mainStreamId() const {
    return GetField<int32_t>(VT_MAINSTREAMID, 0);
  }
  int32_t count() const {
    return GetField<int32_t>(VT_COUNT, 0);
  }
  MainStreamStateType state() const {
    return static_cast<MainStreamStateType>(GetField<int32_t>(VT_STATE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MAINSTREAMID) &&
           VerifyField<int32_t>(verifier, VT_COUNT) &&
           VerifyField<int32_t>(verifier, VT_STATE) &&
           verifier.EndTable();
  }
};

struct MainStreamDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mainStreamId(int32_t mainStreamId) {
    fbb_.AddElement<int32_t>(MainStreamData::VT_MAINSTREAMID, mainStreamId, 0);
  }
  void add_count(int32_t count) {
    fbb_.AddElement<int32_t>(MainStreamData::VT_COUNT, count, 0);
  }
  void add_state(MainStreamStateType state) {
    fbb_.AddElement<int32_t>(MainStreamData::VT_STATE, static_cast<int32_t>(state), 0);
  }
  explicit MainStreamDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MainStreamDataBuilder &operator=(const MainStreamDataBuilder &);
  flatbuffers::Offset<MainStreamData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MainStreamData>(end);
    return o;
  }
};

inline flatbuffers::Offset<MainStreamData> CreateMainStreamData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t mainStreamId = 0,
    int32_t count = 0,
    MainStreamStateType state = MainStreamStateType_MAIN_STREAM_STATE_NONE) {
  MainStreamDataBuilder builder_(_fbb);
  builder_.add_state(state);
  builder_.add_count(count);
  builder_.add_mainStreamId(mainStreamId);
  return builder_.Finish();
}

/// MAIN_STREAM_DATA_NOTIFY
struct MainStreamDataNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATA = 4
  };
  const MainStreamData *data() const {
    return GetPointer<const MainStreamData *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyTable(data()) &&
           verifier.EndTable();
  }
};

struct MainStreamDataNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<MainStreamData> data) {
    fbb_.AddOffset(MainStreamDataNotify::VT_DATA, data);
  }
  explicit MainStreamDataNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MainStreamDataNotifyBuilder &operator=(const MainStreamDataNotifyBuilder &);
  flatbuffers::Offset<MainStreamDataNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MainStreamDataNotify>(end);
    fbb_.Required(o, MainStreamDataNotify::VT_DATA);
    return o;
  }
};

inline flatbuffers::Offset<MainStreamDataNotify> CreateMainStreamDataNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<MainStreamData> data = 0) {
  MainStreamDataNotifyBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

/// MAIN_STREAM_DATA_SET_NOTIFY
struct MainStreamDataSetNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATAS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<MainStreamData>> *datas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MainStreamData>> *>(VT_DATAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DATAS) &&
           verifier.VerifyVector(datas()) &&
           verifier.VerifyVectorOfTables(datas()) &&
           verifier.EndTable();
  }
};

struct MainStreamDataSetNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_datas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MainStreamData>>> datas) {
    fbb_.AddOffset(MainStreamDataSetNotify::VT_DATAS, datas);
  }
  explicit MainStreamDataSetNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MainStreamDataSetNotifyBuilder &operator=(const MainStreamDataSetNotifyBuilder &);
  flatbuffers::Offset<MainStreamDataSetNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MainStreamDataSetNotify>(end);
    fbb_.Required(o, MainStreamDataSetNotify::VT_DATAS);
    return o;
  }
};

inline flatbuffers::Offset<MainStreamDataSetNotify> CreateMainStreamDataSetNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MainStreamData>>> datas = 0) {
  MainStreamDataSetNotifyBuilder builder_(_fbb);
  builder_.add_datas(datas);
  return builder_.Finish();
}

inline flatbuffers::Offset<MainStreamDataSetNotify> CreateMainStreamDataSetNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<MainStreamData>> *datas = nullptr) {
  return LeanPacket::CreateMainStreamDataSetNotify(
      _fbb,
      datas ? _fbb.CreateVector<flatbuffers::Offset<MainStreamData>>(*datas) : 0);
}

/// MAIN_STREAM_DIRECT_NOTIFY
struct MainStreamDirectNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MAINSTREAMID = 4,
    VT_DIRECTIONID = 6
  };
  int32_t mainStreamId() const {
    return GetField<int32_t>(VT_MAINSTREAMID, 0);
  }
  int32_t directionId() const {
    return GetField<int32_t>(VT_DIRECTIONID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MAINSTREAMID) &&
           VerifyField<int32_t>(verifier, VT_DIRECTIONID) &&
           verifier.EndTable();
  }
};

struct MainStreamDirectNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mainStreamId(int32_t mainStreamId) {
    fbb_.AddElement<int32_t>(MainStreamDirectNotify::VT_MAINSTREAMID, mainStreamId, 0);
  }
  void add_directionId(int32_t directionId) {
    fbb_.AddElement<int32_t>(MainStreamDirectNotify::VT_DIRECTIONID, directionId, 0);
  }
  explicit MainStreamDirectNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MainStreamDirectNotifyBuilder &operator=(const MainStreamDirectNotifyBuilder &);
  flatbuffers::Offset<MainStreamDirectNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MainStreamDirectNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<MainStreamDirectNotify> CreateMainStreamDirectNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t mainStreamId = 0,
    int32_t directionId = 0) {
  MainStreamDirectNotifyBuilder builder_(_fbb);
  builder_.add_directionId(directionId);
  builder_.add_mainStreamId(mainStreamId);
  return builder_.Finish();
}

/// MAIN_STREAM_PRE_ACTION_REQUEST
struct MainStreamPreActionRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MAINSTREAMID = 4,
    VT_ACTIONTYPE = 6,
    VT_SMAPID = 8,
    VT_EVENTSETID = 10
  };
  int32_t mainStreamId() const {
    return GetField<int32_t>(VT_MAINSTREAMID, 0);
  }
  MainStreamPreActionType actionType() const {
    return static_cast<MainStreamPreActionType>(GetField<int32_t>(VT_ACTIONTYPE, 0));
  }
  int32_t smapId() const {
    return GetField<int32_t>(VT_SMAPID, 0);
  }
  int32_t eventSetId() const {
    return GetField<int32_t>(VT_EVENTSETID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MAINSTREAMID) &&
           VerifyField<int32_t>(verifier, VT_ACTIONTYPE) &&
           VerifyField<int32_t>(verifier, VT_SMAPID) &&
           VerifyField<int32_t>(verifier, VT_EVENTSETID) &&
           verifier.EndTable();
  }
};

struct MainStreamPreActionRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mainStreamId(int32_t mainStreamId) {
    fbb_.AddElement<int32_t>(MainStreamPreActionRequest::VT_MAINSTREAMID, mainStreamId, 0);
  }
  void add_actionType(MainStreamPreActionType actionType) {
    fbb_.AddElement<int32_t>(MainStreamPreActionRequest::VT_ACTIONTYPE, static_cast<int32_t>(actionType), 0);
  }
  void add_smapId(int32_t smapId) {
    fbb_.AddElement<int32_t>(MainStreamPreActionRequest::VT_SMAPID, smapId, 0);
  }
  void add_eventSetId(int32_t eventSetId) {
    fbb_.AddElement<int32_t>(MainStreamPreActionRequest::VT_EVENTSETID, eventSetId, 0);
  }
  explicit MainStreamPreActionRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MainStreamPreActionRequestBuilder &operator=(const MainStreamPreActionRequestBuilder &);
  flatbuffers::Offset<MainStreamPreActionRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MainStreamPreActionRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<MainStreamPreActionRequest> CreateMainStreamPreActionRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t mainStreamId = 0,
    MainStreamPreActionType actionType = MainStreamPreActionType_MS_PRE_ACTION_TYPE_NONE,
    int32_t smapId = 0,
    int32_t eventSetId = 0) {
  MainStreamPreActionRequestBuilder builder_(_fbb);
  builder_.add_eventSetId(eventSetId);
  builder_.add_smapId(smapId);
  builder_.add_actionType(actionType);
  builder_.add_mainStreamId(mainStreamId);
  return builder_.Finish();
}

/// MAIN_STREAM_PRE_ACTION_RESPONSE
struct MainStreamPreActionResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           verifier.EndTable();
  }
};

struct MainStreamPreActionResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(MainStreamPreActionResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  explicit MainStreamPreActionResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MainStreamPreActionResponseBuilder &operator=(const MainStreamPreActionResponseBuilder &);
  flatbuffers::Offset<MainStreamPreActionResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MainStreamPreActionResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<MainStreamPreActionResponse> CreateMainStreamPreActionResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE) {
  MainStreamPreActionResponseBuilder builder_(_fbb);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

/// MAIN_STREAM_FINISHED_BACK_NOTIFY
struct MainStreamFinishedBackNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MAINSTREAMID = 4
  };
  int32_t mainStreamId() const {
    return GetField<int32_t>(VT_MAINSTREAMID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MAINSTREAMID) &&
           verifier.EndTable();
  }
};

struct MainStreamFinishedBackNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mainStreamId(int32_t mainStreamId) {
    fbb_.AddElement<int32_t>(MainStreamFinishedBackNotify::VT_MAINSTREAMID, mainStreamId, 0);
  }
  explicit MainStreamFinishedBackNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MainStreamFinishedBackNotifyBuilder &operator=(const MainStreamFinishedBackNotifyBuilder &);
  flatbuffers::Offset<MainStreamFinishedBackNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MainStreamFinishedBackNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<MainStreamFinishedBackNotify> CreateMainStreamFinishedBackNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t mainStreamId = 0) {
  MainStreamFinishedBackNotifyBuilder builder_(_fbb);
  builder_.add_mainStreamId(mainStreamId);
  return builder_.Finish();
}

/// MAIN_STREAM_DO_BUTTON_ACTION_REQUEST
struct MainStreamDoButtonActionRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MAINSTREAMID = 4
  };
  int32_t mainStreamId() const {
    return GetField<int32_t>(VT_MAINSTREAMID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MAINSTREAMID) &&
           verifier.EndTable();
  }
};

struct MainStreamDoButtonActionRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mainStreamId(int32_t mainStreamId) {
    fbb_.AddElement<int32_t>(MainStreamDoButtonActionRequest::VT_MAINSTREAMID, mainStreamId, 0);
  }
  explicit MainStreamDoButtonActionRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MainStreamDoButtonActionRequestBuilder &operator=(const MainStreamDoButtonActionRequestBuilder &);
  flatbuffers::Offset<MainStreamDoButtonActionRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MainStreamDoButtonActionRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<MainStreamDoButtonActionRequest> CreateMainStreamDoButtonActionRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t mainStreamId = 0) {
  MainStreamDoButtonActionRequestBuilder builder_(_fbb);
  builder_.add_mainStreamId(mainStreamId);
  return builder_.Finish();
}

/// MAIN_STREAM_DO_BUTTON_ACTION_RESPONSE
struct MainStreamDoButtonActionResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           verifier.EndTable();
  }
};

struct MainStreamDoButtonActionResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(MainStreamDoButtonActionResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  explicit MainStreamDoButtonActionResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MainStreamDoButtonActionResponseBuilder &operator=(const MainStreamDoButtonActionResponseBuilder &);
  flatbuffers::Offset<MainStreamDoButtonActionResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MainStreamDoButtonActionResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<MainStreamDoButtonActionResponse> CreateMainStreamDoButtonActionResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE) {
  MainStreamDoButtonActionResponseBuilder builder_(_fbb);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

/// MAIN_STREAM_ON_REWARD_UI_NOTIFY
struct MainStreamOnRewardUiNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MAINSTREAMID = 4,
    VT_REWARDID = 6,
    VT_REWARDINFO = 8,
    VT_ORIGNREWARDINFO = 10
  };
  int32_t mainStreamId() const {
    return GetField<int32_t>(VT_MAINSTREAMID, 0);
  }
  int32_t rewardId() const {
    return GetField<int32_t>(VT_REWARDID, 0);
  }
  const RewardInfo *rewardInfo() const {
    return GetPointer<const RewardInfo *>(VT_REWARDINFO);
  }
  const RewardInfo *orignRewardInfo() const {
    return GetPointer<const RewardInfo *>(VT_ORIGNREWARDINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MAINSTREAMID) &&
           VerifyField<int32_t>(verifier, VT_REWARDID) &&
           VerifyOffsetRequired(verifier, VT_REWARDINFO) &&
           verifier.VerifyTable(rewardInfo()) &&
           VerifyOffsetRequired(verifier, VT_ORIGNREWARDINFO) &&
           verifier.VerifyTable(orignRewardInfo()) &&
           verifier.EndTable();
  }
};

struct MainStreamOnRewardUiNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mainStreamId(int32_t mainStreamId) {
    fbb_.AddElement<int32_t>(MainStreamOnRewardUiNotify::VT_MAINSTREAMID, mainStreamId, 0);
  }
  void add_rewardId(int32_t rewardId) {
    fbb_.AddElement<int32_t>(MainStreamOnRewardUiNotify::VT_REWARDID, rewardId, 0);
  }
  void add_rewardInfo(flatbuffers::Offset<RewardInfo> rewardInfo) {
    fbb_.AddOffset(MainStreamOnRewardUiNotify::VT_REWARDINFO, rewardInfo);
  }
  void add_orignRewardInfo(flatbuffers::Offset<RewardInfo> orignRewardInfo) {
    fbb_.AddOffset(MainStreamOnRewardUiNotify::VT_ORIGNREWARDINFO, orignRewardInfo);
  }
  explicit MainStreamOnRewardUiNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MainStreamOnRewardUiNotifyBuilder &operator=(const MainStreamOnRewardUiNotifyBuilder &);
  flatbuffers::Offset<MainStreamOnRewardUiNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MainStreamOnRewardUiNotify>(end);
    fbb_.Required(o, MainStreamOnRewardUiNotify::VT_REWARDINFO);
    fbb_.Required(o, MainStreamOnRewardUiNotify::VT_ORIGNREWARDINFO);
    return o;
  }
};

inline flatbuffers::Offset<MainStreamOnRewardUiNotify> CreateMainStreamOnRewardUiNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t mainStreamId = 0,
    int32_t rewardId = 0,
    flatbuffers::Offset<RewardInfo> rewardInfo = 0,
    flatbuffers::Offset<RewardInfo> orignRewardInfo = 0) {
  MainStreamOnRewardUiNotifyBuilder builder_(_fbb);
  builder_.add_orignRewardInfo(orignRewardInfo);
  builder_.add_rewardInfo(rewardInfo);
  builder_.add_rewardId(rewardId);
  builder_.add_mainStreamId(mainStreamId);
  return builder_.Finish();
}

/// 일일과제 항목 데이터
struct DailyHomeworkData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONTENTSTYPE = 4,
    VT_ID = 6,
    VT_COUNT = 8
  };
  DailyHomeworkType contentsType() const {
    return static_cast<DailyHomeworkType>(GetField<int32_t>(VT_CONTENTSTYPE, 0));
  }
  int16_t id() const {
    return GetField<int16_t>(VT_ID, 0);
  }
  int16_t count() const {
    return GetField<int16_t>(VT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CONTENTSTYPE) &&
           VerifyField<int16_t>(verifier, VT_ID) &&
           VerifyField<int16_t>(verifier, VT_COUNT) &&
           verifier.EndTable();
  }
};

struct DailyHomeworkDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_contentsType(DailyHomeworkType contentsType) {
    fbb_.AddElement<int32_t>(DailyHomeworkData::VT_CONTENTSTYPE, static_cast<int32_t>(contentsType), 0);
  }
  void add_id(int16_t id) {
    fbb_.AddElement<int16_t>(DailyHomeworkData::VT_ID, id, 0);
  }
  void add_count(int16_t count) {
    fbb_.AddElement<int16_t>(DailyHomeworkData::VT_COUNT, count, 0);
  }
  explicit DailyHomeworkDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DailyHomeworkDataBuilder &operator=(const DailyHomeworkDataBuilder &);
  flatbuffers::Offset<DailyHomeworkData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DailyHomeworkData>(end);
    return o;
  }
};

inline flatbuffers::Offset<DailyHomeworkData> CreateDailyHomeworkData(
    flatbuffers::FlatBufferBuilder &_fbb,
    DailyHomeworkType contentsType = DailyHomeworkType_DAILY_HOMEWORK_TYPE_NONE,
    int16_t id = 0,
    int16_t count = 0) {
  DailyHomeworkDataBuilder builder_(_fbb);
  builder_.add_contentsType(contentsType);
  builder_.add_count(count);
  builder_.add_id(id);
  return builder_.Finish();
}

/// 일일과제 활약도 보상 상태
struct DailyHomeworkActivityRewardStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_COMPLETE = 6
  };
  int16_t id() const {
    return GetField<int16_t>(VT_ID, 0);
  }
  bool complete() const {
    return GetField<uint8_t>(VT_COMPLETE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_COMPLETE) &&
           verifier.EndTable();
  }
};

struct DailyHomeworkActivityRewardStatusBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int16_t id) {
    fbb_.AddElement<int16_t>(DailyHomeworkActivityRewardStatus::VT_ID, id, 0);
  }
  void add_complete(bool complete) {
    fbb_.AddElement<uint8_t>(DailyHomeworkActivityRewardStatus::VT_COMPLETE, static_cast<uint8_t>(complete), 0);
  }
  explicit DailyHomeworkActivityRewardStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DailyHomeworkActivityRewardStatusBuilder &operator=(const DailyHomeworkActivityRewardStatusBuilder &);
  flatbuffers::Offset<DailyHomeworkActivityRewardStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DailyHomeworkActivityRewardStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<DailyHomeworkActivityRewardStatus> CreateDailyHomeworkActivityRewardStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t id = 0,
    bool complete = false) {
  DailyHomeworkActivityRewardStatusBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_complete(complete);
  return builder_.Finish();
}

/// DAILY_HOMEWORK_DATA_ALL_NOTIFY
struct DailyHomeworkDataAllNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CHAPTER = 4,
    VT_ACTIVITYPOINT = 6,
    VT_DATAS = 8,
    VT_ACTIVITYPOINTSTATUSES = 10
  };
  int32_t chapter() const {
    return GetField<int32_t>(VT_CHAPTER, 0);
  }
  int32_t activityPoint() const {
    return GetField<int32_t>(VT_ACTIVITYPOINT, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<DailyHomeworkData>> *datas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DailyHomeworkData>> *>(VT_DATAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<DailyHomeworkActivityRewardStatus>> *activityPointStatuses() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DailyHomeworkActivityRewardStatus>> *>(VT_ACTIVITYPOINTSTATUSES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CHAPTER) &&
           VerifyField<int32_t>(verifier, VT_ACTIVITYPOINT) &&
           VerifyOffsetRequired(verifier, VT_DATAS) &&
           verifier.VerifyVector(datas()) &&
           verifier.VerifyVectorOfTables(datas()) &&
           VerifyOffsetRequired(verifier, VT_ACTIVITYPOINTSTATUSES) &&
           verifier.VerifyVector(activityPointStatuses()) &&
           verifier.VerifyVectorOfTables(activityPointStatuses()) &&
           verifier.EndTable();
  }
};

struct DailyHomeworkDataAllNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_chapter(int32_t chapter) {
    fbb_.AddElement<int32_t>(DailyHomeworkDataAllNotify::VT_CHAPTER, chapter, 0);
  }
  void add_activityPoint(int32_t activityPoint) {
    fbb_.AddElement<int32_t>(DailyHomeworkDataAllNotify::VT_ACTIVITYPOINT, activityPoint, 0);
  }
  void add_datas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DailyHomeworkData>>> datas) {
    fbb_.AddOffset(DailyHomeworkDataAllNotify::VT_DATAS, datas);
  }
  void add_activityPointStatuses(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DailyHomeworkActivityRewardStatus>>> activityPointStatuses) {
    fbb_.AddOffset(DailyHomeworkDataAllNotify::VT_ACTIVITYPOINTSTATUSES, activityPointStatuses);
  }
  explicit DailyHomeworkDataAllNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DailyHomeworkDataAllNotifyBuilder &operator=(const DailyHomeworkDataAllNotifyBuilder &);
  flatbuffers::Offset<DailyHomeworkDataAllNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DailyHomeworkDataAllNotify>(end);
    fbb_.Required(o, DailyHomeworkDataAllNotify::VT_DATAS);
    fbb_.Required(o, DailyHomeworkDataAllNotify::VT_ACTIVITYPOINTSTATUSES);
    return o;
  }
};

inline flatbuffers::Offset<DailyHomeworkDataAllNotify> CreateDailyHomeworkDataAllNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t chapter = 0,
    int32_t activityPoint = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DailyHomeworkData>>> datas = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DailyHomeworkActivityRewardStatus>>> activityPointStatuses = 0) {
  DailyHomeworkDataAllNotifyBuilder builder_(_fbb);
  builder_.add_activityPointStatuses(activityPointStatuses);
  builder_.add_datas(datas);
  builder_.add_activityPoint(activityPoint);
  builder_.add_chapter(chapter);
  return builder_.Finish();
}

inline flatbuffers::Offset<DailyHomeworkDataAllNotify> CreateDailyHomeworkDataAllNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t chapter = 0,
    int32_t activityPoint = 0,
    const std::vector<flatbuffers::Offset<DailyHomeworkData>> *datas = nullptr,
    const std::vector<flatbuffers::Offset<DailyHomeworkActivityRewardStatus>> *activityPointStatuses = nullptr) {
  return LeanPacket::CreateDailyHomeworkDataAllNotify(
      _fbb,
      chapter,
      activityPoint,
      datas ? _fbb.CreateVector<flatbuffers::Offset<DailyHomeworkData>>(*datas) : 0,
      activityPointStatuses ? _fbb.CreateVector<flatbuffers::Offset<DailyHomeworkActivityRewardStatus>>(*activityPointStatuses) : 0);
}

/// DAILY_HOMEWORK_DATA_UPDATE_NOTIFY
struct DailyHomeworkDataUpdateNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACTIVITYPOINT = 4,
    VT_DATA = 6
  };
  /// activityPoint는 절대값
  int32_t activityPoint() const {
    return GetField<int32_t>(VT_ACTIVITYPOINT, 0);
  }
  const DailyHomeworkData *data() const {
    return GetPointer<const DailyHomeworkData *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ACTIVITYPOINT) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyTable(data()) &&
           verifier.EndTable();
  }
};

struct DailyHomeworkDataUpdateNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_activityPoint(int32_t activityPoint) {
    fbb_.AddElement<int32_t>(DailyHomeworkDataUpdateNotify::VT_ACTIVITYPOINT, activityPoint, 0);
  }
  void add_data(flatbuffers::Offset<DailyHomeworkData> data) {
    fbb_.AddOffset(DailyHomeworkDataUpdateNotify::VT_DATA, data);
  }
  explicit DailyHomeworkDataUpdateNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DailyHomeworkDataUpdateNotifyBuilder &operator=(const DailyHomeworkDataUpdateNotifyBuilder &);
  flatbuffers::Offset<DailyHomeworkDataUpdateNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DailyHomeworkDataUpdateNotify>(end);
    fbb_.Required(o, DailyHomeworkDataUpdateNotify::VT_DATA);
    return o;
  }
};

inline flatbuffers::Offset<DailyHomeworkDataUpdateNotify> CreateDailyHomeworkDataUpdateNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t activityPoint = 0,
    flatbuffers::Offset<DailyHomeworkData> data = 0) {
  DailyHomeworkDataUpdateNotifyBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_activityPoint(activityPoint);
  return builder_.Finish();
}

/// DAILY_HOMEWORK_GET_REWARD_REQUEST
struct DailyHomeworkGetRewardRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATAID = 4
  };
  int32_t dataId() const {
    return GetField<int32_t>(VT_DATAID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DATAID) &&
           verifier.EndTable();
  }
};

struct DailyHomeworkGetRewardRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dataId(int32_t dataId) {
    fbb_.AddElement<int32_t>(DailyHomeworkGetRewardRequest::VT_DATAID, dataId, 0);
  }
  explicit DailyHomeworkGetRewardRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DailyHomeworkGetRewardRequestBuilder &operator=(const DailyHomeworkGetRewardRequestBuilder &);
  flatbuffers::Offset<DailyHomeworkGetRewardRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DailyHomeworkGetRewardRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DailyHomeworkGetRewardRequest> CreateDailyHomeworkGetRewardRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t dataId = 0) {
  DailyHomeworkGetRewardRequestBuilder builder_(_fbb);
  builder_.add_dataId(dataId);
  return builder_.Finish();
}

/// DAILY_HOMEWORK_GET_REWARD_RESPONSE
struct DailyHomeworkGetRewardResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           verifier.EndTable();
  }
};

struct DailyHomeworkGetRewardResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(DailyHomeworkGetRewardResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  explicit DailyHomeworkGetRewardResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DailyHomeworkGetRewardResponseBuilder &operator=(const DailyHomeworkGetRewardResponseBuilder &);
  flatbuffers::Offset<DailyHomeworkGetRewardResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DailyHomeworkGetRewardResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<DailyHomeworkGetRewardResponse> CreateDailyHomeworkGetRewardResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE) {
  DailyHomeworkGetRewardResponseBuilder builder_(_fbb);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

/// CHAPTER_CLEAR_SMAP_REQUEST
/// 챕터 UI에서 smap 완료 후 버튼을 누르면 전송하는 패킷
/// 다음 smap이 열리거나 다음 챕터가 열린다
struct ChapterClearSMapRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ChapterClearSMapRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ChapterClearSMapRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChapterClearSMapRequestBuilder &operator=(const ChapterClearSMapRequestBuilder &);
  flatbuffers::Offset<ChapterClearSMapRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChapterClearSMapRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChapterClearSMapRequest> CreateChapterClearSMapRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ChapterClearSMapRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// CHAPTER_CLEAR_SMAP_RESPONSE
struct ChapterClearSMapResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_CHAPTERID = 6,
    VT_SMAPINDEX = 8
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  /// 위 errorCode가 OK가 아닐 경우에는 아래 값은 0으로 채워집니다
  int16_t chapterId() const {
    return GetField<int16_t>(VT_CHAPTERID, 0);
  }
  int16_t sMapIndex() const {
    return GetField<int16_t>(VT_SMAPINDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int16_t>(verifier, VT_CHAPTERID) &&
           VerifyField<int16_t>(verifier, VT_SMAPINDEX) &&
           verifier.EndTable();
  }
};

struct ChapterClearSMapResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(ChapterClearSMapResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  void add_chapterId(int16_t chapterId) {
    fbb_.AddElement<int16_t>(ChapterClearSMapResponse::VT_CHAPTERID, chapterId, 0);
  }
  void add_sMapIndex(int16_t sMapIndex) {
    fbb_.AddElement<int16_t>(ChapterClearSMapResponse::VT_SMAPINDEX, sMapIndex, 0);
  }
  explicit ChapterClearSMapResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChapterClearSMapResponseBuilder &operator=(const ChapterClearSMapResponseBuilder &);
  flatbuffers::Offset<ChapterClearSMapResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChapterClearSMapResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChapterClearSMapResponse> CreateChapterClearSMapResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE,
    int16_t chapterId = 0,
    int16_t sMapIndex = 0) {
  ChapterClearSMapResponseBuilder builder_(_fbb);
  builder_.add_errorCode(errorCode);
  builder_.add_sMapIndex(sMapIndex);
  builder_.add_chapterId(chapterId);
  return builder_.Finish();
}

/// CHAPTER_JOIN_SMAP_REQUEST
struct ChapterJoinSmapRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SMAPID = 4
  };
  int32_t sMapId() const {
    return GetField<int32_t>(VT_SMAPID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SMAPID) &&
           verifier.EndTable();
  }
};

struct ChapterJoinSmapRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sMapId(int32_t sMapId) {
    fbb_.AddElement<int32_t>(ChapterJoinSmapRequest::VT_SMAPID, sMapId, 0);
  }
  explicit ChapterJoinSmapRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChapterJoinSmapRequestBuilder &operator=(const ChapterJoinSmapRequestBuilder &);
  flatbuffers::Offset<ChapterJoinSmapRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChapterJoinSmapRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChapterJoinSmapRequest> CreateChapterJoinSmapRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t sMapId = 0) {
  ChapterJoinSmapRequestBuilder builder_(_fbb);
  builder_.add_sMapId(sMapId);
  return builder_.Finish();
}

/// CHAPTER_JOIN_SMAP_RESPONSE
struct ChapterJoinSmapResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           verifier.EndTable();
  }
};

struct ChapterJoinSmapResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(ChapterJoinSmapResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  explicit ChapterJoinSmapResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChapterJoinSmapResponseBuilder &operator=(const ChapterJoinSmapResponseBuilder &);
  flatbuffers::Offset<ChapterJoinSmapResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChapterJoinSmapResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChapterJoinSmapResponse> CreateChapterJoinSmapResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE) {
  ChapterJoinSmapResponseBuilder builder_(_fbb);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

///  CHAPTER_JOIN_REQUEST
struct ChapterJoinRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CHAPTERINDEX = 4,
    VT_JOINTYPE = 6,
    VT_SMAPID = 8,
    VT_BOSSEVENTSETID = 10
  };
  int16_t chapterIndex() const {
    return GetField<int16_t>(VT_CHAPTERINDEX, 0);
  }
  ChapterJoinType joinType() const {
    return static_cast<ChapterJoinType>(GetField<int32_t>(VT_JOINTYPE, 0));
  }
  int32_t smapId() const {
    return GetField<int32_t>(VT_SMAPID, 0);
  }
  int32_t bossEventSetId() const {
    return GetField<int32_t>(VT_BOSSEVENTSETID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_CHAPTERINDEX) &&
           VerifyField<int32_t>(verifier, VT_JOINTYPE) &&
           VerifyField<int32_t>(verifier, VT_SMAPID) &&
           VerifyField<int32_t>(verifier, VT_BOSSEVENTSETID) &&
           verifier.EndTable();
  }
};

struct ChapterJoinRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_chapterIndex(int16_t chapterIndex) {
    fbb_.AddElement<int16_t>(ChapterJoinRequest::VT_CHAPTERINDEX, chapterIndex, 0);
  }
  void add_joinType(ChapterJoinType joinType) {
    fbb_.AddElement<int32_t>(ChapterJoinRequest::VT_JOINTYPE, static_cast<int32_t>(joinType), 0);
  }
  void add_smapId(int32_t smapId) {
    fbb_.AddElement<int32_t>(ChapterJoinRequest::VT_SMAPID, smapId, 0);
  }
  void add_bossEventSetId(int32_t bossEventSetId) {
    fbb_.AddElement<int32_t>(ChapterJoinRequest::VT_BOSSEVENTSETID, bossEventSetId, 0);
  }
  explicit ChapterJoinRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChapterJoinRequestBuilder &operator=(const ChapterJoinRequestBuilder &);
  flatbuffers::Offset<ChapterJoinRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChapterJoinRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChapterJoinRequest> CreateChapterJoinRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t chapterIndex = 0,
    ChapterJoinType joinType = ChapterJoinType_CHAPTER_JOIN_TYPE_SMAP,
    int32_t smapId = 0,
    int32_t bossEventSetId = 0) {
  ChapterJoinRequestBuilder builder_(_fbb);
  builder_.add_bossEventSetId(bossEventSetId);
  builder_.add_smapId(smapId);
  builder_.add_joinType(joinType);
  builder_.add_chapterIndex(chapterIndex);
  return builder_.Finish();
}

/// CHAPTER_JOIN_RESPONSE
struct ChapterJoinResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRCODE = 4
  };
  ErrorCode errCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           verifier.EndTable();
  }
};

struct ChapterJoinResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errCode(ErrorCode errCode) {
    fbb_.AddElement<int32_t>(ChapterJoinResponse::VT_ERRCODE, static_cast<int32_t>(errCode), 0);
  }
  explicit ChapterJoinResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChapterJoinResponseBuilder &operator=(const ChapterJoinResponseBuilder &);
  flatbuffers::Offset<ChapterJoinResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChapterJoinResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChapterJoinResponse> CreateChapterJoinResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errCode = ErrorCode_NONE) {
  ChapterJoinResponseBuilder builder_(_fbb);
  builder_.add_errCode(errCode);
  return builder_.Finish();
}

/// CHAPTER_DATA_NOTIFY
/// 삭제하고 CHAPTER_NOTIFY로 대체될 것이다
struct ChapterDataNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CHAPTERID = 4
  };
  int16_t chapterId() const {
    return GetField<int16_t>(VT_CHAPTERID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_CHAPTERID) &&
           verifier.EndTable();
  }
};

struct ChapterDataNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_chapterId(int16_t chapterId) {
    fbb_.AddElement<int16_t>(ChapterDataNotify::VT_CHAPTERID, chapterId, 0);
  }
  explicit ChapterDataNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChapterDataNotifyBuilder &operator=(const ChapterDataNotifyBuilder &);
  flatbuffers::Offset<ChapterDataNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChapterDataNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChapterDataNotify> CreateChapterDataNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t chapterId = 0) {
  ChapterDataNotifyBuilder builder_(_fbb);
  builder_.add_chapterId(chapterId);
  return builder_.Finish();
}

/// CHAPTER_NOTIFY
struct ChapterNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CHAPTERID = 4,
    VT_SMAPINDEX = 6
  };
  int16_t chapterId() const {
    return GetField<int16_t>(VT_CHAPTERID, 0);
  }
  int16_t sMapIndex() const {
    return GetField<int16_t>(VT_SMAPINDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_CHAPTERID) &&
           VerifyField<int16_t>(verifier, VT_SMAPINDEX) &&
           verifier.EndTable();
  }
};

struct ChapterNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_chapterId(int16_t chapterId) {
    fbb_.AddElement<int16_t>(ChapterNotify::VT_CHAPTERID, chapterId, 0);
  }
  void add_sMapIndex(int16_t sMapIndex) {
    fbb_.AddElement<int16_t>(ChapterNotify::VT_SMAPINDEX, sMapIndex, 0);
  }
  explicit ChapterNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChapterNotifyBuilder &operator=(const ChapterNotifyBuilder &);
  flatbuffers::Offset<ChapterNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChapterNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChapterNotify> CreateChapterNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t chapterId = 0,
    int16_t sMapIndex = 0) {
  ChapterNotifyBuilder builder_(_fbb);
  builder_.add_sMapIndex(sMapIndex);
  builder_.add_chapterId(chapterId);
  return builder_.Finish();
}

/// EXIT_INSTANCE_DUNGEON_REQUEST
struct ExitInstanceDungeonRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ExitInstanceDungeonRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ExitInstanceDungeonRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExitInstanceDungeonRequestBuilder &operator=(const ExitInstanceDungeonRequestBuilder &);
  flatbuffers::Offset<ExitInstanceDungeonRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExitInstanceDungeonRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExitInstanceDungeonRequest> CreateExitInstanceDungeonRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ExitInstanceDungeonRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// EXIT_INSTANCE_DUNGEON_RESPONSE
struct ExitInstanceDungeonResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_REASON = 4
  };
  JoinChannelReason reason() const {
    return static_cast<JoinChannelReason>(GetField<int32_t>(VT_REASON, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_REASON) &&
           verifier.EndTable();
  }
};

struct ExitInstanceDungeonResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_reason(JoinChannelReason reason) {
    fbb_.AddElement<int32_t>(ExitInstanceDungeonResponse::VT_REASON, static_cast<int32_t>(reason), 0);
  }
  explicit ExitInstanceDungeonResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExitInstanceDungeonResponseBuilder &operator=(const ExitInstanceDungeonResponseBuilder &);
  flatbuffers::Offset<ExitInstanceDungeonResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExitInstanceDungeonResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExitInstanceDungeonResponse> CreateExitInstanceDungeonResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    JoinChannelReason reason = JoinChannelReason_JOIN_CHANNEL_REASON_NONE) {
  ExitInstanceDungeonResponseBuilder builder_(_fbb);
  builder_.add_reason(reason);
  return builder_.Finish();
}

/// EVENT_MOVE_START_LOC_REQUEST 
struct EventMoveStartLocRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EVENTID = 4,
    VT_PHASEID = 6,
    VT_SMAPID = 8,
    VT_SCENEID = 10,
    VT_POS = 12
  };
  int32_t eventId() const {
    return GetField<int32_t>(VT_EVENTID, 0);
  }
  int32_t phaseId() const {
    return GetField<int32_t>(VT_PHASEID, 0);
  }
  int32_t sMapId() const {
    return GetField<int32_t>(VT_SMAPID, 0);
  }
  int32_t sceneId() const {
    return GetField<int32_t>(VT_SCENEID, 0);
  }
  const Pos *pos() const {
    return GetPointer<const Pos *>(VT_POS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_EVENTID) &&
           VerifyField<int32_t>(verifier, VT_PHASEID) &&
           VerifyField<int32_t>(verifier, VT_SMAPID) &&
           VerifyField<int32_t>(verifier, VT_SCENEID) &&
           VerifyOffset(verifier, VT_POS) &&
           verifier.VerifyTable(pos()) &&
           verifier.EndTable();
  }
};

struct EventMoveStartLocRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eventId(int32_t eventId) {
    fbb_.AddElement<int32_t>(EventMoveStartLocRequest::VT_EVENTID, eventId, 0);
  }
  void add_phaseId(int32_t phaseId) {
    fbb_.AddElement<int32_t>(EventMoveStartLocRequest::VT_PHASEID, phaseId, 0);
  }
  void add_sMapId(int32_t sMapId) {
    fbb_.AddElement<int32_t>(EventMoveStartLocRequest::VT_SMAPID, sMapId, 0);
  }
  void add_sceneId(int32_t sceneId) {
    fbb_.AddElement<int32_t>(EventMoveStartLocRequest::VT_SCENEID, sceneId, 0);
  }
  void add_pos(flatbuffers::Offset<Pos> pos) {
    fbb_.AddOffset(EventMoveStartLocRequest::VT_POS, pos);
  }
  explicit EventMoveStartLocRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EventMoveStartLocRequestBuilder &operator=(const EventMoveStartLocRequestBuilder &);
  flatbuffers::Offset<EventMoveStartLocRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EventMoveStartLocRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<EventMoveStartLocRequest> CreateEventMoveStartLocRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t eventId = 0,
    int32_t phaseId = 0,
    int32_t sMapId = 0,
    int32_t sceneId = 0,
    flatbuffers::Offset<Pos> pos = 0) {
  EventMoveStartLocRequestBuilder builder_(_fbb);
  builder_.add_pos(pos);
  builder_.add_sceneId(sceneId);
  builder_.add_sMapId(sMapId);
  builder_.add_phaseId(phaseId);
  builder_.add_eventId(eventId);
  return builder_.Finish();
}

/// EVENT_MOVE_START_LOC_RESPONSE 
struct EventMoveStartLocResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EVENTID = 4,
    VT_ERRCODE = 6
  };
  int32_t eventId() const {
    return GetField<int32_t>(VT_EVENTID, 0);
  }
  ErrorCode errCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_EVENTID) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           verifier.EndTable();
  }
};

struct EventMoveStartLocResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eventId(int32_t eventId) {
    fbb_.AddElement<int32_t>(EventMoveStartLocResponse::VT_EVENTID, eventId, 0);
  }
  void add_errCode(ErrorCode errCode) {
    fbb_.AddElement<int32_t>(EventMoveStartLocResponse::VT_ERRCODE, static_cast<int32_t>(errCode), 0);
  }
  explicit EventMoveStartLocResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EventMoveStartLocResponseBuilder &operator=(const EventMoveStartLocResponseBuilder &);
  flatbuffers::Offset<EventMoveStartLocResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EventMoveStartLocResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<EventMoveStartLocResponse> CreateEventMoveStartLocResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t eventId = 0,
    ErrorCode errCode = ErrorCode_NONE) {
  EventMoveStartLocResponseBuilder builder_(_fbb);
  builder_.add_errCode(errCode);
  builder_.add_eventId(eventId);
  return builder_.Finish();
}

/// EVENT_RETURN_LAST_LOC_REQUEST 
struct EventReturnLastLocRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EVENTID = 4
  };
  int32_t eventId() const {
    return GetField<int32_t>(VT_EVENTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_EVENTID) &&
           verifier.EndTable();
  }
};

struct EventReturnLastLocRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eventId(int32_t eventId) {
    fbb_.AddElement<int32_t>(EventReturnLastLocRequest::VT_EVENTID, eventId, 0);
  }
  explicit EventReturnLastLocRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EventReturnLastLocRequestBuilder &operator=(const EventReturnLastLocRequestBuilder &);
  flatbuffers::Offset<EventReturnLastLocRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EventReturnLastLocRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<EventReturnLastLocRequest> CreateEventReturnLastLocRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t eventId = 0) {
  EventReturnLastLocRequestBuilder builder_(_fbb);
  builder_.add_eventId(eventId);
  return builder_.Finish();
}

/// EVENT_RETURN_LAST_LOC_RESPONSE 
struct EventReturnLastLocResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EVENTID = 4,
    VT_ERRCODE = 6
  };
  int32_t eventId() const {
    return GetField<int32_t>(VT_EVENTID, 0);
  }
  ErrorCode errCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_EVENTID) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           verifier.EndTable();
  }
};

struct EventReturnLastLocResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eventId(int32_t eventId) {
    fbb_.AddElement<int32_t>(EventReturnLastLocResponse::VT_EVENTID, eventId, 0);
  }
  void add_errCode(ErrorCode errCode) {
    fbb_.AddElement<int32_t>(EventReturnLastLocResponse::VT_ERRCODE, static_cast<int32_t>(errCode), 0);
  }
  explicit EventReturnLastLocResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EventReturnLastLocResponseBuilder &operator=(const EventReturnLastLocResponseBuilder &);
  flatbuffers::Offset<EventReturnLastLocResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EventReturnLastLocResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<EventReturnLastLocResponse> CreateEventReturnLastLocResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t eventId = 0,
    ErrorCode errCode = ErrorCode_NONE) {
  EventReturnLastLocResponseBuilder builder_(_fbb);
  builder_.add_errCode(errCode);
  builder_.add_eventId(eventId);
  return builder_.Finish();
}

/// #골드던전
/// GOLD_DUNGEON_INFO_REQUEST
struct GoldDungeonInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GoldDungeonInfoRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GoldDungeonInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GoldDungeonInfoRequestBuilder &operator=(const GoldDungeonInfoRequestBuilder &);
  flatbuffers::Offset<GoldDungeonInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GoldDungeonInfoRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GoldDungeonInfoRequest> CreateGoldDungeonInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GoldDungeonInfoRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// GOLD_DUNGEON_INFO_RESPONSE
struct GoldDungeonInfoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ENTERCOUNT = 4
  };
  int16_t enterCount() const {
    return GetField<int16_t>(VT_ENTERCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_ENTERCOUNT) &&
           verifier.EndTable();
  }
};

struct GoldDungeonInfoResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enterCount(int16_t enterCount) {
    fbb_.AddElement<int16_t>(GoldDungeonInfoResponse::VT_ENTERCOUNT, enterCount, 0);
  }
  explicit GoldDungeonInfoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GoldDungeonInfoResponseBuilder &operator=(const GoldDungeonInfoResponseBuilder &);
  flatbuffers::Offset<GoldDungeonInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GoldDungeonInfoResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GoldDungeonInfoResponse> CreateGoldDungeonInfoResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t enterCount = 0) {
  GoldDungeonInfoResponseBuilder builder_(_fbb);
  builder_.add_enterCount(enterCount);
  return builder_.Finish();
}

/// GOLD_DUNGEON_ENTER_FAILED
struct GoldDungeonEnterFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           verifier.EndTable();
  }
};

struct GoldDungeonEnterFailedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(GoldDungeonEnterFailed::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  explicit GoldDungeonEnterFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GoldDungeonEnterFailedBuilder &operator=(const GoldDungeonEnterFailedBuilder &);
  flatbuffers::Offset<GoldDungeonEnterFailed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GoldDungeonEnterFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<GoldDungeonEnterFailed> CreateGoldDungeonEnterFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE) {
  GoldDungeonEnterFailedBuilder builder_(_fbb);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

/// QUEST_BONUS_REWARD
struct QuestBonusData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_QUESTBONUSID = 4,
    VT_ISRECEIVEDREWARD = 6
  };
  int32_t questBonusId() const {
    return GetField<int32_t>(VT_QUESTBONUSID, 0);
  }
  bool isReceivedReward() const {
    return GetField<uint8_t>(VT_ISRECEIVEDREWARD, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_QUESTBONUSID) &&
           VerifyField<uint8_t>(verifier, VT_ISRECEIVEDREWARD) &&
           verifier.EndTable();
  }
};

struct QuestBonusDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_questBonusId(int32_t questBonusId) {
    fbb_.AddElement<int32_t>(QuestBonusData::VT_QUESTBONUSID, questBonusId, 0);
  }
  void add_isReceivedReward(bool isReceivedReward) {
    fbb_.AddElement<uint8_t>(QuestBonusData::VT_ISRECEIVEDREWARD, static_cast<uint8_t>(isReceivedReward), 0);
  }
  explicit QuestBonusDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuestBonusDataBuilder &operator=(const QuestBonusDataBuilder &);
  flatbuffers::Offset<QuestBonusData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuestBonusData>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuestBonusData> CreateQuestBonusData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t questBonusId = 0,
    bool isReceivedReward = false) {
  QuestBonusDataBuilder builder_(_fbb);
  builder_.add_questBonusId(questBonusId);
  builder_.add_isReceivedReward(isReceivedReward);
  return builder_.Finish();
}

/// QUEST_BONUS_REWARD_REQUEST
struct QuestBonusRewardRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_QUESTBONUSID = 4
  };
  int32_t questBonusId() const {
    return GetField<int32_t>(VT_QUESTBONUSID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_QUESTBONUSID) &&
           verifier.EndTable();
  }
};

struct QuestBonusRewardRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_questBonusId(int32_t questBonusId) {
    fbb_.AddElement<int32_t>(QuestBonusRewardRequest::VT_QUESTBONUSID, questBonusId, 0);
  }
  explicit QuestBonusRewardRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuestBonusRewardRequestBuilder &operator=(const QuestBonusRewardRequestBuilder &);
  flatbuffers::Offset<QuestBonusRewardRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuestBonusRewardRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuestBonusRewardRequest> CreateQuestBonusRewardRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t questBonusId = 0) {
  QuestBonusRewardRequestBuilder builder_(_fbb);
  builder_.add_questBonusId(questBonusId);
  return builder_.Finish();
}

/// QUEST_BONUS_REWARD_RESPONSE
struct QuestBonusRewardResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_QUESTBONUSDATA = 4,
    VT_ERRCODE = 6
  };
  const QuestBonusData *questBonusData() const {
    return GetPointer<const QuestBonusData *>(VT_QUESTBONUSDATA);
  }
  ErrorCode errCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_QUESTBONUSDATA) &&
           verifier.VerifyTable(questBonusData()) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           verifier.EndTable();
  }
};

struct QuestBonusRewardResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_questBonusData(flatbuffers::Offset<QuestBonusData> questBonusData) {
    fbb_.AddOffset(QuestBonusRewardResponse::VT_QUESTBONUSDATA, questBonusData);
  }
  void add_errCode(ErrorCode errCode) {
    fbb_.AddElement<int32_t>(QuestBonusRewardResponse::VT_ERRCODE, static_cast<int32_t>(errCode), 0);
  }
  explicit QuestBonusRewardResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuestBonusRewardResponseBuilder &operator=(const QuestBonusRewardResponseBuilder &);
  flatbuffers::Offset<QuestBonusRewardResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuestBonusRewardResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuestBonusRewardResponse> CreateQuestBonusRewardResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<QuestBonusData> questBonusData = 0,
    ErrorCode errCode = ErrorCode_NONE) {
  QuestBonusRewardResponseBuilder builder_(_fbb);
  builder_.add_errCode(errCode);
  builder_.add_questBonusData(questBonusData);
  return builder_.Finish();
}

/// QUEST_BONUS_REWARD_NOTIFY
struct QuestBonusRewardNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_QUESTBONUSDATASET = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<QuestBonusData>> *questBonusDataSet() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<QuestBonusData>> *>(VT_QUESTBONUSDATASET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_QUESTBONUSDATASET) &&
           verifier.VerifyVector(questBonusDataSet()) &&
           verifier.VerifyVectorOfTables(questBonusDataSet()) &&
           verifier.EndTable();
  }
};

struct QuestBonusRewardNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_questBonusDataSet(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<QuestBonusData>>> questBonusDataSet) {
    fbb_.AddOffset(QuestBonusRewardNotify::VT_QUESTBONUSDATASET, questBonusDataSet);
  }
  explicit QuestBonusRewardNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuestBonusRewardNotifyBuilder &operator=(const QuestBonusRewardNotifyBuilder &);
  flatbuffers::Offset<QuestBonusRewardNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuestBonusRewardNotify>(end);
    fbb_.Required(o, QuestBonusRewardNotify::VT_QUESTBONUSDATASET);
    return o;
  }
};

inline flatbuffers::Offset<QuestBonusRewardNotify> CreateQuestBonusRewardNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<QuestBonusData>>> questBonusDataSet = 0) {
  QuestBonusRewardNotifyBuilder builder_(_fbb);
  builder_.add_questBonusDataSet(questBonusDataSet);
  return builder_.Finish();
}

inline flatbuffers::Offset<QuestBonusRewardNotify> CreateQuestBonusRewardNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<QuestBonusData>> *questBonusDataSet = nullptr) {
  return LeanPacket::CreateQuestBonusRewardNotify(
      _fbb,
      questBonusDataSet ? _fbb.CreateVector<flatbuffers::Offset<QuestBonusData>>(*questBonusDataSet) : 0);
}

/// RECOMMEND_GET_PRAISER_RESPONSE
struct PraiserInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCDBID = 4,
    VT_RANK = 6,
    VT_NAME = 8,
    VT_CONTRIBUTION = 10,
    VT_TOTALCONTRIBUTION = 12,
    VT_LEVEL = 14,
    VT_CLASSTYPE = 16
  };
  uint64_t pcDbId() const {
    return GetField<uint64_t>(VT_PCDBID, 0);
  }
  int16_t rank() const {
    return GetField<int16_t>(VT_RANK, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int64_t contribution() const {
    return GetField<int64_t>(VT_CONTRIBUTION, 0);
  }
  int64_t totalContribution() const {
    return GetField<int64_t>(VT_TOTALCONTRIBUTION, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int32_t classType() const {
    return GetField<int32_t>(VT_CLASSTYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PCDBID) &&
           VerifyField<int16_t>(verifier, VT_RANK) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int64_t>(verifier, VT_CONTRIBUTION) &&
           VerifyField<int64_t>(verifier, VT_TOTALCONTRIBUTION) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_CLASSTYPE) &&
           verifier.EndTable();
  }
};

struct PraiserInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcDbId(uint64_t pcDbId) {
    fbb_.AddElement<uint64_t>(PraiserInfo::VT_PCDBID, pcDbId, 0);
  }
  void add_rank(int16_t rank) {
    fbb_.AddElement<int16_t>(PraiserInfo::VT_RANK, rank, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(PraiserInfo::VT_NAME, name);
  }
  void add_contribution(int64_t contribution) {
    fbb_.AddElement<int64_t>(PraiserInfo::VT_CONTRIBUTION, contribution, 0);
  }
  void add_totalContribution(int64_t totalContribution) {
    fbb_.AddElement<int64_t>(PraiserInfo::VT_TOTALCONTRIBUTION, totalContribution, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(PraiserInfo::VT_LEVEL, level, 0);
  }
  void add_classType(int32_t classType) {
    fbb_.AddElement<int32_t>(PraiserInfo::VT_CLASSTYPE, classType, 0);
  }
  explicit PraiserInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PraiserInfoBuilder &operator=(const PraiserInfoBuilder &);
  flatbuffers::Offset<PraiserInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PraiserInfo>(end);
    fbb_.Required(o, PraiserInfo::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<PraiserInfo> CreatePraiserInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t pcDbId = 0,
    int16_t rank = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int64_t contribution = 0,
    int64_t totalContribution = 0,
    int32_t level = 0,
    int32_t classType = 0) {
  PraiserInfoBuilder builder_(_fbb);
  builder_.add_totalContribution(totalContribution);
  builder_.add_contribution(contribution);
  builder_.add_pcDbId(pcDbId);
  builder_.add_classType(classType);
  builder_.add_level(level);
  builder_.add_name(name);
  builder_.add_rank(rank);
  return builder_.Finish();
}

inline flatbuffers::Offset<PraiserInfo> CreatePraiserInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t pcDbId = 0,
    int16_t rank = 0,
    const char *name = nullptr,
    int64_t contribution = 0,
    int64_t totalContribution = 0,
    int32_t level = 0,
    int32_t classType = 0) {
  return LeanPacket::CreatePraiserInfo(
      _fbb,
      pcDbId,
      rank,
      name ? _fbb.CreateString(name) : 0,
      contribution,
      totalContribution,
      level,
      classType);
}

/// RECOMMEND_GET_PRAISER_REQUEST
struct RecommendGetPraiserRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EVENTSETID = 4,
    VT_EVENTID = 6
  };
  int32_t eventSetId() const {
    return GetField<int32_t>(VT_EVENTSETID, 0);
  }
  int32_t eventId() const {
    return GetField<int32_t>(VT_EVENTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_EVENTSETID) &&
           VerifyField<int32_t>(verifier, VT_EVENTID) &&
           verifier.EndTable();
  }
};

struct RecommendGetPraiserRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eventSetId(int32_t eventSetId) {
    fbb_.AddElement<int32_t>(RecommendGetPraiserRequest::VT_EVENTSETID, eventSetId, 0);
  }
  void add_eventId(int32_t eventId) {
    fbb_.AddElement<int32_t>(RecommendGetPraiserRequest::VT_EVENTID, eventId, 0);
  }
  explicit RecommendGetPraiserRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RecommendGetPraiserRequestBuilder &operator=(const RecommendGetPraiserRequestBuilder &);
  flatbuffers::Offset<RecommendGetPraiserRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RecommendGetPraiserRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RecommendGetPraiserRequest> CreateRecommendGetPraiserRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t eventSetId = 0,
    int32_t eventId = 0) {
  RecommendGetPraiserRequestBuilder builder_(_fbb);
  builder_.add_eventId(eventId);
  builder_.add_eventSetId(eventSetId);
  return builder_.Finish();
}

/// RECOMMEND_GET_PRAISER_RESPONSE
struct RecommendGetPraiserResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRCODE = 4,
    VT_EVENTSETID = 6,
    VT_EVENTID = 8,
    VT_REMAINTIME = 10,
    VT_PRAISERLIST = 12
  };
  ErrorCode errCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRCODE, 0));
  }
  int32_t eventSetId() const {
    return GetField<int32_t>(VT_EVENTSETID, 0);
  }
  int32_t eventId() const {
    return GetField<int32_t>(VT_EVENTID, 0);
  }
  int32_t remainTime() const {
    return GetField<int32_t>(VT_REMAINTIME, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PraiserInfo>> *praiserList() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PraiserInfo>> *>(VT_PRAISERLIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           VerifyField<int32_t>(verifier, VT_EVENTSETID) &&
           VerifyField<int32_t>(verifier, VT_EVENTID) &&
           VerifyField<int32_t>(verifier, VT_REMAINTIME) &&
           VerifyOffset(verifier, VT_PRAISERLIST) &&
           verifier.VerifyVector(praiserList()) &&
           verifier.VerifyVectorOfTables(praiserList()) &&
           verifier.EndTable();
  }
};

struct RecommendGetPraiserResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errCode(ErrorCode errCode) {
    fbb_.AddElement<int32_t>(RecommendGetPraiserResponse::VT_ERRCODE, static_cast<int32_t>(errCode), 0);
  }
  void add_eventSetId(int32_t eventSetId) {
    fbb_.AddElement<int32_t>(RecommendGetPraiserResponse::VT_EVENTSETID, eventSetId, 0);
  }
  void add_eventId(int32_t eventId) {
    fbb_.AddElement<int32_t>(RecommendGetPraiserResponse::VT_EVENTID, eventId, 0);
  }
  void add_remainTime(int32_t remainTime) {
    fbb_.AddElement<int32_t>(RecommendGetPraiserResponse::VT_REMAINTIME, remainTime, 0);
  }
  void add_praiserList(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PraiserInfo>>> praiserList) {
    fbb_.AddOffset(RecommendGetPraiserResponse::VT_PRAISERLIST, praiserList);
  }
  explicit RecommendGetPraiserResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RecommendGetPraiserResponseBuilder &operator=(const RecommendGetPraiserResponseBuilder &);
  flatbuffers::Offset<RecommendGetPraiserResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RecommendGetPraiserResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<RecommendGetPraiserResponse> CreateRecommendGetPraiserResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errCode = ErrorCode_NONE,
    int32_t eventSetId = 0,
    int32_t eventId = 0,
    int32_t remainTime = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PraiserInfo>>> praiserList = 0) {
  RecommendGetPraiserResponseBuilder builder_(_fbb);
  builder_.add_praiserList(praiserList);
  builder_.add_remainTime(remainTime);
  builder_.add_eventId(eventId);
  builder_.add_eventSetId(eventSetId);
  builder_.add_errCode(errCode);
  return builder_.Finish();
}

inline flatbuffers::Offset<RecommendGetPraiserResponse> CreateRecommendGetPraiserResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errCode = ErrorCode_NONE,
    int32_t eventSetId = 0,
    int32_t eventId = 0,
    int32_t remainTime = 0,
    const std::vector<flatbuffers::Offset<PraiserInfo>> *praiserList = nullptr) {
  return LeanPacket::CreateRecommendGetPraiserResponse(
      _fbb,
      errCode,
      eventSetId,
      eventId,
      remainTime,
      praiserList ? _fbb.CreateVector<flatbuffers::Offset<PraiserInfo>>(*praiserList) : 0);
}

/// RECOMMEND_CHOICE_PRAISER_REQUEST
struct RecommendChoicePraiserRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EVENTSETID = 4,
    VT_EVENTID = 6,
    VT_NAME = 8
  };
  int32_t eventSetId() const {
    return GetField<int32_t>(VT_EVENTSETID, 0);
  }
  int32_t eventId() const {
    return GetField<int32_t>(VT_EVENTID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_EVENTSETID) &&
           VerifyField<int32_t>(verifier, VT_EVENTID) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct RecommendChoicePraiserRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eventSetId(int32_t eventSetId) {
    fbb_.AddElement<int32_t>(RecommendChoicePraiserRequest::VT_EVENTSETID, eventSetId, 0);
  }
  void add_eventId(int32_t eventId) {
    fbb_.AddElement<int32_t>(RecommendChoicePraiserRequest::VT_EVENTID, eventId, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(RecommendChoicePraiserRequest::VT_NAME, name);
  }
  explicit RecommendChoicePraiserRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RecommendChoicePraiserRequestBuilder &operator=(const RecommendChoicePraiserRequestBuilder &);
  flatbuffers::Offset<RecommendChoicePraiserRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RecommendChoicePraiserRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RecommendChoicePraiserRequest> CreateRecommendChoicePraiserRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t eventSetId = 0,
    int32_t eventId = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  RecommendChoicePraiserRequestBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_eventId(eventId);
  builder_.add_eventSetId(eventSetId);
  return builder_.Finish();
}

inline flatbuffers::Offset<RecommendChoicePraiserRequest> CreateRecommendChoicePraiserRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t eventSetId = 0,
    int32_t eventId = 0,
    const char *name = nullptr) {
  return LeanPacket::CreateRecommendChoicePraiserRequest(
      _fbb,
      eventSetId,
      eventId,
      name ? _fbb.CreateString(name) : 0);
}

/// RECOMMEND_CHOICE_PRAISER_RESPOSE
struct RecommendChoicePraiserReponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRCODE = 4,
    VT_TARGETPCNAME = 6
  };
  ErrorCode errCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRCODE, 0));
  }
  const flatbuffers::String *targetPcName() const {
    return GetPointer<const flatbuffers::String *>(VT_TARGETPCNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           VerifyOffset(verifier, VT_TARGETPCNAME) &&
           verifier.VerifyString(targetPcName()) &&
           verifier.EndTable();
  }
};

struct RecommendChoicePraiserReponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errCode(ErrorCode errCode) {
    fbb_.AddElement<int32_t>(RecommendChoicePraiserReponse::VT_ERRCODE, static_cast<int32_t>(errCode), 0);
  }
  void add_targetPcName(flatbuffers::Offset<flatbuffers::String> targetPcName) {
    fbb_.AddOffset(RecommendChoicePraiserReponse::VT_TARGETPCNAME, targetPcName);
  }
  explicit RecommendChoicePraiserReponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RecommendChoicePraiserReponseBuilder &operator=(const RecommendChoicePraiserReponseBuilder &);
  flatbuffers::Offset<RecommendChoicePraiserReponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RecommendChoicePraiserReponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<RecommendChoicePraiserReponse> CreateRecommendChoicePraiserReponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errCode = ErrorCode_NONE,
    flatbuffers::Offset<flatbuffers::String> targetPcName = 0) {
  RecommendChoicePraiserReponseBuilder builder_(_fbb);
  builder_.add_targetPcName(targetPcName);
  builder_.add_errCode(errCode);
  return builder_.Finish();
}

inline flatbuffers::Offset<RecommendChoicePraiserReponse> CreateRecommendChoicePraiserReponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errCode = ErrorCode_NONE,
    const char *targetPcName = nullptr) {
  return LeanPacket::CreateRecommendChoicePraiserReponse(
      _fbb,
      errCode,
      targetPcName ? _fbb.CreateString(targetPcName) : 0);
}

/// RECOMMEND_PRAISER_RESULT_NOTIFY
struct RecommendPraiserResultNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCDBID = 4,
    VT_NAME = 6
  };
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct RecommendPraiserResultNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(RecommendPraiserResultNotify::VT_PCDBID, pcDbId, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(RecommendPraiserResultNotify::VT_NAME, name);
  }
  explicit RecommendPraiserResultNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RecommendPraiserResultNotifyBuilder &operator=(const RecommendPraiserResultNotifyBuilder &);
  flatbuffers::Offset<RecommendPraiserResultNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RecommendPraiserResultNotify>(end);
    fbb_.Required(o, RecommendPraiserResultNotify::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<RecommendPraiserResultNotify> CreateRecommendPraiserResultNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcDbId = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  RecommendPraiserResultNotifyBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<RecommendPraiserResultNotify> CreateRecommendPraiserResultNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcDbId = 0,
    const char *name = nullptr) {
  return LeanPacket::CreateRecommendPraiserResultNotify(
      _fbb,
      pcDbId,
      name ? _fbb.CreateString(name) : 0);
}

/// RECOMMEND_CHOICE_RESULT_NOTIFY
struct RecommendChoiceResultNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VOTERPCNAME = 4,
    VT_VOTEDPCNAME = 6
  };
  const flatbuffers::String *voterPcName() const {
    return GetPointer<const flatbuffers::String *>(VT_VOTERPCNAME);
  }
  const flatbuffers::String *votedPcName() const {
    return GetPointer<const flatbuffers::String *>(VT_VOTEDPCNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VOTERPCNAME) &&
           verifier.VerifyString(voterPcName()) &&
           VerifyOffset(verifier, VT_VOTEDPCNAME) &&
           verifier.VerifyString(votedPcName()) &&
           verifier.EndTable();
  }
};

struct RecommendChoiceResultNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_voterPcName(flatbuffers::Offset<flatbuffers::String> voterPcName) {
    fbb_.AddOffset(RecommendChoiceResultNotify::VT_VOTERPCNAME, voterPcName);
  }
  void add_votedPcName(flatbuffers::Offset<flatbuffers::String> votedPcName) {
    fbb_.AddOffset(RecommendChoiceResultNotify::VT_VOTEDPCNAME, votedPcName);
  }
  explicit RecommendChoiceResultNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RecommendChoiceResultNotifyBuilder &operator=(const RecommendChoiceResultNotifyBuilder &);
  flatbuffers::Offset<RecommendChoiceResultNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RecommendChoiceResultNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<RecommendChoiceResultNotify> CreateRecommendChoiceResultNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> voterPcName = 0,
    flatbuffers::Offset<flatbuffers::String> votedPcName = 0) {
  RecommendChoiceResultNotifyBuilder builder_(_fbb);
  builder_.add_votedPcName(votedPcName);
  builder_.add_voterPcName(voterPcName);
  return builder_.Finish();
}

inline flatbuffers::Offset<RecommendChoiceResultNotify> CreateRecommendChoiceResultNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *voterPcName = nullptr,
    const char *votedPcName = nullptr) {
  return LeanPacket::CreateRecommendChoiceResultNotify(
      _fbb,
      voterPcName ? _fbb.CreateString(voterPcName) : 0,
      votedPcName ? _fbb.CreateString(votedPcName) : 0);
}

/// PRESET_CHANGE_REQUEST
struct PresetChangeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_PRESETNO = 6
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int16_t presetNo() const {
    return GetField<int16_t>(VT_PRESETNO, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int16_t>(verifier, VT_PRESETNO) &&
           verifier.EndTable();
  }
};

struct PresetChangeRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(PresetChangeRequest::VT_OBJECTID, objectId, 0);
  }
  void add_presetNo(int16_t presetNo) {
    fbb_.AddElement<int16_t>(PresetChangeRequest::VT_PRESETNO, presetNo, 0);
  }
  explicit PresetChangeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PresetChangeRequestBuilder &operator=(const PresetChangeRequestBuilder &);
  flatbuffers::Offset<PresetChangeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PresetChangeRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<PresetChangeRequest> CreatePresetChangeRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int16_t presetNo = 0) {
  PresetChangeRequestBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_presetNo(presetNo);
  return builder_.Finish();
}

/// PRESET_CHANGE_RESPONSE
struct PresetChangeResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULT = 4,
    VT_OBJECTID = 6,
    VT_PRESETNO = 8,
    VT_SKILLSLOT = 10,
    VT_MAINSKILLSLOTIDX = 12
  };
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int16_t presetNo() const {
    return GetField<int16_t>(VT_PRESETNO, 0);
  }
  const flatbuffers::Vector<int32_t> *skillslot() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SKILLSLOT);
  }
  int8_t mainSkillSlotIdx() const {
    return GetField<int8_t>(VT_MAINSKILLSLOTIDX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int16_t>(verifier, VT_PRESETNO) &&
           VerifyOffset(verifier, VT_SKILLSLOT) &&
           verifier.VerifyVector(skillslot()) &&
           VerifyField<int8_t>(verifier, VT_MAINSKILLSLOTIDX) &&
           verifier.EndTable();
  }
};

struct PresetChangeResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(PresetChangeResponse::VT_RESULT, result, 0);
  }
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(PresetChangeResponse::VT_OBJECTID, objectId, 0);
  }
  void add_presetNo(int16_t presetNo) {
    fbb_.AddElement<int16_t>(PresetChangeResponse::VT_PRESETNO, presetNo, 0);
  }
  void add_skillslot(flatbuffers::Offset<flatbuffers::Vector<int32_t>> skillslot) {
    fbb_.AddOffset(PresetChangeResponse::VT_SKILLSLOT, skillslot);
  }
  void add_mainSkillSlotIdx(int8_t mainSkillSlotIdx) {
    fbb_.AddElement<int8_t>(PresetChangeResponse::VT_MAINSKILLSLOTIDX, mainSkillSlotIdx, 0);
  }
  explicit PresetChangeResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PresetChangeResponseBuilder &operator=(const PresetChangeResponseBuilder &);
  flatbuffers::Offset<PresetChangeResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PresetChangeResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<PresetChangeResponse> CreatePresetChangeResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    int64_t objectId = 0,
    int16_t presetNo = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> skillslot = 0,
    int8_t mainSkillSlotIdx = 0) {
  PresetChangeResponseBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_skillslot(skillslot);
  builder_.add_result(result);
  builder_.add_presetNo(presetNo);
  builder_.add_mainSkillSlotIdx(mainSkillSlotIdx);
  return builder_.Finish();
}

inline flatbuffers::Offset<PresetChangeResponse> CreatePresetChangeResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    int64_t objectId = 0,
    int16_t presetNo = 0,
    const std::vector<int32_t> *skillslot = nullptr,
    int8_t mainSkillSlotIdx = 0) {
  return LeanPacket::CreatePresetChangeResponse(
      _fbb,
      result,
      objectId,
      presetNo,
      skillslot ? _fbb.CreateVector<int32_t>(*skillslot) : 0,
      mainSkillSlotIdx);
}

/// Preset Info
struct PresetItemInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMSLOTS = 4
  };
  const flatbuffers::Vector<int64_t> *itemslots() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_ITEMSLOTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ITEMSLOTS) &&
           verifier.VerifyVector(itemslots()) &&
           verifier.EndTable();
  }
};

struct PresetItemInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemslots(flatbuffers::Offset<flatbuffers::Vector<int64_t>> itemslots) {
    fbb_.AddOffset(PresetItemInfo::VT_ITEMSLOTS, itemslots);
  }
  explicit PresetItemInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PresetItemInfoBuilder &operator=(const PresetItemInfoBuilder &);
  flatbuffers::Offset<PresetItemInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PresetItemInfo>(end);
    fbb_.Required(o, PresetItemInfo::VT_ITEMSLOTS);
    return o;
  }
};

inline flatbuffers::Offset<PresetItemInfo> CreatePresetItemInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> itemslots = 0) {
  PresetItemInfoBuilder builder_(_fbb);
  builder_.add_itemslots(itemslots);
  return builder_.Finish();
}

inline flatbuffers::Offset<PresetItemInfo> CreatePresetItemInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *itemslots = nullptr) {
  return LeanPacket::CreatePresetItemInfo(
      _fbb,
      itemslots ? _fbb.CreateVector<int64_t>(*itemslots) : 0);
}

struct PresetSkillInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SKILLSLOTS = 4
  };
  const flatbuffers::Vector<int32_t> *skillslots() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SKILLSLOTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SKILLSLOTS) &&
           verifier.VerifyVector(skillslots()) &&
           verifier.EndTable();
  }
};

struct PresetSkillInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_skillslots(flatbuffers::Offset<flatbuffers::Vector<int32_t>> skillslots) {
    fbb_.AddOffset(PresetSkillInfo::VT_SKILLSLOTS, skillslots);
  }
  explicit PresetSkillInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PresetSkillInfoBuilder &operator=(const PresetSkillInfoBuilder &);
  flatbuffers::Offset<PresetSkillInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PresetSkillInfo>(end);
    fbb_.Required(o, PresetSkillInfo::VT_SKILLSLOTS);
    return o;
  }
};

inline flatbuffers::Offset<PresetSkillInfo> CreatePresetSkillInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> skillslots = 0) {
  PresetSkillInfoBuilder builder_(_fbb);
  builder_.add_skillslots(skillslots);
  return builder_.Finish();
}

inline flatbuffers::Offset<PresetSkillInfo> CreatePresetSkillInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *skillslots = nullptr) {
  return LeanPacket::CreatePresetSkillInfo(
      _fbb,
      skillslots ? _fbb.CreateVector<int32_t>(*skillslots) : 0);
}

struct PresetCostumeSlotInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SLOT = 4,
    VT_ISVISIBLE = 6
  };
  uint64_t slot() const {
    return GetField<uint64_t>(VT_SLOT, 0);
  }
  bool isVisible() const {
    return GetField<uint8_t>(VT_ISVISIBLE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_SLOT) &&
           VerifyField<uint8_t>(verifier, VT_ISVISIBLE) &&
           verifier.EndTable();
  }
};

struct PresetCostumeSlotInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slot(uint64_t slot) {
    fbb_.AddElement<uint64_t>(PresetCostumeSlotInfo::VT_SLOT, slot, 0);
  }
  void add_isVisible(bool isVisible) {
    fbb_.AddElement<uint8_t>(PresetCostumeSlotInfo::VT_ISVISIBLE, static_cast<uint8_t>(isVisible), 0);
  }
  explicit PresetCostumeSlotInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PresetCostumeSlotInfoBuilder &operator=(const PresetCostumeSlotInfoBuilder &);
  flatbuffers::Offset<PresetCostumeSlotInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PresetCostumeSlotInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<PresetCostumeSlotInfo> CreatePresetCostumeSlotInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t slot = 0,
    bool isVisible = false) {
  PresetCostumeSlotInfoBuilder builder_(_fbb);
  builder_.add_slot(slot);
  builder_.add_isVisible(isVisible);
  return builder_.Finish();
}

struct PresetCostumeInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COSTUMESLOTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<PresetCostumeSlotInfo>> *costumeSlots() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PresetCostumeSlotInfo>> *>(VT_COSTUMESLOTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_COSTUMESLOTS) &&
           verifier.VerifyVector(costumeSlots()) &&
           verifier.VerifyVectorOfTables(costumeSlots()) &&
           verifier.EndTable();
  }
};

struct PresetCostumeInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_costumeSlots(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PresetCostumeSlotInfo>>> costumeSlots) {
    fbb_.AddOffset(PresetCostumeInfo::VT_COSTUMESLOTS, costumeSlots);
  }
  explicit PresetCostumeInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PresetCostumeInfoBuilder &operator=(const PresetCostumeInfoBuilder &);
  flatbuffers::Offset<PresetCostumeInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PresetCostumeInfo>(end);
    fbb_.Required(o, PresetCostumeInfo::VT_COSTUMESLOTS);
    return o;
  }
};

inline flatbuffers::Offset<PresetCostumeInfo> CreatePresetCostumeInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PresetCostumeSlotInfo>>> costumeSlots = 0) {
  PresetCostumeInfoBuilder builder_(_fbb);
  builder_.add_costumeSlots(costumeSlots);
  return builder_.Finish();
}

inline flatbuffers::Offset<PresetCostumeInfo> CreatePresetCostumeInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<PresetCostumeSlotInfo>> *costumeSlots = nullptr) {
  return LeanPacket::CreatePresetCostumeInfo(
      _fbb,
      costumeSlots ? _fbb.CreateVector<flatbuffers::Offset<PresetCostumeSlotInfo>>(*costumeSlots) : 0);
}

struct PresetInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRESETNO = 4,
    VT_ITEM = 6,
    VT_SKILL = 8
  };
  int16_t presetNo() const {
    return GetField<int16_t>(VT_PRESETNO, 0);
  }
  const PresetItemInfo *item() const {
    return GetPointer<const PresetItemInfo *>(VT_ITEM);
  }
  const PresetSkillInfo *skill() const {
    return GetPointer<const PresetSkillInfo *>(VT_SKILL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_PRESETNO) &&
           VerifyOffsetRequired(verifier, VT_ITEM) &&
           verifier.VerifyTable(item()) &&
           VerifyOffsetRequired(verifier, VT_SKILL) &&
           verifier.VerifyTable(skill()) &&
           verifier.EndTable();
  }
};

struct PresetInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_presetNo(int16_t presetNo) {
    fbb_.AddElement<int16_t>(PresetInfo::VT_PRESETNO, presetNo, 0);
  }
  void add_item(flatbuffers::Offset<PresetItemInfo> item) {
    fbb_.AddOffset(PresetInfo::VT_ITEM, item);
  }
  void add_skill(flatbuffers::Offset<PresetSkillInfo> skill) {
    fbb_.AddOffset(PresetInfo::VT_SKILL, skill);
  }
  explicit PresetInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PresetInfoBuilder &operator=(const PresetInfoBuilder &);
  flatbuffers::Offset<PresetInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PresetInfo>(end);
    fbb_.Required(o, PresetInfo::VT_ITEM);
    fbb_.Required(o, PresetInfo::VT_SKILL);
    return o;
  }
};

inline flatbuffers::Offset<PresetInfo> CreatePresetInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t presetNo = 0,
    flatbuffers::Offset<PresetItemInfo> item = 0,
    flatbuffers::Offset<PresetSkillInfo> skill = 0) {
  PresetInfoBuilder builder_(_fbb);
  builder_.add_skill(skill);
  builder_.add_item(item);
  builder_.add_presetNo(presetNo);
  return builder_.Finish();
}

struct CostumePresetInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRESETNO = 4,
    VT_COSTUME = 6
  };
  int16_t presetNo() const {
    return GetField<int16_t>(VT_PRESETNO, 0);
  }
  const PresetCostumeInfo *costume() const {
    return GetPointer<const PresetCostumeInfo *>(VT_COSTUME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_PRESETNO) &&
           VerifyOffsetRequired(verifier, VT_COSTUME) &&
           verifier.VerifyTable(costume()) &&
           verifier.EndTable();
  }
};

struct CostumePresetInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_presetNo(int16_t presetNo) {
    fbb_.AddElement<int16_t>(CostumePresetInfo::VT_PRESETNO, presetNo, 0);
  }
  void add_costume(flatbuffers::Offset<PresetCostumeInfo> costume) {
    fbb_.AddOffset(CostumePresetInfo::VT_COSTUME, costume);
  }
  explicit CostumePresetInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CostumePresetInfoBuilder &operator=(const CostumePresetInfoBuilder &);
  flatbuffers::Offset<CostumePresetInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CostumePresetInfo>(end);
    fbb_.Required(o, CostumePresetInfo::VT_COSTUME);
    return o;
  }
};

inline flatbuffers::Offset<CostumePresetInfo> CreateCostumePresetInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t presetNo = 0,
    flatbuffers::Offset<PresetCostumeInfo> costume = 0) {
  CostumePresetInfoBuilder builder_(_fbb);
  builder_.add_costume(costume);
  builder_.add_presetNo(presetNo);
  return builder_.Finish();
}

/// PRESET_ITEMSLOT_UPDATE_NOTIFY
struct PresetItemSlotUpdateNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRESETNO = 4,
    VT_ITEMSLOT = 6
  };
  int16_t presetNo() const {
    return GetField<int16_t>(VT_PRESETNO, 0);
  }
  const PresetItemInfo *itemslot() const {
    return GetPointer<const PresetItemInfo *>(VT_ITEMSLOT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_PRESETNO) &&
           VerifyOffsetRequired(verifier, VT_ITEMSLOT) &&
           verifier.VerifyTable(itemslot()) &&
           verifier.EndTable();
  }
};

struct PresetItemSlotUpdateNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_presetNo(int16_t presetNo) {
    fbb_.AddElement<int16_t>(PresetItemSlotUpdateNotify::VT_PRESETNO, presetNo, 0);
  }
  void add_itemslot(flatbuffers::Offset<PresetItemInfo> itemslot) {
    fbb_.AddOffset(PresetItemSlotUpdateNotify::VT_ITEMSLOT, itemslot);
  }
  explicit PresetItemSlotUpdateNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PresetItemSlotUpdateNotifyBuilder &operator=(const PresetItemSlotUpdateNotifyBuilder &);
  flatbuffers::Offset<PresetItemSlotUpdateNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PresetItemSlotUpdateNotify>(end);
    fbb_.Required(o, PresetItemSlotUpdateNotify::VT_ITEMSLOT);
    return o;
  }
};

inline flatbuffers::Offset<PresetItemSlotUpdateNotify> CreatePresetItemSlotUpdateNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t presetNo = 0,
    flatbuffers::Offset<PresetItemInfo> itemslot = 0) {
  PresetItemSlotUpdateNotifyBuilder builder_(_fbb);
  builder_.add_itemslot(itemslot);
  builder_.add_presetNo(presetNo);
  return builder_.Finish();
}

/// DAILY_DUNGEON_JOIN_REQUEST
struct DailyDungeonJoinRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_DIFFICULT = 6
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int16_t difficult() const {
    return GetField<int16_t>(VT_DIFFICULT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<int16_t>(verifier, VT_DIFFICULT) &&
           verifier.EndTable();
  }
};

struct DailyDungeonJoinRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(DailyDungeonJoinRequest::VT_ID, id, 0);
  }
  void add_difficult(int16_t difficult) {
    fbb_.AddElement<int16_t>(DailyDungeonJoinRequest::VT_DIFFICULT, difficult, 0);
  }
  explicit DailyDungeonJoinRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DailyDungeonJoinRequestBuilder &operator=(const DailyDungeonJoinRequestBuilder &);
  flatbuffers::Offset<DailyDungeonJoinRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DailyDungeonJoinRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DailyDungeonJoinRequest> CreateDailyDungeonJoinRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int16_t difficult = 0) {
  DailyDungeonJoinRequestBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_difficult(difficult);
  return builder_.Finish();
}

/// DAILY_DUNGEON_JOIN_RESPONSE
struct DailyDungeonJoinResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULT = 4,
    VT_ID = 6,
    VT_DIFFICULT = 8
  };
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int16_t difficult() const {
    return GetField<int16_t>(VT_DIFFICULT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<int16_t>(verifier, VT_DIFFICULT) &&
           verifier.EndTable();
  }
};

struct DailyDungeonJoinResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(DailyDungeonJoinResponse::VT_RESULT, result, 0);
  }
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(DailyDungeonJoinResponse::VT_ID, id, 0);
  }
  void add_difficult(int16_t difficult) {
    fbb_.AddElement<int16_t>(DailyDungeonJoinResponse::VT_DIFFICULT, difficult, 0);
  }
  explicit DailyDungeonJoinResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DailyDungeonJoinResponseBuilder &operator=(const DailyDungeonJoinResponseBuilder &);
  flatbuffers::Offset<DailyDungeonJoinResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DailyDungeonJoinResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<DailyDungeonJoinResponse> CreateDailyDungeonJoinResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    int32_t id = 0,
    int16_t difficult = 0) {
  DailyDungeonJoinResponseBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_result(result);
  builder_.add_difficult(difficult);
  return builder_.Finish();
}

/// FIELD_JOIN_REQUEST
struct FieldJoinRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SMAPID = 4
  };
  int32_t sMapId() const {
    return GetField<int32_t>(VT_SMAPID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SMAPID) &&
           verifier.EndTable();
  }
};

struct FieldJoinRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sMapId(int32_t sMapId) {
    fbb_.AddElement<int32_t>(FieldJoinRequest::VT_SMAPID, sMapId, 0);
  }
  explicit FieldJoinRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FieldJoinRequestBuilder &operator=(const FieldJoinRequestBuilder &);
  flatbuffers::Offset<FieldJoinRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FieldJoinRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<FieldJoinRequest> CreateFieldJoinRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t sMapId = 0) {
  FieldJoinRequestBuilder builder_(_fbb);
  builder_.add_sMapId(sMapId);
  return builder_.Finish();
}

/// FIELD_JOIN_RESPONSE
struct FieldJoinResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SMAPID = 4,
    VT_REASON = 6
  };
  int32_t sMapId() const {
    return GetField<int32_t>(VT_SMAPID, 0);
  }
  JoinChannelReason reason() const {
    return static_cast<JoinChannelReason>(GetField<int32_t>(VT_REASON, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SMAPID) &&
           VerifyField<int32_t>(verifier, VT_REASON) &&
           verifier.EndTable();
  }
};

struct FieldJoinResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sMapId(int32_t sMapId) {
    fbb_.AddElement<int32_t>(FieldJoinResponse::VT_SMAPID, sMapId, 0);
  }
  void add_reason(JoinChannelReason reason) {
    fbb_.AddElement<int32_t>(FieldJoinResponse::VT_REASON, static_cast<int32_t>(reason), 0);
  }
  explicit FieldJoinResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FieldJoinResponseBuilder &operator=(const FieldJoinResponseBuilder &);
  flatbuffers::Offset<FieldJoinResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FieldJoinResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<FieldJoinResponse> CreateFieldJoinResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t sMapId = 0,
    JoinChannelReason reason = JoinChannelReason_JOIN_CHANNEL_REASON_NONE) {
  FieldJoinResponseBuilder builder_(_fbb);
  builder_.add_reason(reason);
  builder_.add_sMapId(sMapId);
  return builder_.Finish();
}

struct ClientItemResultInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMID = 4,
    VT_STACKCOUNT = 6
  };
  int32_t itemId() const {
    return GetField<int32_t>(VT_ITEMID, 0);
  }
  int32_t stackCount() const {
    return GetField<int32_t>(VT_STACKCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ITEMID) &&
           VerifyField<int32_t>(verifier, VT_STACKCOUNT) &&
           verifier.EndTable();
  }
};

struct ClientItemResultInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemId(int32_t itemId) {
    fbb_.AddElement<int32_t>(ClientItemResultInfo::VT_ITEMID, itemId, 0);
  }
  void add_stackCount(int32_t stackCount) {
    fbb_.AddElement<int32_t>(ClientItemResultInfo::VT_STACKCOUNT, stackCount, 0);
  }
  explicit ClientItemResultInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClientItemResultInfoBuilder &operator=(const ClientItemResultInfoBuilder &);
  flatbuffers::Offset<ClientItemResultInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientItemResultInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClientItemResultInfo> CreateClientItemResultInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t itemId = 0,
    int32_t stackCount = 0) {
  ClientItemResultInfoBuilder builder_(_fbb);
  builder_.add_stackCount(stackCount);
  builder_.add_itemId(itemId);
  return builder_.Finish();
}

/// UPDATE_ITEM_GRADE_LEVEL_NOTIFY
struct UpdateItemGradeLevelNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMOBJECTID = 4,
    VT_GRADE = 6,
    VT_LEVEL = 8,
    VT_ENCHANTEXP = 10
  };
  uint64_t itemObjectId() const {
    return GetField<uint64_t>(VT_ITEMOBJECTID, 0);
  }
  int16_t grade() const {
    return GetField<int16_t>(VT_GRADE, 0);
  }
  int16_t level() const {
    return GetField<int16_t>(VT_LEVEL, 0);
  }
  int32_t enchantExp() const {
    return GetField<int32_t>(VT_ENCHANTEXP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ITEMOBJECTID) &&
           VerifyField<int16_t>(verifier, VT_GRADE) &&
           VerifyField<int16_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_ENCHANTEXP) &&
           verifier.EndTable();
  }
};

struct UpdateItemGradeLevelNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemObjectId(uint64_t itemObjectId) {
    fbb_.AddElement<uint64_t>(UpdateItemGradeLevelNotify::VT_ITEMOBJECTID, itemObjectId, 0);
  }
  void add_grade(int16_t grade) {
    fbb_.AddElement<int16_t>(UpdateItemGradeLevelNotify::VT_GRADE, grade, 0);
  }
  void add_level(int16_t level) {
    fbb_.AddElement<int16_t>(UpdateItemGradeLevelNotify::VT_LEVEL, level, 0);
  }
  void add_enchantExp(int32_t enchantExp) {
    fbb_.AddElement<int32_t>(UpdateItemGradeLevelNotify::VT_ENCHANTEXP, enchantExp, 0);
  }
  explicit UpdateItemGradeLevelNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UpdateItemGradeLevelNotifyBuilder &operator=(const UpdateItemGradeLevelNotifyBuilder &);
  flatbuffers::Offset<UpdateItemGradeLevelNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UpdateItemGradeLevelNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<UpdateItemGradeLevelNotify> CreateUpdateItemGradeLevelNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t itemObjectId = 0,
    int16_t grade = 0,
    int16_t level = 0,
    int32_t enchantExp = 0) {
  UpdateItemGradeLevelNotifyBuilder builder_(_fbb);
  builder_.add_itemObjectId(itemObjectId);
  builder_.add_enchantExp(enchantExp);
  builder_.add_level(level);
  builder_.add_grade(grade);
  return builder_.Finish();
}

/// UPDATE_ITEM_OPTION_NOTIFY
struct UpateItemOptionNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMOBJECTID = 4,
    VT_OPTIONID = 6,
    VT_OPTIONLEVEL = 8
  };
  uint64_t itemObjectId() const {
    return GetField<uint64_t>(VT_ITEMOBJECTID, 0);
  }
  int32_t optionId() const {
    return GetField<int32_t>(VT_OPTIONID, 0);
  }
  int16_t optionLevel() const {
    return GetField<int16_t>(VT_OPTIONLEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ITEMOBJECTID) &&
           VerifyField<int32_t>(verifier, VT_OPTIONID) &&
           VerifyField<int16_t>(verifier, VT_OPTIONLEVEL) &&
           verifier.EndTable();
  }
};

struct UpateItemOptionNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemObjectId(uint64_t itemObjectId) {
    fbb_.AddElement<uint64_t>(UpateItemOptionNotify::VT_ITEMOBJECTID, itemObjectId, 0);
  }
  void add_optionId(int32_t optionId) {
    fbb_.AddElement<int32_t>(UpateItemOptionNotify::VT_OPTIONID, optionId, 0);
  }
  void add_optionLevel(int16_t optionLevel) {
    fbb_.AddElement<int16_t>(UpateItemOptionNotify::VT_OPTIONLEVEL, optionLevel, 0);
  }
  explicit UpateItemOptionNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UpateItemOptionNotifyBuilder &operator=(const UpateItemOptionNotifyBuilder &);
  flatbuffers::Offset<UpateItemOptionNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UpateItemOptionNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<UpateItemOptionNotify> CreateUpateItemOptionNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t itemObjectId = 0,
    int32_t optionId = 0,
    int16_t optionLevel = 0) {
  UpateItemOptionNotifyBuilder builder_(_fbb);
  builder_.add_itemObjectId(itemObjectId);
  builder_.add_optionId(optionId);
  builder_.add_optionLevel(optionLevel);
  return builder_.Finish();
}

/// skill Feature info
struct FeatureInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FEATUREID = 4,
    VT_LEVEL = 6
  };
  int32_t featureId() const {
    return GetField<int32_t>(VT_FEATUREID, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FEATUREID) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           verifier.EndTable();
  }
};

struct FeatureInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_featureId(int32_t featureId) {
    fbb_.AddElement<int32_t>(FeatureInfo::VT_FEATUREID, featureId, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(FeatureInfo::VT_LEVEL, level, 0);
  }
  explicit FeatureInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FeatureInfoBuilder &operator=(const FeatureInfoBuilder &);
  flatbuffers::Offset<FeatureInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FeatureInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<FeatureInfo> CreateFeatureInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t featureId = 0,
    int32_t level = 0) {
  FeatureInfoBuilder builder_(_fbb);
  builder_.add_level(level);
  builder_.add_featureId(featureId);
  return builder_.Finish();
}

struct LoadedSkillFeatureInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SKILLID = 4,
    VT_FEATUREINFOS = 6,
    VT_COOLTIME = 8
  };
  int32_t skillId() const {
    return GetField<int32_t>(VT_SKILLID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FeatureInfo>> *featureInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FeatureInfo>> *>(VT_FEATUREINFOS);
  }
  int32_t coolTime() const {
    return GetField<int32_t>(VT_COOLTIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SKILLID) &&
           VerifyOffsetRequired(verifier, VT_FEATUREINFOS) &&
           verifier.VerifyVector(featureInfos()) &&
           verifier.VerifyVectorOfTables(featureInfos()) &&
           VerifyField<int32_t>(verifier, VT_COOLTIME) &&
           verifier.EndTable();
  }
};

struct LoadedSkillFeatureInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_skillId(int32_t skillId) {
    fbb_.AddElement<int32_t>(LoadedSkillFeatureInfo::VT_SKILLID, skillId, 0);
  }
  void add_featureInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FeatureInfo>>> featureInfos) {
    fbb_.AddOffset(LoadedSkillFeatureInfo::VT_FEATUREINFOS, featureInfos);
  }
  void add_coolTime(int32_t coolTime) {
    fbb_.AddElement<int32_t>(LoadedSkillFeatureInfo::VT_COOLTIME, coolTime, 0);
  }
  explicit LoadedSkillFeatureInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LoadedSkillFeatureInfoBuilder &operator=(const LoadedSkillFeatureInfoBuilder &);
  flatbuffers::Offset<LoadedSkillFeatureInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LoadedSkillFeatureInfo>(end);
    fbb_.Required(o, LoadedSkillFeatureInfo::VT_FEATUREINFOS);
    return o;
  }
};

inline flatbuffers::Offset<LoadedSkillFeatureInfo> CreateLoadedSkillFeatureInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t skillId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FeatureInfo>>> featureInfos = 0,
    int32_t coolTime = 0) {
  LoadedSkillFeatureInfoBuilder builder_(_fbb);
  builder_.add_coolTime(coolTime);
  builder_.add_featureInfos(featureInfos);
  builder_.add_skillId(skillId);
  return builder_.Finish();
}

inline flatbuffers::Offset<LoadedSkillFeatureInfo> CreateLoadedSkillFeatureInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t skillId = 0,
    const std::vector<flatbuffers::Offset<FeatureInfo>> *featureInfos = nullptr,
    int32_t coolTime = 0) {
  return LeanPacket::CreateLoadedSkillFeatureInfo(
      _fbb,
      skillId,
      featureInfos ? _fbb.CreateVector<flatbuffers::Offset<FeatureInfo>>(*featureInfos) : 0,
      coolTime);
}

///SKILL_FEATURE_INITIALIZE_REQUEST
struct SkillFeatureInitializeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCOBJECTID = 4,
    VT_SKILLID = 6
  };
  uint64_t pcObjectId() const {
    return GetField<uint64_t>(VT_PCOBJECTID, 0);
  }
  int32_t skillId() const {
    return GetField<int32_t>(VT_SKILLID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PCOBJECTID) &&
           VerifyField<int32_t>(verifier, VT_SKILLID) &&
           verifier.EndTable();
  }
};

struct SkillFeatureInitializeRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcObjectId(uint64_t pcObjectId) {
    fbb_.AddElement<uint64_t>(SkillFeatureInitializeRequest::VT_PCOBJECTID, pcObjectId, 0);
  }
  void add_skillId(int32_t skillId) {
    fbb_.AddElement<int32_t>(SkillFeatureInitializeRequest::VT_SKILLID, skillId, 0);
  }
  explicit SkillFeatureInitializeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SkillFeatureInitializeRequestBuilder &operator=(const SkillFeatureInitializeRequestBuilder &);
  flatbuffers::Offset<SkillFeatureInitializeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkillFeatureInitializeRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkillFeatureInitializeRequest> CreateSkillFeatureInitializeRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t pcObjectId = 0,
    int32_t skillId = 0) {
  SkillFeatureInitializeRequestBuilder builder_(_fbb);
  builder_.add_pcObjectId(pcObjectId);
  builder_.add_skillId(skillId);
  return builder_.Finish();
}

///SKILL_FEATURE_INITIALIZE_RESPONSE
struct SkillFeatureInitializeResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SKILLID = 4,
    VT_RESULT = 6
  };
  const flatbuffers::Vector<int32_t> *skillId() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SKILLID);
  }
  bool result() const {
    return GetField<uint8_t>(VT_RESULT, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SKILLID) &&
           verifier.VerifyVector(skillId()) &&
           VerifyField<uint8_t>(verifier, VT_RESULT) &&
           verifier.EndTable();
  }
};

struct SkillFeatureInitializeResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_skillId(flatbuffers::Offset<flatbuffers::Vector<int32_t>> skillId) {
    fbb_.AddOffset(SkillFeatureInitializeResponse::VT_SKILLID, skillId);
  }
  void add_result(bool result) {
    fbb_.AddElement<uint8_t>(SkillFeatureInitializeResponse::VT_RESULT, static_cast<uint8_t>(result), 0);
  }
  explicit SkillFeatureInitializeResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SkillFeatureInitializeResponseBuilder &operator=(const SkillFeatureInitializeResponseBuilder &);
  flatbuffers::Offset<SkillFeatureInitializeResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkillFeatureInitializeResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkillFeatureInitializeResponse> CreateSkillFeatureInitializeResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> skillId = 0,
    bool result = false) {
  SkillFeatureInitializeResponseBuilder builder_(_fbb);
  builder_.add_skillId(skillId);
  builder_.add_result(result);
  return builder_.Finish();
}

inline flatbuffers::Offset<SkillFeatureInitializeResponse> CreateSkillFeatureInitializeResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *skillId = nullptr,
    bool result = false) {
  return LeanPacket::CreateSkillFeatureInitializeResponse(
      _fbb,
      skillId ? _fbb.CreateVector<int32_t>(*skillId) : 0,
      result);
}

///UPDATE_SKILL_POINT_NOTIFY
struct UpdateSkillPointNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_REMAINPOINT = 4
  };
  int16_t remainPoint() const {
    return GetField<int16_t>(VT_REMAINPOINT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_REMAINPOINT) &&
           verifier.EndTable();
  }
};

struct UpdateSkillPointNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_remainPoint(int16_t remainPoint) {
    fbb_.AddElement<int16_t>(UpdateSkillPointNotify::VT_REMAINPOINT, remainPoint, 0);
  }
  explicit UpdateSkillPointNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UpdateSkillPointNotifyBuilder &operator=(const UpdateSkillPointNotifyBuilder &);
  flatbuffers::Offset<UpdateSkillPointNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UpdateSkillPointNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<UpdateSkillPointNotify> CreateUpdateSkillPointNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t remainPoint = 0) {
  UpdateSkillPointNotifyBuilder builder_(_fbb);
  builder_.add_remainPoint(remainPoint);
  return builder_.Finish();
}

struct ACRewardItemInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMID = 4,
    VT_ITEMGRADE = 6,
    VT_AMOUNT = 8
  };
  int32_t itemId() const {
    return GetField<int32_t>(VT_ITEMID, 0);
  }
  int16_t itemGrade() const {
    return GetField<int16_t>(VT_ITEMGRADE, 0);
  }
  int32_t amount() const {
    return GetField<int32_t>(VT_AMOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ITEMID) &&
           VerifyField<int16_t>(verifier, VT_ITEMGRADE) &&
           VerifyField<int32_t>(verifier, VT_AMOUNT) &&
           verifier.EndTable();
  }
};

struct ACRewardItemInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemId(int32_t itemId) {
    fbb_.AddElement<int32_t>(ACRewardItemInfo::VT_ITEMID, itemId, 0);
  }
  void add_itemGrade(int16_t itemGrade) {
    fbb_.AddElement<int16_t>(ACRewardItemInfo::VT_ITEMGRADE, itemGrade, 0);
  }
  void add_amount(int32_t amount) {
    fbb_.AddElement<int32_t>(ACRewardItemInfo::VT_AMOUNT, amount, 0);
  }
  explicit ACRewardItemInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACRewardItemInfoBuilder &operator=(const ACRewardItemInfoBuilder &);
  flatbuffers::Offset<ACRewardItemInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACRewardItemInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACRewardItemInfo> CreateACRewardItemInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t itemId = 0,
    int16_t itemGrade = 0,
    int32_t amount = 0) {
  ACRewardItemInfoBuilder builder_(_fbb);
  builder_.add_amount(amount);
  builder_.add_itemId(itemId);
  builder_.add_itemGrade(itemGrade);
  return builder_.Finish();
}

struct DailyDungeonInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_EVENTID = 6,
    VT_DAY = 8,
    VT_DIFFICULT = 10,
    VT_SCORE = 12,
    VT_CLEARCOUNT = 14,
    VT_CLEARTIME = 16
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int32_t eventId() const {
    return GetField<int32_t>(VT_EVENTID, 0);
  }
  int16_t day() const {
    return GetField<int16_t>(VT_DAY, 0);
  }
  int16_t difficult() const {
    return GetField<int16_t>(VT_DIFFICULT, 0);
  }
  int32_t score() const {
    return GetField<int32_t>(VT_SCORE, 0);
  }
  int32_t clearCount() const {
    return GetField<int32_t>(VT_CLEARCOUNT, 0);
  }
  int64_t clearTime() const {
    return GetField<int64_t>(VT_CLEARTIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<int32_t>(verifier, VT_EVENTID) &&
           VerifyField<int16_t>(verifier, VT_DAY) &&
           VerifyField<int16_t>(verifier, VT_DIFFICULT) &&
           VerifyField<int32_t>(verifier, VT_SCORE) &&
           VerifyField<int32_t>(verifier, VT_CLEARCOUNT) &&
           VerifyField<int64_t>(verifier, VT_CLEARTIME) &&
           verifier.EndTable();
  }
};

struct DailyDungeonInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(DailyDungeonInfo::VT_ID, id, 0);
  }
  void add_eventId(int32_t eventId) {
    fbb_.AddElement<int32_t>(DailyDungeonInfo::VT_EVENTID, eventId, 0);
  }
  void add_day(int16_t day) {
    fbb_.AddElement<int16_t>(DailyDungeonInfo::VT_DAY, day, 0);
  }
  void add_difficult(int16_t difficult) {
    fbb_.AddElement<int16_t>(DailyDungeonInfo::VT_DIFFICULT, difficult, 0);
  }
  void add_score(int32_t score) {
    fbb_.AddElement<int32_t>(DailyDungeonInfo::VT_SCORE, score, 0);
  }
  void add_clearCount(int32_t clearCount) {
    fbb_.AddElement<int32_t>(DailyDungeonInfo::VT_CLEARCOUNT, clearCount, 0);
  }
  void add_clearTime(int64_t clearTime) {
    fbb_.AddElement<int64_t>(DailyDungeonInfo::VT_CLEARTIME, clearTime, 0);
  }
  explicit DailyDungeonInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DailyDungeonInfoBuilder &operator=(const DailyDungeonInfoBuilder &);
  flatbuffers::Offset<DailyDungeonInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DailyDungeonInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<DailyDungeonInfo> CreateDailyDungeonInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int32_t eventId = 0,
    int16_t day = 0,
    int16_t difficult = 0,
    int32_t score = 0,
    int32_t clearCount = 0,
    int64_t clearTime = 0) {
  DailyDungeonInfoBuilder builder_(_fbb);
  builder_.add_clearTime(clearTime);
  builder_.add_clearCount(clearCount);
  builder_.add_score(score);
  builder_.add_eventId(eventId);
  builder_.add_id(id);
  builder_.add_difficult(difficult);
  builder_.add_day(day);
  return builder_.Finish();
}

/// DAILY_DUNGEON_INFO_REQUEST
struct DailyDungeonInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct DailyDungeonInfoRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DailyDungeonInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DailyDungeonInfoRequestBuilder &operator=(const DailyDungeonInfoRequestBuilder &);
  flatbuffers::Offset<DailyDungeonInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DailyDungeonInfoRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DailyDungeonInfoRequest> CreateDailyDungeonInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DailyDungeonInfoRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// DAILY_DUNGEON_INFO_RESPONSE
struct DailyDungeonInfoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DAY = 4,
    VT_TODAYCLEARCOUNT = 6,
    VT_OTHERDAYCLEARCOUNT = 8
  };
  int8_t day() const {
    return GetField<int8_t>(VT_DAY, 0);
  }
  int32_t todayClearCount() const {
    return GetField<int32_t>(VT_TODAYCLEARCOUNT, 0);
  }
  const flatbuffers::Vector<int32_t> *otherDayClearCount() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OTHERDAYCLEARCOUNT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_DAY) &&
           VerifyField<int32_t>(verifier, VT_TODAYCLEARCOUNT) &&
           VerifyOffset(verifier, VT_OTHERDAYCLEARCOUNT) &&
           verifier.VerifyVector(otherDayClearCount()) &&
           verifier.EndTable();
  }
};

struct DailyDungeonInfoResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_day(int8_t day) {
    fbb_.AddElement<int8_t>(DailyDungeonInfoResponse::VT_DAY, day, 0);
  }
  void add_todayClearCount(int32_t todayClearCount) {
    fbb_.AddElement<int32_t>(DailyDungeonInfoResponse::VT_TODAYCLEARCOUNT, todayClearCount, 0);
  }
  void add_otherDayClearCount(flatbuffers::Offset<flatbuffers::Vector<int32_t>> otherDayClearCount) {
    fbb_.AddOffset(DailyDungeonInfoResponse::VT_OTHERDAYCLEARCOUNT, otherDayClearCount);
  }
  explicit DailyDungeonInfoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DailyDungeonInfoResponseBuilder &operator=(const DailyDungeonInfoResponseBuilder &);
  flatbuffers::Offset<DailyDungeonInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DailyDungeonInfoResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<DailyDungeonInfoResponse> CreateDailyDungeonInfoResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t day = 0,
    int32_t todayClearCount = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> otherDayClearCount = 0) {
  DailyDungeonInfoResponseBuilder builder_(_fbb);
  builder_.add_otherDayClearCount(otherDayClearCount);
  builder_.add_todayClearCount(todayClearCount);
  builder_.add_day(day);
  return builder_.Finish();
}

inline flatbuffers::Offset<DailyDungeonInfoResponse> CreateDailyDungeonInfoResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t day = 0,
    int32_t todayClearCount = 0,
    const std::vector<int32_t> *otherDayClearCount = nullptr) {
  return LeanPacket::CreateDailyDungeonInfoResponse(
      _fbb,
      day,
      todayClearCount,
      otherDayClearCount ? _fbb.CreateVector<int32_t>(*otherDayClearCount) : 0);
}

/// DAILY_DUNGEON_OTHER_JOIN_REQUEST
struct DailyDungeonOtherJoinRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_DIFFICULT = 6
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int16_t difficult() const {
    return GetField<int16_t>(VT_DIFFICULT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<int16_t>(verifier, VT_DIFFICULT) &&
           verifier.EndTable();
  }
};

struct DailyDungeonOtherJoinRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(DailyDungeonOtherJoinRequest::VT_ID, id, 0);
  }
  void add_difficult(int16_t difficult) {
    fbb_.AddElement<int16_t>(DailyDungeonOtherJoinRequest::VT_DIFFICULT, difficult, 0);
  }
  explicit DailyDungeonOtherJoinRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DailyDungeonOtherJoinRequestBuilder &operator=(const DailyDungeonOtherJoinRequestBuilder &);
  flatbuffers::Offset<DailyDungeonOtherJoinRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DailyDungeonOtherJoinRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DailyDungeonOtherJoinRequest> CreateDailyDungeonOtherJoinRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int16_t difficult = 0) {
  DailyDungeonOtherJoinRequestBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_difficult(difficult);
  return builder_.Finish();
}

/// DAILY_DUNGEON_OTHER_JOIN_RESPONSE
struct DailyDungeonOtherJoinResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULT = 4,
    VT_ID = 6,
    VT_DIFFICULT = 8
  };
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int16_t difficult() const {
    return GetField<int16_t>(VT_DIFFICULT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<int16_t>(verifier, VT_DIFFICULT) &&
           verifier.EndTable();
  }
};

struct DailyDungeonOtherJoinResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(DailyDungeonOtherJoinResponse::VT_RESULT, result, 0);
  }
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(DailyDungeonOtherJoinResponse::VT_ID, id, 0);
  }
  void add_difficult(int16_t difficult) {
    fbb_.AddElement<int16_t>(DailyDungeonOtherJoinResponse::VT_DIFFICULT, difficult, 0);
  }
  explicit DailyDungeonOtherJoinResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DailyDungeonOtherJoinResponseBuilder &operator=(const DailyDungeonOtherJoinResponseBuilder &);
  flatbuffers::Offset<DailyDungeonOtherJoinResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DailyDungeonOtherJoinResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<DailyDungeonOtherJoinResponse> CreateDailyDungeonOtherJoinResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    int32_t id = 0,
    int16_t difficult = 0) {
  DailyDungeonOtherJoinResponseBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_result(result);
  builder_.add_difficult(difficult);
  return builder_.Finish();
}

/// START_RESURRECTION_REQUEST
struct StartResurrectionRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CASTERID = 4,
    VT_TARGETID = 6
  };
  int64_t casterId() const {
    return GetField<int64_t>(VT_CASTERID, 0);
  }
  int64_t targetId() const {
    return GetField<int64_t>(VT_TARGETID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_CASTERID) &&
           VerifyField<int64_t>(verifier, VT_TARGETID) &&
           verifier.EndTable();
  }
};

struct StartResurrectionRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_casterId(int64_t casterId) {
    fbb_.AddElement<int64_t>(StartResurrectionRequest::VT_CASTERID, casterId, 0);
  }
  void add_targetId(int64_t targetId) {
    fbb_.AddElement<int64_t>(StartResurrectionRequest::VT_TARGETID, targetId, 0);
  }
  explicit StartResurrectionRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StartResurrectionRequestBuilder &operator=(const StartResurrectionRequestBuilder &);
  flatbuffers::Offset<StartResurrectionRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StartResurrectionRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<StartResurrectionRequest> CreateStartResurrectionRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t casterId = 0,
    int64_t targetId = 0) {
  StartResurrectionRequestBuilder builder_(_fbb);
  builder_.add_targetId(targetId);
  builder_.add_casterId(casterId);
  return builder_.Finish();
}

/// START_RESURRECTION_NOTIFY
struct StartResurrectionNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CASTERID = 4,
    VT_TARGETID = 6,
    VT_RESULT = 8,
    VT_DURATION = 10
  };
  int64_t casterId() const {
    return GetField<int64_t>(VT_CASTERID, 0);
  }
  int64_t targetId() const {
    return GetField<int64_t>(VT_TARGETID, 0);
  }
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  int32_t duration() const {
    return GetField<int32_t>(VT_DURATION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_CASTERID) &&
           VerifyField<int64_t>(verifier, VT_TARGETID) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           VerifyField<int32_t>(verifier, VT_DURATION) &&
           verifier.EndTable();
  }
};

struct StartResurrectionNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_casterId(int64_t casterId) {
    fbb_.AddElement<int64_t>(StartResurrectionNotify::VT_CASTERID, casterId, 0);
  }
  void add_targetId(int64_t targetId) {
    fbb_.AddElement<int64_t>(StartResurrectionNotify::VT_TARGETID, targetId, 0);
  }
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(StartResurrectionNotify::VT_RESULT, result, 0);
  }
  void add_duration(int32_t duration) {
    fbb_.AddElement<int32_t>(StartResurrectionNotify::VT_DURATION, duration, 0);
  }
  explicit StartResurrectionNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StartResurrectionNotifyBuilder &operator=(const StartResurrectionNotifyBuilder &);
  flatbuffers::Offset<StartResurrectionNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StartResurrectionNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<StartResurrectionNotify> CreateStartResurrectionNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t casterId = 0,
    int64_t targetId = 0,
    int32_t result = 0,
    int32_t duration = 0) {
  StartResurrectionNotifyBuilder builder_(_fbb);
  builder_.add_targetId(targetId);
  builder_.add_casterId(casterId);
  builder_.add_duration(duration);
  builder_.add_result(result);
  return builder_.Finish();
}

/// END_RESURRECTION_NOTIFY
struct EndResurrectionNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CASTERID = 4,
    VT_TARGETID = 6
  };
  int64_t casterId() const {
    return GetField<int64_t>(VT_CASTERID, 0);
  }
  int64_t targetId() const {
    return GetField<int64_t>(VT_TARGETID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_CASTERID) &&
           VerifyField<int64_t>(verifier, VT_TARGETID) &&
           verifier.EndTable();
  }
};

struct EndResurrectionNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_casterId(int64_t casterId) {
    fbb_.AddElement<int64_t>(EndResurrectionNotify::VT_CASTERID, casterId, 0);
  }
  void add_targetId(int64_t targetId) {
    fbb_.AddElement<int64_t>(EndResurrectionNotify::VT_TARGETID, targetId, 0);
  }
  explicit EndResurrectionNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EndResurrectionNotifyBuilder &operator=(const EndResurrectionNotifyBuilder &);
  flatbuffers::Offset<EndResurrectionNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EndResurrectionNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<EndResurrectionNotify> CreateEndResurrectionNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t casterId = 0,
    int64_t targetId = 0) {
  EndResurrectionNotifyBuilder builder_(_fbb);
  builder_.add_targetId(targetId);
  builder_.add_casterId(casterId);
  return builder_.Finish();
}

/// CANCEL_RESURRECTION_REQUEST
struct CancelResurrectionRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CASTERID = 4,
    VT_TARGETID = 6
  };
  int64_t casterId() const {
    return GetField<int64_t>(VT_CASTERID, 0);
  }
  int64_t targetId() const {
    return GetField<int64_t>(VT_TARGETID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_CASTERID) &&
           VerifyField<int64_t>(verifier, VT_TARGETID) &&
           verifier.EndTable();
  }
};

struct CancelResurrectionRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_casterId(int64_t casterId) {
    fbb_.AddElement<int64_t>(CancelResurrectionRequest::VT_CASTERID, casterId, 0);
  }
  void add_targetId(int64_t targetId) {
    fbb_.AddElement<int64_t>(CancelResurrectionRequest::VT_TARGETID, targetId, 0);
  }
  explicit CancelResurrectionRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CancelResurrectionRequestBuilder &operator=(const CancelResurrectionRequestBuilder &);
  flatbuffers::Offset<CancelResurrectionRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CancelResurrectionRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<CancelResurrectionRequest> CreateCancelResurrectionRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t casterId = 0,
    int64_t targetId = 0) {
  CancelResurrectionRequestBuilder builder_(_fbb);
  builder_.add_targetId(targetId);
  builder_.add_casterId(casterId);
  return builder_.Finish();
}

/// CANCEL_RESURRECTION_NOTIFY
struct CancelResurrectionNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CASTERID = 4,
    VT_TARGETID = 6
  };
  int64_t casterId() const {
    return GetField<int64_t>(VT_CASTERID, 0);
  }
  int64_t targetId() const {
    return GetField<int64_t>(VT_TARGETID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_CASTERID) &&
           VerifyField<int64_t>(verifier, VT_TARGETID) &&
           verifier.EndTable();
  }
};

struct CancelResurrectionNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_casterId(int64_t casterId) {
    fbb_.AddElement<int64_t>(CancelResurrectionNotify::VT_CASTERID, casterId, 0);
  }
  void add_targetId(int64_t targetId) {
    fbb_.AddElement<int64_t>(CancelResurrectionNotify::VT_TARGETID, targetId, 0);
  }
  explicit CancelResurrectionNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CancelResurrectionNotifyBuilder &operator=(const CancelResurrectionNotifyBuilder &);
  flatbuffers::Offset<CancelResurrectionNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CancelResurrectionNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<CancelResurrectionNotify> CreateCancelResurrectionNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t casterId = 0,
    int64_t targetId = 0) {
  CancelResurrectionNotifyBuilder builder_(_fbb);
  builder_.add_targetId(targetId);
  builder_.add_casterId(casterId);
  return builder_.Finish();
}

struct MoveItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMOBJECTID = 4,
    VT_COUNT = 6
  };
  uint64_t itemObjectId() const {
    return GetField<uint64_t>(VT_ITEMOBJECTID, 0);
  }
  int32_t count() const {
    return GetField<int32_t>(VT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ITEMOBJECTID) &&
           VerifyField<int32_t>(verifier, VT_COUNT) &&
           verifier.EndTable();
  }
};

struct MoveItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemObjectId(uint64_t itemObjectId) {
    fbb_.AddElement<uint64_t>(MoveItem::VT_ITEMOBJECTID, itemObjectId, 0);
  }
  void add_count(int32_t count) {
    fbb_.AddElement<int32_t>(MoveItem::VT_COUNT, count, 0);
  }
  explicit MoveItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MoveItemBuilder &operator=(const MoveItemBuilder &);
  flatbuffers::Offset<MoveItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MoveItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<MoveItem> CreateMoveItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t itemObjectId = 0,
    int32_t count = 0) {
  MoveItemBuilder builder_(_fbb);
  builder_.add_itemObjectId(itemObjectId);
  builder_.add_count(count);
  return builder_.Finish();
}

/// MOVE_ITEM_REQUEST
struct MoveItemRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<MoveItem>> *items() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MoveItem>> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.VerifyVectorOfTables(items()) &&
           verifier.EndTable();
  }
};

struct MoveItemRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MoveItem>>> items) {
    fbb_.AddOffset(MoveItemRequest::VT_ITEMS, items);
  }
  explicit MoveItemRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MoveItemRequestBuilder &operator=(const MoveItemRequestBuilder &);
  flatbuffers::Offset<MoveItemRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MoveItemRequest>(end);
    fbb_.Required(o, MoveItemRequest::VT_ITEMS);
    return o;
  }
};

inline flatbuffers::Offset<MoveItemRequest> CreateMoveItemRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MoveItem>>> items = 0) {
  MoveItemRequestBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<MoveItemRequest> CreateMoveItemRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<MoveItem>> *items = nullptr) {
  return LeanPacket::CreateMoveItemRequest(
      _fbb,
      items ? _fbb.CreateVector<flatbuffers::Offset<MoveItem>>(*items) : 0);
}

struct MoveItemResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           verifier.EndTable();
  }
};

struct MoveItemResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(MoveItemResponse::VT_ERRORCODE, errorCode, 0);
  }
  explicit MoveItemResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MoveItemResponseBuilder &operator=(const MoveItemResponseBuilder &);
  flatbuffers::Offset<MoveItemResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MoveItemResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<MoveItemResponse> CreateMoveItemResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0) {
  MoveItemResponseBuilder builder_(_fbb);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

/// CREATURE_DETECT_TARGET_NOTIFY
struct CreatureDetectTargetNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OWNERID = 4,
    VT_LOOKATTARGETID = 6
  };
  int64_t ownerId() const {
    return GetField<int64_t>(VT_OWNERID, 0);
  }
  int64_t lookAtTargetId() const {
    return GetField<int64_t>(VT_LOOKATTARGETID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OWNERID) &&
           VerifyField<int64_t>(verifier, VT_LOOKATTARGETID) &&
           verifier.EndTable();
  }
};

struct CreatureDetectTargetNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ownerId(int64_t ownerId) {
    fbb_.AddElement<int64_t>(CreatureDetectTargetNotify::VT_OWNERID, ownerId, 0);
  }
  void add_lookAtTargetId(int64_t lookAtTargetId) {
    fbb_.AddElement<int64_t>(CreatureDetectTargetNotify::VT_LOOKATTARGETID, lookAtTargetId, 0);
  }
  explicit CreatureDetectTargetNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CreatureDetectTargetNotifyBuilder &operator=(const CreatureDetectTargetNotifyBuilder &);
  flatbuffers::Offset<CreatureDetectTargetNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CreatureDetectTargetNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<CreatureDetectTargetNotify> CreateCreatureDetectTargetNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t ownerId = 0,
    int64_t lookAtTargetId = 0) {
  CreatureDetectTargetNotifyBuilder builder_(_fbb);
  builder_.add_lookAtTargetId(lookAtTargetId);
  builder_.add_ownerId(ownerId);
  return builder_.Finish();
}

/// SOCIAL_MOTION_START_REQUEST
struct SocialMotionStartRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MOTION = 4
  };
  int16_t motion() const {
    return GetField<int16_t>(VT_MOTION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_MOTION) &&
           verifier.EndTable();
  }
};

struct SocialMotionStartRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_motion(int16_t motion) {
    fbb_.AddElement<int16_t>(SocialMotionStartRequest::VT_MOTION, motion, 0);
  }
  explicit SocialMotionStartRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SocialMotionStartRequestBuilder &operator=(const SocialMotionStartRequestBuilder &);
  flatbuffers::Offset<SocialMotionStartRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SocialMotionStartRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SocialMotionStartRequest> CreateSocialMotionStartRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t motion = 0) {
  SocialMotionStartRequestBuilder builder_(_fbb);
  builder_.add_motion(motion);
  return builder_.Finish();
}

/// SOCIAL_MOTION_START_NOTIFY
struct SocialMotionStartNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_ACTOR = 6,
    VT_MOTION = 8
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  int64_t actor() const {
    return GetField<int64_t>(VT_ACTOR, 0);
  }
  int16_t motion() const {
    return GetField<int16_t>(VT_MOTION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int64_t>(verifier, VT_ACTOR) &&
           VerifyField<int16_t>(verifier, VT_MOTION) &&
           verifier.EndTable();
  }
};

struct SocialMotionStartNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(SocialMotionStartNotify::VT_ERRORCODE, errorCode, 0);
  }
  void add_actor(int64_t actor) {
    fbb_.AddElement<int64_t>(SocialMotionStartNotify::VT_ACTOR, actor, 0);
  }
  void add_motion(int16_t motion) {
    fbb_.AddElement<int16_t>(SocialMotionStartNotify::VT_MOTION, motion, 0);
  }
  explicit SocialMotionStartNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SocialMotionStartNotifyBuilder &operator=(const SocialMotionStartNotifyBuilder &);
  flatbuffers::Offset<SocialMotionStartNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SocialMotionStartNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<SocialMotionStartNotify> CreateSocialMotionStartNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    int64_t actor = 0,
    int16_t motion = 0) {
  SocialMotionStartNotifyBuilder builder_(_fbb);
  builder_.add_actor(actor);
  builder_.add_errorCode(errorCode);
  builder_.add_motion(motion);
  return builder_.Finish();
}

/// SOLO_DUNGEON (공용 데이터 구조)
struct SoloDungeonStageElem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CHAPTERID = 4,
    VT_SMAPID = 6,
    VT_STAGEID = 8,
    VT_ISCLEARED = 10,
    VT_CLEARCOUNT = 12,
    VT_ISONESHOT = 14,
    VT_UPDATETIME = 16
  };
  int32_t chapterId() const {
    return GetField<int32_t>(VT_CHAPTERID, 0);
  }
  int32_t sMapId() const {
    return GetField<int32_t>(VT_SMAPID, 0);
  }
  int32_t stageId() const {
    return GetField<int32_t>(VT_STAGEID, 0);
  }
  bool isCleared() const {
    return GetField<uint8_t>(VT_ISCLEARED, 0) != 0;
  }
  int32_t clearCount() const {
    return GetField<int32_t>(VT_CLEARCOUNT, 0);
  }
  bool isOneShot() const {
    return GetField<uint8_t>(VT_ISONESHOT, 0) != 0;
  }
  int64_t updateTime() const {
    return GetField<int64_t>(VT_UPDATETIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CHAPTERID) &&
           VerifyField<int32_t>(verifier, VT_SMAPID) &&
           VerifyField<int32_t>(verifier, VT_STAGEID) &&
           VerifyField<uint8_t>(verifier, VT_ISCLEARED) &&
           VerifyField<int32_t>(verifier, VT_CLEARCOUNT) &&
           VerifyField<uint8_t>(verifier, VT_ISONESHOT) &&
           VerifyField<int64_t>(verifier, VT_UPDATETIME) &&
           verifier.EndTable();
  }
};

struct SoloDungeonStageElemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_chapterId(int32_t chapterId) {
    fbb_.AddElement<int32_t>(SoloDungeonStageElem::VT_CHAPTERID, chapterId, 0);
  }
  void add_sMapId(int32_t sMapId) {
    fbb_.AddElement<int32_t>(SoloDungeonStageElem::VT_SMAPID, sMapId, 0);
  }
  void add_stageId(int32_t stageId) {
    fbb_.AddElement<int32_t>(SoloDungeonStageElem::VT_STAGEID, stageId, 0);
  }
  void add_isCleared(bool isCleared) {
    fbb_.AddElement<uint8_t>(SoloDungeonStageElem::VT_ISCLEARED, static_cast<uint8_t>(isCleared), 0);
  }
  void add_clearCount(int32_t clearCount) {
    fbb_.AddElement<int32_t>(SoloDungeonStageElem::VT_CLEARCOUNT, clearCount, 0);
  }
  void add_isOneShot(bool isOneShot) {
    fbb_.AddElement<uint8_t>(SoloDungeonStageElem::VT_ISONESHOT, static_cast<uint8_t>(isOneShot), 0);
  }
  void add_updateTime(int64_t updateTime) {
    fbb_.AddElement<int64_t>(SoloDungeonStageElem::VT_UPDATETIME, updateTime, 0);
  }
  explicit SoloDungeonStageElemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SoloDungeonStageElemBuilder &operator=(const SoloDungeonStageElemBuilder &);
  flatbuffers::Offset<SoloDungeonStageElem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SoloDungeonStageElem>(end);
    return o;
  }
};

inline flatbuffers::Offset<SoloDungeonStageElem> CreateSoloDungeonStageElem(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t chapterId = 0,
    int32_t sMapId = 0,
    int32_t stageId = 0,
    bool isCleared = false,
    int32_t clearCount = 0,
    bool isOneShot = false,
    int64_t updateTime = 0) {
  SoloDungeonStageElemBuilder builder_(_fbb);
  builder_.add_updateTime(updateTime);
  builder_.add_clearCount(clearCount);
  builder_.add_stageId(stageId);
  builder_.add_sMapId(sMapId);
  builder_.add_chapterId(chapterId);
  builder_.add_isOneShot(isOneShot);
  builder_.add_isCleared(isCleared);
  return builder_.Finish();
}

/// SOLO_DUNGEON (리로드용 공용 데이터 구조)
struct SoloDungeonReloadElem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STAGEID = 4,
    VT_CLEARCOUNT = 6
  };
  int32_t stageId() const {
    return GetField<int32_t>(VT_STAGEID, 0);
  }
  int32_t clearCount() const {
    return GetField<int32_t>(VT_CLEARCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STAGEID) &&
           VerifyField<int32_t>(verifier, VT_CLEARCOUNT) &&
           verifier.EndTable();
  }
};

struct SoloDungeonReloadElemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stageId(int32_t stageId) {
    fbb_.AddElement<int32_t>(SoloDungeonReloadElem::VT_STAGEID, stageId, 0);
  }
  void add_clearCount(int32_t clearCount) {
    fbb_.AddElement<int32_t>(SoloDungeonReloadElem::VT_CLEARCOUNT, clearCount, 0);
  }
  explicit SoloDungeonReloadElemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SoloDungeonReloadElemBuilder &operator=(const SoloDungeonReloadElemBuilder &);
  flatbuffers::Offset<SoloDungeonReloadElem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SoloDungeonReloadElem>(end);
    return o;
  }
};

inline flatbuffers::Offset<SoloDungeonReloadElem> CreateSoloDungeonReloadElem(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t stageId = 0,
    int32_t clearCount = 0) {
  SoloDungeonReloadElemBuilder builder_(_fbb);
  builder_.add_clearCount(clearCount);
  builder_.add_stageId(stageId);
  return builder_.Finish();
}

/// SOLO_DUNGEON_RELOAD_REQUEST
struct SoloDungeonReloadRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SoloDungeonReloadRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SoloDungeonReloadRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SoloDungeonReloadRequestBuilder &operator=(const SoloDungeonReloadRequestBuilder &);
  flatbuffers::Offset<SoloDungeonReloadRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SoloDungeonReloadRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SoloDungeonReloadRequest> CreateSoloDungeonReloadRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SoloDungeonReloadRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// SOLO_DUNGEON_RELOAD_RESPONSE
struct SoloDungeonReloadResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STAGEELEMS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<SoloDungeonReloadElem>> *stageElems() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SoloDungeonReloadElem>> *>(VT_STAGEELEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STAGEELEMS) &&
           verifier.VerifyVector(stageElems()) &&
           verifier.VerifyVectorOfTables(stageElems()) &&
           verifier.EndTable();
  }
};

struct SoloDungeonReloadResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stageElems(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SoloDungeonReloadElem>>> stageElems) {
    fbb_.AddOffset(SoloDungeonReloadResponse::VT_STAGEELEMS, stageElems);
  }
  explicit SoloDungeonReloadResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SoloDungeonReloadResponseBuilder &operator=(const SoloDungeonReloadResponseBuilder &);
  flatbuffers::Offset<SoloDungeonReloadResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SoloDungeonReloadResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<SoloDungeonReloadResponse> CreateSoloDungeonReloadResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SoloDungeonReloadElem>>> stageElems = 0) {
  SoloDungeonReloadResponseBuilder builder_(_fbb);
  builder_.add_stageElems(stageElems);
  return builder_.Finish();
}

inline flatbuffers::Offset<SoloDungeonReloadResponse> CreateSoloDungeonReloadResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<SoloDungeonReloadElem>> *stageElems = nullptr) {
  return LeanPacket::CreateSoloDungeonReloadResponse(
      _fbb,
      stageElems ? _fbb.CreateVector<flatbuffers::Offset<SoloDungeonReloadElem>>(*stageElems) : 0);
}

/// SOLO_DUNGEON_LOAD_NOTIFY
struct SoloDungeonLoadNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STAGEELEMS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<SoloDungeonStageElem>> *stageElems() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SoloDungeonStageElem>> *>(VT_STAGEELEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_STAGEELEMS) &&
           verifier.VerifyVector(stageElems()) &&
           verifier.VerifyVectorOfTables(stageElems()) &&
           verifier.EndTable();
  }
};

struct SoloDungeonLoadNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stageElems(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SoloDungeonStageElem>>> stageElems) {
    fbb_.AddOffset(SoloDungeonLoadNotify::VT_STAGEELEMS, stageElems);
  }
  explicit SoloDungeonLoadNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SoloDungeonLoadNotifyBuilder &operator=(const SoloDungeonLoadNotifyBuilder &);
  flatbuffers::Offset<SoloDungeonLoadNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SoloDungeonLoadNotify>(end);
    fbb_.Required(o, SoloDungeonLoadNotify::VT_STAGEELEMS);
    return o;
  }
};

inline flatbuffers::Offset<SoloDungeonLoadNotify> CreateSoloDungeonLoadNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SoloDungeonStageElem>>> stageElems = 0) {
  SoloDungeonLoadNotifyBuilder builder_(_fbb);
  builder_.add_stageElems(stageElems);
  return builder_.Finish();
}

inline flatbuffers::Offset<SoloDungeonLoadNotify> CreateSoloDungeonLoadNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<SoloDungeonStageElem>> *stageElems = nullptr) {
  return LeanPacket::CreateSoloDungeonLoadNotify(
      _fbb,
      stageElems ? _fbb.CreateVector<flatbuffers::Offset<SoloDungeonStageElem>>(*stageElems) : 0);
}

/// SOLO_DUNGEON_JOIN_REQUEST
struct SoloDungeonJoinRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STAGEID = 4
  };
  int32_t stageId() const {
    return GetField<int32_t>(VT_STAGEID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STAGEID) &&
           verifier.EndTable();
  }
};

struct SoloDungeonJoinRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stageId(int32_t stageId) {
    fbb_.AddElement<int32_t>(SoloDungeonJoinRequest::VT_STAGEID, stageId, 0);
  }
  explicit SoloDungeonJoinRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SoloDungeonJoinRequestBuilder &operator=(const SoloDungeonJoinRequestBuilder &);
  flatbuffers::Offset<SoloDungeonJoinRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SoloDungeonJoinRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SoloDungeonJoinRequest> CreateSoloDungeonJoinRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t stageId = 0) {
  SoloDungeonJoinRequestBuilder builder_(_fbb);
  builder_.add_stageId(stageId);
  return builder_.Finish();
}

/// SOLO_DUNGEON_JOIN_RESPONSE
struct SoloDungeonJoinResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULT = 4,
    VT_STAGEID = 6
  };
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  int32_t stageId() const {
    return GetField<int32_t>(VT_STAGEID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           VerifyField<int32_t>(verifier, VT_STAGEID) &&
           verifier.EndTable();
  }
};

struct SoloDungeonJoinResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(SoloDungeonJoinResponse::VT_RESULT, result, 0);
  }
  void add_stageId(int32_t stageId) {
    fbb_.AddElement<int32_t>(SoloDungeonJoinResponse::VT_STAGEID, stageId, 0);
  }
  explicit SoloDungeonJoinResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SoloDungeonJoinResponseBuilder &operator=(const SoloDungeonJoinResponseBuilder &);
  flatbuffers::Offset<SoloDungeonJoinResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SoloDungeonJoinResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<SoloDungeonJoinResponse> CreateSoloDungeonJoinResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    int32_t stageId = 0) {
  SoloDungeonJoinResponseBuilder builder_(_fbb);
  builder_.add_stageId(stageId);
  builder_.add_result(result);
  return builder_.Finish();
}

/// SOLO_DUNGEON_CLEAR_NOTIFY
struct SoloDungeonClearNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULT = 4,
    VT_SUCCEED = 6,
    VT_STAGEELEM = 8,
    VT_REWARDS = 10
  };
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  bool succeed() const {
    return GetField<uint8_t>(VT_SUCCEED, 0) != 0;
  }
  const SoloDungeonStageElem *stageElem() const {
    return GetPointer<const SoloDungeonStageElem *>(VT_STAGEELEM);
  }
  const RewardInfo *rewards() const {
    return GetPointer<const RewardInfo *>(VT_REWARDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           VerifyField<uint8_t>(verifier, VT_SUCCEED) &&
           VerifyOffsetRequired(verifier, VT_STAGEELEM) &&
           verifier.VerifyTable(stageElem()) &&
           VerifyOffset(verifier, VT_REWARDS) &&
           verifier.VerifyTable(rewards()) &&
           verifier.EndTable();
  }
};

struct SoloDungeonClearNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(SoloDungeonClearNotify::VT_RESULT, result, 0);
  }
  void add_succeed(bool succeed) {
    fbb_.AddElement<uint8_t>(SoloDungeonClearNotify::VT_SUCCEED, static_cast<uint8_t>(succeed), 0);
  }
  void add_stageElem(flatbuffers::Offset<SoloDungeonStageElem> stageElem) {
    fbb_.AddOffset(SoloDungeonClearNotify::VT_STAGEELEM, stageElem);
  }
  void add_rewards(flatbuffers::Offset<RewardInfo> rewards) {
    fbb_.AddOffset(SoloDungeonClearNotify::VT_REWARDS, rewards);
  }
  explicit SoloDungeonClearNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SoloDungeonClearNotifyBuilder &operator=(const SoloDungeonClearNotifyBuilder &);
  flatbuffers::Offset<SoloDungeonClearNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SoloDungeonClearNotify>(end);
    fbb_.Required(o, SoloDungeonClearNotify::VT_STAGEELEM);
    return o;
  }
};

inline flatbuffers::Offset<SoloDungeonClearNotify> CreateSoloDungeonClearNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    bool succeed = false,
    flatbuffers::Offset<SoloDungeonStageElem> stageElem = 0,
    flatbuffers::Offset<RewardInfo> rewards = 0) {
  SoloDungeonClearNotifyBuilder builder_(_fbb);
  builder_.add_rewards(rewards);
  builder_.add_stageElem(stageElem);
  builder_.add_result(result);
  builder_.add_succeed(succeed);
  return builder_.Finish();
}

/// CHAT_REQUEST
struct ChatRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_LANGUAGE = 6,
    VT_MESSAGE = 8
  };
  int16_t type() const {
    return GetField<int16_t>(VT_TYPE, 0);
  }
  int16_t language() const {
    return GetField<int16_t>(VT_LANGUAGE, 0);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPE) &&
           VerifyField<int16_t>(verifier, VT_LANGUAGE) &&
           VerifyOffsetRequired(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct ChatRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int16_t type) {
    fbb_.AddElement<int16_t>(ChatRequest::VT_TYPE, type, 0);
  }
  void add_language(int16_t language) {
    fbb_.AddElement<int16_t>(ChatRequest::VT_LANGUAGE, language, 0);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(ChatRequest::VT_MESSAGE, message);
  }
  explicit ChatRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChatRequestBuilder &operator=(const ChatRequestBuilder &);
  flatbuffers::Offset<ChatRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChatRequest>(end);
    fbb_.Required(o, ChatRequest::VT_MESSAGE);
    return o;
  }
};

inline flatbuffers::Offset<ChatRequest> CreateChatRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t type = 0,
    int16_t language = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  ChatRequestBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_language(language);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ChatRequest> CreateChatRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t type = 0,
    int16_t language = 0,
    const char *message = nullptr) {
  return LeanPacket::CreateChatRequest(
      _fbb,
      type,
      language,
      message ? _fbb.CreateString(message) : 0);
}

/// CHAT_WHISPER_REQUEST
struct ChatWhisperRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RECEIVERDBID = 4,
    VT_MESSAGE = 6
  };
  int64_t receiverDbId() const {
    return GetField<int64_t>(VT_RECEIVERDBID, 0);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_RECEIVERDBID) &&
           VerifyOffsetRequired(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct ChatWhisperRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_receiverDbId(int64_t receiverDbId) {
    fbb_.AddElement<int64_t>(ChatWhisperRequest::VT_RECEIVERDBID, receiverDbId, 0);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(ChatWhisperRequest::VT_MESSAGE, message);
  }
  explicit ChatWhisperRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChatWhisperRequestBuilder &operator=(const ChatWhisperRequestBuilder &);
  flatbuffers::Offset<ChatWhisperRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChatWhisperRequest>(end);
    fbb_.Required(o, ChatWhisperRequest::VT_MESSAGE);
    return o;
  }
};

inline flatbuffers::Offset<ChatWhisperRequest> CreateChatWhisperRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t receiverDbId = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  ChatWhisperRequestBuilder builder_(_fbb);
  builder_.add_receiverDbId(receiverDbId);
  builder_.add_message(message);
  return builder_.Finish();
}

inline flatbuffers::Offset<ChatWhisperRequest> CreateChatWhisperRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t receiverDbId = 0,
    const char *message = nullptr) {
  return LeanPacket::CreateChatWhisperRequest(
      _fbb,
      receiverDbId,
      message ? _fbb.CreateString(message) : 0);
}

struct ChatPcInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_LEVEL = 6,
    VT_CLASSTYPE = 8,
    VT_TIER = 10,
    VT_TIERLEV = 12,
    VT_OBJECTID = 14,
    VT_PCDBID = 16,
    VT_WORLDID = 18,
    VT_IFF = 20
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int16_t level() const {
    return GetField<int16_t>(VT_LEVEL, 0);
  }
  int16_t classType() const {
    return GetField<int16_t>(VT_CLASSTYPE, 0);
  }
  int16_t tier() const {
    return GetField<int16_t>(VT_TIER, 0);
  }
  int16_t tierLev() const {
    return GetField<int16_t>(VT_TIERLEV, 0);
  }
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  int16_t worldId() const {
    return GetField<int16_t>(VT_WORLDID, 0);
  }
  int32_t iff() const {
    return GetField<int32_t>(VT_IFF, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int16_t>(verifier, VT_LEVEL) &&
           VerifyField<int16_t>(verifier, VT_CLASSTYPE) &&
           VerifyField<int16_t>(verifier, VT_TIER) &&
           VerifyField<int16_t>(verifier, VT_TIERLEV) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           VerifyField<int16_t>(verifier, VT_WORLDID) &&
           VerifyField<int32_t>(verifier, VT_IFF) &&
           verifier.EndTable();
  }
};

struct ChatPcInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ChatPcInfo::VT_NAME, name);
  }
  void add_level(int16_t level) {
    fbb_.AddElement<int16_t>(ChatPcInfo::VT_LEVEL, level, 0);
  }
  void add_classType(int16_t classType) {
    fbb_.AddElement<int16_t>(ChatPcInfo::VT_CLASSTYPE, classType, 0);
  }
  void add_tier(int16_t tier) {
    fbb_.AddElement<int16_t>(ChatPcInfo::VT_TIER, tier, 0);
  }
  void add_tierLev(int16_t tierLev) {
    fbb_.AddElement<int16_t>(ChatPcInfo::VT_TIERLEV, tierLev, 0);
  }
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(ChatPcInfo::VT_OBJECTID, objectId, 0);
  }
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(ChatPcInfo::VT_PCDBID, pcDbId, 0);
  }
  void add_worldId(int16_t worldId) {
    fbb_.AddElement<int16_t>(ChatPcInfo::VT_WORLDID, worldId, 0);
  }
  void add_iff(int32_t iff) {
    fbb_.AddElement<int32_t>(ChatPcInfo::VT_IFF, iff, 0);
  }
  explicit ChatPcInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChatPcInfoBuilder &operator=(const ChatPcInfoBuilder &);
  flatbuffers::Offset<ChatPcInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChatPcInfo>(end);
    fbb_.Required(o, ChatPcInfo::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<ChatPcInfo> CreateChatPcInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int16_t level = 0,
    int16_t classType = 0,
    int16_t tier = 0,
    int16_t tierLev = 0,
    int64_t objectId = 0,
    int64_t pcDbId = 0,
    int16_t worldId = 0,
    int32_t iff = 0) {
  ChatPcInfoBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  builder_.add_objectId(objectId);
  builder_.add_iff(iff);
  builder_.add_name(name);
  builder_.add_worldId(worldId);
  builder_.add_tierLev(tierLev);
  builder_.add_tier(tier);
  builder_.add_classType(classType);
  builder_.add_level(level);
  return builder_.Finish();
}

inline flatbuffers::Offset<ChatPcInfo> CreateChatPcInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int16_t level = 0,
    int16_t classType = 0,
    int16_t tier = 0,
    int16_t tierLev = 0,
    int64_t objectId = 0,
    int64_t pcDbId = 0,
    int16_t worldId = 0,
    int32_t iff = 0) {
  return LeanPacket::CreateChatPcInfo(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      level,
      classType,
      tier,
      tierLev,
      objectId,
      pcDbId,
      worldId,
      iff);
}

struct ChatCommonInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_SENDER = 6,
    VT_TIME = 8,
    VT_MESSAGE = 10,
    VT_CHATNO = 12,
    VT_TEXTTYPE = 14,
    VT_LANGUAGE = 16
  };
  int16_t type() const {
    return GetField<int16_t>(VT_TYPE, 0);
  }
  const ChatPcInfo *sender() const {
    return GetPointer<const ChatPcInfo *>(VT_SENDER);
  }
  int64_t time() const {
    return GetField<int64_t>(VT_TIME, 0);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  int32_t chatNo() const {
    return GetField<int32_t>(VT_CHATNO, 0);
  }
  int16_t textType() const {
    return GetField<int16_t>(VT_TEXTTYPE, 0);
  }
  int16_t language() const {
    return GetField<int16_t>(VT_LANGUAGE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPE) &&
           VerifyOffsetRequired(verifier, VT_SENDER) &&
           verifier.VerifyTable(sender()) &&
           VerifyField<int64_t>(verifier, VT_TIME) &&
           VerifyOffsetRequired(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           VerifyField<int32_t>(verifier, VT_CHATNO) &&
           VerifyField<int16_t>(verifier, VT_TEXTTYPE) &&
           VerifyField<int16_t>(verifier, VT_LANGUAGE) &&
           verifier.EndTable();
  }
};

struct ChatCommonInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int16_t type) {
    fbb_.AddElement<int16_t>(ChatCommonInfo::VT_TYPE, type, 0);
  }
  void add_sender(flatbuffers::Offset<ChatPcInfo> sender) {
    fbb_.AddOffset(ChatCommonInfo::VT_SENDER, sender);
  }
  void add_time(int64_t time) {
    fbb_.AddElement<int64_t>(ChatCommonInfo::VT_TIME, time, 0);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(ChatCommonInfo::VT_MESSAGE, message);
  }
  void add_chatNo(int32_t chatNo) {
    fbb_.AddElement<int32_t>(ChatCommonInfo::VT_CHATNO, chatNo, 0);
  }
  void add_textType(int16_t textType) {
    fbb_.AddElement<int16_t>(ChatCommonInfo::VT_TEXTTYPE, textType, 0);
  }
  void add_language(int16_t language) {
    fbb_.AddElement<int16_t>(ChatCommonInfo::VT_LANGUAGE, language, 0);
  }
  explicit ChatCommonInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChatCommonInfoBuilder &operator=(const ChatCommonInfoBuilder &);
  flatbuffers::Offset<ChatCommonInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChatCommonInfo>(end);
    fbb_.Required(o, ChatCommonInfo::VT_SENDER);
    fbb_.Required(o, ChatCommonInfo::VT_MESSAGE);
    return o;
  }
};

inline flatbuffers::Offset<ChatCommonInfo> CreateChatCommonInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t type = 0,
    flatbuffers::Offset<ChatPcInfo> sender = 0,
    int64_t time = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0,
    int32_t chatNo = 0,
    int16_t textType = 0,
    int16_t language = 0) {
  ChatCommonInfoBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_chatNo(chatNo);
  builder_.add_message(message);
  builder_.add_sender(sender);
  builder_.add_language(language);
  builder_.add_textType(textType);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ChatCommonInfo> CreateChatCommonInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t type = 0,
    flatbuffers::Offset<ChatPcInfo> sender = 0,
    int64_t time = 0,
    const char *message = nullptr,
    int32_t chatNo = 0,
    int16_t textType = 0,
    int16_t language = 0) {
  return LeanPacket::CreateChatCommonInfo(
      _fbb,
      type,
      sender,
      time,
      message ? _fbb.CreateString(message) : 0,
      chatNo,
      textType,
      language);
}

struct ChatGuildInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CHATINFO = 4,
    VT_GUILDNAME = 6,
    VT_GUILDID = 8,
    VT_MEMGRADE = 10,
    VT_JOINTYPE = 12,
    VT_ISTOP = 14,
    VT_ISNEWMEM = 16
  };
  const ChatCommonInfo *chatInfo() const {
    return GetPointer<const ChatCommonInfo *>(VT_CHATINFO);
  }
  const flatbuffers::String *guildName() const {
    return GetPointer<const flatbuffers::String *>(VT_GUILDNAME);
  }
  int32_t guildId() const {
    return GetField<int32_t>(VT_GUILDID, 0);
  }
  int16_t memGrade() const {
    return GetField<int16_t>(VT_MEMGRADE, 0);
  }
  int16_t joinType() const {
    return GetField<int16_t>(VT_JOINTYPE, 0);
  }
  bool isTop() const {
    return GetField<uint8_t>(VT_ISTOP, 0) != 0;
  }
  bool isNewMem() const {
    return GetField<uint8_t>(VT_ISNEWMEM, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CHATINFO) &&
           verifier.VerifyTable(chatInfo()) &&
           VerifyOffset(verifier, VT_GUILDNAME) &&
           verifier.VerifyString(guildName()) &&
           VerifyField<int32_t>(verifier, VT_GUILDID) &&
           VerifyField<int16_t>(verifier, VT_MEMGRADE) &&
           VerifyField<int16_t>(verifier, VT_JOINTYPE) &&
           VerifyField<uint8_t>(verifier, VT_ISTOP) &&
           VerifyField<uint8_t>(verifier, VT_ISNEWMEM) &&
           verifier.EndTable();
  }
};

struct ChatGuildInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_chatInfo(flatbuffers::Offset<ChatCommonInfo> chatInfo) {
    fbb_.AddOffset(ChatGuildInfo::VT_CHATINFO, chatInfo);
  }
  void add_guildName(flatbuffers::Offset<flatbuffers::String> guildName) {
    fbb_.AddOffset(ChatGuildInfo::VT_GUILDNAME, guildName);
  }
  void add_guildId(int32_t guildId) {
    fbb_.AddElement<int32_t>(ChatGuildInfo::VT_GUILDID, guildId, 0);
  }
  void add_memGrade(int16_t memGrade) {
    fbb_.AddElement<int16_t>(ChatGuildInfo::VT_MEMGRADE, memGrade, 0);
  }
  void add_joinType(int16_t joinType) {
    fbb_.AddElement<int16_t>(ChatGuildInfo::VT_JOINTYPE, joinType, 0);
  }
  void add_isTop(bool isTop) {
    fbb_.AddElement<uint8_t>(ChatGuildInfo::VT_ISTOP, static_cast<uint8_t>(isTop), 0);
  }
  void add_isNewMem(bool isNewMem) {
    fbb_.AddElement<uint8_t>(ChatGuildInfo::VT_ISNEWMEM, static_cast<uint8_t>(isNewMem), 0);
  }
  explicit ChatGuildInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChatGuildInfoBuilder &operator=(const ChatGuildInfoBuilder &);
  flatbuffers::Offset<ChatGuildInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChatGuildInfo>(end);
    fbb_.Required(o, ChatGuildInfo::VT_CHATINFO);
    return o;
  }
};

inline flatbuffers::Offset<ChatGuildInfo> CreateChatGuildInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ChatCommonInfo> chatInfo = 0,
    flatbuffers::Offset<flatbuffers::String> guildName = 0,
    int32_t guildId = 0,
    int16_t memGrade = 0,
    int16_t joinType = 0,
    bool isTop = false,
    bool isNewMem = false) {
  ChatGuildInfoBuilder builder_(_fbb);
  builder_.add_guildId(guildId);
  builder_.add_guildName(guildName);
  builder_.add_chatInfo(chatInfo);
  builder_.add_joinType(joinType);
  builder_.add_memGrade(memGrade);
  builder_.add_isNewMem(isNewMem);
  builder_.add_isTop(isTop);
  return builder_.Finish();
}

inline flatbuffers::Offset<ChatGuildInfo> CreateChatGuildInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ChatCommonInfo> chatInfo = 0,
    const char *guildName = nullptr,
    int32_t guildId = 0,
    int16_t memGrade = 0,
    int16_t joinType = 0,
    bool isTop = false,
    bool isNewMem = false) {
  return LeanPacket::CreateChatGuildInfo(
      _fbb,
      chatInfo,
      guildName ? _fbb.CreateString(guildName) : 0,
      guildId,
      memGrade,
      joinType,
      isTop,
      isNewMem);
}

struct ChatWhisperInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CHATINFO = 4,
    VT_OTHER = 6
  };
  const ChatCommonInfo *chatInfo() const {
    return GetPointer<const ChatCommonInfo *>(VT_CHATINFO);
  }
  int64_t other() const {
    return GetField<int64_t>(VT_OTHER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CHATINFO) &&
           verifier.VerifyTable(chatInfo()) &&
           VerifyField<int64_t>(verifier, VT_OTHER) &&
           verifier.EndTable();
  }
};

struct ChatWhisperInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_chatInfo(flatbuffers::Offset<ChatCommonInfo> chatInfo) {
    fbb_.AddOffset(ChatWhisperInfo::VT_CHATINFO, chatInfo);
  }
  void add_other(int64_t other) {
    fbb_.AddElement<int64_t>(ChatWhisperInfo::VT_OTHER, other, 0);
  }
  explicit ChatWhisperInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChatWhisperInfoBuilder &operator=(const ChatWhisperInfoBuilder &);
  flatbuffers::Offset<ChatWhisperInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChatWhisperInfo>(end);
    fbb_.Required(o, ChatWhisperInfo::VT_CHATINFO);
    return o;
  }
};

inline flatbuffers::Offset<ChatWhisperInfo> CreateChatWhisperInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ChatCommonInfo> chatInfo = 0,
    int64_t other = 0) {
  ChatWhisperInfoBuilder builder_(_fbb);
  builder_.add_other(other);
  builder_.add_chatInfo(chatInfo);
  return builder_.Finish();
}

struct ChatErrorNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_PARAM = 6
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  int64_t param() const {
    return GetField<int64_t>(VT_PARAM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int64_t>(verifier, VT_PARAM) &&
           verifier.EndTable();
  }
};

struct ChatErrorNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(ChatErrorNotify::VT_ERRORCODE, errorCode, 0);
  }
  void add_param(int64_t param) {
    fbb_.AddElement<int64_t>(ChatErrorNotify::VT_PARAM, param, 0);
  }
  explicit ChatErrorNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChatErrorNotifyBuilder &operator=(const ChatErrorNotifyBuilder &);
  flatbuffers::Offset<ChatErrorNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChatErrorNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChatErrorNotify> CreateChatErrorNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    int64_t param = 0) {
  ChatErrorNotifyBuilder builder_(_fbb);
  builder_.add_param(param);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

struct ChatCommonNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CHATINFO = 4
  };
  const ChatCommonInfo *chatInfo() const {
    return GetPointer<const ChatCommonInfo *>(VT_CHATINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CHATINFO) &&
           verifier.VerifyTable(chatInfo()) &&
           verifier.EndTable();
  }
};

struct ChatCommonNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_chatInfo(flatbuffers::Offset<ChatCommonInfo> chatInfo) {
    fbb_.AddOffset(ChatCommonNotify::VT_CHATINFO, chatInfo);
  }
  explicit ChatCommonNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChatCommonNotifyBuilder &operator=(const ChatCommonNotifyBuilder &);
  flatbuffers::Offset<ChatCommonNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChatCommonNotify>(end);
    fbb_.Required(o, ChatCommonNotify::VT_CHATINFO);
    return o;
  }
};

inline flatbuffers::Offset<ChatCommonNotify> CreateChatCommonNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ChatCommonInfo> chatInfo = 0) {
  ChatCommonNotifyBuilder builder_(_fbb);
  builder_.add_chatInfo(chatInfo);
  return builder_.Finish();
}

struct ChatGuildNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CHATGUILDINFO = 4
  };
  const ChatGuildInfo *chatGuildInfo() const {
    return GetPointer<const ChatGuildInfo *>(VT_CHATGUILDINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CHATGUILDINFO) &&
           verifier.VerifyTable(chatGuildInfo()) &&
           verifier.EndTable();
  }
};

struct ChatGuildNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_chatGuildInfo(flatbuffers::Offset<ChatGuildInfo> chatGuildInfo) {
    fbb_.AddOffset(ChatGuildNotify::VT_CHATGUILDINFO, chatGuildInfo);
  }
  explicit ChatGuildNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChatGuildNotifyBuilder &operator=(const ChatGuildNotifyBuilder &);
  flatbuffers::Offset<ChatGuildNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChatGuildNotify>(end);
    fbb_.Required(o, ChatGuildNotify::VT_CHATGUILDINFO);
    return o;
  }
};

inline flatbuffers::Offset<ChatGuildNotify> CreateChatGuildNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ChatGuildInfo> chatGuildInfo = 0) {
  ChatGuildNotifyBuilder builder_(_fbb);
  builder_.add_chatGuildInfo(chatGuildInfo);
  return builder_.Finish();
}

struct ChatWhisperNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_CHATWHISPERINFO = 6,
    VT_OTHERINFO = 8
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  const ChatWhisperInfo *chatWhisperInfo() const {
    return GetPointer<const ChatWhisperInfo *>(VT_CHATWHISPERINFO);
  }
  const ChatPcInfo *otherInfo() const {
    return GetPointer<const ChatPcInfo *>(VT_OTHERINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyOffset(verifier, VT_CHATWHISPERINFO) &&
           verifier.VerifyTable(chatWhisperInfo()) &&
           VerifyOffsetRequired(verifier, VT_OTHERINFO) &&
           verifier.VerifyTable(otherInfo()) &&
           verifier.EndTable();
  }
};

struct ChatWhisperNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(ChatWhisperNotify::VT_ERRORCODE, errorCode, 0);
  }
  void add_chatWhisperInfo(flatbuffers::Offset<ChatWhisperInfo> chatWhisperInfo) {
    fbb_.AddOffset(ChatWhisperNotify::VT_CHATWHISPERINFO, chatWhisperInfo);
  }
  void add_otherInfo(flatbuffers::Offset<ChatPcInfo> otherInfo) {
    fbb_.AddOffset(ChatWhisperNotify::VT_OTHERINFO, otherInfo);
  }
  explicit ChatWhisperNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChatWhisperNotifyBuilder &operator=(const ChatWhisperNotifyBuilder &);
  flatbuffers::Offset<ChatWhisperNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChatWhisperNotify>(end);
    fbb_.Required(o, ChatWhisperNotify::VT_OTHERINFO);
    return o;
  }
};

inline flatbuffers::Offset<ChatWhisperNotify> CreateChatWhisperNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    flatbuffers::Offset<ChatWhisperInfo> chatWhisperInfo = 0,
    flatbuffers::Offset<ChatPcInfo> otherInfo = 0) {
  ChatWhisperNotifyBuilder builder_(_fbb);
  builder_.add_otherInfo(otherInfo);
  builder_.add_chatWhisperInfo(chatWhisperInfo);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

struct ChatGuildMsgListRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_CHATNO = 6
  };
  int16_t type() const {
    return GetField<int16_t>(VT_TYPE, 0);
  }
  int32_t chatNo() const {
    return GetField<int32_t>(VT_CHATNO, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_CHATNO) &&
           verifier.EndTable();
  }
};

struct ChatGuildMsgListRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int16_t type) {
    fbb_.AddElement<int16_t>(ChatGuildMsgListRequest::VT_TYPE, type, 0);
  }
  void add_chatNo(int32_t chatNo) {
    fbb_.AddElement<int32_t>(ChatGuildMsgListRequest::VT_CHATNO, chatNo, 0);
  }
  explicit ChatGuildMsgListRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChatGuildMsgListRequestBuilder &operator=(const ChatGuildMsgListRequestBuilder &);
  flatbuffers::Offset<ChatGuildMsgListRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChatGuildMsgListRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChatGuildMsgListRequest> CreateChatGuildMsgListRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t type = 0,
    int32_t chatNo = 0) {
  ChatGuildMsgListRequestBuilder builder_(_fbb);
  builder_.add_chatNo(chatNo);
  builder_.add_type(type);
  return builder_.Finish();
}

struct ChatGuildMsgListResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_MESSAGES = 6,
    VT_CHATNO = 8
  };
  int16_t type() const {
    return GetField<int16_t>(VT_TYPE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ChatGuildInfo>> *messages() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ChatGuildInfo>> *>(VT_MESSAGES);
  }
  int32_t chatNo() const {
    return GetField<int32_t>(VT_CHATNO, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGES) &&
           verifier.VerifyVector(messages()) &&
           verifier.VerifyVectorOfTables(messages()) &&
           VerifyField<int32_t>(verifier, VT_CHATNO) &&
           verifier.EndTable();
  }
};

struct ChatGuildMsgListResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int16_t type) {
    fbb_.AddElement<int16_t>(ChatGuildMsgListResponse::VT_TYPE, type, 0);
  }
  void add_messages(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ChatGuildInfo>>> messages) {
    fbb_.AddOffset(ChatGuildMsgListResponse::VT_MESSAGES, messages);
  }
  void add_chatNo(int32_t chatNo) {
    fbb_.AddElement<int32_t>(ChatGuildMsgListResponse::VT_CHATNO, chatNo, 0);
  }
  explicit ChatGuildMsgListResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChatGuildMsgListResponseBuilder &operator=(const ChatGuildMsgListResponseBuilder &);
  flatbuffers::Offset<ChatGuildMsgListResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChatGuildMsgListResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChatGuildMsgListResponse> CreateChatGuildMsgListResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ChatGuildInfo>>> messages = 0,
    int32_t chatNo = 0) {
  ChatGuildMsgListResponseBuilder builder_(_fbb);
  builder_.add_chatNo(chatNo);
  builder_.add_messages(messages);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ChatGuildMsgListResponse> CreateChatGuildMsgListResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t type = 0,
    const std::vector<flatbuffers::Offset<ChatGuildInfo>> *messages = nullptr,
    int32_t chatNo = 0) {
  return LeanPacket::CreateChatGuildMsgListResponse(
      _fbb,
      type,
      messages ? _fbb.CreateVector<flatbuffers::Offset<ChatGuildInfo>>(*messages) : 0,
      chatNo);
}

struct ChatWhisperMsgListRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RECEIVERDBID = 4,
    VT_CHATNO = 6
  };
  int64_t receiverDbId() const {
    return GetField<int64_t>(VT_RECEIVERDBID, 0);
  }
  int32_t chatNo() const {
    return GetField<int32_t>(VT_CHATNO, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_RECEIVERDBID) &&
           VerifyField<int32_t>(verifier, VT_CHATNO) &&
           verifier.EndTable();
  }
};

struct ChatWhisperMsgListRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_receiverDbId(int64_t receiverDbId) {
    fbb_.AddElement<int64_t>(ChatWhisperMsgListRequest::VT_RECEIVERDBID, receiverDbId, 0);
  }
  void add_chatNo(int32_t chatNo) {
    fbb_.AddElement<int32_t>(ChatWhisperMsgListRequest::VT_CHATNO, chatNo, 0);
  }
  explicit ChatWhisperMsgListRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChatWhisperMsgListRequestBuilder &operator=(const ChatWhisperMsgListRequestBuilder &);
  flatbuffers::Offset<ChatWhisperMsgListRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChatWhisperMsgListRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChatWhisperMsgListRequest> CreateChatWhisperMsgListRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t receiverDbId = 0,
    int32_t chatNo = 0) {
  ChatWhisperMsgListRequestBuilder builder_(_fbb);
  builder_.add_receiverDbId(receiverDbId);
  builder_.add_chatNo(chatNo);
  return builder_.Finish();
}

struct ChatWhisperMsgListResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MESSAGES = 4,
    VT_OTHERDBID = 6,
    VT_CHATNO = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<ChatWhisperInfo>> *messages() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ChatWhisperInfo>> *>(VT_MESSAGES);
  }
  int64_t otherDbId() const {
    return GetField<int64_t>(VT_OTHERDBID, 0);
  }
  int32_t chatNo() const {
    return GetField<int32_t>(VT_CHATNO, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESSAGES) &&
           verifier.VerifyVector(messages()) &&
           verifier.VerifyVectorOfTables(messages()) &&
           VerifyField<int64_t>(verifier, VT_OTHERDBID) &&
           VerifyField<int32_t>(verifier, VT_CHATNO) &&
           verifier.EndTable();
  }
};

struct ChatWhisperMsgListResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_messages(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ChatWhisperInfo>>> messages) {
    fbb_.AddOffset(ChatWhisperMsgListResponse::VT_MESSAGES, messages);
  }
  void add_otherDbId(int64_t otherDbId) {
    fbb_.AddElement<int64_t>(ChatWhisperMsgListResponse::VT_OTHERDBID, otherDbId, 0);
  }
  void add_chatNo(int32_t chatNo) {
    fbb_.AddElement<int32_t>(ChatWhisperMsgListResponse::VT_CHATNO, chatNo, 0);
  }
  explicit ChatWhisperMsgListResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChatWhisperMsgListResponseBuilder &operator=(const ChatWhisperMsgListResponseBuilder &);
  flatbuffers::Offset<ChatWhisperMsgListResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChatWhisperMsgListResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChatWhisperMsgListResponse> CreateChatWhisperMsgListResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ChatWhisperInfo>>> messages = 0,
    int64_t otherDbId = 0,
    int32_t chatNo = 0) {
  ChatWhisperMsgListResponseBuilder builder_(_fbb);
  builder_.add_otherDbId(otherDbId);
  builder_.add_chatNo(chatNo);
  builder_.add_messages(messages);
  return builder_.Finish();
}

inline flatbuffers::Offset<ChatWhisperMsgListResponse> CreateChatWhisperMsgListResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<ChatWhisperInfo>> *messages = nullptr,
    int64_t otherDbId = 0,
    int32_t chatNo = 0) {
  return LeanPacket::CreateChatWhisperMsgListResponse(
      _fbb,
      messages ? _fbb.CreateVector<flatbuffers::Offset<ChatWhisperInfo>>(*messages) : 0,
      otherDbId,
      chatNo);
}

struct ChatLastWhisperMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CHATWHISPERINFO = 4,
    VT_OTHER = 6,
    VT_ISNEW = 8
  };
  const ChatWhisperInfo *chatWhisperInfo() const {
    return GetPointer<const ChatWhisperInfo *>(VT_CHATWHISPERINFO);
  }
  const ChatPcInfo *other() const {
    return GetPointer<const ChatPcInfo *>(VT_OTHER);
  }
  bool isNew() const {
    return GetField<uint8_t>(VT_ISNEW, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CHATWHISPERINFO) &&
           verifier.VerifyTable(chatWhisperInfo()) &&
           VerifyOffsetRequired(verifier, VT_OTHER) &&
           verifier.VerifyTable(other()) &&
           VerifyField<uint8_t>(verifier, VT_ISNEW) &&
           verifier.EndTable();
  }
};

struct ChatLastWhisperMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_chatWhisperInfo(flatbuffers::Offset<ChatWhisperInfo> chatWhisperInfo) {
    fbb_.AddOffset(ChatLastWhisperMessage::VT_CHATWHISPERINFO, chatWhisperInfo);
  }
  void add_other(flatbuffers::Offset<ChatPcInfo> other) {
    fbb_.AddOffset(ChatLastWhisperMessage::VT_OTHER, other);
  }
  void add_isNew(bool isNew) {
    fbb_.AddElement<uint8_t>(ChatLastWhisperMessage::VT_ISNEW, static_cast<uint8_t>(isNew), 0);
  }
  explicit ChatLastWhisperMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChatLastWhisperMessageBuilder &operator=(const ChatLastWhisperMessageBuilder &);
  flatbuffers::Offset<ChatLastWhisperMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChatLastWhisperMessage>(end);
    fbb_.Required(o, ChatLastWhisperMessage::VT_CHATWHISPERINFO);
    fbb_.Required(o, ChatLastWhisperMessage::VT_OTHER);
    return o;
  }
};

inline flatbuffers::Offset<ChatLastWhisperMessage> CreateChatLastWhisperMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ChatWhisperInfo> chatWhisperInfo = 0,
    flatbuffers::Offset<ChatPcInfo> other = 0,
    bool isNew = false) {
  ChatLastWhisperMessageBuilder builder_(_fbb);
  builder_.add_other(other);
  builder_.add_chatWhisperInfo(chatWhisperInfo);
  builder_.add_isNew(isNew);
  return builder_.Finish();
}

struct ChatNewMessageNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CHATNEWMESSAGES = 4,
    VT_CHATGUILDMESSAGES = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<ChatLastWhisperMessage>> *ChatNewMessages() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ChatLastWhisperMessage>> *>(VT_CHATNEWMESSAGES);
  }
  const flatbuffers::Vector<int32_t> *ChatGuildMessages() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CHATGUILDMESSAGES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHATNEWMESSAGES) &&
           verifier.VerifyVector(ChatNewMessages()) &&
           verifier.VerifyVectorOfTables(ChatNewMessages()) &&
           VerifyOffset(verifier, VT_CHATGUILDMESSAGES) &&
           verifier.VerifyVector(ChatGuildMessages()) &&
           verifier.EndTable();
  }
};

struct ChatNewMessageNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ChatNewMessages(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ChatLastWhisperMessage>>> ChatNewMessages) {
    fbb_.AddOffset(ChatNewMessageNotify::VT_CHATNEWMESSAGES, ChatNewMessages);
  }
  void add_ChatGuildMessages(flatbuffers::Offset<flatbuffers::Vector<int32_t>> ChatGuildMessages) {
    fbb_.AddOffset(ChatNewMessageNotify::VT_CHATGUILDMESSAGES, ChatGuildMessages);
  }
  explicit ChatNewMessageNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChatNewMessageNotifyBuilder &operator=(const ChatNewMessageNotifyBuilder &);
  flatbuffers::Offset<ChatNewMessageNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChatNewMessageNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChatNewMessageNotify> CreateChatNewMessageNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ChatLastWhisperMessage>>> ChatNewMessages = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> ChatGuildMessages = 0) {
  ChatNewMessageNotifyBuilder builder_(_fbb);
  builder_.add_ChatGuildMessages(ChatGuildMessages);
  builder_.add_ChatNewMessages(ChatNewMessages);
  return builder_.Finish();
}

inline flatbuffers::Offset<ChatNewMessageNotify> CreateChatNewMessageNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<ChatLastWhisperMessage>> *ChatNewMessages = nullptr,
    const std::vector<int32_t> *ChatGuildMessages = nullptr) {
  return LeanPacket::CreateChatNewMessageNotify(
      _fbb,
      ChatNewMessages ? _fbb.CreateVector<flatbuffers::Offset<ChatLastWhisperMessage>>(*ChatNewMessages) : 0,
      ChatGuildMessages ? _fbb.CreateVector<int32_t>(*ChatGuildMessages) : 0);
}

/// NEW_WHISPER_MESSAGE_NOTIFY
struct NewWhisperMessageNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CHATWHISPERINFO = 4,
    VT_OTHER = 6,
    VT_ISNEW = 8
  };
  const ChatWhisperInfo *chatWhisperInfo() const {
    return GetPointer<const ChatWhisperInfo *>(VT_CHATWHISPERINFO);
  }
  const ChatPcInfo *other() const {
    return GetPointer<const ChatPcInfo *>(VT_OTHER);
  }
  bool isNew() const {
    return GetField<uint8_t>(VT_ISNEW, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CHATWHISPERINFO) &&
           verifier.VerifyTable(chatWhisperInfo()) &&
           VerifyOffsetRequired(verifier, VT_OTHER) &&
           verifier.VerifyTable(other()) &&
           VerifyField<uint8_t>(verifier, VT_ISNEW) &&
           verifier.EndTable();
  }
};

struct NewWhisperMessageNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_chatWhisperInfo(flatbuffers::Offset<ChatWhisperInfo> chatWhisperInfo) {
    fbb_.AddOffset(NewWhisperMessageNotify::VT_CHATWHISPERINFO, chatWhisperInfo);
  }
  void add_other(flatbuffers::Offset<ChatPcInfo> other) {
    fbb_.AddOffset(NewWhisperMessageNotify::VT_OTHER, other);
  }
  void add_isNew(bool isNew) {
    fbb_.AddElement<uint8_t>(NewWhisperMessageNotify::VT_ISNEW, static_cast<uint8_t>(isNew), 0);
  }
  explicit NewWhisperMessageNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NewWhisperMessageNotifyBuilder &operator=(const NewWhisperMessageNotifyBuilder &);
  flatbuffers::Offset<NewWhisperMessageNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NewWhisperMessageNotify>(end);
    fbb_.Required(o, NewWhisperMessageNotify::VT_CHATWHISPERINFO);
    fbb_.Required(o, NewWhisperMessageNotify::VT_OTHER);
    return o;
  }
};

inline flatbuffers::Offset<NewWhisperMessageNotify> CreateNewWhisperMessageNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ChatWhisperInfo> chatWhisperInfo = 0,
    flatbuffers::Offset<ChatPcInfo> other = 0,
    bool isNew = false) {
  NewWhisperMessageNotifyBuilder builder_(_fbb);
  builder_.add_other(other);
  builder_.add_chatWhisperInfo(chatWhisperInfo);
  builder_.add_isNew(isNew);
  return builder_.Finish();
}

/// NEW_GUILD_MESSAGE_NOTIFY
struct NewGuildMessageNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GUILDCHATTYPE = 4
  };
  int16_t guildChatType() const {
    return GetField<int16_t>(VT_GUILDCHATTYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_GUILDCHATTYPE) &&
           verifier.EndTable();
  }
};

struct NewGuildMessageNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_guildChatType(int16_t guildChatType) {
    fbb_.AddElement<int16_t>(NewGuildMessageNotify::VT_GUILDCHATTYPE, guildChatType, 0);
  }
  explicit NewGuildMessageNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NewGuildMessageNotifyBuilder &operator=(const NewGuildMessageNotifyBuilder &);
  flatbuffers::Offset<NewGuildMessageNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NewGuildMessageNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<NewGuildMessageNotify> CreateNewGuildMessageNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t guildChatType = 0) {
  NewGuildMessageNotifyBuilder builder_(_fbb);
  builder_.add_guildChatType(guildChatType);
  return builder_.Finish();
}

struct ChatCheckReceiverRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RECEIVER = 4
  };
  const flatbuffers::String *receiver() const {
    return GetPointer<const flatbuffers::String *>(VT_RECEIVER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_RECEIVER) &&
           verifier.VerifyString(receiver()) &&
           verifier.EndTable();
  }
};

struct ChatCheckReceiverRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_receiver(flatbuffers::Offset<flatbuffers::String> receiver) {
    fbb_.AddOffset(ChatCheckReceiverRequest::VT_RECEIVER, receiver);
  }
  explicit ChatCheckReceiverRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChatCheckReceiverRequestBuilder &operator=(const ChatCheckReceiverRequestBuilder &);
  flatbuffers::Offset<ChatCheckReceiverRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChatCheckReceiverRequest>(end);
    fbb_.Required(o, ChatCheckReceiverRequest::VT_RECEIVER);
    return o;
  }
};

inline flatbuffers::Offset<ChatCheckReceiverRequest> CreateChatCheckReceiverRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> receiver = 0) {
  ChatCheckReceiverRequestBuilder builder_(_fbb);
  builder_.add_receiver(receiver);
  return builder_.Finish();
}

inline flatbuffers::Offset<ChatCheckReceiverRequest> CreateChatCheckReceiverRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *receiver = nullptr) {
  return LeanPacket::CreateChatCheckReceiverRequest(
      _fbb,
      receiver ? _fbb.CreateString(receiver) : 0);
}

struct ChatCheckReceiverResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_RECEIVERINFO = 6
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  const ChatPcInfo *receiverInfo() const {
    return GetPointer<const ChatPcInfo *>(VT_RECEIVERINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyOffset(verifier, VT_RECEIVERINFO) &&
           verifier.VerifyTable(receiverInfo()) &&
           verifier.EndTable();
  }
};

struct ChatCheckReceiverResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(ChatCheckReceiverResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_receiverInfo(flatbuffers::Offset<ChatPcInfo> receiverInfo) {
    fbb_.AddOffset(ChatCheckReceiverResponse::VT_RECEIVERINFO, receiverInfo);
  }
  explicit ChatCheckReceiverResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChatCheckReceiverResponseBuilder &operator=(const ChatCheckReceiverResponseBuilder &);
  flatbuffers::Offset<ChatCheckReceiverResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChatCheckReceiverResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChatCheckReceiverResponse> CreateChatCheckReceiverResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    flatbuffers::Offset<ChatPcInfo> receiverInfo = 0) {
  ChatCheckReceiverResponseBuilder builder_(_fbb);
  builder_.add_receiverInfo(receiverInfo);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

struct ChatReadWhisperNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OTHER = 4
  };
  int64_t other() const {
    return GetField<int64_t>(VT_OTHER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OTHER) &&
           verifier.EndTable();
  }
};

struct ChatReadWhisperNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_other(int64_t other) {
    fbb_.AddElement<int64_t>(ChatReadWhisperNotify::VT_OTHER, other, 0);
  }
  explicit ChatReadWhisperNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChatReadWhisperNotifyBuilder &operator=(const ChatReadWhisperNotifyBuilder &);
  flatbuffers::Offset<ChatReadWhisperNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChatReadWhisperNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChatReadWhisperNotify> CreateChatReadWhisperNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t other = 0) {
  ChatReadWhisperNotifyBuilder builder_(_fbb);
  builder_.add_other(other);
  return builder_.Finish();
}

struct ChatReadGuildNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4
  };
  int16_t type() const {
    return GetField<int16_t>(VT_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct ChatReadGuildNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int16_t type) {
    fbb_.AddElement<int16_t>(ChatReadGuildNotify::VT_TYPE, type, 0);
  }
  explicit ChatReadGuildNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChatReadGuildNotifyBuilder &operator=(const ChatReadGuildNotifyBuilder &);
  flatbuffers::Offset<ChatReadGuildNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChatReadGuildNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChatReadGuildNotify> CreateChatReadGuildNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t type = 0) {
  ChatReadGuildNotifyBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

struct ChatDeleteRoom FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OTHER = 4
  };
  int64_t other() const {
    return GetField<int64_t>(VT_OTHER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OTHER) &&
           verifier.EndTable();
  }
};

struct ChatDeleteRoomBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_other(int64_t other) {
    fbb_.AddElement<int64_t>(ChatDeleteRoom::VT_OTHER, other, 0);
  }
  explicit ChatDeleteRoomBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChatDeleteRoomBuilder &operator=(const ChatDeleteRoomBuilder &);
  flatbuffers::Offset<ChatDeleteRoom> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChatDeleteRoom>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChatDeleteRoom> CreateChatDeleteRoom(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t other = 0) {
  ChatDeleteRoomBuilder builder_(_fbb);
  builder_.add_other(other);
  return builder_.Finish();
}

struct ChatAdmin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SENDER = 4,
    VT_TYPE = 6,
    VT_MESSAGE = 8
  };
  int64_t sender() const {
    return GetField<int64_t>(VT_SENDER, 0);
  }
  int16_t type() const {
    return GetField<int16_t>(VT_TYPE, 0);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SENDER) &&
           VerifyField<int16_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct ChatAdminBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sender(int64_t sender) {
    fbb_.AddElement<int64_t>(ChatAdmin::VT_SENDER, sender, 0);
  }
  void add_type(int16_t type) {
    fbb_.AddElement<int16_t>(ChatAdmin::VT_TYPE, type, 0);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(ChatAdmin::VT_MESSAGE, message);
  }
  explicit ChatAdminBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChatAdminBuilder &operator=(const ChatAdminBuilder &);
  flatbuffers::Offset<ChatAdmin> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChatAdmin>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChatAdmin> CreateChatAdmin(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t sender = 0,
    int16_t type = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  ChatAdminBuilder builder_(_fbb);
  builder_.add_sender(sender);
  builder_.add_message(message);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ChatAdmin> CreateChatAdminDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t sender = 0,
    int16_t type = 0,
    const char *message = nullptr) {
  return LeanPacket::CreateChatAdmin(
      _fbb,
      sender,
      type,
      message ? _fbb.CreateString(message) : 0);
}

struct ChatAdminWhisper FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SENDER = 4,
    VT_RECEIVERDBID = 6,
    VT_MESSAGE = 8
  };
  int64_t sender() const {
    return GetField<int64_t>(VT_SENDER, 0);
  }
  int64_t receiverDbId() const {
    return GetField<int64_t>(VT_RECEIVERDBID, 0);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SENDER) &&
           VerifyField<int64_t>(verifier, VT_RECEIVERDBID) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct ChatAdminWhisperBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sender(int64_t sender) {
    fbb_.AddElement<int64_t>(ChatAdminWhisper::VT_SENDER, sender, 0);
  }
  void add_receiverDbId(int64_t receiverDbId) {
    fbb_.AddElement<int64_t>(ChatAdminWhisper::VT_RECEIVERDBID, receiverDbId, 0);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(ChatAdminWhisper::VT_MESSAGE, message);
  }
  explicit ChatAdminWhisperBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChatAdminWhisperBuilder &operator=(const ChatAdminWhisperBuilder &);
  flatbuffers::Offset<ChatAdminWhisper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChatAdminWhisper>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChatAdminWhisper> CreateChatAdminWhisper(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t sender = 0,
    int64_t receiverDbId = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  ChatAdminWhisperBuilder builder_(_fbb);
  builder_.add_receiverDbId(receiverDbId);
  builder_.add_sender(sender);
  builder_.add_message(message);
  return builder_.Finish();
}

inline flatbuffers::Offset<ChatAdminWhisper> CreateChatAdminWhisperDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t sender = 0,
    int64_t receiverDbId = 0,
    const char *message = nullptr) {
  return LeanPacket::CreateChatAdminWhisper(
      _fbb,
      sender,
      receiverDbId,
      message ? _fbb.CreateString(message) : 0);
}

/// - 메일
struct SystemTime FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_YEAR = 4,
    VT_MONTH = 6,
    VT_DAY = 8,
    VT_HOUR = 10,
    VT_MIN = 12,
    VT_SEC = 14
  };
  uint16_t year() const {
    return GetField<uint16_t>(VT_YEAR, 0);
  }
  uint16_t month() const {
    return GetField<uint16_t>(VT_MONTH, 0);
  }
  uint16_t day() const {
    return GetField<uint16_t>(VT_DAY, 0);
  }
  uint16_t hour() const {
    return GetField<uint16_t>(VT_HOUR, 0);
  }
  uint16_t min() const {
    return GetField<uint16_t>(VT_MIN, 0);
  }
  uint16_t sec() const {
    return GetField<uint16_t>(VT_SEC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_YEAR) &&
           VerifyField<uint16_t>(verifier, VT_MONTH) &&
           VerifyField<uint16_t>(verifier, VT_DAY) &&
           VerifyField<uint16_t>(verifier, VT_HOUR) &&
           VerifyField<uint16_t>(verifier, VT_MIN) &&
           VerifyField<uint16_t>(verifier, VT_SEC) &&
           verifier.EndTable();
  }
};

struct SystemTimeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_year(uint16_t year) {
    fbb_.AddElement<uint16_t>(SystemTime::VT_YEAR, year, 0);
  }
  void add_month(uint16_t month) {
    fbb_.AddElement<uint16_t>(SystemTime::VT_MONTH, month, 0);
  }
  void add_day(uint16_t day) {
    fbb_.AddElement<uint16_t>(SystemTime::VT_DAY, day, 0);
  }
  void add_hour(uint16_t hour) {
    fbb_.AddElement<uint16_t>(SystemTime::VT_HOUR, hour, 0);
  }
  void add_min(uint16_t min) {
    fbb_.AddElement<uint16_t>(SystemTime::VT_MIN, min, 0);
  }
  void add_sec(uint16_t sec) {
    fbb_.AddElement<uint16_t>(SystemTime::VT_SEC, sec, 0);
  }
  explicit SystemTimeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SystemTimeBuilder &operator=(const SystemTimeBuilder &);
  flatbuffers::Offset<SystemTime> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SystemTime>(end);
    return o;
  }
};

inline flatbuffers::Offset<SystemTime> CreateSystemTime(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t year = 0,
    uint16_t month = 0,
    uint16_t day = 0,
    uint16_t hour = 0,
    uint16_t min = 0,
    uint16_t sec = 0) {
  SystemTimeBuilder builder_(_fbb);
  builder_.add_sec(sec);
  builder_.add_min(min);
  builder_.add_hour(hour);
  builder_.add_day(day);
  builder_.add_month(month);
  builder_.add_year(year);
  return builder_.Finish();
}

struct MailItemInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMID = 4,
    VT_COUNT = 6,
    VT_GRADE = 8
  };
  int32_t itemId() const {
    return GetField<int32_t>(VT_ITEMID, 0);
  }
  int32_t count() const {
    return GetField<int32_t>(VT_COUNT, 0);
  }
  int16_t grade() const {
    return GetField<int16_t>(VT_GRADE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ITEMID) &&
           VerifyField<int32_t>(verifier, VT_COUNT) &&
           VerifyField<int16_t>(verifier, VT_GRADE) &&
           verifier.EndTable();
  }
};

struct MailItemInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemId(int32_t itemId) {
    fbb_.AddElement<int32_t>(MailItemInfo::VT_ITEMID, itemId, 0);
  }
  void add_count(int32_t count) {
    fbb_.AddElement<int32_t>(MailItemInfo::VT_COUNT, count, 0);
  }
  void add_grade(int16_t grade) {
    fbb_.AddElement<int16_t>(MailItemInfo::VT_GRADE, grade, 0);
  }
  explicit MailItemInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MailItemInfoBuilder &operator=(const MailItemInfoBuilder &);
  flatbuffers::Offset<MailItemInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MailItemInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<MailItemInfo> CreateMailItemInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t itemId = 0,
    int32_t count = 0,
    int16_t grade = 0) {
  MailItemInfoBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_itemId(itemId);
  builder_.add_grade(grade);
  return builder_.Finish();
}

struct MailContentInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CATEGORY = 4,
    VT_SENDER = 6,
    VT_SUBINDEX = 8,
    VT_SUBSTRING = 10
  };
  int16_t category() const {
    return GetField<int16_t>(VT_CATEGORY, 0);
  }
  int32_t sender() const {
    return GetField<int32_t>(VT_SENDER, 0);
  }
  int32_t subIndex() const {
    return GetField<int32_t>(VT_SUBINDEX, 0);
  }
  const flatbuffers::String *subString() const {
    return GetPointer<const flatbuffers::String *>(VT_SUBSTRING);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_CATEGORY) &&
           VerifyField<int32_t>(verifier, VT_SENDER) &&
           VerifyField<int32_t>(verifier, VT_SUBINDEX) &&
           VerifyOffsetRequired(verifier, VT_SUBSTRING) &&
           verifier.VerifyString(subString()) &&
           verifier.EndTable();
  }
};

struct MailContentInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_category(int16_t category) {
    fbb_.AddElement<int16_t>(MailContentInfo::VT_CATEGORY, category, 0);
  }
  void add_sender(int32_t sender) {
    fbb_.AddElement<int32_t>(MailContentInfo::VT_SENDER, sender, 0);
  }
  void add_subIndex(int32_t subIndex) {
    fbb_.AddElement<int32_t>(MailContentInfo::VT_SUBINDEX, subIndex, 0);
  }
  void add_subString(flatbuffers::Offset<flatbuffers::String> subString) {
    fbb_.AddOffset(MailContentInfo::VT_SUBSTRING, subString);
  }
  explicit MailContentInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MailContentInfoBuilder &operator=(const MailContentInfoBuilder &);
  flatbuffers::Offset<MailContentInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MailContentInfo>(end);
    fbb_.Required(o, MailContentInfo::VT_SUBSTRING);
    return o;
  }
};

inline flatbuffers::Offset<MailContentInfo> CreateMailContentInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t category = 0,
    int32_t sender = 0,
    int32_t subIndex = 0,
    flatbuffers::Offset<flatbuffers::String> subString = 0) {
  MailContentInfoBuilder builder_(_fbb);
  builder_.add_subString(subString);
  builder_.add_subIndex(subIndex);
  builder_.add_sender(sender);
  builder_.add_category(category);
  return builder_.Finish();
}

inline flatbuffers::Offset<MailContentInfo> CreateMailContentInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t category = 0,
    int32_t sender = 0,
    int32_t subIndex = 0,
    const char *subString = nullptr) {
  return LeanPacket::CreateMailContentInfo(
      _fbb,
      category,
      sender,
      subIndex,
      subString ? _fbb.CreateString(subString) : 0);
}

struct MailSystemInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CATEGORY = 4,
    VT_SENDER = 6,
    VT_CONTENT = 8
  };
  const flatbuffers::String *category() const {
    return GetPointer<const flatbuffers::String *>(VT_CATEGORY);
  }
  const flatbuffers::String *sender() const {
    return GetPointer<const flatbuffers::String *>(VT_SENDER);
  }
  const flatbuffers::String *content() const {
    return GetPointer<const flatbuffers::String *>(VT_CONTENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CATEGORY) &&
           verifier.VerifyString(category()) &&
           VerifyOffsetRequired(verifier, VT_SENDER) &&
           verifier.VerifyString(sender()) &&
           VerifyOffsetRequired(verifier, VT_CONTENT) &&
           verifier.VerifyString(content()) &&
           verifier.EndTable();
  }
};

struct MailSystemInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_category(flatbuffers::Offset<flatbuffers::String> category) {
    fbb_.AddOffset(MailSystemInfo::VT_CATEGORY, category);
  }
  void add_sender(flatbuffers::Offset<flatbuffers::String> sender) {
    fbb_.AddOffset(MailSystemInfo::VT_SENDER, sender);
  }
  void add_content(flatbuffers::Offset<flatbuffers::String> content) {
    fbb_.AddOffset(MailSystemInfo::VT_CONTENT, content);
  }
  explicit MailSystemInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MailSystemInfoBuilder &operator=(const MailSystemInfoBuilder &);
  flatbuffers::Offset<MailSystemInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MailSystemInfo>(end);
    fbb_.Required(o, MailSystemInfo::VT_CATEGORY);
    fbb_.Required(o, MailSystemInfo::VT_SENDER);
    fbb_.Required(o, MailSystemInfo::VT_CONTENT);
    return o;
  }
};

inline flatbuffers::Offset<MailSystemInfo> CreateMailSystemInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> category = 0,
    flatbuffers::Offset<flatbuffers::String> sender = 0,
    flatbuffers::Offset<flatbuffers::String> content = 0) {
  MailSystemInfoBuilder builder_(_fbb);
  builder_.add_content(content);
  builder_.add_sender(sender);
  builder_.add_category(category);
  return builder_.Finish();
}

inline flatbuffers::Offset<MailSystemInfo> CreateMailSystemInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *category = nullptr,
    const char *sender = nullptr,
    const char *content = nullptr) {
  return LeanPacket::CreateMailSystemInfo(
      _fbb,
      category ? _fbb.CreateString(category) : 0,
      sender ? _fbb.CreateString(sender) : 0,
      content ? _fbb.CreateString(content) : 0);
}

struct MailTimeInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RECEIVEDTIME = 4,
    VT_REMAINTIME = 6
  };
  const SystemTime *receivedTime() const {
    return GetPointer<const SystemTime *>(VT_RECEIVEDTIME);
  }
  int32_t remainTime() const {
    return GetField<int32_t>(VT_REMAINTIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_RECEIVEDTIME) &&
           verifier.VerifyTable(receivedTime()) &&
           VerifyField<int32_t>(verifier, VT_REMAINTIME) &&
           verifier.EndTable();
  }
};

struct MailTimeInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_receivedTime(flatbuffers::Offset<SystemTime> receivedTime) {
    fbb_.AddOffset(MailTimeInfo::VT_RECEIVEDTIME, receivedTime);
  }
  void add_remainTime(int32_t remainTime) {
    fbb_.AddElement<int32_t>(MailTimeInfo::VT_REMAINTIME, remainTime, 0);
  }
  explicit MailTimeInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MailTimeInfoBuilder &operator=(const MailTimeInfoBuilder &);
  flatbuffers::Offset<MailTimeInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MailTimeInfo>(end);
    fbb_.Required(o, MailTimeInfo::VT_RECEIVEDTIME);
    return o;
  }
};

inline flatbuffers::Offset<MailTimeInfo> CreateMailTimeInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<SystemTime> receivedTime = 0,
    int32_t remainTime = 0) {
  MailTimeInfoBuilder builder_(_fbb);
  builder_.add_remainTime(remainTime);
  builder_.add_receivedTime(receivedTime);
  return builder_.Finish();
}

struct BundleRewardInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMS = 4,
    VT_COSTINFOS = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<MailResultItem>> *items() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MailResultItem>> *>(VT_ITEMS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<CostInfo>> *costInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CostInfo>> *>(VT_COSTINFOS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.VerifyVectorOfTables(items()) &&
           VerifyOffsetRequired(verifier, VT_COSTINFOS) &&
           verifier.VerifyVector(costInfos()) &&
           verifier.VerifyVectorOfTables(costInfos()) &&
           verifier.EndTable();
  }
};

struct BundleRewardInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MailResultItem>>> items) {
    fbb_.AddOffset(BundleRewardInfo::VT_ITEMS, items);
  }
  void add_costInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CostInfo>>> costInfos) {
    fbb_.AddOffset(BundleRewardInfo::VT_COSTINFOS, costInfos);
  }
  explicit BundleRewardInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BundleRewardInfoBuilder &operator=(const BundleRewardInfoBuilder &);
  flatbuffers::Offset<BundleRewardInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BundleRewardInfo>(end);
    fbb_.Required(o, BundleRewardInfo::VT_ITEMS);
    fbb_.Required(o, BundleRewardInfo::VT_COSTINFOS);
    return o;
  }
};

inline flatbuffers::Offset<BundleRewardInfo> CreateBundleRewardInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MailResultItem>>> items = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CostInfo>>> costInfos = 0) {
  BundleRewardInfoBuilder builder_(_fbb);
  builder_.add_costInfos(costInfos);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<BundleRewardInfo> CreateBundleRewardInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<MailResultItem>> *items = nullptr,
    const std::vector<flatbuffers::Offset<CostInfo>> *costInfos = nullptr) {
  return LeanPacket::CreateBundleRewardInfo(
      _fbb,
      items ? _fbb.CreateVector<flatbuffers::Offset<MailResultItem>>(*items) : 0,
      costInfos ? _fbb.CreateVector<flatbuffers::Offset<CostInfo>>(*costInfos) : 0);
}

struct MailRewardInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COSTINFO = 4,
    VT_REWARDITEMS = 6,
    VT_ITEMS = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<CostInfo>> *costInfo() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CostInfo>> *>(VT_COSTINFO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<MailItemInfo>> *rewardItems() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MailItemInfo>> *>(VT_REWARDITEMS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ClientLItem>> *items() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ClientLItem>> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_COSTINFO) &&
           verifier.VerifyVector(costInfo()) &&
           verifier.VerifyVectorOfTables(costInfo()) &&
           VerifyOffsetRequired(verifier, VT_REWARDITEMS) &&
           verifier.VerifyVector(rewardItems()) &&
           verifier.VerifyVectorOfTables(rewardItems()) &&
           VerifyOffsetRequired(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.VerifyVectorOfTables(items()) &&
           verifier.EndTable();
  }
};

struct MailRewardInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_costInfo(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CostInfo>>> costInfo) {
    fbb_.AddOffset(MailRewardInfo::VT_COSTINFO, costInfo);
  }
  void add_rewardItems(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MailItemInfo>>> rewardItems) {
    fbb_.AddOffset(MailRewardInfo::VT_REWARDITEMS, rewardItems);
  }
  void add_items(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ClientLItem>>> items) {
    fbb_.AddOffset(MailRewardInfo::VT_ITEMS, items);
  }
  explicit MailRewardInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MailRewardInfoBuilder &operator=(const MailRewardInfoBuilder &);
  flatbuffers::Offset<MailRewardInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MailRewardInfo>(end);
    fbb_.Required(o, MailRewardInfo::VT_COSTINFO);
    fbb_.Required(o, MailRewardInfo::VT_REWARDITEMS);
    fbb_.Required(o, MailRewardInfo::VT_ITEMS);
    return o;
  }
};

inline flatbuffers::Offset<MailRewardInfo> CreateMailRewardInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CostInfo>>> costInfo = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MailItemInfo>>> rewardItems = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ClientLItem>>> items = 0) {
  MailRewardInfoBuilder builder_(_fbb);
  builder_.add_items(items);
  builder_.add_rewardItems(rewardItems);
  builder_.add_costInfo(costInfo);
  return builder_.Finish();
}

inline flatbuffers::Offset<MailRewardInfo> CreateMailRewardInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<CostInfo>> *costInfo = nullptr,
    const std::vector<flatbuffers::Offset<MailItemInfo>> *rewardItems = nullptr,
    const std::vector<flatbuffers::Offset<ClientLItem>> *items = nullptr) {
  return LeanPacket::CreateMailRewardInfo(
      _fbb,
      costInfo ? _fbb.CreateVector<flatbuffers::Offset<CostInfo>>(*costInfo) : 0,
      rewardItems ? _fbb.CreateVector<flatbuffers::Offset<MailItemInfo>>(*rewardItems) : 0,
      items ? _fbb.CreateVector<flatbuffers::Offset<ClientLItem>>(*items) : 0);
}

struct MailInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_OWNERTYPE = 6,
    VT_CONTENT = 8,
    VT_SYSTEM = 10,
    VT_TIME = 12,
    VT_REWARD = 14
  };
  int64_t id() const {
    return GetField<int64_t>(VT_ID, 0);
  }
  int8_t ownerType() const {
    return GetField<int8_t>(VT_OWNERTYPE, 0);
  }
  const MailContentInfo *content() const {
    return GetPointer<const MailContentInfo *>(VT_CONTENT);
  }
  const MailSystemInfo *system() const {
    return GetPointer<const MailSystemInfo *>(VT_SYSTEM);
  }
  const MailTimeInfo *time() const {
    return GetPointer<const MailTimeInfo *>(VT_TIME);
  }
  const MailRewardInfo *reward() const {
    return GetPointer<const MailRewardInfo *>(VT_REWARD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ID) &&
           VerifyField<int8_t>(verifier, VT_OWNERTYPE) &&
           VerifyOffsetRequired(verifier, VT_CONTENT) &&
           verifier.VerifyTable(content()) &&
           VerifyOffsetRequired(verifier, VT_SYSTEM) &&
           verifier.VerifyTable(system()) &&
           VerifyOffsetRequired(verifier, VT_TIME) &&
           verifier.VerifyTable(time()) &&
           VerifyOffsetRequired(verifier, VT_REWARD) &&
           verifier.VerifyTable(reward()) &&
           verifier.EndTable();
  }
};

struct MailInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int64_t id) {
    fbb_.AddElement<int64_t>(MailInfo::VT_ID, id, 0);
  }
  void add_ownerType(int8_t ownerType) {
    fbb_.AddElement<int8_t>(MailInfo::VT_OWNERTYPE, ownerType, 0);
  }
  void add_content(flatbuffers::Offset<MailContentInfo> content) {
    fbb_.AddOffset(MailInfo::VT_CONTENT, content);
  }
  void add_system(flatbuffers::Offset<MailSystemInfo> system) {
    fbb_.AddOffset(MailInfo::VT_SYSTEM, system);
  }
  void add_time(flatbuffers::Offset<MailTimeInfo> time) {
    fbb_.AddOffset(MailInfo::VT_TIME, time);
  }
  void add_reward(flatbuffers::Offset<MailRewardInfo> reward) {
    fbb_.AddOffset(MailInfo::VT_REWARD, reward);
  }
  explicit MailInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MailInfoBuilder &operator=(const MailInfoBuilder &);
  flatbuffers::Offset<MailInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MailInfo>(end);
    fbb_.Required(o, MailInfo::VT_CONTENT);
    fbb_.Required(o, MailInfo::VT_SYSTEM);
    fbb_.Required(o, MailInfo::VT_TIME);
    fbb_.Required(o, MailInfo::VT_REWARD);
    return o;
  }
};

inline flatbuffers::Offset<MailInfo> CreateMailInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t id = 0,
    int8_t ownerType = 0,
    flatbuffers::Offset<MailContentInfo> content = 0,
    flatbuffers::Offset<MailSystemInfo> system = 0,
    flatbuffers::Offset<MailTimeInfo> time = 0,
    flatbuffers::Offset<MailRewardInfo> reward = 0) {
  MailInfoBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_reward(reward);
  builder_.add_time(time);
  builder_.add_system(system);
  builder_.add_content(content);
  builder_.add_ownerType(ownerType);
  return builder_.Finish();
}

struct MailResultItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMID = 4,
    VT_STACKCOUNT = 6
  };
  int32_t itemId() const {
    return GetField<int32_t>(VT_ITEMID, 0);
  }
  int32_t stackCount() const {
    return GetField<int32_t>(VT_STACKCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ITEMID) &&
           VerifyField<int32_t>(verifier, VT_STACKCOUNT) &&
           verifier.EndTable();
  }
};

struct MailResultItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemId(int32_t itemId) {
    fbb_.AddElement<int32_t>(MailResultItem::VT_ITEMID, itemId, 0);
  }
  void add_stackCount(int32_t stackCount) {
    fbb_.AddElement<int32_t>(MailResultItem::VT_STACKCOUNT, stackCount, 0);
  }
  explicit MailResultItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MailResultItemBuilder &operator=(const MailResultItemBuilder &);
  flatbuffers::Offset<MailResultItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MailResultItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<MailResultItem> CreateMailResultItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t itemId = 0,
    int32_t stackCount = 0) {
  MailResultItemBuilder builder_(_fbb);
  builder_.add_stackCount(stackCount);
  builder_.add_itemId(itemId);
  return builder_.Finish();
}

struct MailResultInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMS = 4,
    VT_COSTINFOS = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<MailResultItem>> *items() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MailResultItem>> *>(VT_ITEMS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<CostInfo>> *costInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CostInfo>> *>(VT_COSTINFOS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.VerifyVectorOfTables(items()) &&
           VerifyOffsetRequired(verifier, VT_COSTINFOS) &&
           verifier.VerifyVector(costInfos()) &&
           verifier.VerifyVectorOfTables(costInfos()) &&
           verifier.EndTable();
  }
};

struct MailResultInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MailResultItem>>> items) {
    fbb_.AddOffset(MailResultInfo::VT_ITEMS, items);
  }
  void add_costInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CostInfo>>> costInfos) {
    fbb_.AddOffset(MailResultInfo::VT_COSTINFOS, costInfos);
  }
  explicit MailResultInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MailResultInfoBuilder &operator=(const MailResultInfoBuilder &);
  flatbuffers::Offset<MailResultInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MailResultInfo>(end);
    fbb_.Required(o, MailResultInfo::VT_ITEMS);
    fbb_.Required(o, MailResultInfo::VT_COSTINFOS);
    return o;
  }
};

inline flatbuffers::Offset<MailResultInfo> CreateMailResultInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MailResultItem>>> items = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CostInfo>>> costInfos = 0) {
  MailResultInfoBuilder builder_(_fbb);
  builder_.add_costInfos(costInfos);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<MailResultInfo> CreateMailResultInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<MailResultItem>> *items = nullptr,
    const std::vector<flatbuffers::Offset<CostInfo>> *costInfos = nullptr) {
  return LeanPacket::CreateMailResultInfo(
      _fbb,
      items ? _fbb.CreateVector<flatbuffers::Offset<MailResultItem>>(*items) : 0,
      costInfos ? _fbb.CreateVector<flatbuffers::Offset<CostInfo>>(*costInfos) : 0);
}

/// end
/// MAIL_RECEIVE_NOTIFY
struct MailReceiveNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MAIL = 4
  };
  const MailInfo *mail() const {
    return GetPointer<const MailInfo *>(VT_MAIL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_MAIL) &&
           verifier.VerifyTable(mail()) &&
           verifier.EndTable();
  }
};

struct MailReceiveNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mail(flatbuffers::Offset<MailInfo> mail) {
    fbb_.AddOffset(MailReceiveNotify::VT_MAIL, mail);
  }
  explicit MailReceiveNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MailReceiveNotifyBuilder &operator=(const MailReceiveNotifyBuilder &);
  flatbuffers::Offset<MailReceiveNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MailReceiveNotify>(end);
    fbb_.Required(o, MailReceiveNotify::VT_MAIL);
    return o;
  }
};

inline flatbuffers::Offset<MailReceiveNotify> CreateMailReceiveNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<MailInfo> mail = 0) {
  MailReceiveNotifyBuilder builder_(_fbb);
  builder_.add_mail(mail);
  return builder_.Finish();
}

/// MAIL_REWARD_RECEIVE_REQUEST
struct MailReceiveRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_MAILTYPE = 6,
    VT_OWNERTYPE = 8
  };
  int64_t id() const {
    return GetField<int64_t>(VT_ID, 0);
  }
  int32_t mailType() const {
    return GetField<int32_t>(VT_MAILTYPE, 0);
  }
  int8_t ownerType() const {
    return GetField<int8_t>(VT_OWNERTYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ID) &&
           VerifyField<int32_t>(verifier, VT_MAILTYPE) &&
           VerifyField<int8_t>(verifier, VT_OWNERTYPE) &&
           verifier.EndTable();
  }
};

struct MailReceiveRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int64_t id) {
    fbb_.AddElement<int64_t>(MailReceiveRequest::VT_ID, id, 0);
  }
  void add_mailType(int32_t mailType) {
    fbb_.AddElement<int32_t>(MailReceiveRequest::VT_MAILTYPE, mailType, 0);
  }
  void add_ownerType(int8_t ownerType) {
    fbb_.AddElement<int8_t>(MailReceiveRequest::VT_OWNERTYPE, ownerType, 0);
  }
  explicit MailReceiveRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MailReceiveRequestBuilder &operator=(const MailReceiveRequestBuilder &);
  flatbuffers::Offset<MailReceiveRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MailReceiveRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<MailReceiveRequest> CreateMailReceiveRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t id = 0,
    int32_t mailType = 0,
    int8_t ownerType = 0) {
  MailReceiveRequestBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_mailType(mailType);
  builder_.add_ownerType(ownerType);
  return builder_.Finish();
}

/// MAIL_REWARD_RECEIVE_RESPONSE
struct MailReceiveResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_ID = 6,
    VT_ERRORCODE2 = 8,
    VT_MAILTYPE = 10,
    VT_OWNERTYPE = 12,
    VT_ISALL = 14,
    VT_RESULT = 16
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  const flatbuffers::Vector<int64_t> *id() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_ID);
  }
  int32_t errorCode2() const {
    return GetField<int32_t>(VT_ERRORCODE2, 0);
  }
  int32_t mailType() const {
    return GetField<int32_t>(VT_MAILTYPE, 0);
  }
  int8_t ownerType() const {
    return GetField<int8_t>(VT_OWNERTYPE, 0);
  }
  bool isAll() const {
    return GetField<uint8_t>(VT_ISALL, 0) != 0;
  }
  const MailRewardInfo *result() const {
    return GetPointer<const MailRewardInfo *>(VT_RESULT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyVector(id()) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE2) &&
           VerifyField<int32_t>(verifier, VT_MAILTYPE) &&
           VerifyField<int8_t>(verifier, VT_OWNERTYPE) &&
           VerifyField<uint8_t>(verifier, VT_ISALL) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyTable(result()) &&
           verifier.EndTable();
  }
};

struct MailReceiveResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(MailReceiveResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_id(flatbuffers::Offset<flatbuffers::Vector<int64_t>> id) {
    fbb_.AddOffset(MailReceiveResponse::VT_ID, id);
  }
  void add_errorCode2(int32_t errorCode2) {
    fbb_.AddElement<int32_t>(MailReceiveResponse::VT_ERRORCODE2, errorCode2, 0);
  }
  void add_mailType(int32_t mailType) {
    fbb_.AddElement<int32_t>(MailReceiveResponse::VT_MAILTYPE, mailType, 0);
  }
  void add_ownerType(int8_t ownerType) {
    fbb_.AddElement<int8_t>(MailReceiveResponse::VT_OWNERTYPE, ownerType, 0);
  }
  void add_isAll(bool isAll) {
    fbb_.AddElement<uint8_t>(MailReceiveResponse::VT_ISALL, static_cast<uint8_t>(isAll), 0);
  }
  void add_result(flatbuffers::Offset<MailRewardInfo> result) {
    fbb_.AddOffset(MailReceiveResponse::VT_RESULT, result);
  }
  explicit MailReceiveResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MailReceiveResponseBuilder &operator=(const MailReceiveResponseBuilder &);
  flatbuffers::Offset<MailReceiveResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MailReceiveResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<MailReceiveResponse> CreateMailReceiveResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> id = 0,
    int32_t errorCode2 = 0,
    int32_t mailType = 0,
    int8_t ownerType = 0,
    bool isAll = false,
    flatbuffers::Offset<MailRewardInfo> result = 0) {
  MailReceiveResponseBuilder builder_(_fbb);
  builder_.add_result(result);
  builder_.add_mailType(mailType);
  builder_.add_errorCode2(errorCode2);
  builder_.add_id(id);
  builder_.add_errorCode(errorCode);
  builder_.add_isAll(isAll);
  builder_.add_ownerType(ownerType);
  return builder_.Finish();
}

inline flatbuffers::Offset<MailReceiveResponse> CreateMailReceiveResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    const std::vector<int64_t> *id = nullptr,
    int32_t errorCode2 = 0,
    int32_t mailType = 0,
    int8_t ownerType = 0,
    bool isAll = false,
    flatbuffers::Offset<MailRewardInfo> result = 0) {
  return LeanPacket::CreateMailReceiveResponse(
      _fbb,
      errorCode,
      id ? _fbb.CreateVector<int64_t>(*id) : 0,
      errorCode2,
      mailType,
      ownerType,
      isAll,
      result);
}

///	MAIL_REMOVE_NOTIFY
struct MailRemoveNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4
  };
  const flatbuffers::Vector<int64_t> *id() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyVector(id()) &&
           verifier.EndTable();
  }
};

struct MailRemoveNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::Vector<int64_t>> id) {
    fbb_.AddOffset(MailRemoveNotify::VT_ID, id);
  }
  explicit MailRemoveNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MailRemoveNotifyBuilder &operator=(const MailRemoveNotifyBuilder &);
  flatbuffers::Offset<MailRemoveNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MailRemoveNotify>(end);
    fbb_.Required(o, MailRemoveNotify::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<MailRemoveNotify> CreateMailRemoveNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> id = 0) {
  MailRemoveNotifyBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<MailRemoveNotify> CreateMailRemoveNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *id = nullptr) {
  return LeanPacket::CreateMailRemoveNotify(
      _fbb,
      id ? _fbb.CreateVector<int64_t>(*id) : 0);
}

///PLAYER_IMMEDIATELY_DEAD_REQUEST
struct PlayerImmediatelyDeadRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           verifier.EndTable();
  }
};

struct PlayerImmediatelyDeadRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(PlayerImmediatelyDeadRequest::VT_OBJECTID, objectId, 0);
  }
  explicit PlayerImmediatelyDeadRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlayerImmediatelyDeadRequestBuilder &operator=(const PlayerImmediatelyDeadRequestBuilder &);
  flatbuffers::Offset<PlayerImmediatelyDeadRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlayerImmediatelyDeadRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<PlayerImmediatelyDeadRequest> CreatePlayerImmediatelyDeadRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0) {
  PlayerImmediatelyDeadRequestBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  return builder_.Finish();
}

/// PC_GUILD_INFO_UPDATE_NOTIFY
struct PcGuildInfoUpdateNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_PCGUILDINFO = 6
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  const PcGuildInfo *pcGuildInfo() const {
    return GetPointer<const PcGuildInfo *>(VT_PCGUILDINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyOffset(verifier, VT_PCGUILDINFO) &&
           verifier.VerifyTable(pcGuildInfo()) &&
           verifier.EndTable();
  }
};

struct PcGuildInfoUpdateNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(PcGuildInfoUpdateNotify::VT_OBJECTID, objectId, 0);
  }
  void add_pcGuildInfo(flatbuffers::Offset<PcGuildInfo> pcGuildInfo) {
    fbb_.AddOffset(PcGuildInfoUpdateNotify::VT_PCGUILDINFO, pcGuildInfo);
  }
  explicit PcGuildInfoUpdateNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PcGuildInfoUpdateNotifyBuilder &operator=(const PcGuildInfoUpdateNotifyBuilder &);
  flatbuffers::Offset<PcGuildInfoUpdateNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PcGuildInfoUpdateNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<PcGuildInfoUpdateNotify> CreatePcGuildInfoUpdateNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    flatbuffers::Offset<PcGuildInfo> pcGuildInfo = 0) {
  PcGuildInfoUpdateNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_pcGuildInfo(pcGuildInfo);
  return builder_.Finish();
}

/// DAILY_DUNGEON_CLEAR_NOTIFY
struct DailyDungeonClearNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULT = 4,
    VT_SUCCEED = 6,
    VT_ID = 8,
    VT_TODAYCLEARCOUNT = 10,
    VT_REWARDS = 12,
    VT_DAY = 14
  };
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  bool succeed() const {
    return GetField<uint8_t>(VT_SUCCEED, 0) != 0;
  }
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int32_t todayClearCount() const {
    return GetField<int32_t>(VT_TODAYCLEARCOUNT, 0);
  }
  const RewardInfo *rewards() const {
    return GetPointer<const RewardInfo *>(VT_REWARDS);
  }
  int8_t day() const {
    return GetField<int8_t>(VT_DAY, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           VerifyField<uint8_t>(verifier, VT_SUCCEED) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<int32_t>(verifier, VT_TODAYCLEARCOUNT) &&
           VerifyOffset(verifier, VT_REWARDS) &&
           verifier.VerifyTable(rewards()) &&
           VerifyField<int8_t>(verifier, VT_DAY) &&
           verifier.EndTable();
  }
};

struct DailyDungeonClearNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(DailyDungeonClearNotify::VT_RESULT, result, 0);
  }
  void add_succeed(bool succeed) {
    fbb_.AddElement<uint8_t>(DailyDungeonClearNotify::VT_SUCCEED, static_cast<uint8_t>(succeed), 0);
  }
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(DailyDungeonClearNotify::VT_ID, id, 0);
  }
  void add_todayClearCount(int32_t todayClearCount) {
    fbb_.AddElement<int32_t>(DailyDungeonClearNotify::VT_TODAYCLEARCOUNT, todayClearCount, 0);
  }
  void add_rewards(flatbuffers::Offset<RewardInfo> rewards) {
    fbb_.AddOffset(DailyDungeonClearNotify::VT_REWARDS, rewards);
  }
  void add_day(int8_t day) {
    fbb_.AddElement<int8_t>(DailyDungeonClearNotify::VT_DAY, day, 0);
  }
  explicit DailyDungeonClearNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DailyDungeonClearNotifyBuilder &operator=(const DailyDungeonClearNotifyBuilder &);
  flatbuffers::Offset<DailyDungeonClearNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DailyDungeonClearNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<DailyDungeonClearNotify> CreateDailyDungeonClearNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    bool succeed = false,
    int32_t id = 0,
    int32_t todayClearCount = 0,
    flatbuffers::Offset<RewardInfo> rewards = 0,
    int8_t day = 0) {
  DailyDungeonClearNotifyBuilder builder_(_fbb);
  builder_.add_rewards(rewards);
  builder_.add_todayClearCount(todayClearCount);
  builder_.add_id(id);
  builder_.add_result(result);
  builder_.add_day(day);
  builder_.add_succeed(succeed);
  return builder_.Finish();
}

struct PlayerReviveInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_REVIVETYPE = 4,
    VT_REVIVECOUNT = 6,
    VT_COOLTIMEMILISEC = 8
  };
  int32_t reviveType() const {
    return GetField<int32_t>(VT_REVIVETYPE, 0);
  }
  int32_t reviveCount() const {
    return GetField<int32_t>(VT_REVIVECOUNT, 0);
  }
  int32_t coolTimeMiliSec() const {
    return GetField<int32_t>(VT_COOLTIMEMILISEC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_REVIVETYPE) &&
           VerifyField<int32_t>(verifier, VT_REVIVECOUNT) &&
           VerifyField<int32_t>(verifier, VT_COOLTIMEMILISEC) &&
           verifier.EndTable();
  }
};

struct PlayerReviveInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_reviveType(int32_t reviveType) {
    fbb_.AddElement<int32_t>(PlayerReviveInfo::VT_REVIVETYPE, reviveType, 0);
  }
  void add_reviveCount(int32_t reviveCount) {
    fbb_.AddElement<int32_t>(PlayerReviveInfo::VT_REVIVECOUNT, reviveCount, 0);
  }
  void add_coolTimeMiliSec(int32_t coolTimeMiliSec) {
    fbb_.AddElement<int32_t>(PlayerReviveInfo::VT_COOLTIMEMILISEC, coolTimeMiliSec, 0);
  }
  explicit PlayerReviveInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlayerReviveInfoBuilder &operator=(const PlayerReviveInfoBuilder &);
  flatbuffers::Offset<PlayerReviveInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlayerReviveInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<PlayerReviveInfo> CreatePlayerReviveInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t reviveType = 0,
    int32_t reviveCount = 0,
    int32_t coolTimeMiliSec = 0) {
  PlayerReviveInfoBuilder builder_(_fbb);
  builder_.add_coolTimeMiliSec(coolTimeMiliSec);
  builder_.add_reviveCount(reviveCount);
  builder_.add_reviveType(reviveType);
  return builder_.Finish();
}

struct PlayerReviveInfoNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_REVIVEINFOS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<PlayerReviveInfo>> *reviveInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PlayerReviveInfo>> *>(VT_REVIVEINFOS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_REVIVEINFOS) &&
           verifier.VerifyVector(reviveInfos()) &&
           verifier.VerifyVectorOfTables(reviveInfos()) &&
           verifier.EndTable();
  }
};

struct PlayerReviveInfoNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_reviveInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PlayerReviveInfo>>> reviveInfos) {
    fbb_.AddOffset(PlayerReviveInfoNotify::VT_REVIVEINFOS, reviveInfos);
  }
  explicit PlayerReviveInfoNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlayerReviveInfoNotifyBuilder &operator=(const PlayerReviveInfoNotifyBuilder &);
  flatbuffers::Offset<PlayerReviveInfoNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlayerReviveInfoNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<PlayerReviveInfoNotify> CreatePlayerReviveInfoNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PlayerReviveInfo>>> reviveInfos = 0) {
  PlayerReviveInfoNotifyBuilder builder_(_fbb);
  builder_.add_reviveInfos(reviveInfos);
  return builder_.Finish();
}

inline flatbuffers::Offset<PlayerReviveInfoNotify> CreatePlayerReviveInfoNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<PlayerReviveInfo>> *reviveInfos = nullptr) {
  return LeanPacket::CreatePlayerReviveInfoNotify(
      _fbb,
      reviveInfos ? _fbb.CreateVector<flatbuffers::Offset<PlayerReviveInfo>>(*reviveInfos) : 0);
}

/// UPC_LOAD_START_NOTIFY					= 20021,
struct UpcLoadStartNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_UPCOBJECTID = 4,
    VT_NAME = 6,
    VT_IFF = 8,
    VT_CLASSTYPE = 10,
    VT_LEVEL = 12,
    VT_CUSTOMIZINGINFO = 14,
    VT_EQUIPPARTSINFO = 16,
    VT_COSTUMEPARTSINFO = 18
  };
  int64_t upcObjectId() const {
    return GetField<int64_t>(VT_UPCOBJECTID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t iff() const {
    return GetField<int32_t>(VT_IFF, 0);
  }
  int32_t classType() const {
    return GetField<int32_t>(VT_CLASSTYPE, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  const CustomizeInfo *customizingInfo() const {
    return GetPointer<const CustomizeInfo *>(VT_CUSTOMIZINGINFO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ItemPartsInfo>> *equipPartsInfo() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ItemPartsInfo>> *>(VT_EQUIPPARTSINFO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<CostumePartsInfo>> *costumePartsInfo() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CostumePartsInfo>> *>(VT_COSTUMEPARTSINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_UPCOBJECTID) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_IFF) &&
           VerifyField<int32_t>(verifier, VT_CLASSTYPE) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyOffsetRequired(verifier, VT_CUSTOMIZINGINFO) &&
           verifier.VerifyTable(customizingInfo()) &&
           VerifyOffsetRequired(verifier, VT_EQUIPPARTSINFO) &&
           verifier.VerifyVector(equipPartsInfo()) &&
           verifier.VerifyVectorOfTables(equipPartsInfo()) &&
           VerifyOffsetRequired(verifier, VT_COSTUMEPARTSINFO) &&
           verifier.VerifyVector(costumePartsInfo()) &&
           verifier.VerifyVectorOfTables(costumePartsInfo()) &&
           verifier.EndTable();
  }
};

struct UpcLoadStartNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_upcObjectId(int64_t upcObjectId) {
    fbb_.AddElement<int64_t>(UpcLoadStartNotify::VT_UPCOBJECTID, upcObjectId, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(UpcLoadStartNotify::VT_NAME, name);
  }
  void add_iff(int32_t iff) {
    fbb_.AddElement<int32_t>(UpcLoadStartNotify::VT_IFF, iff, 0);
  }
  void add_classType(int32_t classType) {
    fbb_.AddElement<int32_t>(UpcLoadStartNotify::VT_CLASSTYPE, classType, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(UpcLoadStartNotify::VT_LEVEL, level, 0);
  }
  void add_customizingInfo(flatbuffers::Offset<CustomizeInfo> customizingInfo) {
    fbb_.AddOffset(UpcLoadStartNotify::VT_CUSTOMIZINGINFO, customizingInfo);
  }
  void add_equipPartsInfo(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ItemPartsInfo>>> equipPartsInfo) {
    fbb_.AddOffset(UpcLoadStartNotify::VT_EQUIPPARTSINFO, equipPartsInfo);
  }
  void add_costumePartsInfo(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CostumePartsInfo>>> costumePartsInfo) {
    fbb_.AddOffset(UpcLoadStartNotify::VT_COSTUMEPARTSINFO, costumePartsInfo);
  }
  explicit UpcLoadStartNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UpcLoadStartNotifyBuilder &operator=(const UpcLoadStartNotifyBuilder &);
  flatbuffers::Offset<UpcLoadStartNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UpcLoadStartNotify>(end);
    fbb_.Required(o, UpcLoadStartNotify::VT_NAME);
    fbb_.Required(o, UpcLoadStartNotify::VT_CUSTOMIZINGINFO);
    fbb_.Required(o, UpcLoadStartNotify::VT_EQUIPPARTSINFO);
    fbb_.Required(o, UpcLoadStartNotify::VT_COSTUMEPARTSINFO);
    return o;
  }
};

inline flatbuffers::Offset<UpcLoadStartNotify> CreateUpcLoadStartNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t upcObjectId = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t iff = 0,
    int32_t classType = 0,
    int32_t level = 0,
    flatbuffers::Offset<CustomizeInfo> customizingInfo = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ItemPartsInfo>>> equipPartsInfo = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CostumePartsInfo>>> costumePartsInfo = 0) {
  UpcLoadStartNotifyBuilder builder_(_fbb);
  builder_.add_upcObjectId(upcObjectId);
  builder_.add_costumePartsInfo(costumePartsInfo);
  builder_.add_equipPartsInfo(equipPartsInfo);
  builder_.add_customizingInfo(customizingInfo);
  builder_.add_level(level);
  builder_.add_classType(classType);
  builder_.add_iff(iff);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<UpcLoadStartNotify> CreateUpcLoadStartNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t upcObjectId = 0,
    const char *name = nullptr,
    int32_t iff = 0,
    int32_t classType = 0,
    int32_t level = 0,
    flatbuffers::Offset<CustomizeInfo> customizingInfo = 0,
    const std::vector<flatbuffers::Offset<ItemPartsInfo>> *equipPartsInfo = nullptr,
    const std::vector<flatbuffers::Offset<CostumePartsInfo>> *costumePartsInfo = nullptr) {
  return LeanPacket::CreateUpcLoadStartNotify(
      _fbb,
      upcObjectId,
      name ? _fbb.CreateString(name) : 0,
      iff,
      classType,
      level,
      customizingInfo,
      equipPartsInfo ? _fbb.CreateVector<flatbuffers::Offset<ItemPartsInfo>>(*equipPartsInfo) : 0,
      costumePartsInfo ? _fbb.CreateVector<flatbuffers::Offset<CostumePartsInfo>>(*costumePartsInfo) : 0);
}

/// UPC_LOAD_FINISH_NOTIFY					= 20022,
struct UpcLoadFinishNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           verifier.EndTable();
  }
};

struct UpcLoadFinishNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(UpcLoadFinishNotify::VT_OBJECTID, objectId, 0);
  }
  explicit UpcLoadFinishNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UpcLoadFinishNotifyBuilder &operator=(const UpcLoadFinishNotifyBuilder &);
  flatbuffers::Offset<UpcLoadFinishNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UpcLoadFinishNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<UpcLoadFinishNotify> CreateUpcLoadFinishNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0) {
  UpcLoadFinishNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  return builder_.Finish();
}

/// UPC_HOST_REQUEST
struct UpcHostRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_UPCOBJECTID = 4,
    VT_UPCTYPE = 6,
    VT_PRESETNO = 8,
    VT_SKILLSLOTINFOS = 10,
    VT_PRESET = 12,
    VT_SKILLFEATUREINFOS = 14,
    VT_STATS = 16
  };
  int64_t upcObjectId() const {
    return GetField<int64_t>(VT_UPCOBJECTID, 0);
  }
  UpcType upcType() const {
    return static_cast<UpcType>(GetField<int16_t>(VT_UPCTYPE, 0));
  }
  int16_t presetNo() const {
    return GetField<int16_t>(VT_PRESETNO, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SkillSlotInfo>> *skillSlotInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SkillSlotInfo>> *>(VT_SKILLSLOTINFOS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PresetInfo>> *preset() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PresetInfo>> *>(VT_PRESET);
  }
  const flatbuffers::Vector<flatbuffers::Offset<LoadedSkillFeatureInfo>> *skillFeatureInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LoadedSkillFeatureInfo>> *>(VT_SKILLFEATUREINFOS);
  }
  const Stats *stats() const {
    return GetPointer<const Stats *>(VT_STATS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_UPCOBJECTID) &&
           VerifyField<int16_t>(verifier, VT_UPCTYPE) &&
           VerifyField<int16_t>(verifier, VT_PRESETNO) &&
           VerifyOffsetRequired(verifier, VT_SKILLSLOTINFOS) &&
           verifier.VerifyVector(skillSlotInfos()) &&
           verifier.VerifyVectorOfTables(skillSlotInfos()) &&
           VerifyOffsetRequired(verifier, VT_PRESET) &&
           verifier.VerifyVector(preset()) &&
           verifier.VerifyVectorOfTables(preset()) &&
           VerifyOffsetRequired(verifier, VT_SKILLFEATUREINFOS) &&
           verifier.VerifyVector(skillFeatureInfos()) &&
           verifier.VerifyVectorOfTables(skillFeatureInfos()) &&
           VerifyOffset(verifier, VT_STATS) &&
           verifier.VerifyTable(stats()) &&
           verifier.EndTable();
  }
};

struct UpcHostRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_upcObjectId(int64_t upcObjectId) {
    fbb_.AddElement<int64_t>(UpcHostRequest::VT_UPCOBJECTID, upcObjectId, 0);
  }
  void add_upcType(UpcType upcType) {
    fbb_.AddElement<int16_t>(UpcHostRequest::VT_UPCTYPE, static_cast<int16_t>(upcType), 0);
  }
  void add_presetNo(int16_t presetNo) {
    fbb_.AddElement<int16_t>(UpcHostRequest::VT_PRESETNO, presetNo, 0);
  }
  void add_skillSlotInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SkillSlotInfo>>> skillSlotInfos) {
    fbb_.AddOffset(UpcHostRequest::VT_SKILLSLOTINFOS, skillSlotInfos);
  }
  void add_preset(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PresetInfo>>> preset) {
    fbb_.AddOffset(UpcHostRequest::VT_PRESET, preset);
  }
  void add_skillFeatureInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LoadedSkillFeatureInfo>>> skillFeatureInfos) {
    fbb_.AddOffset(UpcHostRequest::VT_SKILLFEATUREINFOS, skillFeatureInfos);
  }
  void add_stats(flatbuffers::Offset<Stats> stats) {
    fbb_.AddOffset(UpcHostRequest::VT_STATS, stats);
  }
  explicit UpcHostRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UpcHostRequestBuilder &operator=(const UpcHostRequestBuilder &);
  flatbuffers::Offset<UpcHostRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UpcHostRequest>(end);
    fbb_.Required(o, UpcHostRequest::VT_SKILLSLOTINFOS);
    fbb_.Required(o, UpcHostRequest::VT_PRESET);
    fbb_.Required(o, UpcHostRequest::VT_SKILLFEATUREINFOS);
    return o;
  }
};

inline flatbuffers::Offset<UpcHostRequest> CreateUpcHostRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t upcObjectId = 0,
    UpcType upcType = UpcType_UPC_TYPE_ARENA,
    int16_t presetNo = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SkillSlotInfo>>> skillSlotInfos = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PresetInfo>>> preset = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LoadedSkillFeatureInfo>>> skillFeatureInfos = 0,
    flatbuffers::Offset<Stats> stats = 0) {
  UpcHostRequestBuilder builder_(_fbb);
  builder_.add_upcObjectId(upcObjectId);
  builder_.add_stats(stats);
  builder_.add_skillFeatureInfos(skillFeatureInfos);
  builder_.add_preset(preset);
  builder_.add_skillSlotInfos(skillSlotInfos);
  builder_.add_presetNo(presetNo);
  builder_.add_upcType(upcType);
  return builder_.Finish();
}

inline flatbuffers::Offset<UpcHostRequest> CreateUpcHostRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t upcObjectId = 0,
    UpcType upcType = UpcType_UPC_TYPE_ARENA,
    int16_t presetNo = 0,
    const std::vector<flatbuffers::Offset<SkillSlotInfo>> *skillSlotInfos = nullptr,
    const std::vector<flatbuffers::Offset<PresetInfo>> *preset = nullptr,
    const std::vector<flatbuffers::Offset<LoadedSkillFeatureInfo>> *skillFeatureInfos = nullptr,
    flatbuffers::Offset<Stats> stats = 0) {
  return LeanPacket::CreateUpcHostRequest(
      _fbb,
      upcObjectId,
      upcType,
      presetNo,
      skillSlotInfos ? _fbb.CreateVector<flatbuffers::Offset<SkillSlotInfo>>(*skillSlotInfos) : 0,
      preset ? _fbb.CreateVector<flatbuffers::Offset<PresetInfo>>(*preset) : 0,
      skillFeatureInfos ? _fbb.CreateVector<flatbuffers::Offset<LoadedSkillFeatureInfo>>(*skillFeatureInfos) : 0,
      stats);
}

/// UPC_HOST_RESPONSE
struct UpcHostResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_UPCOBJECTID = 4,
    VT_ERRORCODE = 6
  };
  int64_t upcObjectId() const {
    return GetField<int64_t>(VT_UPCOBJECTID, 0);
  }
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_UPCOBJECTID) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           verifier.EndTable();
  }
};

struct UpcHostResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_upcObjectId(int64_t upcObjectId) {
    fbb_.AddElement<int64_t>(UpcHostResponse::VT_UPCOBJECTID, upcObjectId, 0);
  }
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(UpcHostResponse::VT_ERRORCODE, errorCode, 0);
  }
  explicit UpcHostResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UpcHostResponseBuilder &operator=(const UpcHostResponseBuilder &);
  flatbuffers::Offset<UpcHostResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UpcHostResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<UpcHostResponse> CreateUpcHostResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t upcObjectId = 0,
    int32_t errorCode = 0) {
  UpcHostResponseBuilder builder_(_fbb);
  builder_.add_upcObjectId(upcObjectId);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

/// UPC_UNHOST_NOTIFY
struct UpcUnHostNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_UPCOBJECTID = 4
  };
  int64_t upcObjectId() const {
    return GetField<int64_t>(VT_UPCOBJECTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_UPCOBJECTID) &&
           verifier.EndTable();
  }
};

struct UpcUnHostNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_upcObjectId(int64_t upcObjectId) {
    fbb_.AddElement<int64_t>(UpcUnHostNotify::VT_UPCOBJECTID, upcObjectId, 0);
  }
  explicit UpcUnHostNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UpcUnHostNotifyBuilder &operator=(const UpcUnHostNotifyBuilder &);
  flatbuffers::Offset<UpcUnHostNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UpcUnHostNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<UpcUnHostNotify> CreateUpcUnHostNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t upcObjectId = 0) {
  UpcUnHostNotifyBuilder builder_(_fbb);
  builder_.add_upcObjectId(upcObjectId);
  return builder_.Finish();
}

/// UPC_LOAD_START_NOTIFY_REQUEST
struct UpcLoadStartNotifyRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct UpcLoadStartNotifyRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit UpcLoadStartNotifyRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UpcLoadStartNotifyRequestBuilder &operator=(const UpcLoadStartNotifyRequestBuilder &);
  flatbuffers::Offset<UpcLoadStartNotifyRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UpcLoadStartNotifyRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<UpcLoadStartNotifyRequest> CreateUpcLoadStartNotifyRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  UpcLoadStartNotifyRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// PLAYER_DESPAWN_NOTIFY
struct PlayerDespawnNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct PlayerDespawnNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PlayerDespawnNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlayerDespawnNotifyBuilder &operator=(const PlayerDespawnNotifyBuilder &);
  flatbuffers::Offset<PlayerDespawnNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlayerDespawnNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<PlayerDespawnNotify> CreatePlayerDespawnNotify(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PlayerDespawnNotifyBuilder builder_(_fbb);
  return builder_.Finish();
}

struct AddSoulStoneInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FOLLOWERID = 4,
    VT_COUNT = 6
  };
  int32_t followerId() const {
    return GetField<int32_t>(VT_FOLLOWERID, 0);
  }
  int32_t count() const {
    return GetField<int32_t>(VT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FOLLOWERID) &&
           VerifyField<int32_t>(verifier, VT_COUNT) &&
           verifier.EndTable();
  }
};

struct AddSoulStoneInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_followerId(int32_t followerId) {
    fbb_.AddElement<int32_t>(AddSoulStoneInfo::VT_FOLLOWERID, followerId, 0);
  }
  void add_count(int32_t count) {
    fbb_.AddElement<int32_t>(AddSoulStoneInfo::VT_COUNT, count, 0);
  }
  explicit AddSoulStoneInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddSoulStoneInfoBuilder &operator=(const AddSoulStoneInfoBuilder &);
  flatbuffers::Offset<AddSoulStoneInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddSoulStoneInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddSoulStoneInfo> CreateAddSoulStoneInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t followerId = 0,
    int32_t count = 0) {
  AddSoulStoneInfoBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_followerId(followerId);
  return builder_.Finish();
}

///FOLLOWER_ADD_SOUL_STONE_NOTIFY
struct FollowerAddSoulStoneNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ADDINFOS = 4,
    VT_RESULT = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<AddSoulStoneInfo>> *addInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AddSoulStoneInfo>> *>(VT_ADDINFOS);
  }
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ADDINFOS) &&
           verifier.VerifyVector(addInfos()) &&
           verifier.VerifyVectorOfTables(addInfos()) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           verifier.EndTable();
  }
};

struct FollowerAddSoulStoneNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_addInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AddSoulStoneInfo>>> addInfos) {
    fbb_.AddOffset(FollowerAddSoulStoneNotify::VT_ADDINFOS, addInfos);
  }
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(FollowerAddSoulStoneNotify::VT_RESULT, result, 0);
  }
  explicit FollowerAddSoulStoneNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FollowerAddSoulStoneNotifyBuilder &operator=(const FollowerAddSoulStoneNotifyBuilder &);
  flatbuffers::Offset<FollowerAddSoulStoneNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FollowerAddSoulStoneNotify>(end);
    fbb_.Required(o, FollowerAddSoulStoneNotify::VT_ADDINFOS);
    return o;
  }
};

inline flatbuffers::Offset<FollowerAddSoulStoneNotify> CreateFollowerAddSoulStoneNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AddSoulStoneInfo>>> addInfos = 0,
    int32_t result = 0) {
  FollowerAddSoulStoneNotifyBuilder builder_(_fbb);
  builder_.add_result(result);
  builder_.add_addInfos(addInfos);
  return builder_.Finish();
}

inline flatbuffers::Offset<FollowerAddSoulStoneNotify> CreateFollowerAddSoulStoneNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<AddSoulStoneInfo>> *addInfos = nullptr,
    int32_t result = 0) {
  return LeanPacket::CreateFollowerAddSoulStoneNotify(
      _fbb,
      addInfos ? _fbb.CreateVector<flatbuffers::Offset<AddSoulStoneInfo>>(*addInfos) : 0,
      result);
}

/// FOLLOWER_ENCHANT_REQUEST
struct FollowerEnchantRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FOLLOWERID = 4
  };
  int32_t followerId() const {
    return GetField<int32_t>(VT_FOLLOWERID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FOLLOWERID) &&
           verifier.EndTable();
  }
};

struct FollowerEnchantRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_followerId(int32_t followerId) {
    fbb_.AddElement<int32_t>(FollowerEnchantRequest::VT_FOLLOWERID, followerId, 0);
  }
  explicit FollowerEnchantRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FollowerEnchantRequestBuilder &operator=(const FollowerEnchantRequestBuilder &);
  flatbuffers::Offset<FollowerEnchantRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FollowerEnchantRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<FollowerEnchantRequest> CreateFollowerEnchantRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t followerId = 0) {
  FollowerEnchantRequestBuilder builder_(_fbb);
  builder_.add_followerId(followerId);
  return builder_.Finish();
}

///FOLLOWER_ENCHANT_RESPONSE
struct FollowerEnchantResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FOLLOWERID = 4,
    VT_RESULTLEVEL = 6,
    VT_RESULT = 8
  };
  int32_t followerId() const {
    return GetField<int32_t>(VT_FOLLOWERID, 0);
  }
  int32_t resultLevel() const {
    return GetField<int32_t>(VT_RESULTLEVEL, 0);
  }
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FOLLOWERID) &&
           VerifyField<int32_t>(verifier, VT_RESULTLEVEL) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           verifier.EndTable();
  }
};

struct FollowerEnchantResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_followerId(int32_t followerId) {
    fbb_.AddElement<int32_t>(FollowerEnchantResponse::VT_FOLLOWERID, followerId, 0);
  }
  void add_resultLevel(int32_t resultLevel) {
    fbb_.AddElement<int32_t>(FollowerEnchantResponse::VT_RESULTLEVEL, resultLevel, 0);
  }
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(FollowerEnchantResponse::VT_RESULT, result, 0);
  }
  explicit FollowerEnchantResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FollowerEnchantResponseBuilder &operator=(const FollowerEnchantResponseBuilder &);
  flatbuffers::Offset<FollowerEnchantResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FollowerEnchantResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<FollowerEnchantResponse> CreateFollowerEnchantResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t followerId = 0,
    int32_t resultLevel = 0,
    int32_t result = 0) {
  FollowerEnchantResponseBuilder builder_(_fbb);
  builder_.add_result(result);
  builder_.add_resultLevel(resultLevel);
  builder_.add_followerId(followerId);
  return builder_.Finish();
}

///FOLLOWER_START_MISSION_REQUEST	= 22030
struct FollowerStartMissionRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FOLLOWERID = 4,
    VT_POSITIONIDX = 6
  };
  int32_t followerId() const {
    return GetField<int32_t>(VT_FOLLOWERID, 0);
  }
  int16_t positionIdx() const {
    return GetField<int16_t>(VT_POSITIONIDX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FOLLOWERID) &&
           VerifyField<int16_t>(verifier, VT_POSITIONIDX) &&
           verifier.EndTable();
  }
};

struct FollowerStartMissionRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_followerId(int32_t followerId) {
    fbb_.AddElement<int32_t>(FollowerStartMissionRequest::VT_FOLLOWERID, followerId, 0);
  }
  void add_positionIdx(int16_t positionIdx) {
    fbb_.AddElement<int16_t>(FollowerStartMissionRequest::VT_POSITIONIDX, positionIdx, 0);
  }
  explicit FollowerStartMissionRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FollowerStartMissionRequestBuilder &operator=(const FollowerStartMissionRequestBuilder &);
  flatbuffers::Offset<FollowerStartMissionRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FollowerStartMissionRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<FollowerStartMissionRequest> CreateFollowerStartMissionRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t followerId = 0,
    int16_t positionIdx = 0) {
  FollowerStartMissionRequestBuilder builder_(_fbb);
  builder_.add_followerId(followerId);
  builder_.add_positionIdx(positionIdx);
  return builder_.Finish();
}

///FOLLOWER_START_MISSION_NOTIFY	= 22031
struct FollowerStartMissionNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FOLLOWERID = 4,
    VT_RESULT = 6,
    VT_POSITIONIDX = 8,
    VT_REMAINTIME = 10
  };
  int32_t followerId() const {
    return GetField<int32_t>(VT_FOLLOWERID, 0);
  }
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  int32_t positionIdx() const {
    return GetField<int32_t>(VT_POSITIONIDX, 0);
  }
  int64_t remainTime() const {
    return GetField<int64_t>(VT_REMAINTIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FOLLOWERID) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           VerifyField<int32_t>(verifier, VT_POSITIONIDX) &&
           VerifyField<int64_t>(verifier, VT_REMAINTIME) &&
           verifier.EndTable();
  }
};

struct FollowerStartMissionNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_followerId(int32_t followerId) {
    fbb_.AddElement<int32_t>(FollowerStartMissionNotify::VT_FOLLOWERID, followerId, 0);
  }
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(FollowerStartMissionNotify::VT_RESULT, result, 0);
  }
  void add_positionIdx(int32_t positionIdx) {
    fbb_.AddElement<int32_t>(FollowerStartMissionNotify::VT_POSITIONIDX, positionIdx, 0);
  }
  void add_remainTime(int64_t remainTime) {
    fbb_.AddElement<int64_t>(FollowerStartMissionNotify::VT_REMAINTIME, remainTime, 0);
  }
  explicit FollowerStartMissionNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FollowerStartMissionNotifyBuilder &operator=(const FollowerStartMissionNotifyBuilder &);
  flatbuffers::Offset<FollowerStartMissionNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FollowerStartMissionNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<FollowerStartMissionNotify> CreateFollowerStartMissionNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t followerId = 0,
    int32_t result = 0,
    int32_t positionIdx = 0,
    int64_t remainTime = 0) {
  FollowerStartMissionNotifyBuilder builder_(_fbb);
  builder_.add_remainTime(remainTime);
  builder_.add_positionIdx(positionIdx);
  builder_.add_result(result);
  builder_.add_followerId(followerId);
  return builder_.Finish();
}

///FOLLOWER_END_MISSION_REQUEST		= 22032
struct FollowerEndMissionRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FOLLOWERID = 4
  };
  int32_t followerId() const {
    return GetField<int32_t>(VT_FOLLOWERID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FOLLOWERID) &&
           verifier.EndTable();
  }
};

struct FollowerEndMissionRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_followerId(int32_t followerId) {
    fbb_.AddElement<int32_t>(FollowerEndMissionRequest::VT_FOLLOWERID, followerId, 0);
  }
  explicit FollowerEndMissionRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FollowerEndMissionRequestBuilder &operator=(const FollowerEndMissionRequestBuilder &);
  flatbuffers::Offset<FollowerEndMissionRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FollowerEndMissionRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<FollowerEndMissionRequest> CreateFollowerEndMissionRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t followerId = 0) {
  FollowerEndMissionRequestBuilder builder_(_fbb);
  builder_.add_followerId(followerId);
  return builder_.Finish();
}

///FOLLOWER_END_MISSION_RESPONSE	= 22033
struct FollowerEndMissionResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FOLLOWERID = 4,
    VT_RESULT = 6
  };
  int32_t followerId() const {
    return GetField<int32_t>(VT_FOLLOWERID, 0);
  }
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FOLLOWERID) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           verifier.EndTable();
  }
};

struct FollowerEndMissionResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_followerId(int32_t followerId) {
    fbb_.AddElement<int32_t>(FollowerEndMissionResponse::VT_FOLLOWERID, followerId, 0);
  }
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(FollowerEndMissionResponse::VT_RESULT, result, 0);
  }
  explicit FollowerEndMissionResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FollowerEndMissionResponseBuilder &operator=(const FollowerEndMissionResponseBuilder &);
  flatbuffers::Offset<FollowerEndMissionResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FollowerEndMissionResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<FollowerEndMissionResponse> CreateFollowerEndMissionResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t followerId = 0,
    int32_t result = 0) {
  FollowerEndMissionResponseBuilder builder_(_fbb);
  builder_.add_result(result);
  builder_.add_followerId(followerId);
  return builder_.Finish();
}

struct MissionRemainTimeInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FOLLOWERID = 4,
    VT_REMAINTIME = 6
  };
  int32_t followerId() const {
    return GetField<int32_t>(VT_FOLLOWERID, 0);
  }
  int64_t remainTime() const {
    return GetField<int64_t>(VT_REMAINTIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FOLLOWERID) &&
           VerifyField<int64_t>(verifier, VT_REMAINTIME) &&
           verifier.EndTable();
  }
};

struct MissionRemainTimeInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_followerId(int32_t followerId) {
    fbb_.AddElement<int32_t>(MissionRemainTimeInfo::VT_FOLLOWERID, followerId, 0);
  }
  void add_remainTime(int64_t remainTime) {
    fbb_.AddElement<int64_t>(MissionRemainTimeInfo::VT_REMAINTIME, remainTime, 0);
  }
  explicit MissionRemainTimeInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MissionRemainTimeInfoBuilder &operator=(const MissionRemainTimeInfoBuilder &);
  flatbuffers::Offset<MissionRemainTimeInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MissionRemainTimeInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<MissionRemainTimeInfo> CreateMissionRemainTimeInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t followerId = 0,
    int64_t remainTime = 0) {
  MissionRemainTimeInfoBuilder builder_(_fbb);
  builder_.add_remainTime(remainTime);
  builder_.add_followerId(followerId);
  return builder_.Finish();
}

/// FOLLOWER_MISSION_REMAIN_TIME_REQUEST = 22034
struct FollowerMissionRemainTimeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FOLLOWERID = 4
  };
  int32_t followerId() const {
    return GetField<int32_t>(VT_FOLLOWERID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FOLLOWERID) &&
           verifier.EndTable();
  }
};

struct FollowerMissionRemainTimeRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_followerId(int32_t followerId) {
    fbb_.AddElement<int32_t>(FollowerMissionRemainTimeRequest::VT_FOLLOWERID, followerId, 0);
  }
  explicit FollowerMissionRemainTimeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FollowerMissionRemainTimeRequestBuilder &operator=(const FollowerMissionRemainTimeRequestBuilder &);
  flatbuffers::Offset<FollowerMissionRemainTimeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FollowerMissionRemainTimeRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<FollowerMissionRemainTimeRequest> CreateFollowerMissionRemainTimeRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t followerId = 0) {
  FollowerMissionRemainTimeRequestBuilder builder_(_fbb);
  builder_.add_followerId(followerId);
  return builder_.Finish();
}

/// FOLLOWER_MISSION_REMAIN_TIME_RESPONSE = 22035,
struct FollowerMissionRemainTimeResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FOLLOWERREMAINTIMEINFOS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<MissionRemainTimeInfo>> *followerRemainTimeInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MissionRemainTimeInfo>> *>(VT_FOLLOWERREMAINTIMEINFOS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FOLLOWERREMAINTIMEINFOS) &&
           verifier.VerifyVector(followerRemainTimeInfos()) &&
           verifier.VerifyVectorOfTables(followerRemainTimeInfos()) &&
           verifier.EndTable();
  }
};

struct FollowerMissionRemainTimeResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_followerRemainTimeInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MissionRemainTimeInfo>>> followerRemainTimeInfos) {
    fbb_.AddOffset(FollowerMissionRemainTimeResponse::VT_FOLLOWERREMAINTIMEINFOS, followerRemainTimeInfos);
  }
  explicit FollowerMissionRemainTimeResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FollowerMissionRemainTimeResponseBuilder &operator=(const FollowerMissionRemainTimeResponseBuilder &);
  flatbuffers::Offset<FollowerMissionRemainTimeResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FollowerMissionRemainTimeResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<FollowerMissionRemainTimeResponse> CreateFollowerMissionRemainTimeResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MissionRemainTimeInfo>>> followerRemainTimeInfos = 0) {
  FollowerMissionRemainTimeResponseBuilder builder_(_fbb);
  builder_.add_followerRemainTimeInfos(followerRemainTimeInfos);
  return builder_.Finish();
}

inline flatbuffers::Offset<FollowerMissionRemainTimeResponse> CreateFollowerMissionRemainTimeResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<MissionRemainTimeInfo>> *followerRemainTimeInfos = nullptr) {
  return LeanPacket::CreateFollowerMissionRemainTimeResponse(
      _fbb,
      followerRemainTimeInfos ? _fbb.CreateVector<flatbuffers::Offset<MissionRemainTimeInfo>>(*followerRemainTimeInfos) : 0);
}

/// FOLLOWER_MISSION_COMPLETE_REQUEST = 22037
struct FollowerMissionCompleteRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FOLLOWERID = 4
  };
  int32_t followerId() const {
    return GetField<int32_t>(VT_FOLLOWERID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FOLLOWERID) &&
           verifier.EndTable();
  }
};

struct FollowerMissionCompleteRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_followerId(int32_t followerId) {
    fbb_.AddElement<int32_t>(FollowerMissionCompleteRequest::VT_FOLLOWERID, followerId, 0);
  }
  explicit FollowerMissionCompleteRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FollowerMissionCompleteRequestBuilder &operator=(const FollowerMissionCompleteRequestBuilder &);
  flatbuffers::Offset<FollowerMissionCompleteRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FollowerMissionCompleteRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<FollowerMissionCompleteRequest> CreateFollowerMissionCompleteRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t followerId = 0) {
  FollowerMissionCompleteRequestBuilder builder_(_fbb);
  builder_.add_followerId(followerId);
  return builder_.Finish();
}

/// FOLLOWER_MISSION_COMPLETE_RESPONSE = 22038
struct FollowerMissionCompleteResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FOLLOWERID = 4,
    VT_RESULT = 6
  };
  int32_t followerId() const {
    return GetField<int32_t>(VT_FOLLOWERID, 0);
  }
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FOLLOWERID) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           verifier.EndTable();
  }
};

struct FollowerMissionCompleteResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_followerId(int32_t followerId) {
    fbb_.AddElement<int32_t>(FollowerMissionCompleteResponse::VT_FOLLOWERID, followerId, 0);
  }
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(FollowerMissionCompleteResponse::VT_RESULT, result, 0);
  }
  explicit FollowerMissionCompleteResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FollowerMissionCompleteResponseBuilder &operator=(const FollowerMissionCompleteResponseBuilder &);
  flatbuffers::Offset<FollowerMissionCompleteResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FollowerMissionCompleteResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<FollowerMissionCompleteResponse> CreateFollowerMissionCompleteResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t followerId = 0,
    int32_t result = 0) {
  FollowerMissionCompleteResponseBuilder builder_(_fbb);
  builder_.add_result(result);
  builder_.add_followerId(followerId);
  return builder_.Finish();
}

/// GAME_RECONNECT_REQUEST
struct GameReconnectRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GameReconnectRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GameReconnectRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GameReconnectRequestBuilder &operator=(const GameReconnectRequestBuilder &);
  flatbuffers::Offset<GameReconnectRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GameReconnectRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GameReconnectRequest> CreateGameReconnectRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GameReconnectRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// GAME_RECONNECT_RESPONSE
struct GameReconnectResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERROR = 4
  };
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           verifier.EndTable();
  }
};

struct GameReconnectResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(GameReconnectResponse::VT_ERROR, error, 0);
  }
  explicit GameReconnectResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GameReconnectResponseBuilder &operator=(const GameReconnectResponseBuilder &);
  flatbuffers::Offset<GameReconnectResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GameReconnectResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GameReconnectResponse> CreateGameReconnectResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t error = 0) {
  GameReconnectResponseBuilder builder_(_fbb);
  builder_.add_error(error);
  return builder_.Finish();
}

/// RECONNECT_LOAD_DATA_REQUEST
/// RECONNECT_LOAD_DATA_NOTIFY
///FOLLOWER_LOAD_INFO_NOTIFY
struct FollowerLoadInfoNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FOLLOWERS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<FollowerInfo>> *followers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FollowerInfo>> *>(VT_FOLLOWERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_FOLLOWERS) &&
           verifier.VerifyVector(followers()) &&
           verifier.VerifyVectorOfTables(followers()) &&
           verifier.EndTable();
  }
};

struct FollowerLoadInfoNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_followers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FollowerInfo>>> followers) {
    fbb_.AddOffset(FollowerLoadInfoNotify::VT_FOLLOWERS, followers);
  }
  explicit FollowerLoadInfoNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FollowerLoadInfoNotifyBuilder &operator=(const FollowerLoadInfoNotifyBuilder &);
  flatbuffers::Offset<FollowerLoadInfoNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FollowerLoadInfoNotify>(end);
    fbb_.Required(o, FollowerLoadInfoNotify::VT_FOLLOWERS);
    return o;
  }
};

inline flatbuffers::Offset<FollowerLoadInfoNotify> CreateFollowerLoadInfoNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FollowerInfo>>> followers = 0) {
  FollowerLoadInfoNotifyBuilder builder_(_fbb);
  builder_.add_followers(followers);
  return builder_.Finish();
}

inline flatbuffers::Offset<FollowerLoadInfoNotify> CreateFollowerLoadInfoNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FollowerInfo>> *followers = nullptr) {
  return LeanPacket::CreateFollowerLoadInfoNotify(
      _fbb,
      followers ? _fbb.CreateVector<flatbuffers::Offset<FollowerInfo>>(*followers) : 0);
}

struct ReconnectLoadDataRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LOADDATA = 4
  };
  const LoadData *loadData() const {
    return GetPointer<const LoadData *>(VT_LOADDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LOADDATA) &&
           verifier.VerifyTable(loadData()) &&
           verifier.EndTable();
  }
};

struct ReconnectLoadDataRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_loadData(flatbuffers::Offset<LoadData> loadData) {
    fbb_.AddOffset(ReconnectLoadDataRequest::VT_LOADDATA, loadData);
  }
  explicit ReconnectLoadDataRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReconnectLoadDataRequestBuilder &operator=(const ReconnectLoadDataRequestBuilder &);
  flatbuffers::Offset<ReconnectLoadDataRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReconnectLoadDataRequest>(end);
    fbb_.Required(o, ReconnectLoadDataRequest::VT_LOADDATA);
    return o;
  }
};

inline flatbuffers::Offset<ReconnectLoadDataRequest> CreateReconnectLoadDataRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LoadData> loadData = 0) {
  ReconnectLoadDataRequestBuilder builder_(_fbb);
  builder_.add_loadData(loadData);
  return builder_.Finish();
}

/// RECONNECT_LOAD_DATA_RESPONSE
struct ReconnectLoadDataResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SCENEID = 4,
    VT_POS = 6,
    VT_EVENTSETID = 8
  };
  int32_t sceneId() const {
    return GetField<int32_t>(VT_SCENEID, 0);
  }
  const Pos *pos() const {
    return GetPointer<const Pos *>(VT_POS);
  }
  int32_t eventSetId() const {
    return GetField<int32_t>(VT_EVENTSETID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SCENEID) &&
           VerifyOffsetRequired(verifier, VT_POS) &&
           verifier.VerifyTable(pos()) &&
           VerifyField<int32_t>(verifier, VT_EVENTSETID) &&
           verifier.EndTable();
  }
};

struct ReconnectLoadDataResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sceneId(int32_t sceneId) {
    fbb_.AddElement<int32_t>(ReconnectLoadDataResponse::VT_SCENEID, sceneId, 0);
  }
  void add_pos(flatbuffers::Offset<Pos> pos) {
    fbb_.AddOffset(ReconnectLoadDataResponse::VT_POS, pos);
  }
  void add_eventSetId(int32_t eventSetId) {
    fbb_.AddElement<int32_t>(ReconnectLoadDataResponse::VT_EVENTSETID, eventSetId, 0);
  }
  explicit ReconnectLoadDataResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReconnectLoadDataResponseBuilder &operator=(const ReconnectLoadDataResponseBuilder &);
  flatbuffers::Offset<ReconnectLoadDataResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReconnectLoadDataResponse>(end);
    fbb_.Required(o, ReconnectLoadDataResponse::VT_POS);
    return o;
  }
};

inline flatbuffers::Offset<ReconnectLoadDataResponse> CreateReconnectLoadDataResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t sceneId = 0,
    flatbuffers::Offset<Pos> pos = 0,
    int32_t eventSetId = 0) {
  ReconnectLoadDataResponseBuilder builder_(_fbb);
  builder_.add_eventSetId(eventSetId);
  builder_.add_pos(pos);
  builder_.add_sceneId(sceneId);
  return builder_.Finish();
}

/// LOAD_DATA_COMPLETE_NOTIFY
struct LoadDataCompleteNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LoadDataCompleteNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LoadDataCompleteNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LoadDataCompleteNotifyBuilder &operator=(const LoadDataCompleteNotifyBuilder &);
  flatbuffers::Offset<LoadDataCompleteNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LoadDataCompleteNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<LoadDataCompleteNotify> CreateLoadDataCompleteNotify(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LoadDataCompleteNotifyBuilder builder_(_fbb);
  return builder_.Finish();
}

///FOLLOWER_MISSION_REWARD_RESPONSE
struct FollowerMissionRewardResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FOLLOWERID = 4,
    VT_RESULT = 6
  };
  int32_t followerId() const {
    return GetField<int32_t>(VT_FOLLOWERID, 0);
  }
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FOLLOWERID) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           verifier.EndTable();
  }
};

struct FollowerMissionRewardResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_followerId(int32_t followerId) {
    fbb_.AddElement<int32_t>(FollowerMissionRewardResponse::VT_FOLLOWERID, followerId, 0);
  }
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(FollowerMissionRewardResponse::VT_RESULT, result, 0);
  }
  explicit FollowerMissionRewardResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FollowerMissionRewardResponseBuilder &operator=(const FollowerMissionRewardResponseBuilder &);
  flatbuffers::Offset<FollowerMissionRewardResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FollowerMissionRewardResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<FollowerMissionRewardResponse> CreateFollowerMissionRewardResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t followerId = 0,
    int32_t result = 0) {
  FollowerMissionRewardResponseBuilder builder_(_fbb);
  builder_.add_result(result);
  builder_.add_followerId(followerId);
  return builder_.Finish();
}

struct ArenaMemberBasic FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_ACCOUNTDBID = 6,
    VT_PCDBID = 8,
    VT_DBSEVERID = 10,
    VT_PCNAME = 12,
    VT_LEVEL = 14,
    VT_CLASSTYPE = 16,
    VT_COMBATPOWER = 18,
    VT_CUSTOMIZINGINFO = 20,
    VT_PARTS = 22,
    VT_COSTUMEPARTS = 24,
    VT_ARENARANKING = 26,
    VT_ABILITIES = 28
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int64_t accountDbId() const {
    return GetField<int64_t>(VT_ACCOUNTDBID, 0);
  }
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  int16_t dbSeverId() const {
    return GetField<int16_t>(VT_DBSEVERID, 0);
  }
  const flatbuffers::String *pcName() const {
    return GetPointer<const flatbuffers::String *>(VT_PCNAME);
  }
  int16_t level() const {
    return GetField<int16_t>(VT_LEVEL, 0);
  }
  int16_t classType() const {
    return GetField<int16_t>(VT_CLASSTYPE, 0);
  }
  int32_t combatPower() const {
    return GetField<int32_t>(VT_COMBATPOWER, 0);
  }
  const CustomizeInfo *customizingInfo() const {
    return GetPointer<const CustomizeInfo *>(VT_CUSTOMIZINGINFO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ItemPartsInfo>> *parts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ItemPartsInfo>> *>(VT_PARTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<CostumePartsInfo>> *costumeParts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CostumePartsInfo>> *>(VT_COSTUMEPARTS);
  }
  int32_t arenaRanking() const {
    return GetField<int32_t>(VT_ARENARANKING, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PcAbility>> *abilities() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PcAbility>> *>(VT_ABILITIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int64_t>(verifier, VT_ACCOUNTDBID) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           VerifyField<int16_t>(verifier, VT_DBSEVERID) &&
           VerifyOffsetRequired(verifier, VT_PCNAME) &&
           verifier.VerifyString(pcName()) &&
           VerifyField<int16_t>(verifier, VT_LEVEL) &&
           VerifyField<int16_t>(verifier, VT_CLASSTYPE) &&
           VerifyField<int32_t>(verifier, VT_COMBATPOWER) &&
           VerifyOffsetRequired(verifier, VT_CUSTOMIZINGINFO) &&
           verifier.VerifyTable(customizingInfo()) &&
           VerifyOffsetRequired(verifier, VT_PARTS) &&
           verifier.VerifyVector(parts()) &&
           verifier.VerifyVectorOfTables(parts()) &&
           VerifyOffsetRequired(verifier, VT_COSTUMEPARTS) &&
           verifier.VerifyVector(costumeParts()) &&
           verifier.VerifyVectorOfTables(costumeParts()) &&
           VerifyField<int32_t>(verifier, VT_ARENARANKING) &&
           VerifyOffset(verifier, VT_ABILITIES) &&
           verifier.VerifyVector(abilities()) &&
           verifier.VerifyVectorOfTables(abilities()) &&
           verifier.EndTable();
  }
};

struct ArenaMemberBasicBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(ArenaMemberBasic::VT_OBJECTID, objectId, 0);
  }
  void add_accountDbId(int64_t accountDbId) {
    fbb_.AddElement<int64_t>(ArenaMemberBasic::VT_ACCOUNTDBID, accountDbId, 0);
  }
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(ArenaMemberBasic::VT_PCDBID, pcDbId, 0);
  }
  void add_dbSeverId(int16_t dbSeverId) {
    fbb_.AddElement<int16_t>(ArenaMemberBasic::VT_DBSEVERID, dbSeverId, 0);
  }
  void add_pcName(flatbuffers::Offset<flatbuffers::String> pcName) {
    fbb_.AddOffset(ArenaMemberBasic::VT_PCNAME, pcName);
  }
  void add_level(int16_t level) {
    fbb_.AddElement<int16_t>(ArenaMemberBasic::VT_LEVEL, level, 0);
  }
  void add_classType(int16_t classType) {
    fbb_.AddElement<int16_t>(ArenaMemberBasic::VT_CLASSTYPE, classType, 0);
  }
  void add_combatPower(int32_t combatPower) {
    fbb_.AddElement<int32_t>(ArenaMemberBasic::VT_COMBATPOWER, combatPower, 0);
  }
  void add_customizingInfo(flatbuffers::Offset<CustomizeInfo> customizingInfo) {
    fbb_.AddOffset(ArenaMemberBasic::VT_CUSTOMIZINGINFO, customizingInfo);
  }
  void add_parts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ItemPartsInfo>>> parts) {
    fbb_.AddOffset(ArenaMemberBasic::VT_PARTS, parts);
  }
  void add_costumeParts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CostumePartsInfo>>> costumeParts) {
    fbb_.AddOffset(ArenaMemberBasic::VT_COSTUMEPARTS, costumeParts);
  }
  void add_arenaRanking(int32_t arenaRanking) {
    fbb_.AddElement<int32_t>(ArenaMemberBasic::VT_ARENARANKING, arenaRanking, 0);
  }
  void add_abilities(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PcAbility>>> abilities) {
    fbb_.AddOffset(ArenaMemberBasic::VT_ABILITIES, abilities);
  }
  explicit ArenaMemberBasicBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArenaMemberBasicBuilder &operator=(const ArenaMemberBasicBuilder &);
  flatbuffers::Offset<ArenaMemberBasic> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArenaMemberBasic>(end);
    fbb_.Required(o, ArenaMemberBasic::VT_PCNAME);
    fbb_.Required(o, ArenaMemberBasic::VT_CUSTOMIZINGINFO);
    fbb_.Required(o, ArenaMemberBasic::VT_PARTS);
    fbb_.Required(o, ArenaMemberBasic::VT_COSTUMEPARTS);
    return o;
  }
};

inline flatbuffers::Offset<ArenaMemberBasic> CreateArenaMemberBasic(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int64_t accountDbId = 0,
    int64_t pcDbId = 0,
    int16_t dbSeverId = 0,
    flatbuffers::Offset<flatbuffers::String> pcName = 0,
    int16_t level = 0,
    int16_t classType = 0,
    int32_t combatPower = 0,
    flatbuffers::Offset<CustomizeInfo> customizingInfo = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ItemPartsInfo>>> parts = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CostumePartsInfo>>> costumeParts = 0,
    int32_t arenaRanking = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PcAbility>>> abilities = 0) {
  ArenaMemberBasicBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  builder_.add_accountDbId(accountDbId);
  builder_.add_objectId(objectId);
  builder_.add_abilities(abilities);
  builder_.add_arenaRanking(arenaRanking);
  builder_.add_costumeParts(costumeParts);
  builder_.add_parts(parts);
  builder_.add_customizingInfo(customizingInfo);
  builder_.add_combatPower(combatPower);
  builder_.add_pcName(pcName);
  builder_.add_classType(classType);
  builder_.add_level(level);
  builder_.add_dbSeverId(dbSeverId);
  return builder_.Finish();
}

inline flatbuffers::Offset<ArenaMemberBasic> CreateArenaMemberBasicDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int64_t accountDbId = 0,
    int64_t pcDbId = 0,
    int16_t dbSeverId = 0,
    const char *pcName = nullptr,
    int16_t level = 0,
    int16_t classType = 0,
    int32_t combatPower = 0,
    flatbuffers::Offset<CustomizeInfo> customizingInfo = 0,
    const std::vector<flatbuffers::Offset<ItemPartsInfo>> *parts = nullptr,
    const std::vector<flatbuffers::Offset<CostumePartsInfo>> *costumeParts = nullptr,
    int32_t arenaRanking = 0,
    const std::vector<flatbuffers::Offset<PcAbility>> *abilities = nullptr) {
  return LeanPacket::CreateArenaMemberBasic(
      _fbb,
      objectId,
      accountDbId,
      pcDbId,
      dbSeverId,
      pcName ? _fbb.CreateString(pcName) : 0,
      level,
      classType,
      combatPower,
      customizingInfo,
      parts ? _fbb.CreateVector<flatbuffers::Offset<ItemPartsInfo>>(*parts) : 0,
      costumeParts ? _fbb.CreateVector<flatbuffers::Offset<CostumePartsInfo>>(*costumeParts) : 0,
      arenaRanking,
      abilities ? _fbb.CreateVector<flatbuffers::Offset<PcAbility>>(*abilities) : 0);
}

struct ArenaMember FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_ACCOUNTDBID = 6,
    VT_PCDBID = 8,
    VT_DBSEVERID = 10,
    VT_PCNAME = 12,
    VT_LEVEL = 14,
    VT_CLASSTYPE = 16,
    VT_COMBATPOWER = 18,
    VT_CUSTOMIZINGINFO = 20,
    VT_PARTS = 22,
    VT_COSTUMEPARTS = 24,
    VT_ARENARANKING = 26,
    VT_ANGLE = 28
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int64_t accountDbId() const {
    return GetField<int64_t>(VT_ACCOUNTDBID, 0);
  }
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  int16_t dbSeverId() const {
    return GetField<int16_t>(VT_DBSEVERID, 0);
  }
  const flatbuffers::String *pcName() const {
    return GetPointer<const flatbuffers::String *>(VT_PCNAME);
  }
  int16_t level() const {
    return GetField<int16_t>(VT_LEVEL, 0);
  }
  int16_t classType() const {
    return GetField<int16_t>(VT_CLASSTYPE, 0);
  }
  int32_t combatPower() const {
    return GetField<int32_t>(VT_COMBATPOWER, 0);
  }
  const CustomizeInfo *customizingInfo() const {
    return GetPointer<const CustomizeInfo *>(VT_CUSTOMIZINGINFO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ItemPartsInfo>> *parts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ItemPartsInfo>> *>(VT_PARTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<CostumePartsInfo>> *costumeParts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CostumePartsInfo>> *>(VT_COSTUMEPARTS);
  }
  int32_t arenaRanking() const {
    return GetField<int32_t>(VT_ARENARANKING, 0);
  }
  int16_t angle() const {
    return GetField<int16_t>(VT_ANGLE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int64_t>(verifier, VT_ACCOUNTDBID) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           VerifyField<int16_t>(verifier, VT_DBSEVERID) &&
           VerifyOffsetRequired(verifier, VT_PCNAME) &&
           verifier.VerifyString(pcName()) &&
           VerifyField<int16_t>(verifier, VT_LEVEL) &&
           VerifyField<int16_t>(verifier, VT_CLASSTYPE) &&
           VerifyField<int32_t>(verifier, VT_COMBATPOWER) &&
           VerifyOffsetRequired(verifier, VT_CUSTOMIZINGINFO) &&
           verifier.VerifyTable(customizingInfo()) &&
           VerifyOffsetRequired(verifier, VT_PARTS) &&
           verifier.VerifyVector(parts()) &&
           verifier.VerifyVectorOfTables(parts()) &&
           VerifyOffsetRequired(verifier, VT_COSTUMEPARTS) &&
           verifier.VerifyVector(costumeParts()) &&
           verifier.VerifyVectorOfTables(costumeParts()) &&
           VerifyField<int32_t>(verifier, VT_ARENARANKING) &&
           VerifyField<int16_t>(verifier, VT_ANGLE) &&
           verifier.EndTable();
  }
};

struct ArenaMemberBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(ArenaMember::VT_OBJECTID, objectId, 0);
  }
  void add_accountDbId(int64_t accountDbId) {
    fbb_.AddElement<int64_t>(ArenaMember::VT_ACCOUNTDBID, accountDbId, 0);
  }
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(ArenaMember::VT_PCDBID, pcDbId, 0);
  }
  void add_dbSeverId(int16_t dbSeverId) {
    fbb_.AddElement<int16_t>(ArenaMember::VT_DBSEVERID, dbSeverId, 0);
  }
  void add_pcName(flatbuffers::Offset<flatbuffers::String> pcName) {
    fbb_.AddOffset(ArenaMember::VT_PCNAME, pcName);
  }
  void add_level(int16_t level) {
    fbb_.AddElement<int16_t>(ArenaMember::VT_LEVEL, level, 0);
  }
  void add_classType(int16_t classType) {
    fbb_.AddElement<int16_t>(ArenaMember::VT_CLASSTYPE, classType, 0);
  }
  void add_combatPower(int32_t combatPower) {
    fbb_.AddElement<int32_t>(ArenaMember::VT_COMBATPOWER, combatPower, 0);
  }
  void add_customizingInfo(flatbuffers::Offset<CustomizeInfo> customizingInfo) {
    fbb_.AddOffset(ArenaMember::VT_CUSTOMIZINGINFO, customizingInfo);
  }
  void add_parts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ItemPartsInfo>>> parts) {
    fbb_.AddOffset(ArenaMember::VT_PARTS, parts);
  }
  void add_costumeParts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CostumePartsInfo>>> costumeParts) {
    fbb_.AddOffset(ArenaMember::VT_COSTUMEPARTS, costumeParts);
  }
  void add_arenaRanking(int32_t arenaRanking) {
    fbb_.AddElement<int32_t>(ArenaMember::VT_ARENARANKING, arenaRanking, 0);
  }
  void add_angle(int16_t angle) {
    fbb_.AddElement<int16_t>(ArenaMember::VT_ANGLE, angle, 0);
  }
  explicit ArenaMemberBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArenaMemberBuilder &operator=(const ArenaMemberBuilder &);
  flatbuffers::Offset<ArenaMember> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArenaMember>(end);
    fbb_.Required(o, ArenaMember::VT_PCNAME);
    fbb_.Required(o, ArenaMember::VT_CUSTOMIZINGINFO);
    fbb_.Required(o, ArenaMember::VT_PARTS);
    fbb_.Required(o, ArenaMember::VT_COSTUMEPARTS);
    return o;
  }
};

inline flatbuffers::Offset<ArenaMember> CreateArenaMember(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int64_t accountDbId = 0,
    int64_t pcDbId = 0,
    int16_t dbSeverId = 0,
    flatbuffers::Offset<flatbuffers::String> pcName = 0,
    int16_t level = 0,
    int16_t classType = 0,
    int32_t combatPower = 0,
    flatbuffers::Offset<CustomizeInfo> customizingInfo = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ItemPartsInfo>>> parts = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CostumePartsInfo>>> costumeParts = 0,
    int32_t arenaRanking = 0,
    int16_t angle = 0) {
  ArenaMemberBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  builder_.add_accountDbId(accountDbId);
  builder_.add_objectId(objectId);
  builder_.add_arenaRanking(arenaRanking);
  builder_.add_costumeParts(costumeParts);
  builder_.add_parts(parts);
  builder_.add_customizingInfo(customizingInfo);
  builder_.add_combatPower(combatPower);
  builder_.add_pcName(pcName);
  builder_.add_angle(angle);
  builder_.add_classType(classType);
  builder_.add_level(level);
  builder_.add_dbSeverId(dbSeverId);
  return builder_.Finish();
}

inline flatbuffers::Offset<ArenaMember> CreateArenaMemberDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int64_t accountDbId = 0,
    int64_t pcDbId = 0,
    int16_t dbSeverId = 0,
    const char *pcName = nullptr,
    int16_t level = 0,
    int16_t classType = 0,
    int32_t combatPower = 0,
    flatbuffers::Offset<CustomizeInfo> customizingInfo = 0,
    const std::vector<flatbuffers::Offset<ItemPartsInfo>> *parts = nullptr,
    const std::vector<flatbuffers::Offset<CostumePartsInfo>> *costumeParts = nullptr,
    int32_t arenaRanking = 0,
    int16_t angle = 0) {
  return LeanPacket::CreateArenaMember(
      _fbb,
      objectId,
      accountDbId,
      pcDbId,
      dbSeverId,
      pcName ? _fbb.CreateString(pcName) : 0,
      level,
      classType,
      combatPower,
      customizingInfo,
      parts ? _fbb.CreateVector<flatbuffers::Offset<ItemPartsInfo>>(*parts) : 0,
      costumeParts ? _fbb.CreateVector<flatbuffers::Offset<CostumePartsInfo>>(*costumeParts) : 0,
      arenaRanking,
      angle);
}

struct ArenaMemberDetail FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_ACCOUNTDBID = 6,
    VT_PCDBID = 8,
    VT_DBSEVERID = 10,
    VT_PCNAME = 12,
    VT_LEVEL = 14,
    VT_CLASSTYPE = 16,
    VT_COMBATPOWER = 18
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int64_t accountDbId() const {
    return GetField<int64_t>(VT_ACCOUNTDBID, 0);
  }
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  int16_t dbSeverId() const {
    return GetField<int16_t>(VT_DBSEVERID, 0);
  }
  const flatbuffers::String *pcName() const {
    return GetPointer<const flatbuffers::String *>(VT_PCNAME);
  }
  int16_t level() const {
    return GetField<int16_t>(VT_LEVEL, 0);
  }
  int16_t classType() const {
    return GetField<int16_t>(VT_CLASSTYPE, 0);
  }
  int32_t combatPower() const {
    return GetField<int32_t>(VT_COMBATPOWER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int64_t>(verifier, VT_ACCOUNTDBID) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           VerifyField<int16_t>(verifier, VT_DBSEVERID) &&
           VerifyOffsetRequired(verifier, VT_PCNAME) &&
           verifier.VerifyString(pcName()) &&
           VerifyField<int16_t>(verifier, VT_LEVEL) &&
           VerifyField<int16_t>(verifier, VT_CLASSTYPE) &&
           VerifyField<int32_t>(verifier, VT_COMBATPOWER) &&
           verifier.EndTable();
  }
};

struct ArenaMemberDetailBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(ArenaMemberDetail::VT_OBJECTID, objectId, 0);
  }
  void add_accountDbId(int64_t accountDbId) {
    fbb_.AddElement<int64_t>(ArenaMemberDetail::VT_ACCOUNTDBID, accountDbId, 0);
  }
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(ArenaMemberDetail::VT_PCDBID, pcDbId, 0);
  }
  void add_dbSeverId(int16_t dbSeverId) {
    fbb_.AddElement<int16_t>(ArenaMemberDetail::VT_DBSEVERID, dbSeverId, 0);
  }
  void add_pcName(flatbuffers::Offset<flatbuffers::String> pcName) {
    fbb_.AddOffset(ArenaMemberDetail::VT_PCNAME, pcName);
  }
  void add_level(int16_t level) {
    fbb_.AddElement<int16_t>(ArenaMemberDetail::VT_LEVEL, level, 0);
  }
  void add_classType(int16_t classType) {
    fbb_.AddElement<int16_t>(ArenaMemberDetail::VT_CLASSTYPE, classType, 0);
  }
  void add_combatPower(int32_t combatPower) {
    fbb_.AddElement<int32_t>(ArenaMemberDetail::VT_COMBATPOWER, combatPower, 0);
  }
  explicit ArenaMemberDetailBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArenaMemberDetailBuilder &operator=(const ArenaMemberDetailBuilder &);
  flatbuffers::Offset<ArenaMemberDetail> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArenaMemberDetail>(end);
    fbb_.Required(o, ArenaMemberDetail::VT_PCNAME);
    return o;
  }
};

inline flatbuffers::Offset<ArenaMemberDetail> CreateArenaMemberDetail(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int64_t accountDbId = 0,
    int64_t pcDbId = 0,
    int16_t dbSeverId = 0,
    flatbuffers::Offset<flatbuffers::String> pcName = 0,
    int16_t level = 0,
    int16_t classType = 0,
    int32_t combatPower = 0) {
  ArenaMemberDetailBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  builder_.add_accountDbId(accountDbId);
  builder_.add_objectId(objectId);
  builder_.add_combatPower(combatPower);
  builder_.add_pcName(pcName);
  builder_.add_classType(classType);
  builder_.add_level(level);
  builder_.add_dbSeverId(dbSeverId);
  return builder_.Finish();
}

inline flatbuffers::Offset<ArenaMemberDetail> CreateArenaMemberDetailDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int64_t accountDbId = 0,
    int64_t pcDbId = 0,
    int16_t dbSeverId = 0,
    const char *pcName = nullptr,
    int16_t level = 0,
    int16_t classType = 0,
    int32_t combatPower = 0) {
  return LeanPacket::CreateArenaMemberDetail(
      _fbb,
      objectId,
      accountDbId,
      pcDbId,
      dbSeverId,
      pcName ? _fbb.CreateString(pcName) : 0,
      level,
      classType,
      combatPower);
}

struct ArenaTeamClass FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CLASSTYPE0 = 4,
    VT_CLASSTYPE1 = 6,
    VT_CLASSTYPE2 = 8
  };
  int16_t classType0() const {
    return GetField<int16_t>(VT_CLASSTYPE0, 0);
  }
  int16_t classType1() const {
    return GetField<int16_t>(VT_CLASSTYPE1, 0);
  }
  int16_t classType2() const {
    return GetField<int16_t>(VT_CLASSTYPE2, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_CLASSTYPE0) &&
           VerifyField<int16_t>(verifier, VT_CLASSTYPE1) &&
           VerifyField<int16_t>(verifier, VT_CLASSTYPE2) &&
           verifier.EndTable();
  }
};

struct ArenaTeamClassBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_classType0(int16_t classType0) {
    fbb_.AddElement<int16_t>(ArenaTeamClass::VT_CLASSTYPE0, classType0, 0);
  }
  void add_classType1(int16_t classType1) {
    fbb_.AddElement<int16_t>(ArenaTeamClass::VT_CLASSTYPE1, classType1, 0);
  }
  void add_classType2(int16_t classType2) {
    fbb_.AddElement<int16_t>(ArenaTeamClass::VT_CLASSTYPE2, classType2, 0);
  }
  explicit ArenaTeamClassBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArenaTeamClassBuilder &operator=(const ArenaTeamClassBuilder &);
  flatbuffers::Offset<ArenaTeamClass> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArenaTeamClass>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArenaTeamClass> CreateArenaTeamClass(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t classType0 = 0,
    int16_t classType1 = 0,
    int16_t classType2 = 0) {
  ArenaTeamClassBuilder builder_(_fbb);
  builder_.add_classType2(classType2);
  builder_.add_classType1(classType1);
  builder_.add_classType0(classType0);
  return builder_.Finish();
}

/// pc Ranking detail info
struct PcRankInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCNAME = 4,
    VT_LEVEL = 6,
    VT_RANK = 8,
    VT_GUILDID = 10,
    VT_CLASSTYPE = 12,
    VT_SCORE = 14,
    VT_PCDBID = 16,
    VT_INFLUENCELEVEL = 18,
    VT_INFLUENCETIER = 20,
    VT_PCGUILDINFO = 22
  };
  const flatbuffers::String *pcName() const {
    return GetPointer<const flatbuffers::String *>(VT_PCNAME);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int32_t rank() const {
    return GetField<int32_t>(VT_RANK, 0);
  }
  int64_t guildId() const {
    return GetField<int64_t>(VT_GUILDID, 0);
  }
  int16_t classType() const {
    return GetField<int16_t>(VT_CLASSTYPE, 0);
  }
  int32_t score() const {
    return GetField<int32_t>(VT_SCORE, 0);
  }
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  int16_t influenceLevel() const {
    return GetField<int16_t>(VT_INFLUENCELEVEL, 0);
  }
  int16_t influenceTier() const {
    return GetField<int16_t>(VT_INFLUENCETIER, 0);
  }
  const PcGuildInfo *pcGuildInfo() const {
    return GetPointer<const PcGuildInfo *>(VT_PCGUILDINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PCNAME) &&
           verifier.VerifyString(pcName()) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_RANK) &&
           VerifyField<int64_t>(verifier, VT_GUILDID) &&
           VerifyField<int16_t>(verifier, VT_CLASSTYPE) &&
           VerifyField<int32_t>(verifier, VT_SCORE) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           VerifyField<int16_t>(verifier, VT_INFLUENCELEVEL) &&
           VerifyField<int16_t>(verifier, VT_INFLUENCETIER) &&
           VerifyOffset(verifier, VT_PCGUILDINFO) &&
           verifier.VerifyTable(pcGuildInfo()) &&
           verifier.EndTable();
  }
};

struct PcRankInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcName(flatbuffers::Offset<flatbuffers::String> pcName) {
    fbb_.AddOffset(PcRankInfo::VT_PCNAME, pcName);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(PcRankInfo::VT_LEVEL, level, 0);
  }
  void add_rank(int32_t rank) {
    fbb_.AddElement<int32_t>(PcRankInfo::VT_RANK, rank, 0);
  }
  void add_guildId(int64_t guildId) {
    fbb_.AddElement<int64_t>(PcRankInfo::VT_GUILDID, guildId, 0);
  }
  void add_classType(int16_t classType) {
    fbb_.AddElement<int16_t>(PcRankInfo::VT_CLASSTYPE, classType, 0);
  }
  void add_score(int32_t score) {
    fbb_.AddElement<int32_t>(PcRankInfo::VT_SCORE, score, 0);
  }
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(PcRankInfo::VT_PCDBID, pcDbId, 0);
  }
  void add_influenceLevel(int16_t influenceLevel) {
    fbb_.AddElement<int16_t>(PcRankInfo::VT_INFLUENCELEVEL, influenceLevel, 0);
  }
  void add_influenceTier(int16_t influenceTier) {
    fbb_.AddElement<int16_t>(PcRankInfo::VT_INFLUENCETIER, influenceTier, 0);
  }
  void add_pcGuildInfo(flatbuffers::Offset<PcGuildInfo> pcGuildInfo) {
    fbb_.AddOffset(PcRankInfo::VT_PCGUILDINFO, pcGuildInfo);
  }
  explicit PcRankInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PcRankInfoBuilder &operator=(const PcRankInfoBuilder &);
  flatbuffers::Offset<PcRankInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PcRankInfo>(end);
    fbb_.Required(o, PcRankInfo::VT_PCNAME);
    return o;
  }
};

inline flatbuffers::Offset<PcRankInfo> CreatePcRankInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> pcName = 0,
    int32_t level = 0,
    int32_t rank = 0,
    int64_t guildId = 0,
    int16_t classType = 0,
    int32_t score = 0,
    int64_t pcDbId = 0,
    int16_t influenceLevel = 0,
    int16_t influenceTier = 0,
    flatbuffers::Offset<PcGuildInfo> pcGuildInfo = 0) {
  PcRankInfoBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  builder_.add_guildId(guildId);
  builder_.add_pcGuildInfo(pcGuildInfo);
  builder_.add_score(score);
  builder_.add_rank(rank);
  builder_.add_level(level);
  builder_.add_pcName(pcName);
  builder_.add_influenceTier(influenceTier);
  builder_.add_influenceLevel(influenceLevel);
  builder_.add_classType(classType);
  return builder_.Finish();
}

inline flatbuffers::Offset<PcRankInfo> CreatePcRankInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *pcName = nullptr,
    int32_t level = 0,
    int32_t rank = 0,
    int64_t guildId = 0,
    int16_t classType = 0,
    int32_t score = 0,
    int64_t pcDbId = 0,
    int16_t influenceLevel = 0,
    int16_t influenceTier = 0,
    flatbuffers::Offset<PcGuildInfo> pcGuildInfo = 0) {
  return LeanPacket::CreatePcRankInfo(
      _fbb,
      pcName ? _fbb.CreateString(pcName) : 0,
      level,
      rank,
      guildId,
      classType,
      score,
      pcDbId,
      influenceLevel,
      influenceTier,
      pcGuildInfo);
}

struct OtherPcItemInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EQUIPITEMINFO = 4,
    VT_LINKITEMINFO = 6
  };
  const ClientLItem *EquipItemInfo() const {
    return GetPointer<const ClientLItem *>(VT_EQUIPITEMINFO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ClientLItem>> *LinkItemInfo() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ClientLItem>> *>(VT_LINKITEMINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EQUIPITEMINFO) &&
           verifier.VerifyTable(EquipItemInfo()) &&
           VerifyOffset(verifier, VT_LINKITEMINFO) &&
           verifier.VerifyVector(LinkItemInfo()) &&
           verifier.VerifyVectorOfTables(LinkItemInfo()) &&
           verifier.EndTable();
  }
};

struct OtherPcItemInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_EquipItemInfo(flatbuffers::Offset<ClientLItem> EquipItemInfo) {
    fbb_.AddOffset(OtherPcItemInfo::VT_EQUIPITEMINFO, EquipItemInfo);
  }
  void add_LinkItemInfo(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ClientLItem>>> LinkItemInfo) {
    fbb_.AddOffset(OtherPcItemInfo::VT_LINKITEMINFO, LinkItemInfo);
  }
  explicit OtherPcItemInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OtherPcItemInfoBuilder &operator=(const OtherPcItemInfoBuilder &);
  flatbuffers::Offset<OtherPcItemInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OtherPcItemInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<OtherPcItemInfo> CreateOtherPcItemInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ClientLItem> EquipItemInfo = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ClientLItem>>> LinkItemInfo = 0) {
  OtherPcItemInfoBuilder builder_(_fbb);
  builder_.add_LinkItemInfo(LinkItemInfo);
  builder_.add_EquipItemInfo(EquipItemInfo);
  return builder_.Finish();
}

inline flatbuffers::Offset<OtherPcItemInfo> CreateOtherPcItemInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ClientLItem> EquipItemInfo = 0,
    const std::vector<flatbuffers::Offset<ClientLItem>> *LinkItemInfo = nullptr) {
  return LeanPacket::CreateOtherPcItemInfo(
      _fbb,
      EquipItemInfo,
      LinkItemInfo ? _fbb.CreateVector<flatbuffers::Offset<ClientLItem>>(*LinkItemInfo) : 0);
}

struct OtherPcCostumeInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EQUIPITEMINFO = 4,
    VT_ISVISIBLE = 6
  };
  const ClientLItem *EquipItemInfo() const {
    return GetPointer<const ClientLItem *>(VT_EQUIPITEMINFO);
  }
  bool isVisible() const {
    return GetField<uint8_t>(VT_ISVISIBLE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EQUIPITEMINFO) &&
           verifier.VerifyTable(EquipItemInfo()) &&
           VerifyField<uint8_t>(verifier, VT_ISVISIBLE) &&
           verifier.EndTable();
  }
};

struct OtherPcCostumeInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_EquipItemInfo(flatbuffers::Offset<ClientLItem> EquipItemInfo) {
    fbb_.AddOffset(OtherPcCostumeInfo::VT_EQUIPITEMINFO, EquipItemInfo);
  }
  void add_isVisible(bool isVisible) {
    fbb_.AddElement<uint8_t>(OtherPcCostumeInfo::VT_ISVISIBLE, static_cast<uint8_t>(isVisible), 0);
  }
  explicit OtherPcCostumeInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OtherPcCostumeInfoBuilder &operator=(const OtherPcCostumeInfoBuilder &);
  flatbuffers::Offset<OtherPcCostumeInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OtherPcCostumeInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<OtherPcCostumeInfo> CreateOtherPcCostumeInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ClientLItem> EquipItemInfo = 0,
    bool isVisible = false) {
  OtherPcCostumeInfoBuilder builder_(_fbb);
  builder_.add_EquipItemInfo(EquipItemInfo);
  builder_.add_isVisible(isVisible);
  return builder_.Finish();
}

/// ARENA_TEAM_REQUEST
struct ArenaTeamRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ArenaTeamRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ArenaTeamRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArenaTeamRequestBuilder &operator=(const ArenaTeamRequestBuilder &);
  flatbuffers::Offset<ArenaTeamRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArenaTeamRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArenaTeamRequest> CreateArenaTeamRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ArenaTeamRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// ARENA_TEAM_RESPONSE
struct ArenaTeamResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULT = 4,
    VT_TEAMA = 6,
    VT_TEAMB = 8
  };
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ArenaMember>> *teamA() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ArenaMember>> *>(VT_TEAMA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ArenaMember>> *teamB() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ArenaMember>> *>(VT_TEAMB);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           VerifyOffset(verifier, VT_TEAMA) &&
           verifier.VerifyVector(teamA()) &&
           verifier.VerifyVectorOfTables(teamA()) &&
           VerifyOffset(verifier, VT_TEAMB) &&
           verifier.VerifyVector(teamB()) &&
           verifier.VerifyVectorOfTables(teamB()) &&
           verifier.EndTable();
  }
};

struct ArenaTeamResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(ArenaTeamResponse::VT_RESULT, result, 0);
  }
  void add_teamA(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ArenaMember>>> teamA) {
    fbb_.AddOffset(ArenaTeamResponse::VT_TEAMA, teamA);
  }
  void add_teamB(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ArenaMember>>> teamB) {
    fbb_.AddOffset(ArenaTeamResponse::VT_TEAMB, teamB);
  }
  explicit ArenaTeamResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArenaTeamResponseBuilder &operator=(const ArenaTeamResponseBuilder &);
  flatbuffers::Offset<ArenaTeamResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArenaTeamResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArenaTeamResponse> CreateArenaTeamResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ArenaMember>>> teamA = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ArenaMember>>> teamB = 0) {
  ArenaTeamResponseBuilder builder_(_fbb);
  builder_.add_teamB(teamB);
  builder_.add_teamA(teamA);
  builder_.add_result(result);
  return builder_.Finish();
}

inline flatbuffers::Offset<ArenaTeamResponse> CreateArenaTeamResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    const std::vector<flatbuffers::Offset<ArenaMember>> *teamA = nullptr,
    const std::vector<flatbuffers::Offset<ArenaMember>> *teamB = nullptr) {
  return LeanPacket::CreateArenaTeamResponse(
      _fbb,
      result,
      teamA ? _fbb.CreateVector<flatbuffers::Offset<ArenaMember>>(*teamA) : 0,
      teamB ? _fbb.CreateVector<flatbuffers::Offset<ArenaMember>>(*teamB) : 0);
}

/// ARENA_TEAM_REFRESH_REQUEST
struct ArenaTeamRefreshRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ArenaTeamRefreshRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ArenaTeamRefreshRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArenaTeamRefreshRequestBuilder &operator=(const ArenaTeamRefreshRequestBuilder &);
  flatbuffers::Offset<ArenaTeamRefreshRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArenaTeamRefreshRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArenaTeamRefreshRequest> CreateArenaTeamRefreshRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ArenaTeamRefreshRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// ARENA_TEAM_REFRESH_RESPONSE
struct ArenaTeamRefreshResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULT = 4,
    VT_INFO = 6,
    VT_TEAMB = 8
  };
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  const ArenaInfo *info() const {
    return GetPointer<const ArenaInfo *>(VT_INFO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ArenaMember>> *teamB() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ArenaMember>> *>(VT_TEAMB);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           VerifyOffset(verifier, VT_TEAMB) &&
           verifier.VerifyVector(teamB()) &&
           verifier.VerifyVectorOfTables(teamB()) &&
           verifier.EndTable();
  }
};

struct ArenaTeamRefreshResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(ArenaTeamRefreshResponse::VT_RESULT, result, 0);
  }
  void add_info(flatbuffers::Offset<ArenaInfo> info) {
    fbb_.AddOffset(ArenaTeamRefreshResponse::VT_INFO, info);
  }
  void add_teamB(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ArenaMember>>> teamB) {
    fbb_.AddOffset(ArenaTeamRefreshResponse::VT_TEAMB, teamB);
  }
  explicit ArenaTeamRefreshResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArenaTeamRefreshResponseBuilder &operator=(const ArenaTeamRefreshResponseBuilder &);
  flatbuffers::Offset<ArenaTeamRefreshResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArenaTeamRefreshResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArenaTeamRefreshResponse> CreateArenaTeamRefreshResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    flatbuffers::Offset<ArenaInfo> info = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ArenaMember>>> teamB = 0) {
  ArenaTeamRefreshResponseBuilder builder_(_fbb);
  builder_.add_teamB(teamB);
  builder_.add_info(info);
  builder_.add_result(result);
  return builder_.Finish();
}

inline flatbuffers::Offset<ArenaTeamRefreshResponse> CreateArenaTeamRefreshResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    flatbuffers::Offset<ArenaInfo> info = 0,
    const std::vector<flatbuffers::Offset<ArenaMember>> *teamB = nullptr) {
  return LeanPacket::CreateArenaTeamRefreshResponse(
      _fbb,
      result,
      info,
      teamB ? _fbb.CreateVector<flatbuffers::Offset<ArenaMember>>(*teamB) : 0);
}

/// ARENA_JOIN_REQUEST
struct ArenaJoinRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SPENDTYPE = 4
  };
  ArenaSpendType spendType() const {
    return static_cast<ArenaSpendType>(GetField<int16_t>(VT_SPENDTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_SPENDTYPE) &&
           verifier.EndTable();
  }
};

struct ArenaJoinRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_spendType(ArenaSpendType spendType) {
    fbb_.AddElement<int16_t>(ArenaJoinRequest::VT_SPENDTYPE, static_cast<int16_t>(spendType), 0);
  }
  explicit ArenaJoinRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArenaJoinRequestBuilder &operator=(const ArenaJoinRequestBuilder &);
  flatbuffers::Offset<ArenaJoinRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArenaJoinRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArenaJoinRequest> CreateArenaJoinRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    ArenaSpendType spendType = ArenaSpendType_ArenaSpendType_freeTicket) {
  ArenaJoinRequestBuilder builder_(_fbb);
  builder_.add_spendType(spendType);
  return builder_.Finish();
}

/// ARENA_JOIN_RESPONSE
struct ArenaJoinResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULT = 4,
    VT_SPENDTYPE = 6,
    VT_SPENDTICKET = 8,
    VT_FREETICKET = 10,
    VT_PAIDTICKET = 12,
    VT_SPENDDIA = 14,
    VT_TOTALDIA = 16
  };
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  ArenaSpendType spendType() const {
    return static_cast<ArenaSpendType>(GetField<int16_t>(VT_SPENDTYPE, 0));
  }
  int32_t spendTicket() const {
    return GetField<int32_t>(VT_SPENDTICKET, 0);
  }
  int32_t freeTicket() const {
    return GetField<int32_t>(VT_FREETICKET, 0);
  }
  int32_t paidTicket() const {
    return GetField<int32_t>(VT_PAIDTICKET, 0);
  }
  int32_t spendDia() const {
    return GetField<int32_t>(VT_SPENDDIA, 0);
  }
  int32_t totalDia() const {
    return GetField<int32_t>(VT_TOTALDIA, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           VerifyField<int16_t>(verifier, VT_SPENDTYPE) &&
           VerifyField<int32_t>(verifier, VT_SPENDTICKET) &&
           VerifyField<int32_t>(verifier, VT_FREETICKET) &&
           VerifyField<int32_t>(verifier, VT_PAIDTICKET) &&
           VerifyField<int32_t>(verifier, VT_SPENDDIA) &&
           VerifyField<int32_t>(verifier, VT_TOTALDIA) &&
           verifier.EndTable();
  }
};

struct ArenaJoinResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(ArenaJoinResponse::VT_RESULT, result, 0);
  }
  void add_spendType(ArenaSpendType spendType) {
    fbb_.AddElement<int16_t>(ArenaJoinResponse::VT_SPENDTYPE, static_cast<int16_t>(spendType), 0);
  }
  void add_spendTicket(int32_t spendTicket) {
    fbb_.AddElement<int32_t>(ArenaJoinResponse::VT_SPENDTICKET, spendTicket, 0);
  }
  void add_freeTicket(int32_t freeTicket) {
    fbb_.AddElement<int32_t>(ArenaJoinResponse::VT_FREETICKET, freeTicket, 0);
  }
  void add_paidTicket(int32_t paidTicket) {
    fbb_.AddElement<int32_t>(ArenaJoinResponse::VT_PAIDTICKET, paidTicket, 0);
  }
  void add_spendDia(int32_t spendDia) {
    fbb_.AddElement<int32_t>(ArenaJoinResponse::VT_SPENDDIA, spendDia, 0);
  }
  void add_totalDia(int32_t totalDia) {
    fbb_.AddElement<int32_t>(ArenaJoinResponse::VT_TOTALDIA, totalDia, 0);
  }
  explicit ArenaJoinResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArenaJoinResponseBuilder &operator=(const ArenaJoinResponseBuilder &);
  flatbuffers::Offset<ArenaJoinResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArenaJoinResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArenaJoinResponse> CreateArenaJoinResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    ArenaSpendType spendType = ArenaSpendType_ArenaSpendType_freeTicket,
    int32_t spendTicket = 0,
    int32_t freeTicket = 0,
    int32_t paidTicket = 0,
    int32_t spendDia = 0,
    int32_t totalDia = 0) {
  ArenaJoinResponseBuilder builder_(_fbb);
  builder_.add_totalDia(totalDia);
  builder_.add_spendDia(spendDia);
  builder_.add_paidTicket(paidTicket);
  builder_.add_freeTicket(freeTicket);
  builder_.add_spendTicket(spendTicket);
  builder_.add_result(result);
  builder_.add_spendType(spendType);
  return builder_.Finish();
}

/// ARENA_FINISH_REQUEST
struct ArenaFinishRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ArenaFinishRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ArenaFinishRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArenaFinishRequestBuilder &operator=(const ArenaFinishRequestBuilder &);
  flatbuffers::Offset<ArenaFinishRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArenaFinishRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArenaFinishRequest> CreateArenaFinishRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ArenaFinishRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// ARENA_FINISH_NOTIFY
struct ArenaFinishNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ISWIN = 4,
    VT_INFO = 6
  };
  bool isWin() const {
    return GetField<uint8_t>(VT_ISWIN, 0) != 0;
  }
  const ArenaInfo *info() const {
    return GetPointer<const ArenaInfo *>(VT_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ISWIN) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           verifier.EndTable();
  }
};

struct ArenaFinishNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_isWin(bool isWin) {
    fbb_.AddElement<uint8_t>(ArenaFinishNotify::VT_ISWIN, static_cast<uint8_t>(isWin), 0);
  }
  void add_info(flatbuffers::Offset<ArenaInfo> info) {
    fbb_.AddOffset(ArenaFinishNotify::VT_INFO, info);
  }
  explicit ArenaFinishNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArenaFinishNotifyBuilder &operator=(const ArenaFinishNotifyBuilder &);
  flatbuffers::Offset<ArenaFinishNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArenaFinishNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArenaFinishNotify> CreateArenaFinishNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool isWin = false,
    flatbuffers::Offset<ArenaInfo> info = 0) {
  ArenaFinishNotifyBuilder builder_(_fbb);
  builder_.add_info(info);
  builder_.add_isWin(isWin);
  return builder_.Finish();
}

/// ARENA_FINISH_NOTIFY_REQUEST
struct ArenaFinishNotifyRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ArenaFinishNotifyRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ArenaFinishNotifyRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArenaFinishNotifyRequestBuilder &operator=(const ArenaFinishNotifyRequestBuilder &);
  flatbuffers::Offset<ArenaFinishNotifyRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArenaFinishNotifyRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArenaFinishNotifyRequest> CreateArenaFinishNotifyRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ArenaFinishNotifyRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// ARENA_PLAY_INFO_NOTIFY
struct ArenaPlayInfoNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_KILLER = 6,
    VT_DEADER = 8
  };
  AreanPlayInfoType type() const {
    return static_cast<AreanPlayInfoType>(GetField<int16_t>(VT_TYPE, 0));
  }
  int64_t killer() const {
    return GetField<int64_t>(VT_KILLER, 0);
  }
  int64_t deader() const {
    return GetField<int64_t>(VT_DEADER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPE) &&
           VerifyField<int64_t>(verifier, VT_KILLER) &&
           VerifyField<int64_t>(verifier, VT_DEADER) &&
           verifier.EndTable();
  }
};

struct ArenaPlayInfoNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(AreanPlayInfoType type) {
    fbb_.AddElement<int16_t>(ArenaPlayInfoNotify::VT_TYPE, static_cast<int16_t>(type), 0);
  }
  void add_killer(int64_t killer) {
    fbb_.AddElement<int64_t>(ArenaPlayInfoNotify::VT_KILLER, killer, 0);
  }
  void add_deader(int64_t deader) {
    fbb_.AddElement<int64_t>(ArenaPlayInfoNotify::VT_DEADER, deader, 0);
  }
  explicit ArenaPlayInfoNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArenaPlayInfoNotifyBuilder &operator=(const ArenaPlayInfoNotifyBuilder &);
  flatbuffers::Offset<ArenaPlayInfoNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArenaPlayInfoNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArenaPlayInfoNotify> CreateArenaPlayInfoNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    AreanPlayInfoType type = AreanPlayInfoType_AreanPlayInfoType_None,
    int64_t killer = 0,
    int64_t deader = 0) {
  ArenaPlayInfoNotifyBuilder builder_(_fbb);
  builder_.add_deader(deader);
  builder_.add_killer(killer);
  builder_.add_type(type);
  return builder_.Finish();
}

/// DB_GET_TRADE_ITEM_LIST_REQUEST
struct DBItemGetTradeJob FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMKEY = 4,
    VT_USECLASS = 6,
    VT_GROUP = 8,
    VT_SUBGROUP = 10,
    VT_GRADE = 12,
    VT_RAIDTIER = 14,
    VT_ORDERCOL = 16,
    VT_ORDERBY = 18,
    VT_LASTROWINDEX = 20,
    VT_LASTROWVALUE = 22,
    VT_ISNEXT = 24,
    VT_ISCOUNT = 26
  };
  int32_t itemKey() const {
    return GetField<int32_t>(VT_ITEMKEY, 0);
  }
  int16_t useClass() const {
    return GetField<int16_t>(VT_USECLASS, 0);
  }
  int16_t group() const {
    return GetField<int16_t>(VT_GROUP, 0);
  }
  int16_t subgroup() const {
    return GetField<int16_t>(VT_SUBGROUP, 0);
  }
  int16_t grade() const {
    return GetField<int16_t>(VT_GRADE, 0);
  }
  int16_t raidTier() const {
    return GetField<int16_t>(VT_RAIDTIER, 0);
  }
  int16_t orderCol() const {
    return GetField<int16_t>(VT_ORDERCOL, 0);
  }
  int16_t orderBy() const {
    return GetField<int16_t>(VT_ORDERBY, 0);
  }
  int64_t lastRowIndex() const {
    return GetField<int64_t>(VT_LASTROWINDEX, 0);
  }
  float lastRowValue() const {
    return GetField<float>(VT_LASTROWVALUE, 0.0f);
  }
  int8_t isNext() const {
    return GetField<int8_t>(VT_ISNEXT, 0);
  }
  int8_t isCount() const {
    return GetField<int8_t>(VT_ISCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ITEMKEY) &&
           VerifyField<int16_t>(verifier, VT_USECLASS) &&
           VerifyField<int16_t>(verifier, VT_GROUP) &&
           VerifyField<int16_t>(verifier, VT_SUBGROUP) &&
           VerifyField<int16_t>(verifier, VT_GRADE) &&
           VerifyField<int16_t>(verifier, VT_RAIDTIER) &&
           VerifyField<int16_t>(verifier, VT_ORDERCOL) &&
           VerifyField<int16_t>(verifier, VT_ORDERBY) &&
           VerifyField<int64_t>(verifier, VT_LASTROWINDEX) &&
           VerifyField<float>(verifier, VT_LASTROWVALUE) &&
           VerifyField<int8_t>(verifier, VT_ISNEXT) &&
           VerifyField<int8_t>(verifier, VT_ISCOUNT) &&
           verifier.EndTable();
  }
};

struct DBItemGetTradeJobBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemKey(int32_t itemKey) {
    fbb_.AddElement<int32_t>(DBItemGetTradeJob::VT_ITEMKEY, itemKey, 0);
  }
  void add_useClass(int16_t useClass) {
    fbb_.AddElement<int16_t>(DBItemGetTradeJob::VT_USECLASS, useClass, 0);
  }
  void add_group(int16_t group) {
    fbb_.AddElement<int16_t>(DBItemGetTradeJob::VT_GROUP, group, 0);
  }
  void add_subgroup(int16_t subgroup) {
    fbb_.AddElement<int16_t>(DBItemGetTradeJob::VT_SUBGROUP, subgroup, 0);
  }
  void add_grade(int16_t grade) {
    fbb_.AddElement<int16_t>(DBItemGetTradeJob::VT_GRADE, grade, 0);
  }
  void add_raidTier(int16_t raidTier) {
    fbb_.AddElement<int16_t>(DBItemGetTradeJob::VT_RAIDTIER, raidTier, 0);
  }
  void add_orderCol(int16_t orderCol) {
    fbb_.AddElement<int16_t>(DBItemGetTradeJob::VT_ORDERCOL, orderCol, 0);
  }
  void add_orderBy(int16_t orderBy) {
    fbb_.AddElement<int16_t>(DBItemGetTradeJob::VT_ORDERBY, orderBy, 0);
  }
  void add_lastRowIndex(int64_t lastRowIndex) {
    fbb_.AddElement<int64_t>(DBItemGetTradeJob::VT_LASTROWINDEX, lastRowIndex, 0);
  }
  void add_lastRowValue(float lastRowValue) {
    fbb_.AddElement<float>(DBItemGetTradeJob::VT_LASTROWVALUE, lastRowValue, 0.0f);
  }
  void add_isNext(int8_t isNext) {
    fbb_.AddElement<int8_t>(DBItemGetTradeJob::VT_ISNEXT, isNext, 0);
  }
  void add_isCount(int8_t isCount) {
    fbb_.AddElement<int8_t>(DBItemGetTradeJob::VT_ISCOUNT, isCount, 0);
  }
  explicit DBItemGetTradeJobBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DBItemGetTradeJobBuilder &operator=(const DBItemGetTradeJobBuilder &);
  flatbuffers::Offset<DBItemGetTradeJob> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DBItemGetTradeJob>(end);
    return o;
  }
};

inline flatbuffers::Offset<DBItemGetTradeJob> CreateDBItemGetTradeJob(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t itemKey = 0,
    int16_t useClass = 0,
    int16_t group = 0,
    int16_t subgroup = 0,
    int16_t grade = 0,
    int16_t raidTier = 0,
    int16_t orderCol = 0,
    int16_t orderBy = 0,
    int64_t lastRowIndex = 0,
    float lastRowValue = 0.0f,
    int8_t isNext = 0,
    int8_t isCount = 0) {
  DBItemGetTradeJobBuilder builder_(_fbb);
  builder_.add_lastRowIndex(lastRowIndex);
  builder_.add_lastRowValue(lastRowValue);
  builder_.add_itemKey(itemKey);
  builder_.add_orderBy(orderBy);
  builder_.add_orderCol(orderCol);
  builder_.add_raidTier(raidTier);
  builder_.add_grade(grade);
  builder_.add_subgroup(subgroup);
  builder_.add_group(group);
  builder_.add_useClass(useClass);
  builder_.add_isCount(isCount);
  builder_.add_isNext(isNext);
  return builder_.Finish();
}

/// DB_GET_TRADE_ITEM_LIST_RESPONSE
struct DBTradeItemContxt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TRADEROW = 4,
    VT_ITEMDBID = 6,
    VT_ITEMKEY = 8,
    VT_LEVEL = 10,
    VT_GRADE = 12,
    VT_STACKCOUNT = 14,
    VT_UNITPRICE = 16,
    VT_TOTALPRICE = 18,
    VT_BUYERPCNAME = 20,
    VT_CREATETIME = 22,
    VT_ISOWNER = 24,
    VT_TRANSCENDLEVEL = 26,
    VT_STATS = 28
  };
  int64_t tradeRow() const {
    return GetField<int64_t>(VT_TRADEROW, 0);
  }
  int64_t itemDbId() const {
    return GetField<int64_t>(VT_ITEMDBID, 0);
  }
  int32_t itemKey() const {
    return GetField<int32_t>(VT_ITEMKEY, 0);
  }
  int16_t level() const {
    return GetField<int16_t>(VT_LEVEL, 0);
  }
  int16_t grade() const {
    return GetField<int16_t>(VT_GRADE, 0);
  }
  int32_t stackCount() const {
    return GetField<int32_t>(VT_STACKCOUNT, 0);
  }
  int32_t unitPrice() const {
    return GetField<int32_t>(VT_UNITPRICE, 0);
  }
  int32_t totalPrice() const {
    return GetField<int32_t>(VT_TOTALPRICE, 0);
  }
  const flatbuffers::String *buyerPcName() const {
    return GetPointer<const flatbuffers::String *>(VT_BUYERPCNAME);
  }
  int64_t createTime() const {
    return GetField<int64_t>(VT_CREATETIME, 0);
  }
  bool isOwner() const {
    return GetField<uint8_t>(VT_ISOWNER, 0) != 0;
  }
  /// 초월 정보
  int16_t transcendLevel() const {
    return GetField<int16_t>(VT_TRANSCENDLEVEL, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TranscendStat>> *stats() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TranscendStat>> *>(VT_STATS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TRADEROW) &&
           VerifyField<int64_t>(verifier, VT_ITEMDBID) &&
           VerifyField<int32_t>(verifier, VT_ITEMKEY) &&
           VerifyField<int16_t>(verifier, VT_LEVEL) &&
           VerifyField<int16_t>(verifier, VT_GRADE) &&
           VerifyField<int32_t>(verifier, VT_STACKCOUNT) &&
           VerifyField<int32_t>(verifier, VT_UNITPRICE) &&
           VerifyField<int32_t>(verifier, VT_TOTALPRICE) &&
           VerifyOffsetRequired(verifier, VT_BUYERPCNAME) &&
           verifier.VerifyString(buyerPcName()) &&
           VerifyField<int64_t>(verifier, VT_CREATETIME) &&
           VerifyField<uint8_t>(verifier, VT_ISOWNER) &&
           VerifyField<int16_t>(verifier, VT_TRANSCENDLEVEL) &&
           VerifyOffset(verifier, VT_STATS) &&
           verifier.VerifyVector(stats()) &&
           verifier.VerifyVectorOfTables(stats()) &&
           verifier.EndTable();
  }
};

struct DBTradeItemContxtBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tradeRow(int64_t tradeRow) {
    fbb_.AddElement<int64_t>(DBTradeItemContxt::VT_TRADEROW, tradeRow, 0);
  }
  void add_itemDbId(int64_t itemDbId) {
    fbb_.AddElement<int64_t>(DBTradeItemContxt::VT_ITEMDBID, itemDbId, 0);
  }
  void add_itemKey(int32_t itemKey) {
    fbb_.AddElement<int32_t>(DBTradeItemContxt::VT_ITEMKEY, itemKey, 0);
  }
  void add_level(int16_t level) {
    fbb_.AddElement<int16_t>(DBTradeItemContxt::VT_LEVEL, level, 0);
  }
  void add_grade(int16_t grade) {
    fbb_.AddElement<int16_t>(DBTradeItemContxt::VT_GRADE, grade, 0);
  }
  void add_stackCount(int32_t stackCount) {
    fbb_.AddElement<int32_t>(DBTradeItemContxt::VT_STACKCOUNT, stackCount, 0);
  }
  void add_unitPrice(int32_t unitPrice) {
    fbb_.AddElement<int32_t>(DBTradeItemContxt::VT_UNITPRICE, unitPrice, 0);
  }
  void add_totalPrice(int32_t totalPrice) {
    fbb_.AddElement<int32_t>(DBTradeItemContxt::VT_TOTALPRICE, totalPrice, 0);
  }
  void add_buyerPcName(flatbuffers::Offset<flatbuffers::String> buyerPcName) {
    fbb_.AddOffset(DBTradeItemContxt::VT_BUYERPCNAME, buyerPcName);
  }
  void add_createTime(int64_t createTime) {
    fbb_.AddElement<int64_t>(DBTradeItemContxt::VT_CREATETIME, createTime, 0);
  }
  void add_isOwner(bool isOwner) {
    fbb_.AddElement<uint8_t>(DBTradeItemContxt::VT_ISOWNER, static_cast<uint8_t>(isOwner), 0);
  }
  void add_transcendLevel(int16_t transcendLevel) {
    fbb_.AddElement<int16_t>(DBTradeItemContxt::VT_TRANSCENDLEVEL, transcendLevel, 0);
  }
  void add_stats(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TranscendStat>>> stats) {
    fbb_.AddOffset(DBTradeItemContxt::VT_STATS, stats);
  }
  explicit DBTradeItemContxtBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DBTradeItemContxtBuilder &operator=(const DBTradeItemContxtBuilder &);
  flatbuffers::Offset<DBTradeItemContxt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DBTradeItemContxt>(end);
    fbb_.Required(o, DBTradeItemContxt::VT_BUYERPCNAME);
    return o;
  }
};

inline flatbuffers::Offset<DBTradeItemContxt> CreateDBTradeItemContxt(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t tradeRow = 0,
    int64_t itemDbId = 0,
    int32_t itemKey = 0,
    int16_t level = 0,
    int16_t grade = 0,
    int32_t stackCount = 0,
    int32_t unitPrice = 0,
    int32_t totalPrice = 0,
    flatbuffers::Offset<flatbuffers::String> buyerPcName = 0,
    int64_t createTime = 0,
    bool isOwner = false,
    int16_t transcendLevel = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TranscendStat>>> stats = 0) {
  DBTradeItemContxtBuilder builder_(_fbb);
  builder_.add_createTime(createTime);
  builder_.add_itemDbId(itemDbId);
  builder_.add_tradeRow(tradeRow);
  builder_.add_stats(stats);
  builder_.add_buyerPcName(buyerPcName);
  builder_.add_totalPrice(totalPrice);
  builder_.add_unitPrice(unitPrice);
  builder_.add_stackCount(stackCount);
  builder_.add_itemKey(itemKey);
  builder_.add_transcendLevel(transcendLevel);
  builder_.add_grade(grade);
  builder_.add_level(level);
  builder_.add_isOwner(isOwner);
  return builder_.Finish();
}

inline flatbuffers::Offset<DBTradeItemContxt> CreateDBTradeItemContxtDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t tradeRow = 0,
    int64_t itemDbId = 0,
    int32_t itemKey = 0,
    int16_t level = 0,
    int16_t grade = 0,
    int32_t stackCount = 0,
    int32_t unitPrice = 0,
    int32_t totalPrice = 0,
    const char *buyerPcName = nullptr,
    int64_t createTime = 0,
    bool isOwner = false,
    int16_t transcendLevel = 0,
    const std::vector<flatbuffers::Offset<TranscendStat>> *stats = nullptr) {
  return LeanPacket::CreateDBTradeItemContxt(
      _fbb,
      tradeRow,
      itemDbId,
      itemKey,
      level,
      grade,
      stackCount,
      unitPrice,
      totalPrice,
      buyerPcName ? _fbb.CreateString(buyerPcName) : 0,
      createTime,
      isOwner,
      transcendLevel,
      stats ? _fbb.CreateVector<flatbuffers::Offset<TranscendStat>>(*stats) : 0);
}

/// DB_GET_TRADE_ITEM_LIST_RESPONSE
struct DBTradeItemContxts FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TOTALROWCNT = 4,
    VT_TRADEITEMS = 6
  };
  int32_t totalRowCnt() const {
    return GetField<int32_t>(VT_TOTALROWCNT, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<DBTradeItemContxt>> *tradeItems() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DBTradeItemContxt>> *>(VT_TRADEITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TOTALROWCNT) &&
           VerifyOffsetRequired(verifier, VT_TRADEITEMS) &&
           verifier.VerifyVector(tradeItems()) &&
           verifier.VerifyVectorOfTables(tradeItems()) &&
           verifier.EndTable();
  }
};

struct DBTradeItemContxtsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_totalRowCnt(int32_t totalRowCnt) {
    fbb_.AddElement<int32_t>(DBTradeItemContxts::VT_TOTALROWCNT, totalRowCnt, 0);
  }
  void add_tradeItems(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DBTradeItemContxt>>> tradeItems) {
    fbb_.AddOffset(DBTradeItemContxts::VT_TRADEITEMS, tradeItems);
  }
  explicit DBTradeItemContxtsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DBTradeItemContxtsBuilder &operator=(const DBTradeItemContxtsBuilder &);
  flatbuffers::Offset<DBTradeItemContxts> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DBTradeItemContxts>(end);
    fbb_.Required(o, DBTradeItemContxts::VT_TRADEITEMS);
    return o;
  }
};

inline flatbuffers::Offset<DBTradeItemContxts> CreateDBTradeItemContxts(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t totalRowCnt = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DBTradeItemContxt>>> tradeItems = 0) {
  DBTradeItemContxtsBuilder builder_(_fbb);
  builder_.add_tradeItems(tradeItems);
  builder_.add_totalRowCnt(totalRowCnt);
  return builder_.Finish();
}

inline flatbuffers::Offset<DBTradeItemContxts> CreateDBTradeItemContxtsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t totalRowCnt = 0,
    const std::vector<flatbuffers::Offset<DBTradeItemContxt>> *tradeItems = nullptr) {
  return LeanPacket::CreateDBTradeItemContxts(
      _fbb,
      totalRowCnt,
      tradeItems ? _fbb.CreateVector<flatbuffers::Offset<DBTradeItemContxt>>(*tradeItems) : 0);
}

/// TRADE_GET_TRADE_ITEM_LIST_REQUEST
struct TradeGetTradeItemListRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_JOB = 4
  };
  const DBItemGetTradeJob *job() const {
    return GetPointer<const DBItemGetTradeJob *>(VT_JOB);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_JOB) &&
           verifier.VerifyTable(job()) &&
           verifier.EndTable();
  }
};

struct TradeGetTradeItemListRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_job(flatbuffers::Offset<DBItemGetTradeJob> job) {
    fbb_.AddOffset(TradeGetTradeItemListRequest::VT_JOB, job);
  }
  explicit TradeGetTradeItemListRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TradeGetTradeItemListRequestBuilder &operator=(const TradeGetTradeItemListRequestBuilder &);
  flatbuffers::Offset<TradeGetTradeItemListRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TradeGetTradeItemListRequest>(end);
    fbb_.Required(o, TradeGetTradeItemListRequest::VT_JOB);
    return o;
  }
};

inline flatbuffers::Offset<TradeGetTradeItemListRequest> CreateTradeGetTradeItemListRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<DBItemGetTradeJob> job = 0) {
  TradeGetTradeItemListRequestBuilder builder_(_fbb);
  builder_.add_job(job);
  return builder_.Finish();
}

/// TRADE_GET_TRADE_ITEM_LIST_RESPONSE
struct TradeGetTradeItemListResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_TRADEITEMS = 6
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  const DBTradeItemContxts *tradeItems() const {
    return GetPointer<const DBTradeItemContxts *>(VT_TRADEITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyOffset(verifier, VT_TRADEITEMS) &&
           verifier.VerifyTable(tradeItems()) &&
           verifier.EndTable();
  }
};

struct TradeGetTradeItemListResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(TradeGetTradeItemListResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_tradeItems(flatbuffers::Offset<DBTradeItemContxts> tradeItems) {
    fbb_.AddOffset(TradeGetTradeItemListResponse::VT_TRADEITEMS, tradeItems);
  }
  explicit TradeGetTradeItemListResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TradeGetTradeItemListResponseBuilder &operator=(const TradeGetTradeItemListResponseBuilder &);
  flatbuffers::Offset<TradeGetTradeItemListResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TradeGetTradeItemListResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<TradeGetTradeItemListResponse> CreateTradeGetTradeItemListResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    flatbuffers::Offset<DBTradeItemContxts> tradeItems = 0) {
  TradeGetTradeItemListResponseBuilder builder_(_fbb);
  builder_.add_tradeItems(tradeItems);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

/// TRADE_SET_TRADE_ITEM_REQUEST
struct TradeSetTradeItemRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMOBJECTID = 4,
    VT_STACKCNT = 6,
    VT_ORGSTACKCNT = 8,
    VT_PRICE = 10
  };
  uint64_t itemObjectId() const {
    return GetField<uint64_t>(VT_ITEMOBJECTID, 0);
  }
  int32_t stackCnt() const {
    return GetField<int32_t>(VT_STACKCNT, 0);
  }
  int32_t orgStackCnt() const {
    return GetField<int32_t>(VT_ORGSTACKCNT, 0);
  }
  int32_t price() const {
    return GetField<int32_t>(VT_PRICE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ITEMOBJECTID) &&
           VerifyField<int32_t>(verifier, VT_STACKCNT) &&
           VerifyField<int32_t>(verifier, VT_ORGSTACKCNT) &&
           VerifyField<int32_t>(verifier, VT_PRICE) &&
           verifier.EndTable();
  }
};

struct TradeSetTradeItemRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemObjectId(uint64_t itemObjectId) {
    fbb_.AddElement<uint64_t>(TradeSetTradeItemRequest::VT_ITEMOBJECTID, itemObjectId, 0);
  }
  void add_stackCnt(int32_t stackCnt) {
    fbb_.AddElement<int32_t>(TradeSetTradeItemRequest::VT_STACKCNT, stackCnt, 0);
  }
  void add_orgStackCnt(int32_t orgStackCnt) {
    fbb_.AddElement<int32_t>(TradeSetTradeItemRequest::VT_ORGSTACKCNT, orgStackCnt, 0);
  }
  void add_price(int32_t price) {
    fbb_.AddElement<int32_t>(TradeSetTradeItemRequest::VT_PRICE, price, 0);
  }
  explicit TradeSetTradeItemRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TradeSetTradeItemRequestBuilder &operator=(const TradeSetTradeItemRequestBuilder &);
  flatbuffers::Offset<TradeSetTradeItemRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TradeSetTradeItemRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<TradeSetTradeItemRequest> CreateTradeSetTradeItemRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t itemObjectId = 0,
    int32_t stackCnt = 0,
    int32_t orgStackCnt = 0,
    int32_t price = 0) {
  TradeSetTradeItemRequestBuilder builder_(_fbb);
  builder_.add_itemObjectId(itemObjectId);
  builder_.add_price(price);
  builder_.add_orgStackCnt(orgStackCnt);
  builder_.add_stackCnt(stackCnt);
  return builder_.Finish();
}

/// TRADE_SET_TRADE_ITEM_RESPONSE
struct TradeSetTradeItemResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           verifier.EndTable();
  }
};

struct TradeSetTradeItemResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(TradeSetTradeItemResponse::VT_ERRORCODE, errorCode, 0);
  }
  explicit TradeSetTradeItemResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TradeSetTradeItemResponseBuilder &operator=(const TradeSetTradeItemResponseBuilder &);
  flatbuffers::Offset<TradeSetTradeItemResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TradeSetTradeItemResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<TradeSetTradeItemResponse> CreateTradeSetTradeItemResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0) {
  TradeSetTradeItemResponseBuilder builder_(_fbb);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

///  TRADE_BUY_TRADE_ITEM_REQUEST
struct TradeBuyTradeItemRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TRADEROW = 4,
    VT_ITEMID = 6,
    VT_SELLPRICEPRISM = 8,
    VT_TAXPRISM = 10,
    VT_STACKCOUNT = 12,
    VT_GRADE = 14
  };
  int64_t tradeRow() const {
    return GetField<int64_t>(VT_TRADEROW, 0);
  }
  int32_t itemId() const {
    return GetField<int32_t>(VT_ITEMID, 0);
  }
  int32_t sellPricePrism() const {
    return GetField<int32_t>(VT_SELLPRICEPRISM, 0);
  }
  int32_t taxPrism() const {
    return GetField<int32_t>(VT_TAXPRISM, 0);
  }
  int32_t stackCount() const {
    return GetField<int32_t>(VT_STACKCOUNT, 0);
  }
  int16_t grade() const {
    return GetField<int16_t>(VT_GRADE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TRADEROW) &&
           VerifyField<int32_t>(verifier, VT_ITEMID) &&
           VerifyField<int32_t>(verifier, VT_SELLPRICEPRISM) &&
           VerifyField<int32_t>(verifier, VT_TAXPRISM) &&
           VerifyField<int32_t>(verifier, VT_STACKCOUNT) &&
           VerifyField<int16_t>(verifier, VT_GRADE) &&
           verifier.EndTable();
  }
};

struct TradeBuyTradeItemRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tradeRow(int64_t tradeRow) {
    fbb_.AddElement<int64_t>(TradeBuyTradeItemRequest::VT_TRADEROW, tradeRow, 0);
  }
  void add_itemId(int32_t itemId) {
    fbb_.AddElement<int32_t>(TradeBuyTradeItemRequest::VT_ITEMID, itemId, 0);
  }
  void add_sellPricePrism(int32_t sellPricePrism) {
    fbb_.AddElement<int32_t>(TradeBuyTradeItemRequest::VT_SELLPRICEPRISM, sellPricePrism, 0);
  }
  void add_taxPrism(int32_t taxPrism) {
    fbb_.AddElement<int32_t>(TradeBuyTradeItemRequest::VT_TAXPRISM, taxPrism, 0);
  }
  void add_stackCount(int32_t stackCount) {
    fbb_.AddElement<int32_t>(TradeBuyTradeItemRequest::VT_STACKCOUNT, stackCount, 0);
  }
  void add_grade(int16_t grade) {
    fbb_.AddElement<int16_t>(TradeBuyTradeItemRequest::VT_GRADE, grade, 0);
  }
  explicit TradeBuyTradeItemRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TradeBuyTradeItemRequestBuilder &operator=(const TradeBuyTradeItemRequestBuilder &);
  flatbuffers::Offset<TradeBuyTradeItemRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TradeBuyTradeItemRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<TradeBuyTradeItemRequest> CreateTradeBuyTradeItemRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t tradeRow = 0,
    int32_t itemId = 0,
    int32_t sellPricePrism = 0,
    int32_t taxPrism = 0,
    int32_t stackCount = 0,
    int16_t grade = 0) {
  TradeBuyTradeItemRequestBuilder builder_(_fbb);
  builder_.add_tradeRow(tradeRow);
  builder_.add_stackCount(stackCount);
  builder_.add_taxPrism(taxPrism);
  builder_.add_sellPricePrism(sellPricePrism);
  builder_.add_itemId(itemId);
  builder_.add_grade(grade);
  return builder_.Finish();
}

///  TRADE_BUY_TRADE_ITEM_RESPONSE
struct TradeBuyTradeItemResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           verifier.EndTable();
  }
};

struct TradeBuyTradeItemResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(TradeBuyTradeItemResponse::VT_ERRORCODE, errorCode, 0);
  }
  explicit TradeBuyTradeItemResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TradeBuyTradeItemResponseBuilder &operator=(const TradeBuyTradeItemResponseBuilder &);
  flatbuffers::Offset<TradeBuyTradeItemResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TradeBuyTradeItemResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<TradeBuyTradeItemResponse> CreateTradeBuyTradeItemResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0) {
  TradeBuyTradeItemResponseBuilder builder_(_fbb);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

/// TRADE_MY_SALE_LIST_REQUEST
struct TradeMySaleListRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct TradeMySaleListRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TradeMySaleListRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TradeMySaleListRequestBuilder &operator=(const TradeMySaleListRequestBuilder &);
  flatbuffers::Offset<TradeMySaleListRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TradeMySaleListRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<TradeMySaleListRequest> CreateTradeMySaleListRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TradeMySaleListRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// TRADE_MY_SALE_LIST_RESPONSE
struct TradeMySaleListResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_MYSALELIST = 6
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  const DBTradeItemContxts *mySaleList() const {
    return GetPointer<const DBTradeItemContxts *>(VT_MYSALELIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyOffset(verifier, VT_MYSALELIST) &&
           verifier.VerifyTable(mySaleList()) &&
           verifier.EndTable();
  }
};

struct TradeMySaleListResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(TradeMySaleListResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_mySaleList(flatbuffers::Offset<DBTradeItemContxts> mySaleList) {
    fbb_.AddOffset(TradeMySaleListResponse::VT_MYSALELIST, mySaleList);
  }
  explicit TradeMySaleListResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TradeMySaleListResponseBuilder &operator=(const TradeMySaleListResponseBuilder &);
  flatbuffers::Offset<TradeMySaleListResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TradeMySaleListResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<TradeMySaleListResponse> CreateTradeMySaleListResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    flatbuffers::Offset<DBTradeItemContxts> mySaleList = 0) {
  TradeMySaleListResponseBuilder builder_(_fbb);
  builder_.add_mySaleList(mySaleList);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

/// TRADE_SALE_LOG_LIST_REQUEST
struct TradeSaleLogListRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct TradeSaleLogListRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TradeSaleLogListRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TradeSaleLogListRequestBuilder &operator=(const TradeSaleLogListRequestBuilder &);
  flatbuffers::Offset<TradeSaleLogListRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TradeSaleLogListRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<TradeSaleLogListRequest> CreateTradeSaleLogListRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TradeSaleLogListRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// TRADE_SALE_LOG_LIST_RESPONSE
struct TradeSaleLogListResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_SALELOGLIST = 6
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  const DBTradeItemContxts *saleLogList() const {
    return GetPointer<const DBTradeItemContxts *>(VT_SALELOGLIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyOffset(verifier, VT_SALELOGLIST) &&
           verifier.VerifyTable(saleLogList()) &&
           verifier.EndTable();
  }
};

struct TradeSaleLogListResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(TradeSaleLogListResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_saleLogList(flatbuffers::Offset<DBTradeItemContxts> saleLogList) {
    fbb_.AddOffset(TradeSaleLogListResponse::VT_SALELOGLIST, saleLogList);
  }
  explicit TradeSaleLogListResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TradeSaleLogListResponseBuilder &operator=(const TradeSaleLogListResponseBuilder &);
  flatbuffers::Offset<TradeSaleLogListResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TradeSaleLogListResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<TradeSaleLogListResponse> CreateTradeSaleLogListResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    flatbuffers::Offset<DBTradeItemContxts> saleLogList = 0) {
  TradeSaleLogListResponseBuilder builder_(_fbb);
  builder_.add_saleLogList(saleLogList);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

/// TRADE_CANCEL_TRADE_ITEM_REQUEST
struct TradeCancelTradeItemRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TRADEROW = 4,
    VT_ITEMKEY = 6
  };
  int64_t tradeRow() const {
    return GetField<int64_t>(VT_TRADEROW, 0);
  }
  int32_t itemKey() const {
    return GetField<int32_t>(VT_ITEMKEY, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TRADEROW) &&
           VerifyField<int32_t>(verifier, VT_ITEMKEY) &&
           verifier.EndTable();
  }
};

struct TradeCancelTradeItemRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tradeRow(int64_t tradeRow) {
    fbb_.AddElement<int64_t>(TradeCancelTradeItemRequest::VT_TRADEROW, tradeRow, 0);
  }
  void add_itemKey(int32_t itemKey) {
    fbb_.AddElement<int32_t>(TradeCancelTradeItemRequest::VT_ITEMKEY, itemKey, 0);
  }
  explicit TradeCancelTradeItemRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TradeCancelTradeItemRequestBuilder &operator=(const TradeCancelTradeItemRequestBuilder &);
  flatbuffers::Offset<TradeCancelTradeItemRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TradeCancelTradeItemRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<TradeCancelTradeItemRequest> CreateTradeCancelTradeItemRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t tradeRow = 0,
    int32_t itemKey = 0) {
  TradeCancelTradeItemRequestBuilder builder_(_fbb);
  builder_.add_tradeRow(tradeRow);
  builder_.add_itemKey(itemKey);
  return builder_.Finish();
}

/// TRADE_CANCEL_TRADE_ITEM_RESPONSE
struct TradeCancelTradeItemResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_ITEMKEY = 6
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  int32_t itemKey() const {
    return GetField<int32_t>(VT_ITEMKEY, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int32_t>(verifier, VT_ITEMKEY) &&
           verifier.EndTable();
  }
};

struct TradeCancelTradeItemResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(TradeCancelTradeItemResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_itemKey(int32_t itemKey) {
    fbb_.AddElement<int32_t>(TradeCancelTradeItemResponse::VT_ITEMKEY, itemKey, 0);
  }
  explicit TradeCancelTradeItemResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TradeCancelTradeItemResponseBuilder &operator=(const TradeCancelTradeItemResponseBuilder &);
  flatbuffers::Offset<TradeCancelTradeItemResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TradeCancelTradeItemResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<TradeCancelTradeItemResponse> CreateTradeCancelTradeItemResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    int32_t itemKey = 0) {
  TradeCancelTradeItemResponseBuilder builder_(_fbb);
  builder_.add_itemKey(itemKey);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

struct Influence FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_POINT = 4,
    VT_TIER = 6,
    VT_LEVEL = 8,
    VT_PERCENTILE = 10,
    VT_UPDATEREMAINSECOND = 12
  };
  int64_t point() const {
    return GetField<int64_t>(VT_POINT, 0);
  }
  int16_t tier() const {
    return GetField<int16_t>(VT_TIER, 0);
  }
  int16_t level() const {
    return GetField<int16_t>(VT_LEVEL, 0);
  }
  float percentile() const {
    return GetField<float>(VT_PERCENTILE, 0.0f);
  }
  int64_t updateRemainSecond() const {
    return GetField<int64_t>(VT_UPDATEREMAINSECOND, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_POINT) &&
           VerifyField<int16_t>(verifier, VT_TIER) &&
           VerifyField<int16_t>(verifier, VT_LEVEL) &&
           VerifyField<float>(verifier, VT_PERCENTILE) &&
           VerifyField<int64_t>(verifier, VT_UPDATEREMAINSECOND) &&
           verifier.EndTable();
  }
};

struct InfluenceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_point(int64_t point) {
    fbb_.AddElement<int64_t>(Influence::VT_POINT, point, 0);
  }
  void add_tier(int16_t tier) {
    fbb_.AddElement<int16_t>(Influence::VT_TIER, tier, 0);
  }
  void add_level(int16_t level) {
    fbb_.AddElement<int16_t>(Influence::VT_LEVEL, level, 0);
  }
  void add_percentile(float percentile) {
    fbb_.AddElement<float>(Influence::VT_PERCENTILE, percentile, 0.0f);
  }
  void add_updateRemainSecond(int64_t updateRemainSecond) {
    fbb_.AddElement<int64_t>(Influence::VT_UPDATEREMAINSECOND, updateRemainSecond, 0);
  }
  explicit InfluenceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InfluenceBuilder &operator=(const InfluenceBuilder &);
  flatbuffers::Offset<Influence> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Influence>(end);
    return o;
  }
};

inline flatbuffers::Offset<Influence> CreateInfluence(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t point = 0,
    int16_t tier = 0,
    int16_t level = 0,
    float percentile = 0.0f,
    int64_t updateRemainSecond = 0) {
  InfluenceBuilder builder_(_fbb);
  builder_.add_updateRemainSecond(updateRemainSecond);
  builder_.add_point(point);
  builder_.add_percentile(percentile);
  builder_.add_level(level);
  builder_.add_tier(tier);
  return builder_.Finish();
}

/// INFLUENCE_POINT_UP_NOTIFY
struct InfluencePointUpNoti FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_POINT = 6
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  int64_t point() const {
    return GetField<int64_t>(VT_POINT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int64_t>(verifier, VT_POINT) &&
           verifier.EndTable();
  }
};

struct InfluencePointUpNotiBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(InfluencePointUpNoti::VT_ERRORCODE, errorCode, 0);
  }
  void add_point(int64_t point) {
    fbb_.AddElement<int64_t>(InfluencePointUpNoti::VT_POINT, point, 0);
  }
  explicit InfluencePointUpNotiBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InfluencePointUpNotiBuilder &operator=(const InfluencePointUpNotiBuilder &);
  flatbuffers::Offset<InfluencePointUpNoti> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InfluencePointUpNoti>(end);
    return o;
  }
};

inline flatbuffers::Offset<InfluencePointUpNoti> CreateInfluencePointUpNoti(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    int64_t point = 0) {
  InfluencePointUpNotiBuilder builder_(_fbb);
  builder_.add_point(point);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

/// INFLUENCE_DATA_NOTIFY
struct InfluenceDataNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INFLUENCE = 4,
    VT_RENEWALTYPE = 6
  };
  const Influence *influence() const {
    return GetPointer<const Influence *>(VT_INFLUENCE);
  }
  int8_t renewalType() const {
    return GetField<int8_t>(VT_RENEWALTYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_INFLUENCE) &&
           verifier.VerifyTable(influence()) &&
           VerifyField<int8_t>(verifier, VT_RENEWALTYPE) &&
           verifier.EndTable();
  }
};

struct InfluenceDataNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_influence(flatbuffers::Offset<Influence> influence) {
    fbb_.AddOffset(InfluenceDataNotify::VT_INFLUENCE, influence);
  }
  void add_renewalType(int8_t renewalType) {
    fbb_.AddElement<int8_t>(InfluenceDataNotify::VT_RENEWALTYPE, renewalType, 0);
  }
  explicit InfluenceDataNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InfluenceDataNotifyBuilder &operator=(const InfluenceDataNotifyBuilder &);
  flatbuffers::Offset<InfluenceDataNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InfluenceDataNotify>(end);
    fbb_.Required(o, InfluenceDataNotify::VT_INFLUENCE);
    return o;
  }
};

inline flatbuffers::Offset<InfluenceDataNotify> CreateInfluenceDataNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Influence> influence = 0,
    int8_t renewalType = 0) {
  InfluenceDataNotifyBuilder builder_(_fbb);
  builder_.add_influence(influence);
  builder_.add_renewalType(renewalType);
  return builder_.Finish();
}

/// INFLUENCE_AFTER_REFRESH_NOTIFY
struct InfluenceAfterRefreshNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct InfluenceAfterRefreshNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit InfluenceAfterRefreshNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InfluenceAfterRefreshNotifyBuilder &operator=(const InfluenceAfterRefreshNotifyBuilder &);
  flatbuffers::Offset<InfluenceAfterRefreshNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InfluenceAfterRefreshNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<InfluenceAfterRefreshNotify> CreateInfluenceAfterRefreshNotify(
    flatbuffers::FlatBufferBuilder &_fbb) {
  InfluenceAfterRefreshNotifyBuilder builder_(_fbb);
  return builder_.Finish();
}

/// BUNDLE_BOX_RESULT_NOTIFY
struct BundleResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RID = 4,
    VT_PAIDGOLD = 6,
    VT_REWARDGOLD = 8,
    VT_PAIDDIA = 10,
    VT_REWARDDIA = 12,
    VT_ITEMS = 14
  };
  int16_t rId() const {
    return GetField<int16_t>(VT_RID, 0);
  }
  int64_t paidGold() const {
    return GetField<int64_t>(VT_PAIDGOLD, 0);
  }
  int64_t rewardGold() const {
    return GetField<int64_t>(VT_REWARDGOLD, 0);
  }
  int32_t paidDia() const {
    return GetField<int32_t>(VT_PAIDDIA, 0);
  }
  int32_t rewardDia() const {
    return GetField<int32_t>(VT_REWARDDIA, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ClientItemStackInfo>> *items() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ClientItemStackInfo>> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_RID) &&
           VerifyField<int64_t>(verifier, VT_PAIDGOLD) &&
           VerifyField<int64_t>(verifier, VT_REWARDGOLD) &&
           VerifyField<int32_t>(verifier, VT_PAIDDIA) &&
           VerifyField<int32_t>(verifier, VT_REWARDDIA) &&
           VerifyOffsetRequired(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.VerifyVectorOfTables(items()) &&
           verifier.EndTable();
  }
};

struct BundleResultBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rId(int16_t rId) {
    fbb_.AddElement<int16_t>(BundleResult::VT_RID, rId, 0);
  }
  void add_paidGold(int64_t paidGold) {
    fbb_.AddElement<int64_t>(BundleResult::VT_PAIDGOLD, paidGold, 0);
  }
  void add_rewardGold(int64_t rewardGold) {
    fbb_.AddElement<int64_t>(BundleResult::VT_REWARDGOLD, rewardGold, 0);
  }
  void add_paidDia(int32_t paidDia) {
    fbb_.AddElement<int32_t>(BundleResult::VT_PAIDDIA, paidDia, 0);
  }
  void add_rewardDia(int32_t rewardDia) {
    fbb_.AddElement<int32_t>(BundleResult::VT_REWARDDIA, rewardDia, 0);
  }
  void add_items(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ClientItemStackInfo>>> items) {
    fbb_.AddOffset(BundleResult::VT_ITEMS, items);
  }
  explicit BundleResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BundleResultBuilder &operator=(const BundleResultBuilder &);
  flatbuffers::Offset<BundleResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BundleResult>(end);
    fbb_.Required(o, BundleResult::VT_ITEMS);
    return o;
  }
};

inline flatbuffers::Offset<BundleResult> CreateBundleResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t rId = 0,
    int64_t paidGold = 0,
    int64_t rewardGold = 0,
    int32_t paidDia = 0,
    int32_t rewardDia = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ClientItemStackInfo>>> items = 0) {
  BundleResultBuilder builder_(_fbb);
  builder_.add_rewardGold(rewardGold);
  builder_.add_paidGold(paidGold);
  builder_.add_items(items);
  builder_.add_rewardDia(rewardDia);
  builder_.add_paidDia(paidDia);
  builder_.add_rId(rId);
  return builder_.Finish();
}

inline flatbuffers::Offset<BundleResult> CreateBundleResultDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t rId = 0,
    int64_t paidGold = 0,
    int64_t rewardGold = 0,
    int32_t paidDia = 0,
    int32_t rewardDia = 0,
    const std::vector<flatbuffers::Offset<ClientItemStackInfo>> *items = nullptr) {
  return LeanPacket::CreateBundleResult(
      _fbb,
      rId,
      paidGold,
      rewardGold,
      paidDia,
      rewardDia,
      items ? _fbb.CreateVector<flatbuffers::Offset<ClientItemStackInfo>>(*items) : 0);
}

struct BundleBoxResultNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BUNDLES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<BundleResult>> *bundles() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BundleResult>> *>(VT_BUNDLES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BUNDLES) &&
           verifier.VerifyVector(bundles()) &&
           verifier.VerifyVectorOfTables(bundles()) &&
           verifier.EndTable();
  }
};

struct BundleBoxResultNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bundles(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BundleResult>>> bundles) {
    fbb_.AddOffset(BundleBoxResultNotify::VT_BUNDLES, bundles);
  }
  explicit BundleBoxResultNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BundleBoxResultNotifyBuilder &operator=(const BundleBoxResultNotifyBuilder &);
  flatbuffers::Offset<BundleBoxResultNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BundleBoxResultNotify>(end);
    fbb_.Required(o, BundleBoxResultNotify::VT_BUNDLES);
    return o;
  }
};

inline flatbuffers::Offset<BundleBoxResultNotify> CreateBundleBoxResultNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BundleResult>>> bundles = 0) {
  BundleBoxResultNotifyBuilder builder_(_fbb);
  builder_.add_bundles(bundles);
  return builder_.Finish();
}

inline flatbuffers::Offset<BundleBoxResultNotify> CreateBundleBoxResultNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<BundleResult>> *bundles = nullptr) {
  return LeanPacket::CreateBundleBoxResultNotify(
      _fbb,
      bundles ? _fbb.CreateVector<flatbuffers::Offset<BundleResult>>(*bundles) : 0);
}

struct ArenaInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ArenaInfoRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ArenaInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArenaInfoRequestBuilder &operator=(const ArenaInfoRequestBuilder &);
  flatbuffers::Offset<ArenaInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArenaInfoRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArenaInfoRequest> CreateArenaInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ArenaInfoRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ArenaInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TURNNO = 4,
    VT_PAIDTURNNO = 6,
    VT_CONSECUTIVEVICTORIES = 8,
    VT_CURSCORE = 10,
    VT_LEVEL = 12,
    VT_GRADE = 14,
    VT_ACCUMTOTALSCORE = 16,
    VT_TRYCOUNT = 18,
    VT_RANK = 20,
    VT_RANKERCOUNT = 22,
    VT_REWARDINDEX = 24,
    VT_TODAYPLAYCOUNT = 26
  };
  int32_t turnNo() const {
    return GetField<int32_t>(VT_TURNNO, 0);
  }
  int32_t paidTurnNo() const {
    return GetField<int32_t>(VT_PAIDTURNNO, 0);
  }
  int16_t consecutiveVictories() const {
    return GetField<int16_t>(VT_CONSECUTIVEVICTORIES, 0);
  }
  int64_t curScore() const {
    return GetField<int64_t>(VT_CURSCORE, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int32_t grade() const {
    return GetField<int32_t>(VT_GRADE, 0);
  }
  int64_t accumTotalScore() const {
    return GetField<int64_t>(VT_ACCUMTOTALSCORE, 0);
  }
  int16_t tryCount() const {
    return GetField<int16_t>(VT_TRYCOUNT, 0);
  }
  int32_t rank() const {
    return GetField<int32_t>(VT_RANK, 0);
  }
  int32_t rankerCount() const {
    return GetField<int32_t>(VT_RANKERCOUNT, 0);
  }
  int8_t rewardIndex() const {
    return GetField<int8_t>(VT_REWARDINDEX, 0);
  }
  int32_t todayPlayCount() const {
    return GetField<int32_t>(VT_TODAYPLAYCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TURNNO) &&
           VerifyField<int32_t>(verifier, VT_PAIDTURNNO) &&
           VerifyField<int16_t>(verifier, VT_CONSECUTIVEVICTORIES) &&
           VerifyField<int64_t>(verifier, VT_CURSCORE) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_GRADE) &&
           VerifyField<int64_t>(verifier, VT_ACCUMTOTALSCORE) &&
           VerifyField<int16_t>(verifier, VT_TRYCOUNT) &&
           VerifyField<int32_t>(verifier, VT_RANK) &&
           VerifyField<int32_t>(verifier, VT_RANKERCOUNT) &&
           VerifyField<int8_t>(verifier, VT_REWARDINDEX) &&
           VerifyField<int32_t>(verifier, VT_TODAYPLAYCOUNT) &&
           verifier.EndTable();
  }
};

struct ArenaInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_turnNo(int32_t turnNo) {
    fbb_.AddElement<int32_t>(ArenaInfo::VT_TURNNO, turnNo, 0);
  }
  void add_paidTurnNo(int32_t paidTurnNo) {
    fbb_.AddElement<int32_t>(ArenaInfo::VT_PAIDTURNNO, paidTurnNo, 0);
  }
  void add_consecutiveVictories(int16_t consecutiveVictories) {
    fbb_.AddElement<int16_t>(ArenaInfo::VT_CONSECUTIVEVICTORIES, consecutiveVictories, 0);
  }
  void add_curScore(int64_t curScore) {
    fbb_.AddElement<int64_t>(ArenaInfo::VT_CURSCORE, curScore, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(ArenaInfo::VT_LEVEL, level, 0);
  }
  void add_grade(int32_t grade) {
    fbb_.AddElement<int32_t>(ArenaInfo::VT_GRADE, grade, 0);
  }
  void add_accumTotalScore(int64_t accumTotalScore) {
    fbb_.AddElement<int64_t>(ArenaInfo::VT_ACCUMTOTALSCORE, accumTotalScore, 0);
  }
  void add_tryCount(int16_t tryCount) {
    fbb_.AddElement<int16_t>(ArenaInfo::VT_TRYCOUNT, tryCount, 0);
  }
  void add_rank(int32_t rank) {
    fbb_.AddElement<int32_t>(ArenaInfo::VT_RANK, rank, 0);
  }
  void add_rankerCount(int32_t rankerCount) {
    fbb_.AddElement<int32_t>(ArenaInfo::VT_RANKERCOUNT, rankerCount, 0);
  }
  void add_rewardIndex(int8_t rewardIndex) {
    fbb_.AddElement<int8_t>(ArenaInfo::VT_REWARDINDEX, rewardIndex, 0);
  }
  void add_todayPlayCount(int32_t todayPlayCount) {
    fbb_.AddElement<int32_t>(ArenaInfo::VT_TODAYPLAYCOUNT, todayPlayCount, 0);
  }
  explicit ArenaInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArenaInfoBuilder &operator=(const ArenaInfoBuilder &);
  flatbuffers::Offset<ArenaInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArenaInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArenaInfo> CreateArenaInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t turnNo = 0,
    int32_t paidTurnNo = 0,
    int16_t consecutiveVictories = 0,
    int64_t curScore = 0,
    int32_t level = 0,
    int32_t grade = 0,
    int64_t accumTotalScore = 0,
    int16_t tryCount = 0,
    int32_t rank = 0,
    int32_t rankerCount = 0,
    int8_t rewardIndex = 0,
    int32_t todayPlayCount = 0) {
  ArenaInfoBuilder builder_(_fbb);
  builder_.add_accumTotalScore(accumTotalScore);
  builder_.add_curScore(curScore);
  builder_.add_todayPlayCount(todayPlayCount);
  builder_.add_rankerCount(rankerCount);
  builder_.add_rank(rank);
  builder_.add_grade(grade);
  builder_.add_level(level);
  builder_.add_paidTurnNo(paidTurnNo);
  builder_.add_turnNo(turnNo);
  builder_.add_tryCount(tryCount);
  builder_.add_consecutiveVictories(consecutiveVictories);
  builder_.add_rewardIndex(rewardIndex);
  return builder_.Finish();
}

/// ----- 레이드 ---------------------
/// RAID_JOIN_FAILED_NOTIFY
struct RaidJoinFailNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRCODE = 4
  };
  int32_t errCode() const {
    return GetField<int32_t>(VT_ERRCODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           verifier.EndTable();
  }
};

struct RaidJoinFailNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errCode(int32_t errCode) {
    fbb_.AddElement<int32_t>(RaidJoinFailNotify::VT_ERRCODE, errCode, 0);
  }
  explicit RaidJoinFailNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RaidJoinFailNotifyBuilder &operator=(const RaidJoinFailNotifyBuilder &);
  flatbuffers::Offset<RaidJoinFailNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RaidJoinFailNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<RaidJoinFailNotify> CreateRaidJoinFailNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errCode = 0) {
  RaidJoinFailNotifyBuilder builder_(_fbb);
  builder_.add_errCode(errCode);
  return builder_.Finish();
}

/// RAID_INFO_REQUEST
struct RaidInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RaidInfoRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RaidInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RaidInfoRequestBuilder &operator=(const RaidInfoRequestBuilder &);
  flatbuffers::Offset<RaidInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RaidInfoRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RaidInfoRequest> CreateRaidInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RaidInfoRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// RAID_INFO_RESPONSE
struct RaidInfoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ENTERCOUNT = 4
  };
  int32_t enterCount() const {
    return GetField<int32_t>(VT_ENTERCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ENTERCOUNT) &&
           verifier.EndTable();
  }
};

struct RaidInfoResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enterCount(int32_t enterCount) {
    fbb_.AddElement<int32_t>(RaidInfoResponse::VT_ENTERCOUNT, enterCount, 0);
  }
  explicit RaidInfoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RaidInfoResponseBuilder &operator=(const RaidInfoResponseBuilder &);
  flatbuffers::Offset<RaidInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RaidInfoResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<RaidInfoResponse> CreateRaidInfoResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t enterCount = 0) {
  RaidInfoResponseBuilder builder_(_fbb);
  builder_.add_enterCount(enterCount);
  return builder_.Finish();
}

/// RAID_RANDOM_REWARD_PC_NOTIFY
struct RaidRandomRewardPcNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_REWARDID = 4,
    VT_PCRANK = 6,
    VT_PCNAME = 8
  };
  int32_t rewardId() const {
    return GetField<int32_t>(VT_REWARDID, 0);
  }
  int32_t pcRank() const {
    return GetField<int32_t>(VT_PCRANK, 0);
  }
  const flatbuffers::String *pcName() const {
    return GetPointer<const flatbuffers::String *>(VT_PCNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_REWARDID) &&
           VerifyField<int32_t>(verifier, VT_PCRANK) &&
           VerifyOffset(verifier, VT_PCNAME) &&
           verifier.VerifyString(pcName()) &&
           verifier.EndTable();
  }
};

struct RaidRandomRewardPcNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rewardId(int32_t rewardId) {
    fbb_.AddElement<int32_t>(RaidRandomRewardPcNotify::VT_REWARDID, rewardId, 0);
  }
  void add_pcRank(int32_t pcRank) {
    fbb_.AddElement<int32_t>(RaidRandomRewardPcNotify::VT_PCRANK, pcRank, 0);
  }
  void add_pcName(flatbuffers::Offset<flatbuffers::String> pcName) {
    fbb_.AddOffset(RaidRandomRewardPcNotify::VT_PCNAME, pcName);
  }
  explicit RaidRandomRewardPcNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RaidRandomRewardPcNotifyBuilder &operator=(const RaidRandomRewardPcNotifyBuilder &);
  flatbuffers::Offset<RaidRandomRewardPcNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RaidRandomRewardPcNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<RaidRandomRewardPcNotify> CreateRaidRandomRewardPcNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rewardId = 0,
    int32_t pcRank = 0,
    flatbuffers::Offset<flatbuffers::String> pcName = 0) {
  RaidRandomRewardPcNotifyBuilder builder_(_fbb);
  builder_.add_pcName(pcName);
  builder_.add_pcRank(pcRank);
  builder_.add_rewardId(rewardId);
  return builder_.Finish();
}

inline flatbuffers::Offset<RaidRandomRewardPcNotify> CreateRaidRandomRewardPcNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rewardId = 0,
    int32_t pcRank = 0,
    const char *pcName = nullptr) {
  return LeanPacket::CreateRaidRandomRewardPcNotify(
      _fbb,
      rewardId,
      pcRank,
      pcName ? _fbb.CreateString(pcName) : 0);
}

/// PC_LOGIN_DATA_COMPLETE_NOTIFY
struct PcLoginDataCompleteNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct PcLoginDataCompleteNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PcLoginDataCompleteNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PcLoginDataCompleteNotifyBuilder &operator=(const PcLoginDataCompleteNotifyBuilder &);
  flatbuffers::Offset<PcLoginDataCompleteNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PcLoginDataCompleteNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<PcLoginDataCompleteNotify> CreatePcLoginDataCompleteNotify(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PcLoginDataCompleteNotifyBuilder builder_(_fbb);
  return builder_.Finish();
}

struct PcLoginDataStartNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct PcLoginDataStartNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PcLoginDataStartNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PcLoginDataStartNotifyBuilder &operator=(const PcLoginDataStartNotifyBuilder &);
  flatbuffers::Offset<PcLoginDataStartNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PcLoginDataStartNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<PcLoginDataStartNotify> CreatePcLoginDataStartNotify(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PcLoginDataStartNotifyBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ArenaInfoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULT = 4,
    VT_ARENAINFO = 6
  };
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  const ArenaInfo *arenaInfo() const {
    return GetPointer<const ArenaInfo *>(VT_ARENAINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           VerifyOffset(verifier, VT_ARENAINFO) &&
           verifier.VerifyTable(arenaInfo()) &&
           verifier.EndTable();
  }
};

struct ArenaInfoResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(ArenaInfoResponse::VT_RESULT, result, 0);
  }
  void add_arenaInfo(flatbuffers::Offset<ArenaInfo> arenaInfo) {
    fbb_.AddOffset(ArenaInfoResponse::VT_ARENAINFO, arenaInfo);
  }
  explicit ArenaInfoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArenaInfoResponseBuilder &operator=(const ArenaInfoResponseBuilder &);
  flatbuffers::Offset<ArenaInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArenaInfoResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArenaInfoResponse> CreateArenaInfoResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    flatbuffers::Offset<ArenaInfo> arenaInfo = 0) {
  ArenaInfoResponseBuilder builder_(_fbb);
  builder_.add_arenaInfo(arenaInfo);
  builder_.add_result(result);
  return builder_.Finish();
}

struct CrystalSlot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_POSITIONIDX = 4,
    VT_ISOPEN = 6,
    VT_SLOTTYPE = 8
  };
  int32_t positionIdx() const {
    return GetField<int32_t>(VT_POSITIONIDX, 0);
  }
  bool isOpen() const {
    return GetField<uint8_t>(VT_ISOPEN, 0) != 0;
  }
  int32_t slotType() const {
    return GetField<int32_t>(VT_SLOTTYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_POSITIONIDX) &&
           VerifyField<uint8_t>(verifier, VT_ISOPEN) &&
           VerifyField<int32_t>(verifier, VT_SLOTTYPE) &&
           verifier.EndTable();
  }
};

struct CrystalSlotBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_positionIdx(int32_t positionIdx) {
    fbb_.AddElement<int32_t>(CrystalSlot::VT_POSITIONIDX, positionIdx, 0);
  }
  void add_isOpen(bool isOpen) {
    fbb_.AddElement<uint8_t>(CrystalSlot::VT_ISOPEN, static_cast<uint8_t>(isOpen), 0);
  }
  void add_slotType(int32_t slotType) {
    fbb_.AddElement<int32_t>(CrystalSlot::VT_SLOTTYPE, slotType, 0);
  }
  explicit CrystalSlotBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CrystalSlotBuilder &operator=(const CrystalSlotBuilder &);
  flatbuffers::Offset<CrystalSlot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CrystalSlot>(end);
    return o;
  }
};

inline flatbuffers::Offset<CrystalSlot> CreateCrystalSlot(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t positionIdx = 0,
    bool isOpen = false,
    int32_t slotType = 0) {
  CrystalSlotBuilder builder_(_fbb);
  builder_.add_slotType(slotType);
  builder_.add_positionIdx(positionIdx);
  builder_.add_isOpen(isOpen);
  return builder_.Finish();
}

/// DIMENSION_CRYSTAL_INSERT_REQUEST
struct DimensionCrystalInsertRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SOURCEITEMOBJECTID = 4,
    VT_MATERIALITEMOBJECTID = 6,
    VT_SLOTINDEX = 8
  };
  int64_t sourceItemObjectId() const {
    return GetField<int64_t>(VT_SOURCEITEMOBJECTID, 0);
  }
  int64_t materialItemObjectId() const {
    return GetField<int64_t>(VT_MATERIALITEMOBJECTID, 0);
  }
  int8_t slotIndex() const {
    return GetField<int8_t>(VT_SLOTINDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SOURCEITEMOBJECTID) &&
           VerifyField<int64_t>(verifier, VT_MATERIALITEMOBJECTID) &&
           VerifyField<int8_t>(verifier, VT_SLOTINDEX) &&
           verifier.EndTable();
  }
};

struct DimensionCrystalInsertRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sourceItemObjectId(int64_t sourceItemObjectId) {
    fbb_.AddElement<int64_t>(DimensionCrystalInsertRequest::VT_SOURCEITEMOBJECTID, sourceItemObjectId, 0);
  }
  void add_materialItemObjectId(int64_t materialItemObjectId) {
    fbb_.AddElement<int64_t>(DimensionCrystalInsertRequest::VT_MATERIALITEMOBJECTID, materialItemObjectId, 0);
  }
  void add_slotIndex(int8_t slotIndex) {
    fbb_.AddElement<int8_t>(DimensionCrystalInsertRequest::VT_SLOTINDEX, slotIndex, 0);
  }
  explicit DimensionCrystalInsertRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DimensionCrystalInsertRequestBuilder &operator=(const DimensionCrystalInsertRequestBuilder &);
  flatbuffers::Offset<DimensionCrystalInsertRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DimensionCrystalInsertRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DimensionCrystalInsertRequest> CreateDimensionCrystalInsertRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t sourceItemObjectId = 0,
    int64_t materialItemObjectId = 0,
    int8_t slotIndex = 0) {
  DimensionCrystalInsertRequestBuilder builder_(_fbb);
  builder_.add_materialItemObjectId(materialItemObjectId);
  builder_.add_sourceItemObjectId(sourceItemObjectId);
  builder_.add_slotIndex(slotIndex);
  return builder_.Finish();
}

/// DIMENSION_CRYSTAL_INSERT_RESPONSE
struct DimensionCrystalInsertResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SOURCEITEMOBJECTID = 4,
    VT_MATERIALOBJECTID = 6,
    VT_POSITIONIDX = 8,
    VT_RESULT = 10
  };
  int64_t sourceItemObjectId() const {
    return GetField<int64_t>(VT_SOURCEITEMOBJECTID, 0);
  }
  int64_t materialObjectId() const {
    return GetField<int64_t>(VT_MATERIALOBJECTID, 0);
  }
  int32_t positionIdx() const {
    return GetField<int32_t>(VT_POSITIONIDX, 0);
  }
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SOURCEITEMOBJECTID) &&
           VerifyField<int64_t>(verifier, VT_MATERIALOBJECTID) &&
           VerifyField<int32_t>(verifier, VT_POSITIONIDX) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           verifier.EndTable();
  }
};

struct DimensionCrystalInsertResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sourceItemObjectId(int64_t sourceItemObjectId) {
    fbb_.AddElement<int64_t>(DimensionCrystalInsertResponse::VT_SOURCEITEMOBJECTID, sourceItemObjectId, 0);
  }
  void add_materialObjectId(int64_t materialObjectId) {
    fbb_.AddElement<int64_t>(DimensionCrystalInsertResponse::VT_MATERIALOBJECTID, materialObjectId, 0);
  }
  void add_positionIdx(int32_t positionIdx) {
    fbb_.AddElement<int32_t>(DimensionCrystalInsertResponse::VT_POSITIONIDX, positionIdx, 0);
  }
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(DimensionCrystalInsertResponse::VT_RESULT, result, 0);
  }
  explicit DimensionCrystalInsertResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DimensionCrystalInsertResponseBuilder &operator=(const DimensionCrystalInsertResponseBuilder &);
  flatbuffers::Offset<DimensionCrystalInsertResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DimensionCrystalInsertResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<DimensionCrystalInsertResponse> CreateDimensionCrystalInsertResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t sourceItemObjectId = 0,
    int64_t materialObjectId = 0,
    int32_t positionIdx = 0,
    int32_t result = 0) {
  DimensionCrystalInsertResponseBuilder builder_(_fbb);
  builder_.add_materialObjectId(materialObjectId);
  builder_.add_sourceItemObjectId(sourceItemObjectId);
  builder_.add_result(result);
  builder_.add_positionIdx(positionIdx);
  return builder_.Finish();
}

/// DIMENSION_CRYSTAL_REMOVE_REQUEST
struct DimensionCrystalRemoveRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SOURCEITEMOBJECTID = 4,
    VT_MATERIALITEMOBJECTID = 6,
    VT_POSITIONIDX = 8
  };
  int64_t sourceItemObjectId() const {
    return GetField<int64_t>(VT_SOURCEITEMOBJECTID, 0);
  }
  int64_t materialItemObjectId() const {
    return GetField<int64_t>(VT_MATERIALITEMOBJECTID, 0);
  }
  int32_t positionIdx() const {
    return GetField<int32_t>(VT_POSITIONIDX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SOURCEITEMOBJECTID) &&
           VerifyField<int64_t>(verifier, VT_MATERIALITEMOBJECTID) &&
           VerifyField<int32_t>(verifier, VT_POSITIONIDX) &&
           verifier.EndTable();
  }
};

struct DimensionCrystalRemoveRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sourceItemObjectId(int64_t sourceItemObjectId) {
    fbb_.AddElement<int64_t>(DimensionCrystalRemoveRequest::VT_SOURCEITEMOBJECTID, sourceItemObjectId, 0);
  }
  void add_materialItemObjectId(int64_t materialItemObjectId) {
    fbb_.AddElement<int64_t>(DimensionCrystalRemoveRequest::VT_MATERIALITEMOBJECTID, materialItemObjectId, 0);
  }
  void add_positionIdx(int32_t positionIdx) {
    fbb_.AddElement<int32_t>(DimensionCrystalRemoveRequest::VT_POSITIONIDX, positionIdx, 0);
  }
  explicit DimensionCrystalRemoveRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DimensionCrystalRemoveRequestBuilder &operator=(const DimensionCrystalRemoveRequestBuilder &);
  flatbuffers::Offset<DimensionCrystalRemoveRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DimensionCrystalRemoveRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DimensionCrystalRemoveRequest> CreateDimensionCrystalRemoveRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t sourceItemObjectId = 0,
    int64_t materialItemObjectId = 0,
    int32_t positionIdx = 0) {
  DimensionCrystalRemoveRequestBuilder builder_(_fbb);
  builder_.add_materialItemObjectId(materialItemObjectId);
  builder_.add_sourceItemObjectId(sourceItemObjectId);
  builder_.add_positionIdx(positionIdx);
  return builder_.Finish();
}

/// DIMENSION_CRYSTAL_REMOVE_RESPONSE
struct DimensionCrystalRemoveResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SOURCEITEMOBJECTID = 4,
    VT_MATERIALITEMOBJECTID = 6,
    VT_RESULT = 8
  };
  int64_t sourceItemObjectid() const {
    return GetField<int64_t>(VT_SOURCEITEMOBJECTID, 0);
  }
  int64_t materialItemObjectId() const {
    return GetField<int64_t>(VT_MATERIALITEMOBJECTID, 0);
  }
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SOURCEITEMOBJECTID) &&
           VerifyField<int64_t>(verifier, VT_MATERIALITEMOBJECTID) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           verifier.EndTable();
  }
};

struct DimensionCrystalRemoveResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sourceItemObjectid(int64_t sourceItemObjectid) {
    fbb_.AddElement<int64_t>(DimensionCrystalRemoveResponse::VT_SOURCEITEMOBJECTID, sourceItemObjectid, 0);
  }
  void add_materialItemObjectId(int64_t materialItemObjectId) {
    fbb_.AddElement<int64_t>(DimensionCrystalRemoveResponse::VT_MATERIALITEMOBJECTID, materialItemObjectId, 0);
  }
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(DimensionCrystalRemoveResponse::VT_RESULT, result, 0);
  }
  explicit DimensionCrystalRemoveResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DimensionCrystalRemoveResponseBuilder &operator=(const DimensionCrystalRemoveResponseBuilder &);
  flatbuffers::Offset<DimensionCrystalRemoveResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DimensionCrystalRemoveResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<DimensionCrystalRemoveResponse> CreateDimensionCrystalRemoveResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t sourceItemObjectid = 0,
    int64_t materialItemObjectId = 0,
    int32_t result = 0) {
  DimensionCrystalRemoveResponseBuilder builder_(_fbb);
  builder_.add_materialItemObjectId(materialItemObjectId);
  builder_.add_sourceItemObjectid(sourceItemObjectid);
  builder_.add_result(result);
  return builder_.Finish();
}

/// DIMENSION_CRYSTAL_LEVELUP_REQUEST
struct DimensionCrystalLevelUpRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SOURCEITEMOBJECTID = 4,
    VT_MATERIALITEMOBJECTIDS = 6
  };
  int64_t sourceItemObjectId() const {
    return GetField<int64_t>(VT_SOURCEITEMOBJECTID, 0);
  }
  const flatbuffers::Vector<int64_t> *materialItemObjectIds() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_MATERIALITEMOBJECTIDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SOURCEITEMOBJECTID) &&
           VerifyOffsetRequired(verifier, VT_MATERIALITEMOBJECTIDS) &&
           verifier.VerifyVector(materialItemObjectIds()) &&
           verifier.EndTable();
  }
};

struct DimensionCrystalLevelUpRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sourceItemObjectId(int64_t sourceItemObjectId) {
    fbb_.AddElement<int64_t>(DimensionCrystalLevelUpRequest::VT_SOURCEITEMOBJECTID, sourceItemObjectId, 0);
  }
  void add_materialItemObjectIds(flatbuffers::Offset<flatbuffers::Vector<int64_t>> materialItemObjectIds) {
    fbb_.AddOffset(DimensionCrystalLevelUpRequest::VT_MATERIALITEMOBJECTIDS, materialItemObjectIds);
  }
  explicit DimensionCrystalLevelUpRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DimensionCrystalLevelUpRequestBuilder &operator=(const DimensionCrystalLevelUpRequestBuilder &);
  flatbuffers::Offset<DimensionCrystalLevelUpRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DimensionCrystalLevelUpRequest>(end);
    fbb_.Required(o, DimensionCrystalLevelUpRequest::VT_MATERIALITEMOBJECTIDS);
    return o;
  }
};

inline flatbuffers::Offset<DimensionCrystalLevelUpRequest> CreateDimensionCrystalLevelUpRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t sourceItemObjectId = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> materialItemObjectIds = 0) {
  DimensionCrystalLevelUpRequestBuilder builder_(_fbb);
  builder_.add_sourceItemObjectId(sourceItemObjectId);
  builder_.add_materialItemObjectIds(materialItemObjectIds);
  return builder_.Finish();
}

inline flatbuffers::Offset<DimensionCrystalLevelUpRequest> CreateDimensionCrystalLevelUpRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t sourceItemObjectId = 0,
    const std::vector<int64_t> *materialItemObjectIds = nullptr) {
  return LeanPacket::CreateDimensionCrystalLevelUpRequest(
      _fbb,
      sourceItemObjectId,
      materialItemObjectIds ? _fbb.CreateVector<int64_t>(*materialItemObjectIds) : 0);
}

/// DIMENISON_CRYSTAL_LEVELUP_RESPONSE
struct DimensionCrystalLevelUpResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SOURCEITEMOBJECTID = 4,
    VT_LEVEL = 6,
    VT_ENCHANTEXP = 8,
    VT_RESULT = 10
  };
  int64_t sourceItemObjectId() const {
    return GetField<int64_t>(VT_SOURCEITEMOBJECTID, 0);
  }
  int16_t level() const {
    return GetField<int16_t>(VT_LEVEL, 0);
  }
  int32_t enchantExp() const {
    return GetField<int32_t>(VT_ENCHANTEXP, 0);
  }
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SOURCEITEMOBJECTID) &&
           VerifyField<int16_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_ENCHANTEXP) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           verifier.EndTable();
  }
};

struct DimensionCrystalLevelUpResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sourceItemObjectId(int64_t sourceItemObjectId) {
    fbb_.AddElement<int64_t>(DimensionCrystalLevelUpResponse::VT_SOURCEITEMOBJECTID, sourceItemObjectId, 0);
  }
  void add_level(int16_t level) {
    fbb_.AddElement<int16_t>(DimensionCrystalLevelUpResponse::VT_LEVEL, level, 0);
  }
  void add_enchantExp(int32_t enchantExp) {
    fbb_.AddElement<int32_t>(DimensionCrystalLevelUpResponse::VT_ENCHANTEXP, enchantExp, 0);
  }
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(DimensionCrystalLevelUpResponse::VT_RESULT, result, 0);
  }
  explicit DimensionCrystalLevelUpResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DimensionCrystalLevelUpResponseBuilder &operator=(const DimensionCrystalLevelUpResponseBuilder &);
  flatbuffers::Offset<DimensionCrystalLevelUpResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DimensionCrystalLevelUpResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<DimensionCrystalLevelUpResponse> CreateDimensionCrystalLevelUpResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t sourceItemObjectId = 0,
    int16_t level = 0,
    int32_t enchantExp = 0,
    int32_t result = 0) {
  DimensionCrystalLevelUpResponseBuilder builder_(_fbb);
  builder_.add_sourceItemObjectId(sourceItemObjectId);
  builder_.add_result(result);
  builder_.add_enchantExp(enchantExp);
  builder_.add_level(level);
  return builder_.Finish();
}

/// DIMENSION_CRYSTAL_UPGRADE_REQUEST
struct DimensionCrystalUpgradeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SOURCEITEMOBJECTID = 4
  };
  int64_t sourceItemObjectId() const {
    return GetField<int64_t>(VT_SOURCEITEMOBJECTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SOURCEITEMOBJECTID) &&
           verifier.EndTable();
  }
};

struct DimensionCrystalUpgradeRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sourceItemObjectId(int64_t sourceItemObjectId) {
    fbb_.AddElement<int64_t>(DimensionCrystalUpgradeRequest::VT_SOURCEITEMOBJECTID, sourceItemObjectId, 0);
  }
  explicit DimensionCrystalUpgradeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DimensionCrystalUpgradeRequestBuilder &operator=(const DimensionCrystalUpgradeRequestBuilder &);
  flatbuffers::Offset<DimensionCrystalUpgradeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DimensionCrystalUpgradeRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DimensionCrystalUpgradeRequest> CreateDimensionCrystalUpgradeRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t sourceItemObjectId = 0) {
  DimensionCrystalUpgradeRequestBuilder builder_(_fbb);
  builder_.add_sourceItemObjectId(sourceItemObjectId);
  return builder_.Finish();
}

/// DIMENSION_CRYSTAL_UPGRADE_RESPONSE
struct DimensionCrystalUpgradeResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SOURCEITEMOBJECTID = 4,
    VT_GRADE = 6,
    VT_LEVEL = 8,
    VT_ENCHANTEXP = 10,
    VT_RESULT = 12
  };
  int64_t sourceItemObjectId() const {
    return GetField<int64_t>(VT_SOURCEITEMOBJECTID, 0);
  }
  int16_t grade() const {
    return GetField<int16_t>(VT_GRADE, 0);
  }
  int16_t level() const {
    return GetField<int16_t>(VT_LEVEL, 0);
  }
  int32_t enchantExp() const {
    return GetField<int32_t>(VT_ENCHANTEXP, 0);
  }
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SOURCEITEMOBJECTID) &&
           VerifyField<int16_t>(verifier, VT_GRADE) &&
           VerifyField<int16_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_ENCHANTEXP) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           verifier.EndTable();
  }
};

struct DimensionCrystalUpgradeResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sourceItemObjectId(int64_t sourceItemObjectId) {
    fbb_.AddElement<int64_t>(DimensionCrystalUpgradeResponse::VT_SOURCEITEMOBJECTID, sourceItemObjectId, 0);
  }
  void add_grade(int16_t grade) {
    fbb_.AddElement<int16_t>(DimensionCrystalUpgradeResponse::VT_GRADE, grade, 0);
  }
  void add_level(int16_t level) {
    fbb_.AddElement<int16_t>(DimensionCrystalUpgradeResponse::VT_LEVEL, level, 0);
  }
  void add_enchantExp(int32_t enchantExp) {
    fbb_.AddElement<int32_t>(DimensionCrystalUpgradeResponse::VT_ENCHANTEXP, enchantExp, 0);
  }
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(DimensionCrystalUpgradeResponse::VT_RESULT, result, 0);
  }
  explicit DimensionCrystalUpgradeResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DimensionCrystalUpgradeResponseBuilder &operator=(const DimensionCrystalUpgradeResponseBuilder &);
  flatbuffers::Offset<DimensionCrystalUpgradeResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DimensionCrystalUpgradeResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<DimensionCrystalUpgradeResponse> CreateDimensionCrystalUpgradeResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t sourceItemObjectId = 0,
    int16_t grade = 0,
    int16_t level = 0,
    int32_t enchantExp = 0,
    int32_t result = 0) {
  DimensionCrystalUpgradeResponseBuilder builder_(_fbb);
  builder_.add_sourceItemObjectId(sourceItemObjectId);
  builder_.add_result(result);
  builder_.add_enchantExp(enchantExp);
  builder_.add_level(level);
  builder_.add_grade(grade);
  return builder_.Finish();
}

///----- 보너스_일일 충전 -----------------
/// BONUS_DAILY_RECHARGE_MANUAL_REQUEST
struct DailyRechargeManualRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ARTIFACTLEVEL = 4
  };
  int16_t artifactLevel() const {
    return GetField<int16_t>(VT_ARTIFACTLEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_ARTIFACTLEVEL) &&
           verifier.EndTable();
  }
};

struct DailyRechargeManualRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_artifactLevel(int16_t artifactLevel) {
    fbb_.AddElement<int16_t>(DailyRechargeManualRequest::VT_ARTIFACTLEVEL, artifactLevel, 0);
  }
  explicit DailyRechargeManualRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DailyRechargeManualRequestBuilder &operator=(const DailyRechargeManualRequestBuilder &);
  flatbuffers::Offset<DailyRechargeManualRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DailyRechargeManualRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DailyRechargeManualRequest> CreateDailyRechargeManualRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t artifactLevel = 0) {
  DailyRechargeManualRequestBuilder builder_(_fbb);
  builder_.add_artifactLevel(artifactLevel);
  return builder_.Finish();
}

/// BONUS_DAILY_RECHARGE_MANUAL_RESPONSE
struct DailyRechargeManualResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRCODE = 4,
    VT_INVOICETYPE = 6,
    VT_REWARD = 8
  };
  int32_t errCode() const {
    return GetField<int32_t>(VT_ERRCODE, 0);
  }
  int16_t invoiceType() const {
    return GetField<int16_t>(VT_INVOICETYPE, 0);
  }
  const RewardInfo *reward() const {
    return GetPointer<const RewardInfo *>(VT_REWARD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           VerifyField<int16_t>(verifier, VT_INVOICETYPE) &&
           VerifyOffset(verifier, VT_REWARD) &&
           verifier.VerifyTable(reward()) &&
           verifier.EndTable();
  }
};

struct DailyRechargeManualResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errCode(int32_t errCode) {
    fbb_.AddElement<int32_t>(DailyRechargeManualResponse::VT_ERRCODE, errCode, 0);
  }
  void add_invoiceType(int16_t invoiceType) {
    fbb_.AddElement<int16_t>(DailyRechargeManualResponse::VT_INVOICETYPE, invoiceType, 0);
  }
  void add_reward(flatbuffers::Offset<RewardInfo> reward) {
    fbb_.AddOffset(DailyRechargeManualResponse::VT_REWARD, reward);
  }
  explicit DailyRechargeManualResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DailyRechargeManualResponseBuilder &operator=(const DailyRechargeManualResponseBuilder &);
  flatbuffers::Offset<DailyRechargeManualResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DailyRechargeManualResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<DailyRechargeManualResponse> CreateDailyRechargeManualResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errCode = 0,
    int16_t invoiceType = 0,
    flatbuffers::Offset<RewardInfo> reward = 0) {
  DailyRechargeManualResponseBuilder builder_(_fbb);
  builder_.add_reward(reward);
  builder_.add_errCode(errCode);
  builder_.add_invoiceType(invoiceType);
  return builder_.Finish();
}

/// BONUS_DAILY_RECHARGE_INFO_REQUEST 
struct BonusDailyRechargeInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct BonusDailyRechargeInfoRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BonusDailyRechargeInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BonusDailyRechargeInfoRequestBuilder &operator=(const BonusDailyRechargeInfoRequestBuilder &);
  flatbuffers::Offset<BonusDailyRechargeInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BonusDailyRechargeInfoRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<BonusDailyRechargeInfoRequest> CreateBonusDailyRechargeInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BonusDailyRechargeInfoRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// BONUS_DAILY_RECHARGE_INFO_RESPONSE
struct BonusDailyRechargeInfoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ISMANUALRECHARGABLE = 4
  };
  bool isManualRechargable() const {
    return GetField<uint8_t>(VT_ISMANUALRECHARGABLE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ISMANUALRECHARGABLE) &&
           verifier.EndTable();
  }
};

struct BonusDailyRechargeInfoResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_isManualRechargable(bool isManualRechargable) {
    fbb_.AddElement<uint8_t>(BonusDailyRechargeInfoResponse::VT_ISMANUALRECHARGABLE, static_cast<uint8_t>(isManualRechargable), 0);
  }
  explicit BonusDailyRechargeInfoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BonusDailyRechargeInfoResponseBuilder &operator=(const BonusDailyRechargeInfoResponseBuilder &);
  flatbuffers::Offset<BonusDailyRechargeInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BonusDailyRechargeInfoResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<BonusDailyRechargeInfoResponse> CreateBonusDailyRechargeInfoResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool isManualRechargable = false) {
  BonusDailyRechargeInfoResponseBuilder builder_(_fbb);
  builder_.add_isManualRechargable(isManualRechargable);
  return builder_.Finish();
}

struct InfiniteTowerInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CLEAREDSTAGE = 4,
    VT_ISREWARDABLE = 6
  };
  int32_t clearedStage() const {
    return GetField<int32_t>(VT_CLEAREDSTAGE, 0);
  }
  bool isRewardable() const {
    return GetField<uint8_t>(VT_ISREWARDABLE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CLEAREDSTAGE) &&
           VerifyField<uint8_t>(verifier, VT_ISREWARDABLE) &&
           verifier.EndTable();
  }
};

struct InfiniteTowerInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_clearedStage(int32_t clearedStage) {
    fbb_.AddElement<int32_t>(InfiniteTowerInfo::VT_CLEAREDSTAGE, clearedStage, 0);
  }
  void add_isRewardable(bool isRewardable) {
    fbb_.AddElement<uint8_t>(InfiniteTowerInfo::VT_ISREWARDABLE, static_cast<uint8_t>(isRewardable), 0);
  }
  explicit InfiniteTowerInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InfiniteTowerInfoBuilder &operator=(const InfiniteTowerInfoBuilder &);
  flatbuffers::Offset<InfiniteTowerInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InfiniteTowerInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<InfiniteTowerInfo> CreateInfiniteTowerInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t clearedStage = 0,
    bool isRewardable = false) {
  InfiniteTowerInfoBuilder builder_(_fbb);
  builder_.add_clearedStage(clearedStage);
  builder_.add_isRewardable(isRewardable);
  return builder_.Finish();
}

/// INFINITE_TOWER_INFO_REQUEST
struct InfiniteTowerInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct InfiniteTowerInfoRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit InfiniteTowerInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InfiniteTowerInfoRequestBuilder &operator=(const InfiniteTowerInfoRequestBuilder &);
  flatbuffers::Offset<InfiniteTowerInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InfiniteTowerInfoRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<InfiniteTowerInfoRequest> CreateInfiniteTowerInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  InfiniteTowerInfoRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// INFINITE_TOWER_INFO_RESPONSE
struct InfiniteTowerInfoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INFO = 4
  };
  const InfiniteTowerInfo *info() const {
    return GetPointer<const InfiniteTowerInfo *>(VT_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           verifier.EndTable();
  }
};

struct InfiniteTowerInfoResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_info(flatbuffers::Offset<InfiniteTowerInfo> info) {
    fbb_.AddOffset(InfiniteTowerInfoResponse::VT_INFO, info);
  }
  explicit InfiniteTowerInfoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InfiniteTowerInfoResponseBuilder &operator=(const InfiniteTowerInfoResponseBuilder &);
  flatbuffers::Offset<InfiniteTowerInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InfiniteTowerInfoResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<InfiniteTowerInfoResponse> CreateInfiniteTowerInfoResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<InfiniteTowerInfo> info = 0) {
  InfiniteTowerInfoResponseBuilder builder_(_fbb);
  builder_.add_info(info);
  return builder_.Finish();
}

/// INFINITE_TOWER_JOIN_REQUEST
struct InfiniteTowerJoinRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STAGE = 4,
    VT_PAIDTYPE = 6
  };
  int32_t stage() const {
    return GetField<int32_t>(VT_STAGE, 0);
  }
  InfiniteTowerPaidType paidType() const {
    return static_cast<InfiniteTowerPaidType>(GetField<int32_t>(VT_PAIDTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STAGE) &&
           VerifyField<int32_t>(verifier, VT_PAIDTYPE) &&
           verifier.EndTable();
  }
};

struct InfiniteTowerJoinRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stage(int32_t stage) {
    fbb_.AddElement<int32_t>(InfiniteTowerJoinRequest::VT_STAGE, stage, 0);
  }
  void add_paidType(InfiniteTowerPaidType paidType) {
    fbb_.AddElement<int32_t>(InfiniteTowerJoinRequest::VT_PAIDTYPE, static_cast<int32_t>(paidType), 0);
  }
  explicit InfiniteTowerJoinRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InfiniteTowerJoinRequestBuilder &operator=(const InfiniteTowerJoinRequestBuilder &);
  flatbuffers::Offset<InfiniteTowerJoinRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InfiniteTowerJoinRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<InfiniteTowerJoinRequest> CreateInfiniteTowerJoinRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t stage = 0,
    InfiniteTowerPaidType paidType = InfiniteTowerPaidType_INFINITE_TOWER_PAID_TYPE_TICKET) {
  InfiniteTowerJoinRequestBuilder builder_(_fbb);
  builder_.add_paidType(paidType);
  builder_.add_stage(stage);
  return builder_.Finish();
}

/// INFINITE_TOWER_JOIN_RESPONSE
struct InfiniteTowerJoinResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRCODE = 4
  };
  int32_t errCode() const {
    return GetField<int32_t>(VT_ERRCODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           verifier.EndTable();
  }
};

struct InfiniteTowerJoinResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errCode(int32_t errCode) {
    fbb_.AddElement<int32_t>(InfiniteTowerJoinResponse::VT_ERRCODE, errCode, 0);
  }
  explicit InfiniteTowerJoinResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InfiniteTowerJoinResponseBuilder &operator=(const InfiniteTowerJoinResponseBuilder &);
  flatbuffers::Offset<InfiniteTowerJoinResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InfiniteTowerJoinResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<InfiniteTowerJoinResponse> CreateInfiniteTowerJoinResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errCode = 0) {
  InfiniteTowerJoinResponseBuilder builder_(_fbb);
  builder_.add_errCode(errCode);
  return builder_.Finish();
}

/// INFINITE_TOWER_SWEEP_REQUEST
struct InfiniteTowerSweepRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STAGE = 4
  };
  int32_t stage() const {
    return GetField<int32_t>(VT_STAGE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STAGE) &&
           verifier.EndTable();
  }
};

struct InfiniteTowerSweepRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stage(int32_t stage) {
    fbb_.AddElement<int32_t>(InfiniteTowerSweepRequest::VT_STAGE, stage, 0);
  }
  explicit InfiniteTowerSweepRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InfiniteTowerSweepRequestBuilder &operator=(const InfiniteTowerSweepRequestBuilder &);
  flatbuffers::Offset<InfiniteTowerSweepRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InfiniteTowerSweepRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<InfiniteTowerSweepRequest> CreateInfiniteTowerSweepRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t stage = 0) {
  InfiniteTowerSweepRequestBuilder builder_(_fbb);
  builder_.add_stage(stage);
  return builder_.Finish();
}

/// INFINITE_TOWER_SWEEP_RESPONSE
struct InfiniteTowerSweepResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRCODE = 4,
    VT_REWARD = 6
  };
  int32_t errCode() const {
    return GetField<int32_t>(VT_ERRCODE, 0);
  }
  const RewardInfo *reward() const {
    return GetPointer<const RewardInfo *>(VT_REWARD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           VerifyOffset(verifier, VT_REWARD) &&
           verifier.VerifyTable(reward()) &&
           verifier.EndTable();
  }
};

struct InfiniteTowerSweepResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errCode(int32_t errCode) {
    fbb_.AddElement<int32_t>(InfiniteTowerSweepResponse::VT_ERRCODE, errCode, 0);
  }
  void add_reward(flatbuffers::Offset<RewardInfo> reward) {
    fbb_.AddOffset(InfiniteTowerSweepResponse::VT_REWARD, reward);
  }
  explicit InfiniteTowerSweepResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InfiniteTowerSweepResponseBuilder &operator=(const InfiniteTowerSweepResponseBuilder &);
  flatbuffers::Offset<InfiniteTowerSweepResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InfiniteTowerSweepResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<InfiniteTowerSweepResponse> CreateInfiniteTowerSweepResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errCode = 0,
    flatbuffers::Offset<RewardInfo> reward = 0) {
  InfiniteTowerSweepResponseBuilder builder_(_fbb);
  builder_.add_reward(reward);
  builder_.add_errCode(errCode);
  return builder_.Finish();
}

/// INFINITE_TOWER_CLEAR_NOTIFY
struct InfiniteTowerClearNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STAGE = 4,
    VT_REWARD = 6
  };
  int32_t stage() const {
    return GetField<int32_t>(VT_STAGE, 0);
  }
  const RewardInfo *reward() const {
    return GetPointer<const RewardInfo *>(VT_REWARD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STAGE) &&
           VerifyOffsetRequired(verifier, VT_REWARD) &&
           verifier.VerifyTable(reward()) &&
           verifier.EndTable();
  }
};

struct InfiniteTowerClearNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stage(int32_t stage) {
    fbb_.AddElement<int32_t>(InfiniteTowerClearNotify::VT_STAGE, stage, 0);
  }
  void add_reward(flatbuffers::Offset<RewardInfo> reward) {
    fbb_.AddOffset(InfiniteTowerClearNotify::VT_REWARD, reward);
  }
  explicit InfiniteTowerClearNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InfiniteTowerClearNotifyBuilder &operator=(const InfiniteTowerClearNotifyBuilder &);
  flatbuffers::Offset<InfiniteTowerClearNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InfiniteTowerClearNotify>(end);
    fbb_.Required(o, InfiniteTowerClearNotify::VT_REWARD);
    return o;
  }
};

inline flatbuffers::Offset<InfiniteTowerClearNotify> CreateInfiniteTowerClearNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t stage = 0,
    flatbuffers::Offset<RewardInfo> reward = 0) {
  InfiniteTowerClearNotifyBuilder builder_(_fbb);
  builder_.add_reward(reward);
  builder_.add_stage(stage);
  return builder_.Finish();
}

struct ShopPurchaseProductMissionInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MISSIONID = 4,
    VT_STATE = 6,
    VT_UPDATETIME = 8
  };
  int8_t missionId() const {
    return GetField<int8_t>(VT_MISSIONID, 0);
  }
  int8_t state() const {
    return GetField<int8_t>(VT_STATE, 0);
  }
  int64_t updateTime() const {
    return GetField<int64_t>(VT_UPDATETIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MISSIONID) &&
           VerifyField<int8_t>(verifier, VT_STATE) &&
           VerifyField<int64_t>(verifier, VT_UPDATETIME) &&
           verifier.EndTable();
  }
};

struct ShopPurchaseProductMissionInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_missionId(int8_t missionId) {
    fbb_.AddElement<int8_t>(ShopPurchaseProductMissionInfo::VT_MISSIONID, missionId, 0);
  }
  void add_state(int8_t state) {
    fbb_.AddElement<int8_t>(ShopPurchaseProductMissionInfo::VT_STATE, state, 0);
  }
  void add_updateTime(int64_t updateTime) {
    fbb_.AddElement<int64_t>(ShopPurchaseProductMissionInfo::VT_UPDATETIME, updateTime, 0);
  }
  explicit ShopPurchaseProductMissionInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShopPurchaseProductMissionInfoBuilder &operator=(const ShopPurchaseProductMissionInfoBuilder &);
  flatbuffers::Offset<ShopPurchaseProductMissionInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShopPurchaseProductMissionInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShopPurchaseProductMissionInfo> CreateShopPurchaseProductMissionInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t missionId = 0,
    int8_t state = 0,
    int64_t updateTime = 0) {
  ShopPurchaseProductMissionInfoBuilder builder_(_fbb);
  builder_.add_updateTime(updateTime);
  builder_.add_state(state);
  builder_.add_missionId(missionId);
  return builder_.Finish();
}

struct ShopPurchaseProductInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRODUCTID = 4,
    VT_PURCHASETIME = 6,
    VT_EXPIRETIME = 8,
    VT_PURCHASECOUNT = 10,
    VT_BONUSPOINT = 12,
    VT_PROMOTIONPOINT = 14,
    VT_MISSIONS = 16
  };
  int32_t productId() const {
    return GetField<int32_t>(VT_PRODUCTID, 0);
  }
  int64_t purchaseTime() const {
    return GetField<int64_t>(VT_PURCHASETIME, 0);
  }
  int64_t expireTime() const {
    return GetField<int64_t>(VT_EXPIRETIME, 0);
  }
  int8_t purchaseCount() const {
    return GetField<int8_t>(VT_PURCHASECOUNT, 0);
  }
  int16_t bonusPoint() const {
    return GetField<int16_t>(VT_BONUSPOINT, 0);
  }
  int32_t promotionPoint() const {
    return GetField<int32_t>(VT_PROMOTIONPOINT, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ShopPurchaseProductMissionInfo>> *missions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ShopPurchaseProductMissionInfo>> *>(VT_MISSIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PRODUCTID) &&
           VerifyField<int64_t>(verifier, VT_PURCHASETIME) &&
           VerifyField<int64_t>(verifier, VT_EXPIRETIME) &&
           VerifyField<int8_t>(verifier, VT_PURCHASECOUNT) &&
           VerifyField<int16_t>(verifier, VT_BONUSPOINT) &&
           VerifyField<int32_t>(verifier, VT_PROMOTIONPOINT) &&
           VerifyOffsetRequired(verifier, VT_MISSIONS) &&
           verifier.VerifyVector(missions()) &&
           verifier.VerifyVectorOfTables(missions()) &&
           verifier.EndTable();
  }
};

struct ShopPurchaseProductInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_productId(int32_t productId) {
    fbb_.AddElement<int32_t>(ShopPurchaseProductInfo::VT_PRODUCTID, productId, 0);
  }
  void add_purchaseTime(int64_t purchaseTime) {
    fbb_.AddElement<int64_t>(ShopPurchaseProductInfo::VT_PURCHASETIME, purchaseTime, 0);
  }
  void add_expireTime(int64_t expireTime) {
    fbb_.AddElement<int64_t>(ShopPurchaseProductInfo::VT_EXPIRETIME, expireTime, 0);
  }
  void add_purchaseCount(int8_t purchaseCount) {
    fbb_.AddElement<int8_t>(ShopPurchaseProductInfo::VT_PURCHASECOUNT, purchaseCount, 0);
  }
  void add_bonusPoint(int16_t bonusPoint) {
    fbb_.AddElement<int16_t>(ShopPurchaseProductInfo::VT_BONUSPOINT, bonusPoint, 0);
  }
  void add_promotionPoint(int32_t promotionPoint) {
    fbb_.AddElement<int32_t>(ShopPurchaseProductInfo::VT_PROMOTIONPOINT, promotionPoint, 0);
  }
  void add_missions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShopPurchaseProductMissionInfo>>> missions) {
    fbb_.AddOffset(ShopPurchaseProductInfo::VT_MISSIONS, missions);
  }
  explicit ShopPurchaseProductInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShopPurchaseProductInfoBuilder &operator=(const ShopPurchaseProductInfoBuilder &);
  flatbuffers::Offset<ShopPurchaseProductInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShopPurchaseProductInfo>(end);
    fbb_.Required(o, ShopPurchaseProductInfo::VT_MISSIONS);
    return o;
  }
};

inline flatbuffers::Offset<ShopPurchaseProductInfo> CreateShopPurchaseProductInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t productId = 0,
    int64_t purchaseTime = 0,
    int64_t expireTime = 0,
    int8_t purchaseCount = 0,
    int16_t bonusPoint = 0,
    int32_t promotionPoint = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShopPurchaseProductMissionInfo>>> missions = 0) {
  ShopPurchaseProductInfoBuilder builder_(_fbb);
  builder_.add_expireTime(expireTime);
  builder_.add_purchaseTime(purchaseTime);
  builder_.add_missions(missions);
  builder_.add_promotionPoint(promotionPoint);
  builder_.add_productId(productId);
  builder_.add_bonusPoint(bonusPoint);
  builder_.add_purchaseCount(purchaseCount);
  return builder_.Finish();
}

inline flatbuffers::Offset<ShopPurchaseProductInfo> CreateShopPurchaseProductInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t productId = 0,
    int64_t purchaseTime = 0,
    int64_t expireTime = 0,
    int8_t purchaseCount = 0,
    int16_t bonusPoint = 0,
    int32_t promotionPoint = 0,
    const std::vector<flatbuffers::Offset<ShopPurchaseProductMissionInfo>> *missions = nullptr) {
  return LeanPacket::CreateShopPurchaseProductInfo(
      _fbb,
      productId,
      purchaseTime,
      expireTime,
      purchaseCount,
      bonusPoint,
      promotionPoint,
      missions ? _fbb.CreateVector<flatbuffers::Offset<ShopPurchaseProductMissionInfo>>(*missions) : 0);
}

/// SHOP_PURCHASE_PRODUCT_REQUEST
struct ShopPurchaseProductRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRODUCTID = 4,
    VT_GIFTPCDBID = 6,
    VT_BUYCOUNT = 8
  };
  int32_t productId() const {
    return GetField<int32_t>(VT_PRODUCTID, 0);
  }
  int64_t giftPcDbId() const {
    return GetField<int64_t>(VT_GIFTPCDBID, 0);
  }
  uint8_t buyCount() const {
    return GetField<uint8_t>(VT_BUYCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PRODUCTID) &&
           VerifyField<int64_t>(verifier, VT_GIFTPCDBID) &&
           VerifyField<uint8_t>(verifier, VT_BUYCOUNT) &&
           verifier.EndTable();
  }
};

struct ShopPurchaseProductRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_productId(int32_t productId) {
    fbb_.AddElement<int32_t>(ShopPurchaseProductRequest::VT_PRODUCTID, productId, 0);
  }
  void add_giftPcDbId(int64_t giftPcDbId) {
    fbb_.AddElement<int64_t>(ShopPurchaseProductRequest::VT_GIFTPCDBID, giftPcDbId, 0);
  }
  void add_buyCount(uint8_t buyCount) {
    fbb_.AddElement<uint8_t>(ShopPurchaseProductRequest::VT_BUYCOUNT, buyCount, 0);
  }
  explicit ShopPurchaseProductRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShopPurchaseProductRequestBuilder &operator=(const ShopPurchaseProductRequestBuilder &);
  flatbuffers::Offset<ShopPurchaseProductRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShopPurchaseProductRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShopPurchaseProductRequest> CreateShopPurchaseProductRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t productId = 0,
    int64_t giftPcDbId = 0,
    uint8_t buyCount = 0) {
  ShopPurchaseProductRequestBuilder builder_(_fbb);
  builder_.add_giftPcDbId(giftPcDbId);
  builder_.add_productId(productId);
  builder_.add_buyCount(buyCount);
  return builder_.Finish();
}

struct EffectGrade FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMID = 4,
    VT_REWARDGRADE = 6
  };
  int32_t itemId() const {
    return GetField<int32_t>(VT_ITEMID, 0);
  }
  int32_t rewardGrade() const {
    return GetField<int32_t>(VT_REWARDGRADE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ITEMID) &&
           VerifyField<int32_t>(verifier, VT_REWARDGRADE) &&
           verifier.EndTable();
  }
};

struct EffectGradeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemId(int32_t itemId) {
    fbb_.AddElement<int32_t>(EffectGrade::VT_ITEMID, itemId, 0);
  }
  void add_rewardGrade(int32_t rewardGrade) {
    fbb_.AddElement<int32_t>(EffectGrade::VT_REWARDGRADE, rewardGrade, 0);
  }
  explicit EffectGradeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EffectGradeBuilder &operator=(const EffectGradeBuilder &);
  flatbuffers::Offset<EffectGrade> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EffectGrade>(end);
    return o;
  }
};

inline flatbuffers::Offset<EffectGrade> CreateEffectGrade(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t itemId = 0,
    int32_t rewardGrade = 0) {
  EffectGradeBuilder builder_(_fbb);
  builder_.add_rewardGrade(rewardGrade);
  builder_.add_itemId(itemId);
  return builder_.Finish();
}

/// SHOP_PURCHASE_PRODUCT_RESPONSE
struct ShopPurchaseProductResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRODUCTID = 4,
    VT_GIFTPCDBID = 6,
    VT_ERROR = 8,
    VT_PRODUCTINFO = 10,
    VT_REWARD = 12,
    VT_GIFTPCNAME = 14,
    VT_EFFECTGRADE = 16
  };
  int32_t productId() const {
    return GetField<int32_t>(VT_PRODUCTID, 0);
  }
  int64_t giftPcDbId() const {
    return GetField<int64_t>(VT_GIFTPCDBID, 0);
  }
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  const ShopPurchaseProductInfo *productInfo() const {
    return GetPointer<const ShopPurchaseProductInfo *>(VT_PRODUCTINFO);
  }
  const MailRewardInfo *reward() const {
    return GetPointer<const MailRewardInfo *>(VT_REWARD);
  }
  const flatbuffers::String *giftPcName() const {
    return GetPointer<const flatbuffers::String *>(VT_GIFTPCNAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<EffectGrade>> *effectGrade() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EffectGrade>> *>(VT_EFFECTGRADE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PRODUCTID) &&
           VerifyField<int64_t>(verifier, VT_GIFTPCDBID) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           VerifyOffset(verifier, VT_PRODUCTINFO) &&
           verifier.VerifyTable(productInfo()) &&
           VerifyOffset(verifier, VT_REWARD) &&
           verifier.VerifyTable(reward()) &&
           VerifyOffset(verifier, VT_GIFTPCNAME) &&
           verifier.VerifyString(giftPcName()) &&
           VerifyOffset(verifier, VT_EFFECTGRADE) &&
           verifier.VerifyVector(effectGrade()) &&
           verifier.VerifyVectorOfTables(effectGrade()) &&
           verifier.EndTable();
  }
};

struct ShopPurchaseProductResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_productId(int32_t productId) {
    fbb_.AddElement<int32_t>(ShopPurchaseProductResponse::VT_PRODUCTID, productId, 0);
  }
  void add_giftPcDbId(int64_t giftPcDbId) {
    fbb_.AddElement<int64_t>(ShopPurchaseProductResponse::VT_GIFTPCDBID, giftPcDbId, 0);
  }
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(ShopPurchaseProductResponse::VT_ERROR, error, 0);
  }
  void add_productInfo(flatbuffers::Offset<ShopPurchaseProductInfo> productInfo) {
    fbb_.AddOffset(ShopPurchaseProductResponse::VT_PRODUCTINFO, productInfo);
  }
  void add_reward(flatbuffers::Offset<MailRewardInfo> reward) {
    fbb_.AddOffset(ShopPurchaseProductResponse::VT_REWARD, reward);
  }
  void add_giftPcName(flatbuffers::Offset<flatbuffers::String> giftPcName) {
    fbb_.AddOffset(ShopPurchaseProductResponse::VT_GIFTPCNAME, giftPcName);
  }
  void add_effectGrade(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EffectGrade>>> effectGrade) {
    fbb_.AddOffset(ShopPurchaseProductResponse::VT_EFFECTGRADE, effectGrade);
  }
  explicit ShopPurchaseProductResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShopPurchaseProductResponseBuilder &operator=(const ShopPurchaseProductResponseBuilder &);
  flatbuffers::Offset<ShopPurchaseProductResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShopPurchaseProductResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShopPurchaseProductResponse> CreateShopPurchaseProductResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t productId = 0,
    int64_t giftPcDbId = 0,
    int32_t error = 0,
    flatbuffers::Offset<ShopPurchaseProductInfo> productInfo = 0,
    flatbuffers::Offset<MailRewardInfo> reward = 0,
    flatbuffers::Offset<flatbuffers::String> giftPcName = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EffectGrade>>> effectGrade = 0) {
  ShopPurchaseProductResponseBuilder builder_(_fbb);
  builder_.add_giftPcDbId(giftPcDbId);
  builder_.add_effectGrade(effectGrade);
  builder_.add_giftPcName(giftPcName);
  builder_.add_reward(reward);
  builder_.add_productInfo(productInfo);
  builder_.add_error(error);
  builder_.add_productId(productId);
  return builder_.Finish();
}

inline flatbuffers::Offset<ShopPurchaseProductResponse> CreateShopPurchaseProductResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t productId = 0,
    int64_t giftPcDbId = 0,
    int32_t error = 0,
    flatbuffers::Offset<ShopPurchaseProductInfo> productInfo = 0,
    flatbuffers::Offset<MailRewardInfo> reward = 0,
    const char *giftPcName = nullptr,
    const std::vector<flatbuffers::Offset<EffectGrade>> *effectGrade = nullptr) {
  return LeanPacket::CreateShopPurchaseProductResponse(
      _fbb,
      productId,
      giftPcDbId,
      error,
      productInfo,
      reward,
      giftPcName ? _fbb.CreateString(giftPcName) : 0,
      effectGrade ? _fbb.CreateVector<flatbuffers::Offset<EffectGrade>>(*effectGrade) : 0);
}

/// SHOP_PURCHASE_PRODUCT_REWARD_REQUEST
struct ShopPurchaseProductRewardRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRODUCTID = 4,
    VT_MISSIONID = 6
  };
  int32_t productId() const {
    return GetField<int32_t>(VT_PRODUCTID, 0);
  }
  int16_t missionId() const {
    return GetField<int16_t>(VT_MISSIONID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PRODUCTID) &&
           VerifyField<int16_t>(verifier, VT_MISSIONID) &&
           verifier.EndTable();
  }
};

struct ShopPurchaseProductRewardRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_productId(int32_t productId) {
    fbb_.AddElement<int32_t>(ShopPurchaseProductRewardRequest::VT_PRODUCTID, productId, 0);
  }
  void add_missionId(int16_t missionId) {
    fbb_.AddElement<int16_t>(ShopPurchaseProductRewardRequest::VT_MISSIONID, missionId, 0);
  }
  explicit ShopPurchaseProductRewardRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShopPurchaseProductRewardRequestBuilder &operator=(const ShopPurchaseProductRewardRequestBuilder &);
  flatbuffers::Offset<ShopPurchaseProductRewardRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShopPurchaseProductRewardRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShopPurchaseProductRewardRequest> CreateShopPurchaseProductRewardRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t productId = 0,
    int16_t missionId = 0) {
  ShopPurchaseProductRewardRequestBuilder builder_(_fbb);
  builder_.add_productId(productId);
  builder_.add_missionId(missionId);
  return builder_.Finish();
}

/// SHOP_PURCHASE_PRODUCT_REWARD_RESPONSE
struct ShopPurchaseProductRewardResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRODUCTID = 4,
    VT_MISSIONID = 6,
    VT_ERROR = 8,
    VT_REWARD = 10
  };
  int32_t productId() const {
    return GetField<int32_t>(VT_PRODUCTID, 0);
  }
  int16_t missionId() const {
    return GetField<int16_t>(VT_MISSIONID, 0);
  }
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  const MailRewardInfo *reward() const {
    return GetPointer<const MailRewardInfo *>(VT_REWARD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PRODUCTID) &&
           VerifyField<int16_t>(verifier, VT_MISSIONID) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           VerifyOffset(verifier, VT_REWARD) &&
           verifier.VerifyTable(reward()) &&
           verifier.EndTable();
  }
};

struct ShopPurchaseProductRewardResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_productId(int32_t productId) {
    fbb_.AddElement<int32_t>(ShopPurchaseProductRewardResponse::VT_PRODUCTID, productId, 0);
  }
  void add_missionId(int16_t missionId) {
    fbb_.AddElement<int16_t>(ShopPurchaseProductRewardResponse::VT_MISSIONID, missionId, 0);
  }
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(ShopPurchaseProductRewardResponse::VT_ERROR, error, 0);
  }
  void add_reward(flatbuffers::Offset<MailRewardInfo> reward) {
    fbb_.AddOffset(ShopPurchaseProductRewardResponse::VT_REWARD, reward);
  }
  explicit ShopPurchaseProductRewardResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShopPurchaseProductRewardResponseBuilder &operator=(const ShopPurchaseProductRewardResponseBuilder &);
  flatbuffers::Offset<ShopPurchaseProductRewardResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShopPurchaseProductRewardResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShopPurchaseProductRewardResponse> CreateShopPurchaseProductRewardResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t productId = 0,
    int16_t missionId = 0,
    int32_t error = 0,
    flatbuffers::Offset<MailRewardInfo> reward = 0) {
  ShopPurchaseProductRewardResponseBuilder builder_(_fbb);
  builder_.add_reward(reward);
  builder_.add_error(error);
  builder_.add_productId(productId);
  builder_.add_missionId(missionId);
  return builder_.Finish();
}

/// SHOP_PURCHASE_PRODUCT_BONUS_REWARD_REQUEST
struct ShopPurchaseProductBonusRewardRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRODUCTID = 4
  };
  int32_t productId() const {
    return GetField<int32_t>(VT_PRODUCTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PRODUCTID) &&
           verifier.EndTable();
  }
};

struct ShopPurchaseProductBonusRewardRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_productId(int32_t productId) {
    fbb_.AddElement<int32_t>(ShopPurchaseProductBonusRewardRequest::VT_PRODUCTID, productId, 0);
  }
  explicit ShopPurchaseProductBonusRewardRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShopPurchaseProductBonusRewardRequestBuilder &operator=(const ShopPurchaseProductBonusRewardRequestBuilder &);
  flatbuffers::Offset<ShopPurchaseProductBonusRewardRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShopPurchaseProductBonusRewardRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShopPurchaseProductBonusRewardRequest> CreateShopPurchaseProductBonusRewardRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t productId = 0) {
  ShopPurchaseProductBonusRewardRequestBuilder builder_(_fbb);
  builder_.add_productId(productId);
  return builder_.Finish();
}

/// SHOP_PURCHASE_PRODUCT_BONUS_REWARD_RESPONSE
struct ShopPurchaseProductBonusRewardResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRODUCTID = 4,
    VT_ERROR = 6,
    VT_BOUNSPOINT = 8,
    VT_REWARD = 10
  };
  int32_t productId() const {
    return GetField<int32_t>(VT_PRODUCTID, 0);
  }
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  int8_t bounsPoint() const {
    return GetField<int8_t>(VT_BOUNSPOINT, 0);
  }
  const MailRewardInfo *reward() const {
    return GetPointer<const MailRewardInfo *>(VT_REWARD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PRODUCTID) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           VerifyField<int8_t>(verifier, VT_BOUNSPOINT) &&
           VerifyOffset(verifier, VT_REWARD) &&
           verifier.VerifyTable(reward()) &&
           verifier.EndTable();
  }
};

struct ShopPurchaseProductBonusRewardResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_productId(int32_t productId) {
    fbb_.AddElement<int32_t>(ShopPurchaseProductBonusRewardResponse::VT_PRODUCTID, productId, 0);
  }
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(ShopPurchaseProductBonusRewardResponse::VT_ERROR, error, 0);
  }
  void add_bounsPoint(int8_t bounsPoint) {
    fbb_.AddElement<int8_t>(ShopPurchaseProductBonusRewardResponse::VT_BOUNSPOINT, bounsPoint, 0);
  }
  void add_reward(flatbuffers::Offset<MailRewardInfo> reward) {
    fbb_.AddOffset(ShopPurchaseProductBonusRewardResponse::VT_REWARD, reward);
  }
  explicit ShopPurchaseProductBonusRewardResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShopPurchaseProductBonusRewardResponseBuilder &operator=(const ShopPurchaseProductBonusRewardResponseBuilder &);
  flatbuffers::Offset<ShopPurchaseProductBonusRewardResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShopPurchaseProductBonusRewardResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShopPurchaseProductBonusRewardResponse> CreateShopPurchaseProductBonusRewardResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t productId = 0,
    int32_t error = 0,
    int8_t bounsPoint = 0,
    flatbuffers::Offset<MailRewardInfo> reward = 0) {
  ShopPurchaseProductBonusRewardResponseBuilder builder_(_fbb);
  builder_.add_reward(reward);
  builder_.add_error(error);
  builder_.add_productId(productId);
  builder_.add_bounsPoint(bounsPoint);
  return builder_.Finish();
}

/// SHOP_PURCHASE_PRODUCT_PROMOTION_REWARD_REQUEST
struct ShopPurchaseProductPromotionRewardRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRODUCTID = 4
  };
  int32_t productId() const {
    return GetField<int32_t>(VT_PRODUCTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PRODUCTID) &&
           verifier.EndTable();
  }
};

struct ShopPurchaseProductPromotionRewardRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_productId(int32_t productId) {
    fbb_.AddElement<int32_t>(ShopPurchaseProductPromotionRewardRequest::VT_PRODUCTID, productId, 0);
  }
  explicit ShopPurchaseProductPromotionRewardRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShopPurchaseProductPromotionRewardRequestBuilder &operator=(const ShopPurchaseProductPromotionRewardRequestBuilder &);
  flatbuffers::Offset<ShopPurchaseProductPromotionRewardRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShopPurchaseProductPromotionRewardRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShopPurchaseProductPromotionRewardRequest> CreateShopPurchaseProductPromotionRewardRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t productId = 0) {
  ShopPurchaseProductPromotionRewardRequestBuilder builder_(_fbb);
  builder_.add_productId(productId);
  return builder_.Finish();
}

/// SHOP_PURCHASE_PRODUCT_PROMOTION_REWARD_RESPONSE
struct ShopPurchaseProductPromotionRewardResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRODUCTID = 4,
    VT_ERROR = 6
  };
  int32_t productId() const {
    return GetField<int32_t>(VT_PRODUCTID, 0);
  }
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PRODUCTID) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           verifier.EndTable();
  }
};

struct ShopPurchaseProductPromotionRewardResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_productId(int32_t productId) {
    fbb_.AddElement<int32_t>(ShopPurchaseProductPromotionRewardResponse::VT_PRODUCTID, productId, 0);
  }
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(ShopPurchaseProductPromotionRewardResponse::VT_ERROR, error, 0);
  }
  explicit ShopPurchaseProductPromotionRewardResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShopPurchaseProductPromotionRewardResponseBuilder &operator=(const ShopPurchaseProductPromotionRewardResponseBuilder &);
  flatbuffers::Offset<ShopPurchaseProductPromotionRewardResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShopPurchaseProductPromotionRewardResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShopPurchaseProductPromotionRewardResponse> CreateShopPurchaseProductPromotionRewardResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t productId = 0,
    int32_t error = 0) {
  ShopPurchaseProductPromotionRewardResponseBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_productId(productId);
  return builder_.Finish();
}

/// SHOP_PURCHASE_PRODUCT_LIST_NOTIFY
struct ShopPurchaseProductListNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRODUCTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<ShopPurchaseProductInfo>> *products() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ShopPurchaseProductInfo>> *>(VT_PRODUCTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PRODUCTS) &&
           verifier.VerifyVector(products()) &&
           verifier.VerifyVectorOfTables(products()) &&
           verifier.EndTable();
  }
};

struct ShopPurchaseProductListNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_products(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShopPurchaseProductInfo>>> products) {
    fbb_.AddOffset(ShopPurchaseProductListNotify::VT_PRODUCTS, products);
  }
  explicit ShopPurchaseProductListNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShopPurchaseProductListNotifyBuilder &operator=(const ShopPurchaseProductListNotifyBuilder &);
  flatbuffers::Offset<ShopPurchaseProductListNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShopPurchaseProductListNotify>(end);
    fbb_.Required(o, ShopPurchaseProductListNotify::VT_PRODUCTS);
    return o;
  }
};

inline flatbuffers::Offset<ShopPurchaseProductListNotify> CreateShopPurchaseProductListNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShopPurchaseProductInfo>>> products = 0) {
  ShopPurchaseProductListNotifyBuilder builder_(_fbb);
  builder_.add_products(products);
  return builder_.Finish();
}

inline flatbuffers::Offset<ShopPurchaseProductListNotify> CreateShopPurchaseProductListNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<ShopPurchaseProductInfo>> *products = nullptr) {
  return LeanPacket::CreateShopPurchaseProductListNotify(
      _fbb,
      products ? _fbb.CreateVector<flatbuffers::Offset<ShopPurchaseProductInfo>>(*products) : 0);
}

/// SHOP_PURCHASE_PRODUCT_EXPIRE_DATE_NOTIFY
struct ShopPurchaseProductExpireDateNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRODUCTIDS = 4,
    VT_PURCHASELIMITIDS = 6
  };
  const flatbuffers::Vector<int32_t> *productIds() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PRODUCTIDS);
  }
  const flatbuffers::Vector<int32_t> *purchaseLimitIds() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PURCHASELIMITIDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PRODUCTIDS) &&
           verifier.VerifyVector(productIds()) &&
           VerifyOffsetRequired(verifier, VT_PURCHASELIMITIDS) &&
           verifier.VerifyVector(purchaseLimitIds()) &&
           verifier.EndTable();
  }
};

struct ShopPurchaseProductExpireDateNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_productIds(flatbuffers::Offset<flatbuffers::Vector<int32_t>> productIds) {
    fbb_.AddOffset(ShopPurchaseProductExpireDateNotify::VT_PRODUCTIDS, productIds);
  }
  void add_purchaseLimitIds(flatbuffers::Offset<flatbuffers::Vector<int32_t>> purchaseLimitIds) {
    fbb_.AddOffset(ShopPurchaseProductExpireDateNotify::VT_PURCHASELIMITIDS, purchaseLimitIds);
  }
  explicit ShopPurchaseProductExpireDateNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShopPurchaseProductExpireDateNotifyBuilder &operator=(const ShopPurchaseProductExpireDateNotifyBuilder &);
  flatbuffers::Offset<ShopPurchaseProductExpireDateNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShopPurchaseProductExpireDateNotify>(end);
    fbb_.Required(o, ShopPurchaseProductExpireDateNotify::VT_PRODUCTIDS);
    fbb_.Required(o, ShopPurchaseProductExpireDateNotify::VT_PURCHASELIMITIDS);
    return o;
  }
};

inline flatbuffers::Offset<ShopPurchaseProductExpireDateNotify> CreateShopPurchaseProductExpireDateNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> productIds = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> purchaseLimitIds = 0) {
  ShopPurchaseProductExpireDateNotifyBuilder builder_(_fbb);
  builder_.add_purchaseLimitIds(purchaseLimitIds);
  builder_.add_productIds(productIds);
  return builder_.Finish();
}

inline flatbuffers::Offset<ShopPurchaseProductExpireDateNotify> CreateShopPurchaseProductExpireDateNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *productIds = nullptr,
    const std::vector<int32_t> *purchaseLimitIds = nullptr) {
  return LeanPacket::CreateShopPurchaseProductExpireDateNotify(
      _fbb,
      productIds ? _fbb.CreateVector<int32_t>(*productIds) : 0,
      purchaseLimitIds ? _fbb.CreateVector<int32_t>(*purchaseLimitIds) : 0);
}

struct ShopPurchaseProductMissionUpdateInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRODUCTID = 4,
    VT_MISSIONS = 6
  };
  int32_t productId() const {
    return GetField<int32_t>(VT_PRODUCTID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ShopPurchaseProductMissionInfo>> *missions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ShopPurchaseProductMissionInfo>> *>(VT_MISSIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PRODUCTID) &&
           VerifyOffsetRequired(verifier, VT_MISSIONS) &&
           verifier.VerifyVector(missions()) &&
           verifier.VerifyVectorOfTables(missions()) &&
           verifier.EndTable();
  }
};

struct ShopPurchaseProductMissionUpdateInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_productId(int32_t productId) {
    fbb_.AddElement<int32_t>(ShopPurchaseProductMissionUpdateInfo::VT_PRODUCTID, productId, 0);
  }
  void add_missions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShopPurchaseProductMissionInfo>>> missions) {
    fbb_.AddOffset(ShopPurchaseProductMissionUpdateInfo::VT_MISSIONS, missions);
  }
  explicit ShopPurchaseProductMissionUpdateInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShopPurchaseProductMissionUpdateInfoBuilder &operator=(const ShopPurchaseProductMissionUpdateInfoBuilder &);
  flatbuffers::Offset<ShopPurchaseProductMissionUpdateInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShopPurchaseProductMissionUpdateInfo>(end);
    fbb_.Required(o, ShopPurchaseProductMissionUpdateInfo::VT_MISSIONS);
    return o;
  }
};

inline flatbuffers::Offset<ShopPurchaseProductMissionUpdateInfo> CreateShopPurchaseProductMissionUpdateInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t productId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShopPurchaseProductMissionInfo>>> missions = 0) {
  ShopPurchaseProductMissionUpdateInfoBuilder builder_(_fbb);
  builder_.add_missions(missions);
  builder_.add_productId(productId);
  return builder_.Finish();
}

inline flatbuffers::Offset<ShopPurchaseProductMissionUpdateInfo> CreateShopPurchaseProductMissionUpdateInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t productId = 0,
    const std::vector<flatbuffers::Offset<ShopPurchaseProductMissionInfo>> *missions = nullptr) {
  return LeanPacket::CreateShopPurchaseProductMissionUpdateInfo(
      _fbb,
      productId,
      missions ? _fbb.CreateVector<flatbuffers::Offset<ShopPurchaseProductMissionInfo>>(*missions) : 0);
}

/// SHOP_PURCHASE_PRODUCT_MISSION_UPDATE_NOTIFY
struct ShopPurchaseProductMissionUpdateNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INFOS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<ShopPurchaseProductMissionUpdateInfo>> *infos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ShopPurchaseProductMissionUpdateInfo>> *>(VT_INFOS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_INFOS) &&
           verifier.VerifyVector(infos()) &&
           verifier.VerifyVectorOfTables(infos()) &&
           verifier.EndTable();
  }
};

struct ShopPurchaseProductMissionUpdateNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_infos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShopPurchaseProductMissionUpdateInfo>>> infos) {
    fbb_.AddOffset(ShopPurchaseProductMissionUpdateNotify::VT_INFOS, infos);
  }
  explicit ShopPurchaseProductMissionUpdateNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShopPurchaseProductMissionUpdateNotifyBuilder &operator=(const ShopPurchaseProductMissionUpdateNotifyBuilder &);
  flatbuffers::Offset<ShopPurchaseProductMissionUpdateNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShopPurchaseProductMissionUpdateNotify>(end);
    fbb_.Required(o, ShopPurchaseProductMissionUpdateNotify::VT_INFOS);
    return o;
  }
};

inline flatbuffers::Offset<ShopPurchaseProductMissionUpdateNotify> CreateShopPurchaseProductMissionUpdateNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShopPurchaseProductMissionUpdateInfo>>> infos = 0) {
  ShopPurchaseProductMissionUpdateNotifyBuilder builder_(_fbb);
  builder_.add_infos(infos);
  return builder_.Finish();
}

inline flatbuffers::Offset<ShopPurchaseProductMissionUpdateNotify> CreateShopPurchaseProductMissionUpdateNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<ShopPurchaseProductMissionUpdateInfo>> *infos = nullptr) {
  return LeanPacket::CreateShopPurchaseProductMissionUpdateNotify(
      _fbb,
      infos ? _fbb.CreateVector<flatbuffers::Offset<ShopPurchaseProductMissionUpdateInfo>>(*infos) : 0);
}

/// SHOP_PURCHASE_PRODUCT_BONUS_POINT_UPDATE_NOTIFY
struct ShopPurchaseProductBonusPointUpdateNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRODUCTID = 4,
    VT_BONUSPOINT = 6
  };
  int32_t productId() const {
    return GetField<int32_t>(VT_PRODUCTID, 0);
  }
  int16_t bonusPoint() const {
    return GetField<int16_t>(VT_BONUSPOINT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PRODUCTID) &&
           VerifyField<int16_t>(verifier, VT_BONUSPOINT) &&
           verifier.EndTable();
  }
};

struct ShopPurchaseProductBonusPointUpdateNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_productId(int32_t productId) {
    fbb_.AddElement<int32_t>(ShopPurchaseProductBonusPointUpdateNotify::VT_PRODUCTID, productId, 0);
  }
  void add_bonusPoint(int16_t bonusPoint) {
    fbb_.AddElement<int16_t>(ShopPurchaseProductBonusPointUpdateNotify::VT_BONUSPOINT, bonusPoint, 0);
  }
  explicit ShopPurchaseProductBonusPointUpdateNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShopPurchaseProductBonusPointUpdateNotifyBuilder &operator=(const ShopPurchaseProductBonusPointUpdateNotifyBuilder &);
  flatbuffers::Offset<ShopPurchaseProductBonusPointUpdateNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShopPurchaseProductBonusPointUpdateNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShopPurchaseProductBonusPointUpdateNotify> CreateShopPurchaseProductBonusPointUpdateNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t productId = 0,
    int16_t bonusPoint = 0) {
  ShopPurchaseProductBonusPointUpdateNotifyBuilder builder_(_fbb);
  builder_.add_productId(productId);
  builder_.add_bonusPoint(bonusPoint);
  return builder_.Finish();
}

/// SHOP_PURCHASE_PRODUCT_PROMOTION_UPDATE_NOTIFY
struct ShopPurchaseProductPromotionUpdateNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRODUCTID = 4,
    VT_PROMOTIONPOINT = 6
  };
  int32_t productId() const {
    return GetField<int32_t>(VT_PRODUCTID, 0);
  }
  int32_t promotionPoint() const {
    return GetField<int32_t>(VT_PROMOTIONPOINT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PRODUCTID) &&
           VerifyField<int32_t>(verifier, VT_PROMOTIONPOINT) &&
           verifier.EndTable();
  }
};

struct ShopPurchaseProductPromotionUpdateNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_productId(int32_t productId) {
    fbb_.AddElement<int32_t>(ShopPurchaseProductPromotionUpdateNotify::VT_PRODUCTID, productId, 0);
  }
  void add_promotionPoint(int32_t promotionPoint) {
    fbb_.AddElement<int32_t>(ShopPurchaseProductPromotionUpdateNotify::VT_PROMOTIONPOINT, promotionPoint, 0);
  }
  explicit ShopPurchaseProductPromotionUpdateNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShopPurchaseProductPromotionUpdateNotifyBuilder &operator=(const ShopPurchaseProductPromotionUpdateNotifyBuilder &);
  flatbuffers::Offset<ShopPurchaseProductPromotionUpdateNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShopPurchaseProductPromotionUpdateNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShopPurchaseProductPromotionUpdateNotify> CreateShopPurchaseProductPromotionUpdateNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t productId = 0,
    int32_t promotionPoint = 0) {
  ShopPurchaseProductPromotionUpdateNotifyBuilder builder_(_fbb);
  builder_.add_promotionPoint(promotionPoint);
  builder_.add_productId(productId);
  return builder_.Finish();
}

struct RankGetPcDetailInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCDBID = 4
  };
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           verifier.EndTable();
  }
};

struct RankGetPcDetailInfoRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(RankGetPcDetailInfoRequest::VT_PCDBID, pcDbId, 0);
  }
  explicit RankGetPcDetailInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RankGetPcDetailInfoRequestBuilder &operator=(const RankGetPcDetailInfoRequestBuilder &);
  flatbuffers::Offset<RankGetPcDetailInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RankGetPcDetailInfoRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RankGetPcDetailInfoRequest> CreateRankGetPcDetailInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcDbId = 0) {
  RankGetPcDetailInfoRequestBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  return builder_.Finish();
}

struct RedisGetMyRankRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RANKTYPE = 4
  };
  int8_t rankType() const {
    return GetField<int8_t>(VT_RANKTYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_RANKTYPE) &&
           verifier.EndTable();
  }
};

struct RedisGetMyRankRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rankType(int8_t rankType) {
    fbb_.AddElement<int8_t>(RedisGetMyRankRequest::VT_RANKTYPE, rankType, 0);
  }
  explicit RedisGetMyRankRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RedisGetMyRankRequestBuilder &operator=(const RedisGetMyRankRequestBuilder &);
  flatbuffers::Offset<RedisGetMyRankRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RedisGetMyRankRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RedisGetMyRankRequest> CreateRedisGetMyRankRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t rankType = 0) {
  RedisGetMyRankRequestBuilder builder_(_fbb);
  builder_.add_rankType(rankType);
  return builder_.Finish();
}

struct RedisGetMyRankResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MYRANK = 4,
    VT_RESULT = 6
  };
  const PcRankInfo *myRank() const {
    return GetPointer<const PcRankInfo *>(VT_MYRANK);
  }
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MYRANK) &&
           verifier.VerifyTable(myRank()) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           verifier.EndTable();
  }
};

struct RedisGetMyRankResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_myRank(flatbuffers::Offset<PcRankInfo> myRank) {
    fbb_.AddOffset(RedisGetMyRankResponse::VT_MYRANK, myRank);
  }
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(RedisGetMyRankResponse::VT_RESULT, result, 0);
  }
  explicit RedisGetMyRankResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RedisGetMyRankResponseBuilder &operator=(const RedisGetMyRankResponseBuilder &);
  flatbuffers::Offset<RedisGetMyRankResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RedisGetMyRankResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<RedisGetMyRankResponse> CreateRedisGetMyRankResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<PcRankInfo> myRank = 0,
    int32_t result = 0) {
  RedisGetMyRankResponseBuilder builder_(_fbb);
  builder_.add_result(result);
  builder_.add_myRank(myRank);
  return builder_.Finish();
}

struct RedisGetRangeRankInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RANKTYPE = 4,
    VT_BEGINIDX = 6,
    VT_ENDIDX = 8
  };
  int8_t rankType() const {
    return GetField<int8_t>(VT_RANKTYPE, 0);
  }
  int64_t beginIdx() const {
    return GetField<int64_t>(VT_BEGINIDX, 0);
  }
  int64_t endIdx() const {
    return GetField<int64_t>(VT_ENDIDX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_RANKTYPE) &&
           VerifyField<int64_t>(verifier, VT_BEGINIDX) &&
           VerifyField<int64_t>(verifier, VT_ENDIDX) &&
           verifier.EndTable();
  }
};

struct RedisGetRangeRankInfoRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rankType(int8_t rankType) {
    fbb_.AddElement<int8_t>(RedisGetRangeRankInfoRequest::VT_RANKTYPE, rankType, 0);
  }
  void add_beginIdx(int64_t beginIdx) {
    fbb_.AddElement<int64_t>(RedisGetRangeRankInfoRequest::VT_BEGINIDX, beginIdx, 0);
  }
  void add_endIdx(int64_t endIdx) {
    fbb_.AddElement<int64_t>(RedisGetRangeRankInfoRequest::VT_ENDIDX, endIdx, 0);
  }
  explicit RedisGetRangeRankInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RedisGetRangeRankInfoRequestBuilder &operator=(const RedisGetRangeRankInfoRequestBuilder &);
  flatbuffers::Offset<RedisGetRangeRankInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RedisGetRangeRankInfoRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RedisGetRangeRankInfoRequest> CreateRedisGetRangeRankInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t rankType = 0,
    int64_t beginIdx = 0,
    int64_t endIdx = 0) {
  RedisGetRangeRankInfoRequestBuilder builder_(_fbb);
  builder_.add_endIdx(endIdx);
  builder_.add_beginIdx(beginIdx);
  builder_.add_rankType(rankType);
  return builder_.Finish();
}

struct RedisGetRangeRankInfoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RANKINFOS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<PcRankInfo>> *rankInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PcRankInfo>> *>(VT_RANKINFOS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RANKINFOS) &&
           verifier.VerifyVector(rankInfos()) &&
           verifier.VerifyVectorOfTables(rankInfos()) &&
           verifier.EndTable();
  }
};

struct RedisGetRangeRankInfoResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rankInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PcRankInfo>>> rankInfos) {
    fbb_.AddOffset(RedisGetRangeRankInfoResponse::VT_RANKINFOS, rankInfos);
  }
  explicit RedisGetRangeRankInfoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RedisGetRangeRankInfoResponseBuilder &operator=(const RedisGetRangeRankInfoResponseBuilder &);
  flatbuffers::Offset<RedisGetRangeRankInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RedisGetRangeRankInfoResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<RedisGetRangeRankInfoResponse> CreateRedisGetRangeRankInfoResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PcRankInfo>>> rankInfos = 0) {
  RedisGetRangeRankInfoResponseBuilder builder_(_fbb);
  builder_.add_rankInfos(rankInfos);
  return builder_.Finish();
}

inline flatbuffers::Offset<RedisGetRangeRankInfoResponse> CreateRedisGetRangeRankInfoResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<PcRankInfo>> *rankInfos = nullptr) {
  return LeanPacket::CreateRedisGetRangeRankInfoResponse(
      _fbb,
      rankInfos ? _fbb.CreateVector<flatbuffers::Offset<PcRankInfo>>(*rankInfos) : 0);
}

///----- 출석체크 -----------------
struct AttendanceInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BOARDID = 4,
    VT_STAMPCOUNT = 6,
    VT_ISSTAMPABLE = 8
  };
  int16_t boardId() const {
    return GetField<int16_t>(VT_BOARDID, 0);
  }
  int16_t stampCount() const {
    return GetField<int16_t>(VT_STAMPCOUNT, 0);
  }
  bool isStampable() const {
    return GetField<uint8_t>(VT_ISSTAMPABLE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_BOARDID) &&
           VerifyField<int16_t>(verifier, VT_STAMPCOUNT) &&
           VerifyField<uint8_t>(verifier, VT_ISSTAMPABLE) &&
           verifier.EndTable();
  }
};

struct AttendanceInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_boardId(int16_t boardId) {
    fbb_.AddElement<int16_t>(AttendanceInfo::VT_BOARDID, boardId, 0);
  }
  void add_stampCount(int16_t stampCount) {
    fbb_.AddElement<int16_t>(AttendanceInfo::VT_STAMPCOUNT, stampCount, 0);
  }
  void add_isStampable(bool isStampable) {
    fbb_.AddElement<uint8_t>(AttendanceInfo::VT_ISSTAMPABLE, static_cast<uint8_t>(isStampable), 0);
  }
  explicit AttendanceInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttendanceInfoBuilder &operator=(const AttendanceInfoBuilder &);
  flatbuffers::Offset<AttendanceInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AttendanceInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttendanceInfo> CreateAttendanceInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t boardId = 0,
    int16_t stampCount = 0,
    bool isStampable = false) {
  AttendanceInfoBuilder builder_(_fbb);
  builder_.add_stampCount(stampCount);
  builder_.add_boardId(boardId);
  builder_.add_isStampable(isStampable);
  return builder_.Finish();
}

/// ATTENDANCE_INFO_REQUEST	
struct AttendanceInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AttendanceInfoRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AttendanceInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttendanceInfoRequestBuilder &operator=(const AttendanceInfoRequestBuilder &);
  flatbuffers::Offset<AttendanceInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AttendanceInfoRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttendanceInfoRequest> CreateAttendanceInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AttendanceInfoRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// ATTENDANCE_INFO_RESPONSE
struct AttendanceInfoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATA = 4
  };
  const AttendanceInfo *data() const {
    return GetPointer<const AttendanceInfo *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyTable(data()) &&
           verifier.EndTable();
  }
};

struct AttendanceInfoResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<AttendanceInfo> data) {
    fbb_.AddOffset(AttendanceInfoResponse::VT_DATA, data);
  }
  explicit AttendanceInfoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttendanceInfoResponseBuilder &operator=(const AttendanceInfoResponseBuilder &);
  flatbuffers::Offset<AttendanceInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AttendanceInfoResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttendanceInfoResponse> CreateAttendanceInfoResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<AttendanceInfo> data = 0) {
  AttendanceInfoResponseBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

/// ATTENDANCE_STAMP_REQUEST
struct AttendanceStampRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BOARDID = 4
  };
  int16_t boardId() const {
    return GetField<int16_t>(VT_BOARDID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_BOARDID) &&
           verifier.EndTable();
  }
};

struct AttendanceStampRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_boardId(int16_t boardId) {
    fbb_.AddElement<int16_t>(AttendanceStampRequest::VT_BOARDID, boardId, 0);
  }
  explicit AttendanceStampRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttendanceStampRequestBuilder &operator=(const AttendanceStampRequestBuilder &);
  flatbuffers::Offset<AttendanceStampRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AttendanceStampRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttendanceStampRequest> CreateAttendanceStampRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t boardId = 0) {
  AttendanceStampRequestBuilder builder_(_fbb);
  builder_.add_boardId(boardId);
  return builder_.Finish();
}

/// ATTENDANCE_STAMP_RESPONSE
struct AttendanceStampResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRCODE = 4,
    VT_DATA = 6
  };
  ErrorCode errCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRCODE, 0));
  }
  const AttendanceInfo *data() const {
    return GetPointer<const AttendanceInfo *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyTable(data()) &&
           verifier.EndTable();
  }
};

struct AttendanceStampResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errCode(ErrorCode errCode) {
    fbb_.AddElement<int32_t>(AttendanceStampResponse::VT_ERRCODE, static_cast<int32_t>(errCode), 0);
  }
  void add_data(flatbuffers::Offset<AttendanceInfo> data) {
    fbb_.AddOffset(AttendanceStampResponse::VT_DATA, data);
  }
  explicit AttendanceStampResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttendanceStampResponseBuilder &operator=(const AttendanceStampResponseBuilder &);
  flatbuffers::Offset<AttendanceStampResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AttendanceStampResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttendanceStampResponse> CreateAttendanceStampResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errCode = ErrorCode_NONE,
    flatbuffers::Offset<AttendanceInfo> data = 0) {
  AttendanceStampResponseBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_errCode(errCode);
  return builder_.Finish();
}

///----- 접속보상 -----------------
/// ACCESS_TIME_INFO_REQUEST
struct AccessTimeInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AccessTimeInfoRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AccessTimeInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AccessTimeInfoRequestBuilder &operator=(const AccessTimeInfoRequestBuilder &);
  flatbuffers::Offset<AccessTimeInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AccessTimeInfoRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<AccessTimeInfoRequest> CreateAccessTimeInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AccessTimeInfoRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// ACCESS_TIME_INFO_RESPONSE
struct AccessTimeInfoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCESSMINUTE = 4,
    VT_MAXREWARDEDID = 6
  };
  int16_t accessMinute() const {
    return GetField<int16_t>(VT_ACCESSMINUTE, 0);
  }
  int16_t maxRewardedId() const {
    return GetField<int16_t>(VT_MAXREWARDEDID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_ACCESSMINUTE) &&
           VerifyField<int16_t>(verifier, VT_MAXREWARDEDID) &&
           verifier.EndTable();
  }
};

struct AccessTimeInfoResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accessMinute(int16_t accessMinute) {
    fbb_.AddElement<int16_t>(AccessTimeInfoResponse::VT_ACCESSMINUTE, accessMinute, 0);
  }
  void add_maxRewardedId(int16_t maxRewardedId) {
    fbb_.AddElement<int16_t>(AccessTimeInfoResponse::VT_MAXREWARDEDID, maxRewardedId, 0);
  }
  explicit AccessTimeInfoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AccessTimeInfoResponseBuilder &operator=(const AccessTimeInfoResponseBuilder &);
  flatbuffers::Offset<AccessTimeInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AccessTimeInfoResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<AccessTimeInfoResponse> CreateAccessTimeInfoResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t accessMinute = 0,
    int16_t maxRewardedId = 0) {
  AccessTimeInfoResponseBuilder builder_(_fbb);
  builder_.add_maxRewardedId(maxRewardedId);
  builder_.add_accessMinute(accessMinute);
  return builder_.Finish();
}

/// ACCESS_TIME_REWARD_REQUEST
struct AccessTimeRewardRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCESSMINUTE = 4
  };
  int16_t accessMinute() const {
    return GetField<int16_t>(VT_ACCESSMINUTE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_ACCESSMINUTE) &&
           verifier.EndTable();
  }
};

struct AccessTimeRewardRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accessMinute(int16_t accessMinute) {
    fbb_.AddElement<int16_t>(AccessTimeRewardRequest::VT_ACCESSMINUTE, accessMinute, 0);
  }
  explicit AccessTimeRewardRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AccessTimeRewardRequestBuilder &operator=(const AccessTimeRewardRequestBuilder &);
  flatbuffers::Offset<AccessTimeRewardRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AccessTimeRewardRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<AccessTimeRewardRequest> CreateAccessTimeRewardRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t accessMinute = 0) {
  AccessTimeRewardRequestBuilder builder_(_fbb);
  builder_.add_accessMinute(accessMinute);
  return builder_.Finish();
}

/// ACCESS_TIME_REWARD_RESPONSE
struct AccessTimeRewardResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRCODE = 4,
    VT_MAXREWARDEDID = 6,
    VT_REWARDINFO = 8
  };
  ErrorCode errCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRCODE, 0));
  }
  int16_t maxRewardedId() const {
    return GetField<int16_t>(VT_MAXREWARDEDID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<RewardInfo>> *rewardInfo() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<RewardInfo>> *>(VT_REWARDINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           VerifyField<int16_t>(verifier, VT_MAXREWARDEDID) &&
           VerifyOffset(verifier, VT_REWARDINFO) &&
           verifier.VerifyVector(rewardInfo()) &&
           verifier.VerifyVectorOfTables(rewardInfo()) &&
           verifier.EndTable();
  }
};

struct AccessTimeRewardResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errCode(ErrorCode errCode) {
    fbb_.AddElement<int32_t>(AccessTimeRewardResponse::VT_ERRCODE, static_cast<int32_t>(errCode), 0);
  }
  void add_maxRewardedId(int16_t maxRewardedId) {
    fbb_.AddElement<int16_t>(AccessTimeRewardResponse::VT_MAXREWARDEDID, maxRewardedId, 0);
  }
  void add_rewardInfo(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RewardInfo>>> rewardInfo) {
    fbb_.AddOffset(AccessTimeRewardResponse::VT_REWARDINFO, rewardInfo);
  }
  explicit AccessTimeRewardResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AccessTimeRewardResponseBuilder &operator=(const AccessTimeRewardResponseBuilder &);
  flatbuffers::Offset<AccessTimeRewardResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AccessTimeRewardResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<AccessTimeRewardResponse> CreateAccessTimeRewardResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errCode = ErrorCode_NONE,
    int16_t maxRewardedId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RewardInfo>>> rewardInfo = 0) {
  AccessTimeRewardResponseBuilder builder_(_fbb);
  builder_.add_rewardInfo(rewardInfo);
  builder_.add_errCode(errCode);
  builder_.add_maxRewardedId(maxRewardedId);
  return builder_.Finish();
}

inline flatbuffers::Offset<AccessTimeRewardResponse> CreateAccessTimeRewardResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errCode = ErrorCode_NONE,
    int16_t maxRewardedId = 0,
    const std::vector<flatbuffers::Offset<RewardInfo>> *rewardInfo = nullptr) {
  return LeanPacket::CreateAccessTimeRewardResponse(
      _fbb,
      errCode,
      maxRewardedId,
      rewardInfo ? _fbb.CreateVector<flatbuffers::Offset<RewardInfo>>(*rewardInfo) : 0);
}

/// REST_TIME_INFO_REQUEST
struct RestTimeInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RestTimeInfoRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RestTimeInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RestTimeInfoRequestBuilder &operator=(const RestTimeInfoRequestBuilder &);
  flatbuffers::Offset<RestTimeInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RestTimeInfoRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RestTimeInfoRequest> CreateRestTimeInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RestTimeInfoRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// REST_TIME_INFO_RESPONSE
struct RestTimeInfoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_POINT = 4
  };
  int16_t point() const {
    return GetField<int16_t>(VT_POINT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_POINT) &&
           verifier.EndTable();
  }
};

struct RestTimeInfoResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_point(int16_t point) {
    fbb_.AddElement<int16_t>(RestTimeInfoResponse::VT_POINT, point, 0);
  }
  explicit RestTimeInfoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RestTimeInfoResponseBuilder &operator=(const RestTimeInfoResponseBuilder &);
  flatbuffers::Offset<RestTimeInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RestTimeInfoResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<RestTimeInfoResponse> CreateRestTimeInfoResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t point = 0) {
  RestTimeInfoResponseBuilder builder_(_fbb);
  builder_.add_point(point);
  return builder_.Finish();
}

/// REST_TIME_REWARD_REQUEST
struct RestTimeRewardRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PAIDTYPE = 4,
    VT_REWARDTYPE = 6
  };
  RestPaidType paidType() const {
    return static_cast<RestPaidType>(GetField<int16_t>(VT_PAIDTYPE, 0));
  }
  int16_t rewardType() const {
    return GetField<int16_t>(VT_REWARDTYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_PAIDTYPE) &&
           VerifyField<int16_t>(verifier, VT_REWARDTYPE) &&
           verifier.EndTable();
  }
};

struct RestTimeRewardRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_paidType(RestPaidType paidType) {
    fbb_.AddElement<int16_t>(RestTimeRewardRequest::VT_PAIDTYPE, static_cast<int16_t>(paidType), 0);
  }
  void add_rewardType(int16_t rewardType) {
    fbb_.AddElement<int16_t>(RestTimeRewardRequest::VT_REWARDTYPE, rewardType, 0);
  }
  explicit RestTimeRewardRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RestTimeRewardRequestBuilder &operator=(const RestTimeRewardRequestBuilder &);
  flatbuffers::Offset<RestTimeRewardRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RestTimeRewardRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RestTimeRewardRequest> CreateRestTimeRewardRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    RestPaidType paidType = RestPaidType_REST_PAID_TYPE_FREE,
    int16_t rewardType = 0) {
  RestTimeRewardRequestBuilder builder_(_fbb);
  builder_.add_rewardType(rewardType);
  builder_.add_paidType(paidType);
  return builder_.Finish();
}

/// REST_TIME_REWARD_RESPONSE
struct RestTimeRewardResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRCODE = 4,
    VT_POINT = 6,
    VT_REWARDINFO = 8
  };
  ErrorCode errCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRCODE, 0));
  }
  int16_t point() const {
    return GetField<int16_t>(VT_POINT, 0);
  }
  const RewardInfo *rewardInfo() const {
    return GetPointer<const RewardInfo *>(VT_REWARDINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           VerifyField<int16_t>(verifier, VT_POINT) &&
           VerifyOffset(verifier, VT_REWARDINFO) &&
           verifier.VerifyTable(rewardInfo()) &&
           verifier.EndTable();
  }
};

struct RestTimeRewardResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errCode(ErrorCode errCode) {
    fbb_.AddElement<int32_t>(RestTimeRewardResponse::VT_ERRCODE, static_cast<int32_t>(errCode), 0);
  }
  void add_point(int16_t point) {
    fbb_.AddElement<int16_t>(RestTimeRewardResponse::VT_POINT, point, 0);
  }
  void add_rewardInfo(flatbuffers::Offset<RewardInfo> rewardInfo) {
    fbb_.AddOffset(RestTimeRewardResponse::VT_REWARDINFO, rewardInfo);
  }
  explicit RestTimeRewardResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RestTimeRewardResponseBuilder &operator=(const RestTimeRewardResponseBuilder &);
  flatbuffers::Offset<RestTimeRewardResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RestTimeRewardResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<RestTimeRewardResponse> CreateRestTimeRewardResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errCode = ErrorCode_NONE,
    int16_t point = 0,
    flatbuffers::Offset<RewardInfo> rewardInfo = 0) {
  RestTimeRewardResponseBuilder builder_(_fbb);
  builder_.add_rewardInfo(rewardInfo);
  builder_.add_errCode(errCode);
  builder_.add_point(point);
  return builder_.Finish();
}

/// ACQUIRE_CONTRIBUTION_NOTIFY
struct AcquireContributionNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACQPOINT = 4,
    VT_TARGETOBJID = 6,
    VT_MYCONTRIBUTIONINFO = 8,
    VT_ACQTYPE = 10
  };
  double acqPoint() const {
    return GetField<double>(VT_ACQPOINT, 0.0);
  }
  int64_t targetObjId() const {
    return GetField<int64_t>(VT_TARGETOBJID, 0);
  }
  const EventContribution *myContributionInfo() const {
    return GetPointer<const EventContribution *>(VT_MYCONTRIBUTIONINFO);
  }
  int16_t acqType() const {
    return GetField<int16_t>(VT_ACQTYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_ACQPOINT) &&
           VerifyField<int64_t>(verifier, VT_TARGETOBJID) &&
           VerifyOffsetRequired(verifier, VT_MYCONTRIBUTIONINFO) &&
           verifier.VerifyTable(myContributionInfo()) &&
           VerifyField<int16_t>(verifier, VT_ACQTYPE) &&
           verifier.EndTable();
  }
};

struct AcquireContributionNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acqPoint(double acqPoint) {
    fbb_.AddElement<double>(AcquireContributionNotify::VT_ACQPOINT, acqPoint, 0.0);
  }
  void add_targetObjId(int64_t targetObjId) {
    fbb_.AddElement<int64_t>(AcquireContributionNotify::VT_TARGETOBJID, targetObjId, 0);
  }
  void add_myContributionInfo(flatbuffers::Offset<EventContribution> myContributionInfo) {
    fbb_.AddOffset(AcquireContributionNotify::VT_MYCONTRIBUTIONINFO, myContributionInfo);
  }
  void add_acqType(int16_t acqType) {
    fbb_.AddElement<int16_t>(AcquireContributionNotify::VT_ACQTYPE, acqType, 0);
  }
  explicit AcquireContributionNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AcquireContributionNotifyBuilder &operator=(const AcquireContributionNotifyBuilder &);
  flatbuffers::Offset<AcquireContributionNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AcquireContributionNotify>(end);
    fbb_.Required(o, AcquireContributionNotify::VT_MYCONTRIBUTIONINFO);
    return o;
  }
};

inline flatbuffers::Offset<AcquireContributionNotify> CreateAcquireContributionNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    double acqPoint = 0.0,
    int64_t targetObjId = 0,
    flatbuffers::Offset<EventContribution> myContributionInfo = 0,
    int16_t acqType = 0) {
  AcquireContributionNotifyBuilder builder_(_fbb);
  builder_.add_targetObjId(targetObjId);
  builder_.add_acqPoint(acqPoint);
  builder_.add_myContributionInfo(myContributionInfo);
  builder_.add_acqType(acqType);
  return builder_.Finish();
}

/// #길드 기본 정보
/// 길드 목록에 보여주기 위한 용도
/// 가입하지 않은 길드 정보 확인용이다
struct GuildBasicInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_NAME = 6,
    VT_LEVEL = 8,
    VT_JOINTYPE = 10,
    VT_CREST = 12,
    VT_MEMBERCOUNT = 14,
    VT_MONARCHPOINT = 16,
    VT_RANK = 18
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int16_t level() const {
    return GetField<int16_t>(VT_LEVEL, 0);
  }
  /// LeanData::eGuild_joinType
  int8_t joinType() const {
    return GetField<int8_t>(VT_JOINTYPE, 0);
  }
  const GuildCrest *crest() const {
    return GetPointer<const GuildCrest *>(VT_CREST);
  }
  int16_t memberCount() const {
    return GetField<int16_t>(VT_MEMBERCOUNT, 0);
  }
  /// 군주 포인트
  int64_t monarchPoint() const {
    return GetField<int64_t>(VT_MONARCHPOINT, 0);
  }
  int32_t rank() const {
    return GetField<int32_t>(VT_RANK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int16_t>(verifier, VT_LEVEL) &&
           VerifyField<int8_t>(verifier, VT_JOINTYPE) &&
           VerifyOffsetRequired(verifier, VT_CREST) &&
           verifier.VerifyTable(crest()) &&
           VerifyField<int16_t>(verifier, VT_MEMBERCOUNT) &&
           VerifyField<int64_t>(verifier, VT_MONARCHPOINT) &&
           VerifyField<int32_t>(verifier, VT_RANK) &&
           verifier.EndTable();
  }
};

struct GuildBasicInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(GuildBasicInfo::VT_ID, id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(GuildBasicInfo::VT_NAME, name);
  }
  void add_level(int16_t level) {
    fbb_.AddElement<int16_t>(GuildBasicInfo::VT_LEVEL, level, 0);
  }
  void add_joinType(int8_t joinType) {
    fbb_.AddElement<int8_t>(GuildBasicInfo::VT_JOINTYPE, joinType, 0);
  }
  void add_crest(flatbuffers::Offset<GuildCrest> crest) {
    fbb_.AddOffset(GuildBasicInfo::VT_CREST, crest);
  }
  void add_memberCount(int16_t memberCount) {
    fbb_.AddElement<int16_t>(GuildBasicInfo::VT_MEMBERCOUNT, memberCount, 0);
  }
  void add_monarchPoint(int64_t monarchPoint) {
    fbb_.AddElement<int64_t>(GuildBasicInfo::VT_MONARCHPOINT, monarchPoint, 0);
  }
  void add_rank(int32_t rank) {
    fbb_.AddElement<int32_t>(GuildBasicInfo::VT_RANK, rank, 0);
  }
  explicit GuildBasicInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildBasicInfoBuilder &operator=(const GuildBasicInfoBuilder &);
  flatbuffers::Offset<GuildBasicInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildBasicInfo>(end);
    fbb_.Required(o, GuildBasicInfo::VT_NAME);
    fbb_.Required(o, GuildBasicInfo::VT_CREST);
    return o;
  }
};

inline flatbuffers::Offset<GuildBasicInfo> CreateGuildBasicInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int16_t level = 0,
    int8_t joinType = 0,
    flatbuffers::Offset<GuildCrest> crest = 0,
    int16_t memberCount = 0,
    int64_t monarchPoint = 0,
    int32_t rank = 0) {
  GuildBasicInfoBuilder builder_(_fbb);
  builder_.add_monarchPoint(monarchPoint);
  builder_.add_rank(rank);
  builder_.add_crest(crest);
  builder_.add_name(name);
  builder_.add_id(id);
  builder_.add_memberCount(memberCount);
  builder_.add_level(level);
  builder_.add_joinType(joinType);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildBasicInfo> CreateGuildBasicInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    const char *name = nullptr,
    int16_t level = 0,
    int8_t joinType = 0,
    flatbuffers::Offset<GuildCrest> crest = 0,
    int16_t memberCount = 0,
    int64_t monarchPoint = 0,
    int32_t rank = 0) {
  return LeanPacket::CreateGuildBasicInfo(
      _fbb,
      id,
      name ? _fbb.CreateString(name) : 0,
      level,
      joinType,
      crest,
      memberCount,
      monarchPoint,
      rank);
}

/// 길드 상세 보기 정보
/// 가입하지 않은 길드 정보 확인용이다
struct GuildDetailInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BASICINFO = 4,
    VT_LEADERNAME = 6,
    VT_INTROMESSAGE = 8,
    VT_JOINLIMITLEVEL = 10,
    VT_PREVRANK = 12,
    VT_COMBATPOWERAVG = 14,
    VT_CREATETIMEUTC = 16,
    VT_JOINREQUESTED = 18
  };
  const GuildBasicInfo *basicInfo() const {
    return GetPointer<const GuildBasicInfo *>(VT_BASICINFO);
  }
  const flatbuffers::String *leaderName() const {
    return GetPointer<const flatbuffers::String *>(VT_LEADERNAME);
  }
  const flatbuffers::String *introMessage() const {
    return GetPointer<const flatbuffers::String *>(VT_INTROMESSAGE);
  }
  int16_t joinLimitLevel() const {
    return GetField<int16_t>(VT_JOINLIMITLEVEL, 0);
  }
  /// 전 시즌 랭킹 (0이면 이전 시즌 순위 없음)
  int32_t prevRank() const {
    return GetField<int32_t>(VT_PREVRANK, 0);
  }
  int32_t combatPowerAvg() const {
    return GetField<int32_t>(VT_COMBATPOWERAVG, 0);
  }
  int64_t createTimeUtc() const {
    return GetField<int64_t>(VT_CREATETIMEUTC, 0);
  }
  bool joinRequested() const {
    return GetField<uint8_t>(VT_JOINREQUESTED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BASICINFO) &&
           verifier.VerifyTable(basicInfo()) &&
           VerifyOffsetRequired(verifier, VT_LEADERNAME) &&
           verifier.VerifyString(leaderName()) &&
           VerifyOffsetRequired(verifier, VT_INTROMESSAGE) &&
           verifier.VerifyString(introMessage()) &&
           VerifyField<int16_t>(verifier, VT_JOINLIMITLEVEL) &&
           VerifyField<int32_t>(verifier, VT_PREVRANK) &&
           VerifyField<int32_t>(verifier, VT_COMBATPOWERAVG) &&
           VerifyField<int64_t>(verifier, VT_CREATETIMEUTC) &&
           VerifyField<uint8_t>(verifier, VT_JOINREQUESTED) &&
           verifier.EndTable();
  }
};

struct GuildDetailInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_basicInfo(flatbuffers::Offset<GuildBasicInfo> basicInfo) {
    fbb_.AddOffset(GuildDetailInfo::VT_BASICINFO, basicInfo);
  }
  void add_leaderName(flatbuffers::Offset<flatbuffers::String> leaderName) {
    fbb_.AddOffset(GuildDetailInfo::VT_LEADERNAME, leaderName);
  }
  void add_introMessage(flatbuffers::Offset<flatbuffers::String> introMessage) {
    fbb_.AddOffset(GuildDetailInfo::VT_INTROMESSAGE, introMessage);
  }
  void add_joinLimitLevel(int16_t joinLimitLevel) {
    fbb_.AddElement<int16_t>(GuildDetailInfo::VT_JOINLIMITLEVEL, joinLimitLevel, 0);
  }
  void add_prevRank(int32_t prevRank) {
    fbb_.AddElement<int32_t>(GuildDetailInfo::VT_PREVRANK, prevRank, 0);
  }
  void add_combatPowerAvg(int32_t combatPowerAvg) {
    fbb_.AddElement<int32_t>(GuildDetailInfo::VT_COMBATPOWERAVG, combatPowerAvg, 0);
  }
  void add_createTimeUtc(int64_t createTimeUtc) {
    fbb_.AddElement<int64_t>(GuildDetailInfo::VT_CREATETIMEUTC, createTimeUtc, 0);
  }
  void add_joinRequested(bool joinRequested) {
    fbb_.AddElement<uint8_t>(GuildDetailInfo::VT_JOINREQUESTED, static_cast<uint8_t>(joinRequested), 0);
  }
  explicit GuildDetailInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildDetailInfoBuilder &operator=(const GuildDetailInfoBuilder &);
  flatbuffers::Offset<GuildDetailInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildDetailInfo>(end);
    fbb_.Required(o, GuildDetailInfo::VT_BASICINFO);
    fbb_.Required(o, GuildDetailInfo::VT_LEADERNAME);
    fbb_.Required(o, GuildDetailInfo::VT_INTROMESSAGE);
    return o;
  }
};

inline flatbuffers::Offset<GuildDetailInfo> CreateGuildDetailInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GuildBasicInfo> basicInfo = 0,
    flatbuffers::Offset<flatbuffers::String> leaderName = 0,
    flatbuffers::Offset<flatbuffers::String> introMessage = 0,
    int16_t joinLimitLevel = 0,
    int32_t prevRank = 0,
    int32_t combatPowerAvg = 0,
    int64_t createTimeUtc = 0,
    bool joinRequested = false) {
  GuildDetailInfoBuilder builder_(_fbb);
  builder_.add_createTimeUtc(createTimeUtc);
  builder_.add_combatPowerAvg(combatPowerAvg);
  builder_.add_prevRank(prevRank);
  builder_.add_introMessage(introMessage);
  builder_.add_leaderName(leaderName);
  builder_.add_basicInfo(basicInfo);
  builder_.add_joinLimitLevel(joinLimitLevel);
  builder_.add_joinRequested(joinRequested);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildDetailInfo> CreateGuildDetailInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GuildBasicInfo> basicInfo = 0,
    const char *leaderName = nullptr,
    const char *introMessage = nullptr,
    int16_t joinLimitLevel = 0,
    int32_t prevRank = 0,
    int32_t combatPowerAvg = 0,
    int64_t createTimeUtc = 0,
    bool joinRequested = false) {
  return LeanPacket::CreateGuildDetailInfo(
      _fbb,
      basicInfo,
      leaderName ? _fbb.CreateString(leaderName) : 0,
      introMessage ? _fbb.CreateString(introMessage) : 0,
      joinLimitLevel,
      prevRank,
      combatPowerAvg,
      createTimeUtc,
      joinRequested);
}

/// 길드 랭킹 정보
struct GuildRankingInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_NAME = 6,
    VT_CREST = 8,
    VT_RANK = 10,
    VT_LEADERNAME = 12,
    VT_LEADERLEVEL = 14,
    VT_LEADERINFLUENCETIER = 16,
    VT_LEADERINFLUENCELEVEL = 18,
    VT_SCORE = 20
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const GuildCrest *crest() const {
    return GetPointer<const GuildCrest *>(VT_CREST);
  }
  /// 순위 (1 base)
  int32_t rank() const {
    return GetField<int32_t>(VT_RANK, 0);
  }
  /// 총사령관
  const flatbuffers::String *leaderName() const {
    return GetPointer<const flatbuffers::String *>(VT_LEADERNAME);
  }
  int16_t leaderLevel() const {
    return GetField<int16_t>(VT_LEADERLEVEL, 0);
  }
  int16_t leaderInfluenceTier() const {
    return GetField<int16_t>(VT_LEADERINFLUENCETIER, 0);
  }
  int16_t leaderInfluenceLevel() const {
    return GetField<int16_t>(VT_LEADERINFLUENCELEVEL, 0);
  }
  /// 레벨 / 전투력 / 군주포인트 / 군주길드 횟수
  int64_t score() const {
    return GetField<int64_t>(VT_SCORE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_CREST) &&
           verifier.VerifyTable(crest()) &&
           VerifyField<int32_t>(verifier, VT_RANK) &&
           VerifyOffsetRequired(verifier, VT_LEADERNAME) &&
           verifier.VerifyString(leaderName()) &&
           VerifyField<int16_t>(verifier, VT_LEADERLEVEL) &&
           VerifyField<int16_t>(verifier, VT_LEADERINFLUENCETIER) &&
           VerifyField<int16_t>(verifier, VT_LEADERINFLUENCELEVEL) &&
           VerifyField<int64_t>(verifier, VT_SCORE) &&
           verifier.EndTable();
  }
};

struct GuildRankingInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(GuildRankingInfo::VT_ID, id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(GuildRankingInfo::VT_NAME, name);
  }
  void add_crest(flatbuffers::Offset<GuildCrest> crest) {
    fbb_.AddOffset(GuildRankingInfo::VT_CREST, crest);
  }
  void add_rank(int32_t rank) {
    fbb_.AddElement<int32_t>(GuildRankingInfo::VT_RANK, rank, 0);
  }
  void add_leaderName(flatbuffers::Offset<flatbuffers::String> leaderName) {
    fbb_.AddOffset(GuildRankingInfo::VT_LEADERNAME, leaderName);
  }
  void add_leaderLevel(int16_t leaderLevel) {
    fbb_.AddElement<int16_t>(GuildRankingInfo::VT_LEADERLEVEL, leaderLevel, 0);
  }
  void add_leaderInfluenceTier(int16_t leaderInfluenceTier) {
    fbb_.AddElement<int16_t>(GuildRankingInfo::VT_LEADERINFLUENCETIER, leaderInfluenceTier, 0);
  }
  void add_leaderInfluenceLevel(int16_t leaderInfluenceLevel) {
    fbb_.AddElement<int16_t>(GuildRankingInfo::VT_LEADERINFLUENCELEVEL, leaderInfluenceLevel, 0);
  }
  void add_score(int64_t score) {
    fbb_.AddElement<int64_t>(GuildRankingInfo::VT_SCORE, score, 0);
  }
  explicit GuildRankingInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildRankingInfoBuilder &operator=(const GuildRankingInfoBuilder &);
  flatbuffers::Offset<GuildRankingInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildRankingInfo>(end);
    fbb_.Required(o, GuildRankingInfo::VT_NAME);
    fbb_.Required(o, GuildRankingInfo::VT_CREST);
    fbb_.Required(o, GuildRankingInfo::VT_LEADERNAME);
    return o;
  }
};

inline flatbuffers::Offset<GuildRankingInfo> CreateGuildRankingInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<GuildCrest> crest = 0,
    int32_t rank = 0,
    flatbuffers::Offset<flatbuffers::String> leaderName = 0,
    int16_t leaderLevel = 0,
    int16_t leaderInfluenceTier = 0,
    int16_t leaderInfluenceLevel = 0,
    int64_t score = 0) {
  GuildRankingInfoBuilder builder_(_fbb);
  builder_.add_score(score);
  builder_.add_leaderName(leaderName);
  builder_.add_rank(rank);
  builder_.add_crest(crest);
  builder_.add_name(name);
  builder_.add_id(id);
  builder_.add_leaderInfluenceLevel(leaderInfluenceLevel);
  builder_.add_leaderInfluenceTier(leaderInfluenceTier);
  builder_.add_leaderLevel(leaderLevel);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildRankingInfo> CreateGuildRankingInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    const char *name = nullptr,
    flatbuffers::Offset<GuildCrest> crest = 0,
    int32_t rank = 0,
    const char *leaderName = nullptr,
    int16_t leaderLevel = 0,
    int16_t leaderInfluenceTier = 0,
    int16_t leaderInfluenceLevel = 0,
    int64_t score = 0) {
  return LeanPacket::CreateGuildRankingInfo(
      _fbb,
      id,
      name ? _fbb.CreateString(name) : 0,
      crest,
      rank,
      leaderName ? _fbb.CreateString(leaderName) : 0,
      leaderLevel,
      leaderInfluenceTier,
      leaderInfluenceLevel,
      score);
}

/// #길드 정보
/// 유저에게 내 길드 정보를 보여주기 위한 용도
struct GuildInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_NAME = 6,
    VT_LEVEL = 8,
    VT_EXP = 10,
    VT_JOINTYPE = 12,
    VT_JOINLIMITLEVEL = 14,
    VT_CREST = 16,
    VT_LEADERNAME = 18,
    VT_INTROMESSAGE = 20,
    VT_NOTICEMESSAGE = 22,
    VT_RANK = 24,
    VT_MEMBERCOUNT = 26,
    VT_COMBATPOWERAVG = 28,
    VT_MONARCHPOINT = 30,
    VT_CREATETIMEUTC = 32,
    VT_DUNGEONRANK = 34,
    VT_DUNGEONSCORE = 36
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int16_t level() const {
    return GetField<int16_t>(VT_LEVEL, 0);
  }
  int32_t exp() const {
    return GetField<int32_t>(VT_EXP, 0);
  }
  /// LeanData::eGuild_joinType
  int8_t joinType() const {
    return GetField<int8_t>(VT_JOINTYPE, 0);
  }
  int16_t joinLimitLevel() const {
    return GetField<int16_t>(VT_JOINLIMITLEVEL, 0);
  }
  const GuildCrest *crest() const {
    return GetPointer<const GuildCrest *>(VT_CREST);
  }
  const flatbuffers::String *leaderName() const {
    return GetPointer<const flatbuffers::String *>(VT_LEADERNAME);
  }
  const flatbuffers::String *introMessage() const {
    return GetPointer<const flatbuffers::String *>(VT_INTROMESSAGE);
  }
  const flatbuffers::String *noticeMessage() const {
    return GetPointer<const flatbuffers::String *>(VT_NOTICEMESSAGE);
  }
  /// 현재 랭킹
  int32_t rank() const {
    return GetField<int32_t>(VT_RANK, 0);
  }
  int32_t memberCount() const {
    return GetField<int32_t>(VT_MEMBERCOUNT, 0);
  }
  int32_t combatPowerAvg() const {
    return GetField<int32_t>(VT_COMBATPOWERAVG, 0);
  }
  int64_t monarchPoint() const {
    return GetField<int64_t>(VT_MONARCHPOINT, 0);
  }
  /// 길드 생성 시간. 다음과 같이 변환해서 쓰세요
  /// new DateTime(ticks, DateTimeKind.Utc).ToLocalTime(); // local time
  int64_t createTimeUtc() const {
    return GetField<int64_t>(VT_CREATETIMEUTC, 0);
  }
  /// 길드던전 랭킹
  int32_t dungeonRank() const {
    return GetField<int32_t>(VT_DUNGEONRANK, 0);
  }
  int64_t dungeonScore() const {
    return GetField<int64_t>(VT_DUNGEONSCORE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int16_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_EXP) &&
           VerifyField<int8_t>(verifier, VT_JOINTYPE) &&
           VerifyField<int16_t>(verifier, VT_JOINLIMITLEVEL) &&
           VerifyOffsetRequired(verifier, VT_CREST) &&
           verifier.VerifyTable(crest()) &&
           VerifyOffsetRequired(verifier, VT_LEADERNAME) &&
           verifier.VerifyString(leaderName()) &&
           VerifyOffsetRequired(verifier, VT_INTROMESSAGE) &&
           verifier.VerifyString(introMessage()) &&
           VerifyOffsetRequired(verifier, VT_NOTICEMESSAGE) &&
           verifier.VerifyString(noticeMessage()) &&
           VerifyField<int32_t>(verifier, VT_RANK) &&
           VerifyField<int32_t>(verifier, VT_MEMBERCOUNT) &&
           VerifyField<int32_t>(verifier, VT_COMBATPOWERAVG) &&
           VerifyField<int64_t>(verifier, VT_MONARCHPOINT) &&
           VerifyField<int64_t>(verifier, VT_CREATETIMEUTC) &&
           VerifyField<int32_t>(verifier, VT_DUNGEONRANK) &&
           VerifyField<int64_t>(verifier, VT_DUNGEONSCORE) &&
           verifier.EndTable();
  }
};

struct GuildInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(GuildInfo::VT_ID, id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(GuildInfo::VT_NAME, name);
  }
  void add_level(int16_t level) {
    fbb_.AddElement<int16_t>(GuildInfo::VT_LEVEL, level, 0);
  }
  void add_exp(int32_t exp) {
    fbb_.AddElement<int32_t>(GuildInfo::VT_EXP, exp, 0);
  }
  void add_joinType(int8_t joinType) {
    fbb_.AddElement<int8_t>(GuildInfo::VT_JOINTYPE, joinType, 0);
  }
  void add_joinLimitLevel(int16_t joinLimitLevel) {
    fbb_.AddElement<int16_t>(GuildInfo::VT_JOINLIMITLEVEL, joinLimitLevel, 0);
  }
  void add_crest(flatbuffers::Offset<GuildCrest> crest) {
    fbb_.AddOffset(GuildInfo::VT_CREST, crest);
  }
  void add_leaderName(flatbuffers::Offset<flatbuffers::String> leaderName) {
    fbb_.AddOffset(GuildInfo::VT_LEADERNAME, leaderName);
  }
  void add_introMessage(flatbuffers::Offset<flatbuffers::String> introMessage) {
    fbb_.AddOffset(GuildInfo::VT_INTROMESSAGE, introMessage);
  }
  void add_noticeMessage(flatbuffers::Offset<flatbuffers::String> noticeMessage) {
    fbb_.AddOffset(GuildInfo::VT_NOTICEMESSAGE, noticeMessage);
  }
  void add_rank(int32_t rank) {
    fbb_.AddElement<int32_t>(GuildInfo::VT_RANK, rank, 0);
  }
  void add_memberCount(int32_t memberCount) {
    fbb_.AddElement<int32_t>(GuildInfo::VT_MEMBERCOUNT, memberCount, 0);
  }
  void add_combatPowerAvg(int32_t combatPowerAvg) {
    fbb_.AddElement<int32_t>(GuildInfo::VT_COMBATPOWERAVG, combatPowerAvg, 0);
  }
  void add_monarchPoint(int64_t monarchPoint) {
    fbb_.AddElement<int64_t>(GuildInfo::VT_MONARCHPOINT, monarchPoint, 0);
  }
  void add_createTimeUtc(int64_t createTimeUtc) {
    fbb_.AddElement<int64_t>(GuildInfo::VT_CREATETIMEUTC, createTimeUtc, 0);
  }
  void add_dungeonRank(int32_t dungeonRank) {
    fbb_.AddElement<int32_t>(GuildInfo::VT_DUNGEONRANK, dungeonRank, 0);
  }
  void add_dungeonScore(int64_t dungeonScore) {
    fbb_.AddElement<int64_t>(GuildInfo::VT_DUNGEONSCORE, dungeonScore, 0);
  }
  explicit GuildInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildInfoBuilder &operator=(const GuildInfoBuilder &);
  flatbuffers::Offset<GuildInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildInfo>(end);
    fbb_.Required(o, GuildInfo::VT_NAME);
    fbb_.Required(o, GuildInfo::VT_CREST);
    fbb_.Required(o, GuildInfo::VT_LEADERNAME);
    fbb_.Required(o, GuildInfo::VT_INTROMESSAGE);
    fbb_.Required(o, GuildInfo::VT_NOTICEMESSAGE);
    return o;
  }
};

inline flatbuffers::Offset<GuildInfo> CreateGuildInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int16_t level = 0,
    int32_t exp = 0,
    int8_t joinType = 0,
    int16_t joinLimitLevel = 0,
    flatbuffers::Offset<GuildCrest> crest = 0,
    flatbuffers::Offset<flatbuffers::String> leaderName = 0,
    flatbuffers::Offset<flatbuffers::String> introMessage = 0,
    flatbuffers::Offset<flatbuffers::String> noticeMessage = 0,
    int32_t rank = 0,
    int32_t memberCount = 0,
    int32_t combatPowerAvg = 0,
    int64_t monarchPoint = 0,
    int64_t createTimeUtc = 0,
    int32_t dungeonRank = 0,
    int64_t dungeonScore = 0) {
  GuildInfoBuilder builder_(_fbb);
  builder_.add_dungeonScore(dungeonScore);
  builder_.add_createTimeUtc(createTimeUtc);
  builder_.add_monarchPoint(monarchPoint);
  builder_.add_dungeonRank(dungeonRank);
  builder_.add_combatPowerAvg(combatPowerAvg);
  builder_.add_memberCount(memberCount);
  builder_.add_rank(rank);
  builder_.add_noticeMessage(noticeMessage);
  builder_.add_introMessage(introMessage);
  builder_.add_leaderName(leaderName);
  builder_.add_crest(crest);
  builder_.add_exp(exp);
  builder_.add_name(name);
  builder_.add_id(id);
  builder_.add_joinLimitLevel(joinLimitLevel);
  builder_.add_level(level);
  builder_.add_joinType(joinType);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildInfo> CreateGuildInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    const char *name = nullptr,
    int16_t level = 0,
    int32_t exp = 0,
    int8_t joinType = 0,
    int16_t joinLimitLevel = 0,
    flatbuffers::Offset<GuildCrest> crest = 0,
    const char *leaderName = nullptr,
    const char *introMessage = nullptr,
    const char *noticeMessage = nullptr,
    int32_t rank = 0,
    int32_t memberCount = 0,
    int32_t combatPowerAvg = 0,
    int64_t monarchPoint = 0,
    int64_t createTimeUtc = 0,
    int32_t dungeonRank = 0,
    int64_t dungeonScore = 0) {
  return LeanPacket::CreateGuildInfo(
      _fbb,
      id,
      name ? _fbb.CreateString(name) : 0,
      level,
      exp,
      joinType,
      joinLimitLevel,
      crest,
      leaderName ? _fbb.CreateString(leaderName) : 0,
      introMessage ? _fbb.CreateString(introMessage) : 0,
      noticeMessage ? _fbb.CreateString(noticeMessage) : 0,
      rank,
      memberCount,
      combatPowerAvg,
      monarchPoint,
      createTimeUtc,
      dungeonRank,
      dungeonScore);
}

/// 로그인 시 처음 한번 받는 길드 정보
struct GuildLoginInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_ATTENDAVALIABLETIMEUTC = 6,
    VT_JOINAVALIABLETIMEUTC = 8,
    VT_APPLICANTCOUNT = 10
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  /// 출석 가능한 시간
  int64_t attendAvaliableTimeUtc() const {
    return GetField<int64_t>(VT_ATTENDAVALIABLETIMEUTC, 0);
  }
  /// 가입/창설 가능한 시간
  int64_t joinAvaliableTimeUtc() const {
    return GetField<int64_t>(VT_JOINAVALIABLETIMEUTC, 0);
  }
  /// 가입 요청 개수
  int32_t applicantCount() const {
    return GetField<int32_t>(VT_APPLICANTCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<int64_t>(verifier, VT_ATTENDAVALIABLETIMEUTC) &&
           VerifyField<int64_t>(verifier, VT_JOINAVALIABLETIMEUTC) &&
           VerifyField<int32_t>(verifier, VT_APPLICANTCOUNT) &&
           verifier.EndTable();
  }
};

struct GuildLoginInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(GuildLoginInfo::VT_ID, id, 0);
  }
  void add_attendAvaliableTimeUtc(int64_t attendAvaliableTimeUtc) {
    fbb_.AddElement<int64_t>(GuildLoginInfo::VT_ATTENDAVALIABLETIMEUTC, attendAvaliableTimeUtc, 0);
  }
  void add_joinAvaliableTimeUtc(int64_t joinAvaliableTimeUtc) {
    fbb_.AddElement<int64_t>(GuildLoginInfo::VT_JOINAVALIABLETIMEUTC, joinAvaliableTimeUtc, 0);
  }
  void add_applicantCount(int32_t applicantCount) {
    fbb_.AddElement<int32_t>(GuildLoginInfo::VT_APPLICANTCOUNT, applicantCount, 0);
  }
  explicit GuildLoginInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildLoginInfoBuilder &operator=(const GuildLoginInfoBuilder &);
  flatbuffers::Offset<GuildLoginInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildLoginInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildLoginInfo> CreateGuildLoginInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int64_t attendAvaliableTimeUtc = 0,
    int64_t joinAvaliableTimeUtc = 0,
    int32_t applicantCount = 0) {
  GuildLoginInfoBuilder builder_(_fbb);
  builder_.add_joinAvaliableTimeUtc(joinAvaliableTimeUtc);
  builder_.add_attendAvaliableTimeUtc(attendAvaliableTimeUtc);
  builder_.add_applicantCount(applicantCount);
  builder_.add_id(id);
  return builder_.Finish();
}

/// #길드 멤버 정보
struct GuildMemberInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCDBID = 4,
    VT_NAME = 6,
    VT_GRADE = 8,
    VT_LEVEL = 10,
    VT_CLASSTYPE = 12,
    VT_COMBATPOWER = 14,
    VT_MONARCHPOINT = 16,
    VT_ONLINE = 18,
    VT_LASTLOGINTIMEUTC = 20,
    VT_ACCUMDONATE = 22,
    VT_ATTENDCOUNT = 24
  };
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int8_t grade() const {
    return GetField<int8_t>(VT_GRADE, 0);
  }
  int16_t level() const {
    return GetField<int16_t>(VT_LEVEL, 0);
  }
  int32_t classType() const {
    return GetField<int32_t>(VT_CLASSTYPE, 0);
  }
  int32_t combatPower() const {
    return GetField<int32_t>(VT_COMBATPOWER, 0);
  }
  int32_t monarchPoint() const {
    return GetField<int32_t>(VT_MONARCHPOINT, 0);
  }
  /// 접속 여부
  bool online() const {
    return GetField<uint8_t>(VT_ONLINE, 0) != 0;
  }
  /// online == true 면 0
  int64_t lastLoginTimeUtc() const {
    return GetField<int64_t>(VT_LASTLOGINTIMEUTC, 0);
  }
  int32_t accumDonate() const {
    return GetField<int32_t>(VT_ACCUMDONATE, 0);
  }
  int32_t attendCount() const {
    return GetField<int32_t>(VT_ATTENDCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_GRADE) &&
           VerifyField<int16_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_CLASSTYPE) &&
           VerifyField<int32_t>(verifier, VT_COMBATPOWER) &&
           VerifyField<int32_t>(verifier, VT_MONARCHPOINT) &&
           VerifyField<uint8_t>(verifier, VT_ONLINE) &&
           VerifyField<int64_t>(verifier, VT_LASTLOGINTIMEUTC) &&
           VerifyField<int32_t>(verifier, VT_ACCUMDONATE) &&
           VerifyField<int32_t>(verifier, VT_ATTENDCOUNT) &&
           verifier.EndTable();
  }
};

struct GuildMemberInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(GuildMemberInfo::VT_PCDBID, pcDbId, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(GuildMemberInfo::VT_NAME, name);
  }
  void add_grade(int8_t grade) {
    fbb_.AddElement<int8_t>(GuildMemberInfo::VT_GRADE, grade, 0);
  }
  void add_level(int16_t level) {
    fbb_.AddElement<int16_t>(GuildMemberInfo::VT_LEVEL, level, 0);
  }
  void add_classType(int32_t classType) {
    fbb_.AddElement<int32_t>(GuildMemberInfo::VT_CLASSTYPE, classType, 0);
  }
  void add_combatPower(int32_t combatPower) {
    fbb_.AddElement<int32_t>(GuildMemberInfo::VT_COMBATPOWER, combatPower, 0);
  }
  void add_monarchPoint(int32_t monarchPoint) {
    fbb_.AddElement<int32_t>(GuildMemberInfo::VT_MONARCHPOINT, monarchPoint, 0);
  }
  void add_online(bool online) {
    fbb_.AddElement<uint8_t>(GuildMemberInfo::VT_ONLINE, static_cast<uint8_t>(online), 0);
  }
  void add_lastLoginTimeUtc(int64_t lastLoginTimeUtc) {
    fbb_.AddElement<int64_t>(GuildMemberInfo::VT_LASTLOGINTIMEUTC, lastLoginTimeUtc, 0);
  }
  void add_accumDonate(int32_t accumDonate) {
    fbb_.AddElement<int32_t>(GuildMemberInfo::VT_ACCUMDONATE, accumDonate, 0);
  }
  void add_attendCount(int32_t attendCount) {
    fbb_.AddElement<int32_t>(GuildMemberInfo::VT_ATTENDCOUNT, attendCount, 0);
  }
  explicit GuildMemberInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildMemberInfoBuilder &operator=(const GuildMemberInfoBuilder &);
  flatbuffers::Offset<GuildMemberInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildMemberInfo>(end);
    fbb_.Required(o, GuildMemberInfo::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<GuildMemberInfo> CreateGuildMemberInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcDbId = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int8_t grade = 0,
    int16_t level = 0,
    int32_t classType = 0,
    int32_t combatPower = 0,
    int32_t monarchPoint = 0,
    bool online = false,
    int64_t lastLoginTimeUtc = 0,
    int32_t accumDonate = 0,
    int32_t attendCount = 0) {
  GuildMemberInfoBuilder builder_(_fbb);
  builder_.add_lastLoginTimeUtc(lastLoginTimeUtc);
  builder_.add_pcDbId(pcDbId);
  builder_.add_attendCount(attendCount);
  builder_.add_accumDonate(accumDonate);
  builder_.add_monarchPoint(monarchPoint);
  builder_.add_combatPower(combatPower);
  builder_.add_classType(classType);
  builder_.add_name(name);
  builder_.add_level(level);
  builder_.add_online(online);
  builder_.add_grade(grade);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildMemberInfo> CreateGuildMemberInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcDbId = 0,
    const char *name = nullptr,
    int8_t grade = 0,
    int16_t level = 0,
    int32_t classType = 0,
    int32_t combatPower = 0,
    int32_t monarchPoint = 0,
    bool online = false,
    int64_t lastLoginTimeUtc = 0,
    int32_t accumDonate = 0,
    int32_t attendCount = 0) {
  return LeanPacket::CreateGuildMemberInfo(
      _fbb,
      pcDbId,
      name ? _fbb.CreateString(name) : 0,
      grade,
      level,
      classType,
      combatPower,
      monarchPoint,
      online,
      lastLoginTimeUtc,
      accumDonate,
      attendCount);
}

/// #길드 요청자 정보
struct GuildJoinRequestInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCDBID = 4,
    VT_NAME = 6,
    VT_LEVEL = 8,
    VT_CLASSTYPE = 10,
    VT_COMBATPOWER = 12,
    VT_MONARCHPOINT = 14,
    VT_REQUESTTIMEUTC = 16,
    VT_LASTLOGINTIMEUTC = 18,
    VT_ONLINE = 20
  };
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int16_t level() const {
    return GetField<int16_t>(VT_LEVEL, 0);
  }
  int32_t classType() const {
    return GetField<int32_t>(VT_CLASSTYPE, 0);
  }
  int32_t combatPower() const {
    return GetField<int32_t>(VT_COMBATPOWER, 0);
  }
  int32_t monarchPoint() const {
    return GetField<int32_t>(VT_MONARCHPOINT, 0);
  }
  /// 가입 요청 시간
  int64_t requestTimeUtc() const {
    return GetField<int64_t>(VT_REQUESTTIMEUTC, 0);
  }
  int64_t lastLoginTimeUtc() const {
    return GetField<int64_t>(VT_LASTLOGINTIMEUTC, 0);
  }
  /// 접속 여부
  bool online() const {
    return GetField<uint8_t>(VT_ONLINE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int16_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_CLASSTYPE) &&
           VerifyField<int32_t>(verifier, VT_COMBATPOWER) &&
           VerifyField<int32_t>(verifier, VT_MONARCHPOINT) &&
           VerifyField<int64_t>(verifier, VT_REQUESTTIMEUTC) &&
           VerifyField<int64_t>(verifier, VT_LASTLOGINTIMEUTC) &&
           VerifyField<uint8_t>(verifier, VT_ONLINE) &&
           verifier.EndTable();
  }
};

struct GuildJoinRequestInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(GuildJoinRequestInfo::VT_PCDBID, pcDbId, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(GuildJoinRequestInfo::VT_NAME, name);
  }
  void add_level(int16_t level) {
    fbb_.AddElement<int16_t>(GuildJoinRequestInfo::VT_LEVEL, level, 0);
  }
  void add_classType(int32_t classType) {
    fbb_.AddElement<int32_t>(GuildJoinRequestInfo::VT_CLASSTYPE, classType, 0);
  }
  void add_combatPower(int32_t combatPower) {
    fbb_.AddElement<int32_t>(GuildJoinRequestInfo::VT_COMBATPOWER, combatPower, 0);
  }
  void add_monarchPoint(int32_t monarchPoint) {
    fbb_.AddElement<int32_t>(GuildJoinRequestInfo::VT_MONARCHPOINT, monarchPoint, 0);
  }
  void add_requestTimeUtc(int64_t requestTimeUtc) {
    fbb_.AddElement<int64_t>(GuildJoinRequestInfo::VT_REQUESTTIMEUTC, requestTimeUtc, 0);
  }
  void add_lastLoginTimeUtc(int64_t lastLoginTimeUtc) {
    fbb_.AddElement<int64_t>(GuildJoinRequestInfo::VT_LASTLOGINTIMEUTC, lastLoginTimeUtc, 0);
  }
  void add_online(bool online) {
    fbb_.AddElement<uint8_t>(GuildJoinRequestInfo::VT_ONLINE, static_cast<uint8_t>(online), 0);
  }
  explicit GuildJoinRequestInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildJoinRequestInfoBuilder &operator=(const GuildJoinRequestInfoBuilder &);
  flatbuffers::Offset<GuildJoinRequestInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildJoinRequestInfo>(end);
    fbb_.Required(o, GuildJoinRequestInfo::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<GuildJoinRequestInfo> CreateGuildJoinRequestInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcDbId = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int16_t level = 0,
    int32_t classType = 0,
    int32_t combatPower = 0,
    int32_t monarchPoint = 0,
    int64_t requestTimeUtc = 0,
    int64_t lastLoginTimeUtc = 0,
    bool online = false) {
  GuildJoinRequestInfoBuilder builder_(_fbb);
  builder_.add_lastLoginTimeUtc(lastLoginTimeUtc);
  builder_.add_requestTimeUtc(requestTimeUtc);
  builder_.add_pcDbId(pcDbId);
  builder_.add_monarchPoint(monarchPoint);
  builder_.add_combatPower(combatPower);
  builder_.add_classType(classType);
  builder_.add_name(name);
  builder_.add_level(level);
  builder_.add_online(online);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildJoinRequestInfo> CreateGuildJoinRequestInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcDbId = 0,
    const char *name = nullptr,
    int16_t level = 0,
    int32_t classType = 0,
    int32_t combatPower = 0,
    int32_t monarchPoint = 0,
    int64_t requestTimeUtc = 0,
    int64_t lastLoginTimeUtc = 0,
    bool online = false) {
  return LeanPacket::CreateGuildJoinRequestInfo(
      _fbb,
      pcDbId,
      name ? _fbb.CreateString(name) : 0,
      level,
      classType,
      combatPower,
      monarchPoint,
      requestTimeUtc,
      lastLoginTimeUtc,
      online);
}

/// GUILD_INFO_NOTIFY
struct GuildInfoNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GUILDINFO = 4
  };
  const GuildLoginInfo *guildInfo() const {
    return GetPointer<const GuildLoginInfo *>(VT_GUILDINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_GUILDINFO) &&
           verifier.VerifyTable(guildInfo()) &&
           verifier.EndTable();
  }
};

struct GuildInfoNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_guildInfo(flatbuffers::Offset<GuildLoginInfo> guildInfo) {
    fbb_.AddOffset(GuildInfoNotify::VT_GUILDINFO, guildInfo);
  }
  explicit GuildInfoNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildInfoNotifyBuilder &operator=(const GuildInfoNotifyBuilder &);
  flatbuffers::Offset<GuildInfoNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildInfoNotify>(end);
    fbb_.Required(o, GuildInfoNotify::VT_GUILDINFO);
    return o;
  }
};

inline flatbuffers::Offset<GuildInfoNotify> CreateGuildInfoNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GuildLoginInfo> guildInfo = 0) {
  GuildInfoNotifyBuilder builder_(_fbb);
  builder_.add_guildInfo(guildInfo);
  return builder_.Finish();
}

/// GUILD_NOT_IMPL_NOTIFY
struct GuildNotImplNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GuildNotImplNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GuildNotImplNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildNotImplNotifyBuilder &operator=(const GuildNotImplNotifyBuilder &);
  flatbuffers::Offset<GuildNotImplNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildNotImplNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildNotImplNotify> CreateGuildNotImplNotify(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GuildNotImplNotifyBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GuildCrest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_SYMBOL = 6,
    VT_COLOR = 8
  };
  int16_t frame() const {
    return GetField<int16_t>(VT_FRAME, 0);
  }
  int16_t symbol() const {
    return GetField<int16_t>(VT_SYMBOL, 0);
  }
  int16_t color() const {
    return GetField<int16_t>(VT_COLOR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_FRAME) &&
           VerifyField<int16_t>(verifier, VT_SYMBOL) &&
           VerifyField<int16_t>(verifier, VT_COLOR) &&
           verifier.EndTable();
  }
};

struct GuildCrestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(int16_t frame) {
    fbb_.AddElement<int16_t>(GuildCrest::VT_FRAME, frame, 0);
  }
  void add_symbol(int16_t symbol) {
    fbb_.AddElement<int16_t>(GuildCrest::VT_SYMBOL, symbol, 0);
  }
  void add_color(int16_t color) {
    fbb_.AddElement<int16_t>(GuildCrest::VT_COLOR, color, 0);
  }
  explicit GuildCrestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildCrestBuilder &operator=(const GuildCrestBuilder &);
  flatbuffers::Offset<GuildCrest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildCrest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildCrest> CreateGuildCrest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t frame = 0,
    int16_t symbol = 0,
    int16_t color = 0) {
  GuildCrestBuilder builder_(_fbb);
  builder_.add_color(color);
  builder_.add_symbol(symbol);
  builder_.add_frame(frame);
  return builder_.Finish();
}

/// GUILD_CREATE_REQUEST
struct GuildCreateRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_JOINTYPE = 6,
    VT_JOINLIMITLEVEL = 8,
    VT_CREST = 10,
    VT_INTRO = 12,
    VT_NOTICE = 14
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  /// LeanData::eGuild_joinType
  int8_t joinType() const {
    return GetField<int8_t>(VT_JOINTYPE, 0);
  }
  /// 가입 제한 레벨
  int16_t joinLimitLevel() const {
    return GetField<int16_t>(VT_JOINLIMITLEVEL, 0);
  }
  /// 길드 문장
  const GuildCrest *crest() const {
    return GetPointer<const GuildCrest *>(VT_CREST);
  }
  /// 소개글
  const flatbuffers::String *intro() const {
    return GetPointer<const flatbuffers::String *>(VT_INTRO);
  }
  /// 공지글
  const flatbuffers::String *notice() const {
    return GetPointer<const flatbuffers::String *>(VT_NOTICE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_JOINTYPE) &&
           VerifyField<int16_t>(verifier, VT_JOINLIMITLEVEL) &&
           VerifyOffsetRequired(verifier, VT_CREST) &&
           verifier.VerifyTable(crest()) &&
           VerifyOffset(verifier, VT_INTRO) &&
           verifier.VerifyString(intro()) &&
           VerifyOffset(verifier, VT_NOTICE) &&
           verifier.VerifyString(notice()) &&
           verifier.EndTable();
  }
};

struct GuildCreateRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(GuildCreateRequest::VT_NAME, name);
  }
  void add_joinType(int8_t joinType) {
    fbb_.AddElement<int8_t>(GuildCreateRequest::VT_JOINTYPE, joinType, 0);
  }
  void add_joinLimitLevel(int16_t joinLimitLevel) {
    fbb_.AddElement<int16_t>(GuildCreateRequest::VT_JOINLIMITLEVEL, joinLimitLevel, 0);
  }
  void add_crest(flatbuffers::Offset<GuildCrest> crest) {
    fbb_.AddOffset(GuildCreateRequest::VT_CREST, crest);
  }
  void add_intro(flatbuffers::Offset<flatbuffers::String> intro) {
    fbb_.AddOffset(GuildCreateRequest::VT_INTRO, intro);
  }
  void add_notice(flatbuffers::Offset<flatbuffers::String> notice) {
    fbb_.AddOffset(GuildCreateRequest::VT_NOTICE, notice);
  }
  explicit GuildCreateRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildCreateRequestBuilder &operator=(const GuildCreateRequestBuilder &);
  flatbuffers::Offset<GuildCreateRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildCreateRequest>(end);
    fbb_.Required(o, GuildCreateRequest::VT_NAME);
    fbb_.Required(o, GuildCreateRequest::VT_CREST);
    return o;
  }
};

inline flatbuffers::Offset<GuildCreateRequest> CreateGuildCreateRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int8_t joinType = 0,
    int16_t joinLimitLevel = 0,
    flatbuffers::Offset<GuildCrest> crest = 0,
    flatbuffers::Offset<flatbuffers::String> intro = 0,
    flatbuffers::Offset<flatbuffers::String> notice = 0) {
  GuildCreateRequestBuilder builder_(_fbb);
  builder_.add_notice(notice);
  builder_.add_intro(intro);
  builder_.add_crest(crest);
  builder_.add_name(name);
  builder_.add_joinLimitLevel(joinLimitLevel);
  builder_.add_joinType(joinType);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildCreateRequest> CreateGuildCreateRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int8_t joinType = 0,
    int16_t joinLimitLevel = 0,
    flatbuffers::Offset<GuildCrest> crest = 0,
    const char *intro = nullptr,
    const char *notice = nullptr) {
  return LeanPacket::CreateGuildCreateRequest(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      joinType,
      joinLimitLevel,
      crest,
      intro ? _fbb.CreateString(intro) : 0,
      notice ? _fbb.CreateString(notice) : 0);
}

/// GUILD_CREATE_RESPONSE
struct GuildCreateResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           verifier.EndTable();
  }
};

struct GuildCreateResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(GuildCreateResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  explicit GuildCreateResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildCreateResponseBuilder &operator=(const GuildCreateResponseBuilder &);
  flatbuffers::Offset<GuildCreateResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildCreateResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildCreateResponse> CreateGuildCreateResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE) {
  GuildCreateResponseBuilder builder_(_fbb);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

/// GUILD_CHECK_NAME_REQUEST
struct GuildCheckNameRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GUILDNAME = 4
  };
  const flatbuffers::String *guildName() const {
    return GetPointer<const flatbuffers::String *>(VT_GUILDNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_GUILDNAME) &&
           verifier.VerifyString(guildName()) &&
           verifier.EndTable();
  }
};

struct GuildCheckNameRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_guildName(flatbuffers::Offset<flatbuffers::String> guildName) {
    fbb_.AddOffset(GuildCheckNameRequest::VT_GUILDNAME, guildName);
  }
  explicit GuildCheckNameRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildCheckNameRequestBuilder &operator=(const GuildCheckNameRequestBuilder &);
  flatbuffers::Offset<GuildCheckNameRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildCheckNameRequest>(end);
    fbb_.Required(o, GuildCheckNameRequest::VT_GUILDNAME);
    return o;
  }
};

inline flatbuffers::Offset<GuildCheckNameRequest> CreateGuildCheckNameRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> guildName = 0) {
  GuildCheckNameRequestBuilder builder_(_fbb);
  builder_.add_guildName(guildName);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildCheckNameRequest> CreateGuildCheckNameRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *guildName = nullptr) {
  return LeanPacket::CreateGuildCheckNameRequest(
      _fbb,
      guildName ? _fbb.CreateString(guildName) : 0);
}

/// GUILD_CHECK_NAME_RESPONSE
struct GuildCheckNameResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           verifier.EndTable();
  }
};

struct GuildCheckNameResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(GuildCheckNameResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  explicit GuildCheckNameResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildCheckNameResponseBuilder &operator=(const GuildCheckNameResponseBuilder &);
  flatbuffers::Offset<GuildCheckNameResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildCheckNameResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildCheckNameResponse> CreateGuildCheckNameResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE) {
  GuildCheckNameResponseBuilder builder_(_fbb);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

/// GUILD_DESTROY_REQUEST
struct GuildDestroyRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_USERINPUT = 4
  };
  const flatbuffers::String *userInput() const {
    return GetPointer<const flatbuffers::String *>(VT_USERINPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_USERINPUT) &&
           verifier.VerifyString(userInput()) &&
           verifier.EndTable();
  }
};

struct GuildDestroyRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_userInput(flatbuffers::Offset<flatbuffers::String> userInput) {
    fbb_.AddOffset(GuildDestroyRequest::VT_USERINPUT, userInput);
  }
  explicit GuildDestroyRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildDestroyRequestBuilder &operator=(const GuildDestroyRequestBuilder &);
  flatbuffers::Offset<GuildDestroyRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildDestroyRequest>(end);
    fbb_.Required(o, GuildDestroyRequest::VT_USERINPUT);
    return o;
  }
};

inline flatbuffers::Offset<GuildDestroyRequest> CreateGuildDestroyRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> userInput = 0) {
  GuildDestroyRequestBuilder builder_(_fbb);
  builder_.add_userInput(userInput);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildDestroyRequest> CreateGuildDestroyRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *userInput = nullptr) {
  return LeanPacket::CreateGuildDestroyRequest(
      _fbb,
      userInput ? _fbb.CreateString(userInput) : 0);
}

/// GUILD_DESTROY_RESPONSE
struct GuildDestroyResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_JOINAVALIABLETIMEUTC = 6
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  int64_t joinAvaliableTimeUtc() const {
    return GetField<int64_t>(VT_JOINAVALIABLETIMEUTC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int64_t>(verifier, VT_JOINAVALIABLETIMEUTC) &&
           verifier.EndTable();
  }
};

struct GuildDestroyResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(GuildDestroyResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  void add_joinAvaliableTimeUtc(int64_t joinAvaliableTimeUtc) {
    fbb_.AddElement<int64_t>(GuildDestroyResponse::VT_JOINAVALIABLETIMEUTC, joinAvaliableTimeUtc, 0);
  }
  explicit GuildDestroyResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildDestroyResponseBuilder &operator=(const GuildDestroyResponseBuilder &);
  flatbuffers::Offset<GuildDestroyResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildDestroyResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildDestroyResponse> CreateGuildDestroyResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE,
    int64_t joinAvaliableTimeUtc = 0) {
  GuildDestroyResponseBuilder builder_(_fbb);
  builder_.add_joinAvaliableTimeUtc(joinAvaliableTimeUtc);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

/// GUILD_INFO_REQUEST
struct GuildInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GuildInfoRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GuildInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildInfoRequestBuilder &operator=(const GuildInfoRequestBuilder &);
  flatbuffers::Offset<GuildInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildInfoRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildInfoRequest> CreateGuildInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GuildInfoRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// GUILD_INFO_RESPONSE
struct GuildInfoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GUILDINFO = 4,
    VT_NEEDNAMECHANGE = 6,
    VT_SEASONENDDATETIMEUTC = 8
  };
  const GuildInfo *guildInfo() const {
    return GetPointer<const GuildInfo *>(VT_GUILDINFO);
  }
  bool needNameChange() const {
    return GetField<uint8_t>(VT_NEEDNAMECHANGE, 0) != 0;
  }
  /// 시즌 종료 시간. 다음과 같이 변환해서 쓰세요
  /// new DateTime(ticks, DateTimeKind.Utc).ToLocalTime(); // local time
  int64_t seasonEndDateTimeUtc() const {
    return GetField<int64_t>(VT_SEASONENDDATETIMEUTC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GUILDINFO) &&
           verifier.VerifyTable(guildInfo()) &&
           VerifyField<uint8_t>(verifier, VT_NEEDNAMECHANGE) &&
           VerifyField<int64_t>(verifier, VT_SEASONENDDATETIMEUTC) &&
           verifier.EndTable();
  }
};

struct GuildInfoResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_guildInfo(flatbuffers::Offset<GuildInfo> guildInfo) {
    fbb_.AddOffset(GuildInfoResponse::VT_GUILDINFO, guildInfo);
  }
  void add_needNameChange(bool needNameChange) {
    fbb_.AddElement<uint8_t>(GuildInfoResponse::VT_NEEDNAMECHANGE, static_cast<uint8_t>(needNameChange), 0);
  }
  void add_seasonEndDateTimeUtc(int64_t seasonEndDateTimeUtc) {
    fbb_.AddElement<int64_t>(GuildInfoResponse::VT_SEASONENDDATETIMEUTC, seasonEndDateTimeUtc, 0);
  }
  explicit GuildInfoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildInfoResponseBuilder &operator=(const GuildInfoResponseBuilder &);
  flatbuffers::Offset<GuildInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildInfoResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildInfoResponse> CreateGuildInfoResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GuildInfo> guildInfo = 0,
    bool needNameChange = false,
    int64_t seasonEndDateTimeUtc = 0) {
  GuildInfoResponseBuilder builder_(_fbb);
  builder_.add_seasonEndDateTimeUtc(seasonEndDateTimeUtc);
  builder_.add_guildInfo(guildInfo);
  builder_.add_needNameChange(needNameChange);
  return builder_.Finish();
}

/// GUILD_FIND_REQUEST
struct GuildFindRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GUILDNAME = 4
  };
  const flatbuffers::String *guildName() const {
    return GetPointer<const flatbuffers::String *>(VT_GUILDNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_GUILDNAME) &&
           verifier.VerifyString(guildName()) &&
           verifier.EndTable();
  }
};

struct GuildFindRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_guildName(flatbuffers::Offset<flatbuffers::String> guildName) {
    fbb_.AddOffset(GuildFindRequest::VT_GUILDNAME, guildName);
  }
  explicit GuildFindRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildFindRequestBuilder &operator=(const GuildFindRequestBuilder &);
  flatbuffers::Offset<GuildFindRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildFindRequest>(end);
    fbb_.Required(o, GuildFindRequest::VT_GUILDNAME);
    return o;
  }
};

inline flatbuffers::Offset<GuildFindRequest> CreateGuildFindRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> guildName = 0) {
  GuildFindRequestBuilder builder_(_fbb);
  builder_.add_guildName(guildName);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildFindRequest> CreateGuildFindRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *guildName = nullptr) {
  return LeanPacket::CreateGuildFindRequest(
      _fbb,
      guildName ? _fbb.CreateString(guildName) : 0);
}

/// GUILD_FIND_RESPONSE
struct GuildFindResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_GUILDINFOS = 6
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  /// 실패면 없음
  const flatbuffers::Vector<flatbuffers::Offset<GuildBasicInfo>> *guildInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GuildBasicInfo>> *>(VT_GUILDINFOS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyOffset(verifier, VT_GUILDINFOS) &&
           verifier.VerifyVector(guildInfos()) &&
           verifier.VerifyVectorOfTables(guildInfos()) &&
           verifier.EndTable();
  }
};

struct GuildFindResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(GuildFindResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  void add_guildInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuildBasicInfo>>> guildInfos) {
    fbb_.AddOffset(GuildFindResponse::VT_GUILDINFOS, guildInfos);
  }
  explicit GuildFindResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildFindResponseBuilder &operator=(const GuildFindResponseBuilder &);
  flatbuffers::Offset<GuildFindResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildFindResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildFindResponse> CreateGuildFindResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuildBasicInfo>>> guildInfos = 0) {
  GuildFindResponseBuilder builder_(_fbb);
  builder_.add_guildInfos(guildInfos);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildFindResponse> CreateGuildFindResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE,
    const std::vector<flatbuffers::Offset<GuildBasicInfo>> *guildInfos = nullptr) {
  return LeanPacket::CreateGuildFindResponse(
      _fbb,
      errorCode,
      guildInfos ? _fbb.CreateVector<flatbuffers::Offset<GuildBasicInfo>>(*guildInfos) : 0);
}

/// GUILD_JOIN_REQ_REQUEST
struct GuildJoinReqRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GUILDID = 4
  };
  int32_t guildId() const {
    return GetField<int32_t>(VT_GUILDID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_GUILDID) &&
           verifier.EndTable();
  }
};

struct GuildJoinReqRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_guildId(int32_t guildId) {
    fbb_.AddElement<int32_t>(GuildJoinReqRequest::VT_GUILDID, guildId, 0);
  }
  explicit GuildJoinReqRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildJoinReqRequestBuilder &operator=(const GuildJoinReqRequestBuilder &);
  flatbuffers::Offset<GuildJoinReqRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildJoinReqRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildJoinReqRequest> CreateGuildJoinReqRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t guildId = 0) {
  GuildJoinReqRequestBuilder builder_(_fbb);
  builder_.add_guildId(guildId);
  return builder_.Finish();
}

/// GUILD_JOIN_REQ_RESPONSE
struct GuildJoinReqResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           verifier.EndTable();
  }
};

struct GuildJoinReqResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(GuildJoinReqResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  explicit GuildJoinReqResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildJoinReqResponseBuilder &operator=(const GuildJoinReqResponseBuilder &);
  flatbuffers::Offset<GuildJoinReqResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildJoinReqResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildJoinReqResponse> CreateGuildJoinReqResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE) {
  GuildJoinReqResponseBuilder builder_(_fbb);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

/// GUILD_APPLICANT_UPDATE_NOTIFY
struct GuildApplicantUpdateNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_JOINREQUESTCOUNT = 4
  };
  int32_t joinRequestCount() const {
    return GetField<int32_t>(VT_JOINREQUESTCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_JOINREQUESTCOUNT) &&
           verifier.EndTable();
  }
};

struct GuildApplicantUpdateNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_joinRequestCount(int32_t joinRequestCount) {
    fbb_.AddElement<int32_t>(GuildApplicantUpdateNotify::VT_JOINREQUESTCOUNT, joinRequestCount, 0);
  }
  explicit GuildApplicantUpdateNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildApplicantUpdateNotifyBuilder &operator=(const GuildApplicantUpdateNotifyBuilder &);
  flatbuffers::Offset<GuildApplicantUpdateNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildApplicantUpdateNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildApplicantUpdateNotify> CreateGuildApplicantUpdateNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t joinRequestCount = 0) {
  GuildApplicantUpdateNotifyBuilder builder_(_fbb);
  builder_.add_joinRequestCount(joinRequestCount);
  return builder_.Finish();
}

/// GUILD_NEW_MEMBER_NOTIFY
struct GuildNewMemberNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MEMBER = 4
  };
  const GuildMemberInfo *member() const {
    return GetPointer<const GuildMemberInfo *>(VT_MEMBER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_MEMBER) &&
           verifier.VerifyTable(member()) &&
           verifier.EndTable();
  }
};

struct GuildNewMemberNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_member(flatbuffers::Offset<GuildMemberInfo> member) {
    fbb_.AddOffset(GuildNewMemberNotify::VT_MEMBER, member);
  }
  explicit GuildNewMemberNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildNewMemberNotifyBuilder &operator=(const GuildNewMemberNotifyBuilder &);
  flatbuffers::Offset<GuildNewMemberNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildNewMemberNotify>(end);
    fbb_.Required(o, GuildNewMemberNotify::VT_MEMBER);
    return o;
  }
};

inline flatbuffers::Offset<GuildNewMemberNotify> CreateGuildNewMemberNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GuildMemberInfo> member = 0) {
  GuildNewMemberNotifyBuilder builder_(_fbb);
  builder_.add_member(member);
  return builder_.Finish();
}

/// GUILD_LEAVE_REQUEST
struct GuildLeaveRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GuildLeaveRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GuildLeaveRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildLeaveRequestBuilder &operator=(const GuildLeaveRequestBuilder &);
  flatbuffers::Offset<GuildLeaveRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildLeaveRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildLeaveRequest> CreateGuildLeaveRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GuildLeaveRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// GUILD_LEAVE_RESPONSE
struct GuildLeaveResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           verifier.EndTable();
  }
};

struct GuildLeaveResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(GuildLeaveResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  explicit GuildLeaveResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildLeaveResponseBuilder &operator=(const GuildLeaveResponseBuilder &);
  flatbuffers::Offset<GuildLeaveResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildLeaveResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildLeaveResponse> CreateGuildLeaveResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE) {
  GuildLeaveResponseBuilder builder_(_fbb);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

/// GUILD_JOIN_NOTIFY
struct GuildJoinNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GUILDID = 4
  };
  int32_t guildId() const {
    return GetField<int32_t>(VT_GUILDID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_GUILDID) &&
           verifier.EndTable();
  }
};

struct GuildJoinNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_guildId(int32_t guildId) {
    fbb_.AddElement<int32_t>(GuildJoinNotify::VT_GUILDID, guildId, 0);
  }
  explicit GuildJoinNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildJoinNotifyBuilder &operator=(const GuildJoinNotifyBuilder &);
  flatbuffers::Offset<GuildJoinNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildJoinNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildJoinNotify> CreateGuildJoinNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t guildId = 0) {
  GuildJoinNotifyBuilder builder_(_fbb);
  builder_.add_guildId(guildId);
  return builder_.Finish();
}

/// GUILD_LEAVE_NOTIFY
struct GuildLeaveNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_REASON = 4,
    VT_JOINAVALIABLETIMEUTC = 6
  };
  GuildLeaveReason reason() const {
    return static_cast<GuildLeaveReason>(GetField<int8_t>(VT_REASON, 0));
  }
  int64_t joinAvaliableTimeUtc() const {
    return GetField<int64_t>(VT_JOINAVALIABLETIMEUTC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_REASON) &&
           VerifyField<int64_t>(verifier, VT_JOINAVALIABLETIMEUTC) &&
           verifier.EndTable();
  }
};

struct GuildLeaveNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_reason(GuildLeaveReason reason) {
    fbb_.AddElement<int8_t>(GuildLeaveNotify::VT_REASON, static_cast<int8_t>(reason), 0);
  }
  void add_joinAvaliableTimeUtc(int64_t joinAvaliableTimeUtc) {
    fbb_.AddElement<int64_t>(GuildLeaveNotify::VT_JOINAVALIABLETIMEUTC, joinAvaliableTimeUtc, 0);
  }
  explicit GuildLeaveNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildLeaveNotifyBuilder &operator=(const GuildLeaveNotifyBuilder &);
  flatbuffers::Offset<GuildLeaveNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildLeaveNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildLeaveNotify> CreateGuildLeaveNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    GuildLeaveReason reason = GuildLeaveReason_GuildLeaveReason_Leave,
    int64_t joinAvaliableTimeUtc = 0) {
  GuildLeaveNotifyBuilder builder_(_fbb);
  builder_.add_joinAvaliableTimeUtc(joinAvaliableTimeUtc);
  builder_.add_reason(reason);
  return builder_.Finish();
}

/// GUILD_LEAVE_MEMBER_NOTIFY
struct GuildLeaveMemberNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCDBID = 4
  };
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           verifier.EndTable();
  }
};

struct GuildLeaveMemberNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(GuildLeaveMemberNotify::VT_PCDBID, pcDbId, 0);
  }
  explicit GuildLeaveMemberNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildLeaveMemberNotifyBuilder &operator=(const GuildLeaveMemberNotifyBuilder &);
  flatbuffers::Offset<GuildLeaveMemberNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildLeaveMemberNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildLeaveMemberNotify> CreateGuildLeaveMemberNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcDbId = 0) {
  GuildLeaveMemberNotifyBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  return builder_.Finish();
}

/// GUILD_MEMBER_LIST_REQUEST
struct GuildMemberListRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PAGE = 4,
    VT_SORTTYPE = 6,
    VT_ASCENDING = 8,
    VT_CLASSTYPES = 10,
    VT_GRADETYPES = 12,
    VT_LOGINSTATUS = 14
  };
  int32_t page() const {
    return GetField<int32_t>(VT_PAGE, 0);
  }
  GuildMemberListSortType sortType() const {
    return static_cast<GuildMemberListSortType>(GetField<int8_t>(VT_SORTTYPE, 0));
  }
  bool ascending() const {
    return GetField<uint8_t>(VT_ASCENDING, 0) != 0;
  }
  /// LeanData::eCommon_Pc_classType 값 목록
  /// 전체일 경우 empty
  const flatbuffers::Vector<int16_t> *classTypes() const {
    return GetPointer<const flatbuffers::Vector<int16_t> *>(VT_CLASSTYPES);
  }
  /// LeanData::eCommon_GuildMemberType 값 목록
  /// 전체일 경우 empty
  const flatbuffers::Vector<int8_t> *gradeTypes() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_GRADETYPES);
  }
  GuildMemberListLoginStatus loginStatus() const {
    return static_cast<GuildMemberListLoginStatus>(GetField<int8_t>(VT_LOGINSTATUS, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PAGE) &&
           VerifyField<int8_t>(verifier, VT_SORTTYPE) &&
           VerifyField<uint8_t>(verifier, VT_ASCENDING) &&
           VerifyOffsetRequired(verifier, VT_CLASSTYPES) &&
           verifier.VerifyVector(classTypes()) &&
           VerifyOffsetRequired(verifier, VT_GRADETYPES) &&
           verifier.VerifyVector(gradeTypes()) &&
           VerifyField<int8_t>(verifier, VT_LOGINSTATUS) &&
           verifier.EndTable();
  }
};

struct GuildMemberListRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_page(int32_t page) {
    fbb_.AddElement<int32_t>(GuildMemberListRequest::VT_PAGE, page, 0);
  }
  void add_sortType(GuildMemberListSortType sortType) {
    fbb_.AddElement<int8_t>(GuildMemberListRequest::VT_SORTTYPE, static_cast<int8_t>(sortType), 0);
  }
  void add_ascending(bool ascending) {
    fbb_.AddElement<uint8_t>(GuildMemberListRequest::VT_ASCENDING, static_cast<uint8_t>(ascending), 0);
  }
  void add_classTypes(flatbuffers::Offset<flatbuffers::Vector<int16_t>> classTypes) {
    fbb_.AddOffset(GuildMemberListRequest::VT_CLASSTYPES, classTypes);
  }
  void add_gradeTypes(flatbuffers::Offset<flatbuffers::Vector<int8_t>> gradeTypes) {
    fbb_.AddOffset(GuildMemberListRequest::VT_GRADETYPES, gradeTypes);
  }
  void add_loginStatus(GuildMemberListLoginStatus loginStatus) {
    fbb_.AddElement<int8_t>(GuildMemberListRequest::VT_LOGINSTATUS, static_cast<int8_t>(loginStatus), 0);
  }
  explicit GuildMemberListRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildMemberListRequestBuilder &operator=(const GuildMemberListRequestBuilder &);
  flatbuffers::Offset<GuildMemberListRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildMemberListRequest>(end);
    fbb_.Required(o, GuildMemberListRequest::VT_CLASSTYPES);
    fbb_.Required(o, GuildMemberListRequest::VT_GRADETYPES);
    return o;
  }
};

inline flatbuffers::Offset<GuildMemberListRequest> CreateGuildMemberListRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t page = 0,
    GuildMemberListSortType sortType = GuildMemberListSortType_GuildMemberListSortType_Grade,
    bool ascending = false,
    flatbuffers::Offset<flatbuffers::Vector<int16_t>> classTypes = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> gradeTypes = 0,
    GuildMemberListLoginStatus loginStatus = GuildMemberListLoginStatus_GuildMemberListLoginStatus_All) {
  GuildMemberListRequestBuilder builder_(_fbb);
  builder_.add_gradeTypes(gradeTypes);
  builder_.add_classTypes(classTypes);
  builder_.add_page(page);
  builder_.add_loginStatus(loginStatus);
  builder_.add_ascending(ascending);
  builder_.add_sortType(sortType);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildMemberListRequest> CreateGuildMemberListRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t page = 0,
    GuildMemberListSortType sortType = GuildMemberListSortType_GuildMemberListSortType_Grade,
    bool ascending = false,
    const std::vector<int16_t> *classTypes = nullptr,
    const std::vector<int8_t> *gradeTypes = nullptr,
    GuildMemberListLoginStatus loginStatus = GuildMemberListLoginStatus_GuildMemberListLoginStatus_All) {
  return LeanPacket::CreateGuildMemberListRequest(
      _fbb,
      page,
      sortType,
      ascending,
      classTypes ? _fbb.CreateVector<int16_t>(*classTypes) : 0,
      gradeTypes ? _fbb.CreateVector<int8_t>(*gradeTypes) : 0,
      loginStatus);
}

/// GUILD_MEMBER_LIST_RESPONSE
struct GuildMemberListResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_MEMBERS = 6,
    VT_PAGE = 8,
    VT_PAGETOTAL = 10
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<GuildMemberInfo>> *members() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GuildMemberInfo>> *>(VT_MEMBERS);
  }
  int32_t page() const {
    return GetField<int32_t>(VT_PAGE, 0);
  }
  int32_t pageTotal() const {
    return GetField<int32_t>(VT_PAGETOTAL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyOffset(verifier, VT_MEMBERS) &&
           verifier.VerifyVector(members()) &&
           verifier.VerifyVectorOfTables(members()) &&
           VerifyField<int32_t>(verifier, VT_PAGE) &&
           VerifyField<int32_t>(verifier, VT_PAGETOTAL) &&
           verifier.EndTable();
  }
};

struct GuildMemberListResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(GuildMemberListResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  void add_members(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuildMemberInfo>>> members) {
    fbb_.AddOffset(GuildMemberListResponse::VT_MEMBERS, members);
  }
  void add_page(int32_t page) {
    fbb_.AddElement<int32_t>(GuildMemberListResponse::VT_PAGE, page, 0);
  }
  void add_pageTotal(int32_t pageTotal) {
    fbb_.AddElement<int32_t>(GuildMemberListResponse::VT_PAGETOTAL, pageTotal, 0);
  }
  explicit GuildMemberListResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildMemberListResponseBuilder &operator=(const GuildMemberListResponseBuilder &);
  flatbuffers::Offset<GuildMemberListResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildMemberListResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildMemberListResponse> CreateGuildMemberListResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuildMemberInfo>>> members = 0,
    int32_t page = 0,
    int32_t pageTotal = 0) {
  GuildMemberListResponseBuilder builder_(_fbb);
  builder_.add_pageTotal(pageTotal);
  builder_.add_page(page);
  builder_.add_members(members);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildMemberListResponse> CreateGuildMemberListResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE,
    const std::vector<flatbuffers::Offset<GuildMemberInfo>> *members = nullptr,
    int32_t page = 0,
    int32_t pageTotal = 0) {
  return LeanPacket::CreateGuildMemberListResponse(
      _fbb,
      errorCode,
      members ? _fbb.CreateVector<flatbuffers::Offset<GuildMemberInfo>>(*members) : 0,
      page,
      pageTotal);
}

/// GUILD_ATTEND_REQUEST
struct GuildAttendRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GuildAttendRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GuildAttendRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildAttendRequestBuilder &operator=(const GuildAttendRequestBuilder &);
  flatbuffers::Offset<GuildAttendRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildAttendRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildAttendRequest> CreateGuildAttendRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GuildAttendRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// GUILD_ATTEND_RESPONSE
struct GuildAttendResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_NEXTATTENDAVALIABLETIMEUTC = 6,
    VT_LEVEL = 8,
    VT_EXP = 10
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  /// 다음 출석 가능 시간
  int64_t nextAttendAvaliableTimeUtc() const {
    return GetField<int64_t>(VT_NEXTATTENDAVALIABLETIMEUTC, 0);
  }
  /// 결과 레벨/경험치
  int16_t level() const {
    return GetField<int16_t>(VT_LEVEL, 0);
  }
  int32_t exp() const {
    return GetField<int32_t>(VT_EXP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int64_t>(verifier, VT_NEXTATTENDAVALIABLETIMEUTC) &&
           VerifyField<int16_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_EXP) &&
           verifier.EndTable();
  }
};

struct GuildAttendResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(GuildAttendResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  void add_nextAttendAvaliableTimeUtc(int64_t nextAttendAvaliableTimeUtc) {
    fbb_.AddElement<int64_t>(GuildAttendResponse::VT_NEXTATTENDAVALIABLETIMEUTC, nextAttendAvaliableTimeUtc, 0);
  }
  void add_level(int16_t level) {
    fbb_.AddElement<int16_t>(GuildAttendResponse::VT_LEVEL, level, 0);
  }
  void add_exp(int32_t exp) {
    fbb_.AddElement<int32_t>(GuildAttendResponse::VT_EXP, exp, 0);
  }
  explicit GuildAttendResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildAttendResponseBuilder &operator=(const GuildAttendResponseBuilder &);
  flatbuffers::Offset<GuildAttendResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildAttendResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildAttendResponse> CreateGuildAttendResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE,
    int64_t nextAttendAvaliableTimeUtc = 0,
    int16_t level = 0,
    int32_t exp = 0) {
  GuildAttendResponseBuilder builder_(_fbb);
  builder_.add_nextAttendAvaliableTimeUtc(nextAttendAvaliableTimeUtc);
  builder_.add_exp(exp);
  builder_.add_errorCode(errorCode);
  builder_.add_level(level);
  return builder_.Finish();
}

/// GUILD_DONATE_REQUEST
struct GuildDonateRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRISM = 4
  };
  int32_t prism() const {
    return GetField<int32_t>(VT_PRISM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PRISM) &&
           verifier.EndTable();
  }
};

struct GuildDonateRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_prism(int32_t prism) {
    fbb_.AddElement<int32_t>(GuildDonateRequest::VT_PRISM, prism, 0);
  }
  explicit GuildDonateRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildDonateRequestBuilder &operator=(const GuildDonateRequestBuilder &);
  flatbuffers::Offset<GuildDonateRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildDonateRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildDonateRequest> CreateGuildDonateRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t prism = 0) {
  GuildDonateRequestBuilder builder_(_fbb);
  builder_.add_prism(prism);
  return builder_.Finish();
}

/// GUILD_DONATE_RESPONSE
struct GuildDonateResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_GAINGUILDCOIN = 6,
    VT_LEVEL = 8,
    VT_EXP = 10
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  /// Pc가 획득한 길드 주화
  int32_t gainGuildCoin() const {
    return GetField<int32_t>(VT_GAINGUILDCOIN, 0);
  }
  /// 결과 레벨/경험치
  int16_t level() const {
    return GetField<int16_t>(VT_LEVEL, 0);
  }
  int32_t exp() const {
    return GetField<int32_t>(VT_EXP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int32_t>(verifier, VT_GAINGUILDCOIN) &&
           VerifyField<int16_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_EXP) &&
           verifier.EndTable();
  }
};

struct GuildDonateResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(GuildDonateResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  void add_gainGuildCoin(int32_t gainGuildCoin) {
    fbb_.AddElement<int32_t>(GuildDonateResponse::VT_GAINGUILDCOIN, gainGuildCoin, 0);
  }
  void add_level(int16_t level) {
    fbb_.AddElement<int16_t>(GuildDonateResponse::VT_LEVEL, level, 0);
  }
  void add_exp(int32_t exp) {
    fbb_.AddElement<int32_t>(GuildDonateResponse::VT_EXP, exp, 0);
  }
  explicit GuildDonateResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildDonateResponseBuilder &operator=(const GuildDonateResponseBuilder &);
  flatbuffers::Offset<GuildDonateResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildDonateResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildDonateResponse> CreateGuildDonateResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE,
    int32_t gainGuildCoin = 0,
    int16_t level = 0,
    int32_t exp = 0) {
  GuildDonateResponseBuilder builder_(_fbb);
  builder_.add_exp(exp);
  builder_.add_gainGuildCoin(gainGuildCoin);
  builder_.add_errorCode(errorCode);
  builder_.add_level(level);
  return builder_.Finish();
}

/// GUILD_RANKING_LIST_REQUEST
struct GuildRankingListRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PAGE = 4,
    VT_SORTTYPE = 6
  };
  /// zero-based
  int32_t page() const {
    return GetField<int32_t>(VT_PAGE, 0);
  }
  GuildRankSortType sortType() const {
    return static_cast<GuildRankSortType>(GetField<int8_t>(VT_SORTTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PAGE) &&
           VerifyField<int8_t>(verifier, VT_SORTTYPE) &&
           verifier.EndTable();
  }
};

struct GuildRankingListRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_page(int32_t page) {
    fbb_.AddElement<int32_t>(GuildRankingListRequest::VT_PAGE, page, 0);
  }
  void add_sortType(GuildRankSortType sortType) {
    fbb_.AddElement<int8_t>(GuildRankingListRequest::VT_SORTTYPE, static_cast<int8_t>(sortType), 0);
  }
  explicit GuildRankingListRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildRankingListRequestBuilder &operator=(const GuildRankingListRequestBuilder &);
  flatbuffers::Offset<GuildRankingListRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildRankingListRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildRankingListRequest> CreateGuildRankingListRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t page = 0,
    GuildRankSortType sortType = GuildRankSortType_GuildRankSortType_Level) {
  GuildRankingListRequestBuilder builder_(_fbb);
  builder_.add_page(page);
  builder_.add_sortType(sortType);
  return builder_.Finish();
}

/// GUILD_RANKING_LIST_RESPONSE
struct GuildRankingListResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_GUILDINFOS = 6,
    VT_PAGE = 8,
    VT_MYGUILDINFO = 10
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<GuildRankingInfo>> *guildInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GuildRankingInfo>> *>(VT_GUILDINFOS);
  }
  int32_t page() const {
    return GetField<int32_t>(VT_PAGE, 0);
  }
  /// 내 길드의 정보
  const GuildRankingInfo *myGuildInfo() const {
    return GetPointer<const GuildRankingInfo *>(VT_MYGUILDINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyOffset(verifier, VT_GUILDINFOS) &&
           verifier.VerifyVector(guildInfos()) &&
           verifier.VerifyVectorOfTables(guildInfos()) &&
           VerifyField<int32_t>(verifier, VT_PAGE) &&
           VerifyOffset(verifier, VT_MYGUILDINFO) &&
           verifier.VerifyTable(myGuildInfo()) &&
           verifier.EndTable();
  }
};

struct GuildRankingListResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(GuildRankingListResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  void add_guildInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuildRankingInfo>>> guildInfos) {
    fbb_.AddOffset(GuildRankingListResponse::VT_GUILDINFOS, guildInfos);
  }
  void add_page(int32_t page) {
    fbb_.AddElement<int32_t>(GuildRankingListResponse::VT_PAGE, page, 0);
  }
  void add_myGuildInfo(flatbuffers::Offset<GuildRankingInfo> myGuildInfo) {
    fbb_.AddOffset(GuildRankingListResponse::VT_MYGUILDINFO, myGuildInfo);
  }
  explicit GuildRankingListResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildRankingListResponseBuilder &operator=(const GuildRankingListResponseBuilder &);
  flatbuffers::Offset<GuildRankingListResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildRankingListResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildRankingListResponse> CreateGuildRankingListResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuildRankingInfo>>> guildInfos = 0,
    int32_t page = 0,
    flatbuffers::Offset<GuildRankingInfo> myGuildInfo = 0) {
  GuildRankingListResponseBuilder builder_(_fbb);
  builder_.add_myGuildInfo(myGuildInfo);
  builder_.add_page(page);
  builder_.add_guildInfos(guildInfos);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildRankingListResponse> CreateGuildRankingListResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE,
    const std::vector<flatbuffers::Offset<GuildRankingInfo>> *guildInfos = nullptr,
    int32_t page = 0,
    flatbuffers::Offset<GuildRankingInfo> myGuildInfo = 0) {
  return LeanPacket::CreateGuildRankingListResponse(
      _fbb,
      errorCode,
      guildInfos ? _fbb.CreateVector<flatbuffers::Offset<GuildRankingInfo>>(*guildInfos) : 0,
      page,
      myGuildInfo);
}

/// GUILD_LIST_REQUEST
struct GuildListRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PAGE = 4,
    VT_SORTTYPE = 6,
    VT_ONLYFREEJOIN = 8,
    VT_ASCENDING = 10
  };
  int32_t page() const {
    return GetField<int32_t>(VT_PAGE, 0);
  }
  GuildListSortType sortType() const {
    return static_cast<GuildListSortType>(GetField<int8_t>(VT_SORTTYPE, 0));
  }
  bool onlyFreeJoin() const {
    return GetField<uint8_t>(VT_ONLYFREEJOIN, 0) != 0;
  }
  bool ascending() const {
    return GetField<uint8_t>(VT_ASCENDING, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PAGE) &&
           VerifyField<int8_t>(verifier, VT_SORTTYPE) &&
           VerifyField<uint8_t>(verifier, VT_ONLYFREEJOIN) &&
           VerifyField<uint8_t>(verifier, VT_ASCENDING) &&
           verifier.EndTable();
  }
};

struct GuildListRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_page(int32_t page) {
    fbb_.AddElement<int32_t>(GuildListRequest::VT_PAGE, page, 0);
  }
  void add_sortType(GuildListSortType sortType) {
    fbb_.AddElement<int8_t>(GuildListRequest::VT_SORTTYPE, static_cast<int8_t>(sortType), 0);
  }
  void add_onlyFreeJoin(bool onlyFreeJoin) {
    fbb_.AddElement<uint8_t>(GuildListRequest::VT_ONLYFREEJOIN, static_cast<uint8_t>(onlyFreeJoin), 0);
  }
  void add_ascending(bool ascending) {
    fbb_.AddElement<uint8_t>(GuildListRequest::VT_ASCENDING, static_cast<uint8_t>(ascending), 0);
  }
  explicit GuildListRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildListRequestBuilder &operator=(const GuildListRequestBuilder &);
  flatbuffers::Offset<GuildListRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildListRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildListRequest> CreateGuildListRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t page = 0,
    GuildListSortType sortType = GuildListSortType_GuildListSortType_Rank,
    bool onlyFreeJoin = false,
    bool ascending = false) {
  GuildListRequestBuilder builder_(_fbb);
  builder_.add_page(page);
  builder_.add_ascending(ascending);
  builder_.add_onlyFreeJoin(onlyFreeJoin);
  builder_.add_sortType(sortType);
  return builder_.Finish();
}

/// GUILD_LIST_RESPONSE
struct GuildListResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_GUILDINFOS = 6,
    VT_PAGE = 8,
    VT_PAGETOTAL = 10
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<GuildBasicInfo>> *guildInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GuildBasicInfo>> *>(VT_GUILDINFOS);
  }
  int32_t page() const {
    return GetField<int32_t>(VT_PAGE, 0);
  }
  int32_t pageTotal() const {
    return GetField<int32_t>(VT_PAGETOTAL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyOffset(verifier, VT_GUILDINFOS) &&
           verifier.VerifyVector(guildInfos()) &&
           verifier.VerifyVectorOfTables(guildInfos()) &&
           VerifyField<int32_t>(verifier, VT_PAGE) &&
           VerifyField<int32_t>(verifier, VT_PAGETOTAL) &&
           verifier.EndTable();
  }
};

struct GuildListResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(GuildListResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  void add_guildInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuildBasicInfo>>> guildInfos) {
    fbb_.AddOffset(GuildListResponse::VT_GUILDINFOS, guildInfos);
  }
  void add_page(int32_t page) {
    fbb_.AddElement<int32_t>(GuildListResponse::VT_PAGE, page, 0);
  }
  void add_pageTotal(int32_t pageTotal) {
    fbb_.AddElement<int32_t>(GuildListResponse::VT_PAGETOTAL, pageTotal, 0);
  }
  explicit GuildListResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildListResponseBuilder &operator=(const GuildListResponseBuilder &);
  flatbuffers::Offset<GuildListResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildListResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildListResponse> CreateGuildListResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuildBasicInfo>>> guildInfos = 0,
    int32_t page = 0,
    int32_t pageTotal = 0) {
  GuildListResponseBuilder builder_(_fbb);
  builder_.add_pageTotal(pageTotal);
  builder_.add_page(page);
  builder_.add_guildInfos(guildInfos);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildListResponse> CreateGuildListResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE,
    const std::vector<flatbuffers::Offset<GuildBasicInfo>> *guildInfos = nullptr,
    int32_t page = 0,
    int32_t pageTotal = 0) {
  return LeanPacket::CreateGuildListResponse(
      _fbb,
      errorCode,
      guildInfos ? _fbb.CreateVector<flatbuffers::Offset<GuildBasicInfo>>(*guildInfos) : 0,
      page,
      pageTotal);
}

/// GUILD_DETAIL_INFO_REQUEST
struct GuildDetailInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GUILDNAME = 4
  };
  const flatbuffers::String *guildName() const {
    return GetPointer<const flatbuffers::String *>(VT_GUILDNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_GUILDNAME) &&
           verifier.VerifyString(guildName()) &&
           verifier.EndTable();
  }
};

struct GuildDetailInfoRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_guildName(flatbuffers::Offset<flatbuffers::String> guildName) {
    fbb_.AddOffset(GuildDetailInfoRequest::VT_GUILDNAME, guildName);
  }
  explicit GuildDetailInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildDetailInfoRequestBuilder &operator=(const GuildDetailInfoRequestBuilder &);
  flatbuffers::Offset<GuildDetailInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildDetailInfoRequest>(end);
    fbb_.Required(o, GuildDetailInfoRequest::VT_GUILDNAME);
    return o;
  }
};

inline flatbuffers::Offset<GuildDetailInfoRequest> CreateGuildDetailInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> guildName = 0) {
  GuildDetailInfoRequestBuilder builder_(_fbb);
  builder_.add_guildName(guildName);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildDetailInfoRequest> CreateGuildDetailInfoRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *guildName = nullptr) {
  return LeanPacket::CreateGuildDetailInfoRequest(
      _fbb,
      guildName ? _fbb.CreateString(guildName) : 0);
}

/// GUILD_DETAIL_INFO_RESPONSE
struct GuildDetailInfoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_DETAILINFO = 6
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  const GuildDetailInfo *detailInfo() const {
    return GetPointer<const GuildDetailInfo *>(VT_DETAILINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyOffset(verifier, VT_DETAILINFO) &&
           verifier.VerifyTable(detailInfo()) &&
           verifier.EndTable();
  }
};

struct GuildDetailInfoResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(GuildDetailInfoResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  void add_detailInfo(flatbuffers::Offset<GuildDetailInfo> detailInfo) {
    fbb_.AddOffset(GuildDetailInfoResponse::VT_DETAILINFO, detailInfo);
  }
  explicit GuildDetailInfoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildDetailInfoResponseBuilder &operator=(const GuildDetailInfoResponseBuilder &);
  flatbuffers::Offset<GuildDetailInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildDetailInfoResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildDetailInfoResponse> CreateGuildDetailInfoResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE,
    flatbuffers::Offset<GuildDetailInfo> detailInfo = 0) {
  GuildDetailInfoResponseBuilder builder_(_fbb);
  builder_.add_detailInfo(detailInfo);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

/// GUILD_MY_JOIN_REQ_LIST_REQUEST
struct GuildMyJoinReqListRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GuildMyJoinReqListRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GuildMyJoinReqListRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildMyJoinReqListRequestBuilder &operator=(const GuildMyJoinReqListRequestBuilder &);
  flatbuffers::Offset<GuildMyJoinReqListRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildMyJoinReqListRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildMyJoinReqListRequest> CreateGuildMyJoinReqListRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GuildMyJoinReqListRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// GUILD_MY_JOIN_REQ_LIST_RESPONSE
struct GuildMyJoinReqListResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_GUILDINFOS = 6
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<GuildBasicInfo>> *guildInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GuildBasicInfo>> *>(VT_GUILDINFOS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyOffset(verifier, VT_GUILDINFOS) &&
           verifier.VerifyVector(guildInfos()) &&
           verifier.VerifyVectorOfTables(guildInfos()) &&
           verifier.EndTable();
  }
};

struct GuildMyJoinReqListResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(GuildMyJoinReqListResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  void add_guildInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuildBasicInfo>>> guildInfos) {
    fbb_.AddOffset(GuildMyJoinReqListResponse::VT_GUILDINFOS, guildInfos);
  }
  explicit GuildMyJoinReqListResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildMyJoinReqListResponseBuilder &operator=(const GuildMyJoinReqListResponseBuilder &);
  flatbuffers::Offset<GuildMyJoinReqListResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildMyJoinReqListResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildMyJoinReqListResponse> CreateGuildMyJoinReqListResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuildBasicInfo>>> guildInfos = 0) {
  GuildMyJoinReqListResponseBuilder builder_(_fbb);
  builder_.add_guildInfos(guildInfos);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildMyJoinReqListResponse> CreateGuildMyJoinReqListResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE,
    const std::vector<flatbuffers::Offset<GuildBasicInfo>> *guildInfos = nullptr) {
  return LeanPacket::CreateGuildMyJoinReqListResponse(
      _fbb,
      errorCode,
      guildInfos ? _fbb.CreateVector<flatbuffers::Offset<GuildBasicInfo>>(*guildInfos) : 0);
}

/// GUILD_REMOVE_JOIN_REQ_REQUEST
struct GuildRemoveJoinReqRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GUILDIDS = 4
  };
  const flatbuffers::Vector<int32_t> *guildIds() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_GUILDIDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_GUILDIDS) &&
           verifier.VerifyVector(guildIds()) &&
           verifier.EndTable();
  }
};

struct GuildRemoveJoinReqRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_guildIds(flatbuffers::Offset<flatbuffers::Vector<int32_t>> guildIds) {
    fbb_.AddOffset(GuildRemoveJoinReqRequest::VT_GUILDIDS, guildIds);
  }
  explicit GuildRemoveJoinReqRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildRemoveJoinReqRequestBuilder &operator=(const GuildRemoveJoinReqRequestBuilder &);
  flatbuffers::Offset<GuildRemoveJoinReqRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildRemoveJoinReqRequest>(end);
    fbb_.Required(o, GuildRemoveJoinReqRequest::VT_GUILDIDS);
    return o;
  }
};

inline flatbuffers::Offset<GuildRemoveJoinReqRequest> CreateGuildRemoveJoinReqRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> guildIds = 0) {
  GuildRemoveJoinReqRequestBuilder builder_(_fbb);
  builder_.add_guildIds(guildIds);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildRemoveJoinReqRequest> CreateGuildRemoveJoinReqRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *guildIds = nullptr) {
  return LeanPacket::CreateGuildRemoveJoinReqRequest(
      _fbb,
      guildIds ? _fbb.CreateVector<int32_t>(*guildIds) : 0);
}

/// GUILD_REMOVE_JOIN_REQ_RESPONSE
struct GuildRemoveJoinReqResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           verifier.EndTable();
  }
};

struct GuildRemoveJoinReqResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(GuildRemoveJoinReqResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  explicit GuildRemoveJoinReqResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildRemoveJoinReqResponseBuilder &operator=(const GuildRemoveJoinReqResponseBuilder &);
  flatbuffers::Offset<GuildRemoveJoinReqResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildRemoveJoinReqResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildRemoveJoinReqResponse> CreateGuildRemoveJoinReqResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE) {
  GuildRemoveJoinReqResponseBuilder builder_(_fbb);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

/// GUILD_JOIN_REQ_LIST_REQUEST
struct GuildJoinReqListRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PAGE = 4,
    VT_SORTTYPE = 6,
    VT_ASCENDING = 8,
    VT_CLASSTYPES = 10,
    VT_LOGINSTATUS = 12
  };
  int32_t page() const {
    return GetField<int32_t>(VT_PAGE, 0);
  }
  GuildMemberListSortType sortType() const {
    return static_cast<GuildMemberListSortType>(GetField<int8_t>(VT_SORTTYPE, 0));
  }
  bool ascending() const {
    return GetField<uint8_t>(VT_ASCENDING, 0) != 0;
  }
  /// LeanData::eCommon_Pc_classType 값 목록
  /// 전체일 경우 empty
  const flatbuffers::Vector<int16_t> *classTypes() const {
    return GetPointer<const flatbuffers::Vector<int16_t> *>(VT_CLASSTYPES);
  }
  GuildMemberListLoginStatus loginStatus() const {
    return static_cast<GuildMemberListLoginStatus>(GetField<int8_t>(VT_LOGINSTATUS, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PAGE) &&
           VerifyField<int8_t>(verifier, VT_SORTTYPE) &&
           VerifyField<uint8_t>(verifier, VT_ASCENDING) &&
           VerifyOffsetRequired(verifier, VT_CLASSTYPES) &&
           verifier.VerifyVector(classTypes()) &&
           VerifyField<int8_t>(verifier, VT_LOGINSTATUS) &&
           verifier.EndTable();
  }
};

struct GuildJoinReqListRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_page(int32_t page) {
    fbb_.AddElement<int32_t>(GuildJoinReqListRequest::VT_PAGE, page, 0);
  }
  void add_sortType(GuildMemberListSortType sortType) {
    fbb_.AddElement<int8_t>(GuildJoinReqListRequest::VT_SORTTYPE, static_cast<int8_t>(sortType), 0);
  }
  void add_ascending(bool ascending) {
    fbb_.AddElement<uint8_t>(GuildJoinReqListRequest::VT_ASCENDING, static_cast<uint8_t>(ascending), 0);
  }
  void add_classTypes(flatbuffers::Offset<flatbuffers::Vector<int16_t>> classTypes) {
    fbb_.AddOffset(GuildJoinReqListRequest::VT_CLASSTYPES, classTypes);
  }
  void add_loginStatus(GuildMemberListLoginStatus loginStatus) {
    fbb_.AddElement<int8_t>(GuildJoinReqListRequest::VT_LOGINSTATUS, static_cast<int8_t>(loginStatus), 0);
  }
  explicit GuildJoinReqListRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildJoinReqListRequestBuilder &operator=(const GuildJoinReqListRequestBuilder &);
  flatbuffers::Offset<GuildJoinReqListRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildJoinReqListRequest>(end);
    fbb_.Required(o, GuildJoinReqListRequest::VT_CLASSTYPES);
    return o;
  }
};

inline flatbuffers::Offset<GuildJoinReqListRequest> CreateGuildJoinReqListRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t page = 0,
    GuildMemberListSortType sortType = GuildMemberListSortType_GuildMemberListSortType_Grade,
    bool ascending = false,
    flatbuffers::Offset<flatbuffers::Vector<int16_t>> classTypes = 0,
    GuildMemberListLoginStatus loginStatus = GuildMemberListLoginStatus_GuildMemberListLoginStatus_All) {
  GuildJoinReqListRequestBuilder builder_(_fbb);
  builder_.add_classTypes(classTypes);
  builder_.add_page(page);
  builder_.add_loginStatus(loginStatus);
  builder_.add_ascending(ascending);
  builder_.add_sortType(sortType);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildJoinReqListRequest> CreateGuildJoinReqListRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t page = 0,
    GuildMemberListSortType sortType = GuildMemberListSortType_GuildMemberListSortType_Grade,
    bool ascending = false,
    const std::vector<int16_t> *classTypes = nullptr,
    GuildMemberListLoginStatus loginStatus = GuildMemberListLoginStatus_GuildMemberListLoginStatus_All) {
  return LeanPacket::CreateGuildJoinReqListRequest(
      _fbb,
      page,
      sortType,
      ascending,
      classTypes ? _fbb.CreateVector<int16_t>(*classTypes) : 0,
      loginStatus);
}

/// GUILD_JOIN_REQ_LIST_RESPONSE
struct GuildJoinReqListResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_INFOS = 6,
    VT_PAGE = 8,
    VT_PAGETOTAL = 10
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<GuildJoinRequestInfo>> *infos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GuildJoinRequestInfo>> *>(VT_INFOS);
  }
  int32_t page() const {
    return GetField<int32_t>(VT_PAGE, 0);
  }
  int32_t pageTotal() const {
    return GetField<int32_t>(VT_PAGETOTAL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyOffset(verifier, VT_INFOS) &&
           verifier.VerifyVector(infos()) &&
           verifier.VerifyVectorOfTables(infos()) &&
           VerifyField<int32_t>(verifier, VT_PAGE) &&
           VerifyField<int32_t>(verifier, VT_PAGETOTAL) &&
           verifier.EndTable();
  }
};

struct GuildJoinReqListResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(GuildJoinReqListResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  void add_infos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuildJoinRequestInfo>>> infos) {
    fbb_.AddOffset(GuildJoinReqListResponse::VT_INFOS, infos);
  }
  void add_page(int32_t page) {
    fbb_.AddElement<int32_t>(GuildJoinReqListResponse::VT_PAGE, page, 0);
  }
  void add_pageTotal(int32_t pageTotal) {
    fbb_.AddElement<int32_t>(GuildJoinReqListResponse::VT_PAGETOTAL, pageTotal, 0);
  }
  explicit GuildJoinReqListResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildJoinReqListResponseBuilder &operator=(const GuildJoinReqListResponseBuilder &);
  flatbuffers::Offset<GuildJoinReqListResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildJoinReqListResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildJoinReqListResponse> CreateGuildJoinReqListResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuildJoinRequestInfo>>> infos = 0,
    int32_t page = 0,
    int32_t pageTotal = 0) {
  GuildJoinReqListResponseBuilder builder_(_fbb);
  builder_.add_pageTotal(pageTotal);
  builder_.add_page(page);
  builder_.add_infos(infos);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildJoinReqListResponse> CreateGuildJoinReqListResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE,
    const std::vector<flatbuffers::Offset<GuildJoinRequestInfo>> *infos = nullptr,
    int32_t page = 0,
    int32_t pageTotal = 0) {
  return LeanPacket::CreateGuildJoinReqListResponse(
      _fbb,
      errorCode,
      infos ? _fbb.CreateVector<flatbuffers::Offset<GuildJoinRequestInfo>>(*infos) : 0,
      page,
      pageTotal);
}

/// GUILD_ACCEPT_JOIN_REQ_REQUEST
struct GuildAcceptJoinReqRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCDBIDS = 4
  };
  const flatbuffers::Vector<int64_t> *pcDbIds() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PCDBIDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PCDBIDS) &&
           verifier.VerifyVector(pcDbIds()) &&
           verifier.EndTable();
  }
};

struct GuildAcceptJoinReqRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcDbIds(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pcDbIds) {
    fbb_.AddOffset(GuildAcceptJoinReqRequest::VT_PCDBIDS, pcDbIds);
  }
  explicit GuildAcceptJoinReqRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildAcceptJoinReqRequestBuilder &operator=(const GuildAcceptJoinReqRequestBuilder &);
  flatbuffers::Offset<GuildAcceptJoinReqRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildAcceptJoinReqRequest>(end);
    fbb_.Required(o, GuildAcceptJoinReqRequest::VT_PCDBIDS);
    return o;
  }
};

inline flatbuffers::Offset<GuildAcceptJoinReqRequest> CreateGuildAcceptJoinReqRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pcDbIds = 0) {
  GuildAcceptJoinReqRequestBuilder builder_(_fbb);
  builder_.add_pcDbIds(pcDbIds);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildAcceptJoinReqRequest> CreateGuildAcceptJoinReqRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *pcDbIds = nullptr) {
  return LeanPacket::CreateGuildAcceptJoinReqRequest(
      _fbb,
      pcDbIds ? _fbb.CreateVector<int64_t>(*pcDbIds) : 0);
}

/// GUILD_ACCEPT_JOIN_REQ_RESPONSE,
struct GuildAcceptJoinReqResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           verifier.EndTable();
  }
};

struct GuildAcceptJoinReqResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(GuildAcceptJoinReqResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  explicit GuildAcceptJoinReqResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildAcceptJoinReqResponseBuilder &operator=(const GuildAcceptJoinReqResponseBuilder &);
  flatbuffers::Offset<GuildAcceptJoinReqResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildAcceptJoinReqResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildAcceptJoinReqResponse> CreateGuildAcceptJoinReqResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE) {
  GuildAcceptJoinReqResponseBuilder builder_(_fbb);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

/// GUILD_REJECT_JOIN_REQ_REQUEST
struct GuildRejectJoinReqRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCDBIDS = 4
  };
  const flatbuffers::Vector<int64_t> *pcDbIds() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PCDBIDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PCDBIDS) &&
           verifier.VerifyVector(pcDbIds()) &&
           verifier.EndTable();
  }
};

struct GuildRejectJoinReqRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcDbIds(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pcDbIds) {
    fbb_.AddOffset(GuildRejectJoinReqRequest::VT_PCDBIDS, pcDbIds);
  }
  explicit GuildRejectJoinReqRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildRejectJoinReqRequestBuilder &operator=(const GuildRejectJoinReqRequestBuilder &);
  flatbuffers::Offset<GuildRejectJoinReqRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildRejectJoinReqRequest>(end);
    fbb_.Required(o, GuildRejectJoinReqRequest::VT_PCDBIDS);
    return o;
  }
};

inline flatbuffers::Offset<GuildRejectJoinReqRequest> CreateGuildRejectJoinReqRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pcDbIds = 0) {
  GuildRejectJoinReqRequestBuilder builder_(_fbb);
  builder_.add_pcDbIds(pcDbIds);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildRejectJoinReqRequest> CreateGuildRejectJoinReqRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *pcDbIds = nullptr) {
  return LeanPacket::CreateGuildRejectJoinReqRequest(
      _fbb,
      pcDbIds ? _fbb.CreateVector<int64_t>(*pcDbIds) : 0);
}

/// GUILD_REJECT_JOIN_REQ_RESPONSE,
struct GuildRejectJoinReqResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           verifier.EndTable();
  }
};

struct GuildRejectJoinReqResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(GuildRejectJoinReqResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  explicit GuildRejectJoinReqResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildRejectJoinReqResponseBuilder &operator=(const GuildRejectJoinReqResponseBuilder &);
  flatbuffers::Offset<GuildRejectJoinReqResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildRejectJoinReqResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildRejectJoinReqResponse> CreateGuildRejectJoinReqResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE) {
  GuildRejectJoinReqResponseBuilder builder_(_fbb);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

/// GUILD_CHANGE_JOIN_CONDITION_REQUEST
struct GuildChangeJoinConditionRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_JOINTYPE = 4,
    VT_JOINLIMITLEVEL = 6
  };
  /// 둘 중 하나만 바꾼다면 다른 하나는 기존값 그대로 줄 것
  /// LeanData::eGuild_joinType
  int8_t joinType() const {
    return GetField<int8_t>(VT_JOINTYPE, 0);
  }
  int16_t joinLimitLevel() const {
    return GetField<int16_t>(VT_JOINLIMITLEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_JOINTYPE) &&
           VerifyField<int16_t>(verifier, VT_JOINLIMITLEVEL) &&
           verifier.EndTable();
  }
};

struct GuildChangeJoinConditionRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_joinType(int8_t joinType) {
    fbb_.AddElement<int8_t>(GuildChangeJoinConditionRequest::VT_JOINTYPE, joinType, 0);
  }
  void add_joinLimitLevel(int16_t joinLimitLevel) {
    fbb_.AddElement<int16_t>(GuildChangeJoinConditionRequest::VT_JOINLIMITLEVEL, joinLimitLevel, 0);
  }
  explicit GuildChangeJoinConditionRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildChangeJoinConditionRequestBuilder &operator=(const GuildChangeJoinConditionRequestBuilder &);
  flatbuffers::Offset<GuildChangeJoinConditionRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildChangeJoinConditionRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildChangeJoinConditionRequest> CreateGuildChangeJoinConditionRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t joinType = 0,
    int16_t joinLimitLevel = 0) {
  GuildChangeJoinConditionRequestBuilder builder_(_fbb);
  builder_.add_joinLimitLevel(joinLimitLevel);
  builder_.add_joinType(joinType);
  return builder_.Finish();
}

/// GUILD_CHANGE_JOIN_CONDITION_RESPONSE
struct GuildChangeJoinConditionResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           verifier.EndTable();
  }
};

struct GuildChangeJoinConditionResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(GuildChangeJoinConditionResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  explicit GuildChangeJoinConditionResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildChangeJoinConditionResponseBuilder &operator=(const GuildChangeJoinConditionResponseBuilder &);
  flatbuffers::Offset<GuildChangeJoinConditionResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildChangeJoinConditionResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildChangeJoinConditionResponse> CreateGuildChangeJoinConditionResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE) {
  GuildChangeJoinConditionResponseBuilder builder_(_fbb);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

/// GUILD_CHANGE_MSG_REQUEST
struct GuildChangeMsgRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_MSG = 6
  };
  GuildMsgType type() const {
    return static_cast<GuildMsgType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::String *msg() const {
    return GetPointer<const flatbuffers::String *>(VT_MSG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyOffsetRequired(verifier, VT_MSG) &&
           verifier.VerifyString(msg()) &&
           verifier.EndTable();
  }
};

struct GuildChangeMsgRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(GuildMsgType type) {
    fbb_.AddElement<int8_t>(GuildChangeMsgRequest::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_msg(flatbuffers::Offset<flatbuffers::String> msg) {
    fbb_.AddOffset(GuildChangeMsgRequest::VT_MSG, msg);
  }
  explicit GuildChangeMsgRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildChangeMsgRequestBuilder &operator=(const GuildChangeMsgRequestBuilder &);
  flatbuffers::Offset<GuildChangeMsgRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildChangeMsgRequest>(end);
    fbb_.Required(o, GuildChangeMsgRequest::VT_MSG);
    return o;
  }
};

inline flatbuffers::Offset<GuildChangeMsgRequest> CreateGuildChangeMsgRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    GuildMsgType type = GuildMsgType_GuildMsgType_Intro,
    flatbuffers::Offset<flatbuffers::String> msg = 0) {
  GuildChangeMsgRequestBuilder builder_(_fbb);
  builder_.add_msg(msg);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildChangeMsgRequest> CreateGuildChangeMsgRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    GuildMsgType type = GuildMsgType_GuildMsgType_Intro,
    const char *msg = nullptr) {
  return LeanPacket::CreateGuildChangeMsgRequest(
      _fbb,
      type,
      msg ? _fbb.CreateString(msg) : 0);
}

/// GUILD_CHANGE_MSG_RESPONSE
struct GuildChangeMsgResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_TYPE = 6
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  GuildMsgType type() const {
    return static_cast<GuildMsgType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct GuildChangeMsgResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(GuildChangeMsgResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  void add_type(GuildMsgType type) {
    fbb_.AddElement<int8_t>(GuildChangeMsgResponse::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  explicit GuildChangeMsgResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildChangeMsgResponseBuilder &operator=(const GuildChangeMsgResponseBuilder &);
  flatbuffers::Offset<GuildChangeMsgResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildChangeMsgResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildChangeMsgResponse> CreateGuildChangeMsgResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE,
    GuildMsgType type = GuildMsgType_GuildMsgType_Intro) {
  GuildChangeMsgResponseBuilder builder_(_fbb);
  builder_.add_errorCode(errorCode);
  builder_.add_type(type);
  return builder_.Finish();
}

/// GUILD_KICK_MEMBER_REQUEST
struct GuildKickMemberRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCDBIDS = 4
  };
  const flatbuffers::Vector<int64_t> *pcDbIds() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PCDBIDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PCDBIDS) &&
           verifier.VerifyVector(pcDbIds()) &&
           verifier.EndTable();
  }
};

struct GuildKickMemberRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcDbIds(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pcDbIds) {
    fbb_.AddOffset(GuildKickMemberRequest::VT_PCDBIDS, pcDbIds);
  }
  explicit GuildKickMemberRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildKickMemberRequestBuilder &operator=(const GuildKickMemberRequestBuilder &);
  flatbuffers::Offset<GuildKickMemberRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildKickMemberRequest>(end);
    fbb_.Required(o, GuildKickMemberRequest::VT_PCDBIDS);
    return o;
  }
};

inline flatbuffers::Offset<GuildKickMemberRequest> CreateGuildKickMemberRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pcDbIds = 0) {
  GuildKickMemberRequestBuilder builder_(_fbb);
  builder_.add_pcDbIds(pcDbIds);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildKickMemberRequest> CreateGuildKickMemberRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *pcDbIds = nullptr) {
  return LeanPacket::CreateGuildKickMemberRequest(
      _fbb,
      pcDbIds ? _fbb.CreateVector<int64_t>(*pcDbIds) : 0);
}

/// GUILD_KICK_MEMBER_RESPONSE
struct GuildKickMemberResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           verifier.EndTable();
  }
};

struct GuildKickMemberResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(GuildKickMemberResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  explicit GuildKickMemberResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildKickMemberResponseBuilder &operator=(const GuildKickMemberResponseBuilder &);
  flatbuffers::Offset<GuildKickMemberResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildKickMemberResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildKickMemberResponse> CreateGuildKickMemberResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE) {
  GuildKickMemberResponseBuilder builder_(_fbb);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

/// GUILD_LEVEL_UP_NOTIFY
struct GuildLevelUpNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LEVEL = 4,
    VT_EXP = 6
  };
  int16_t level() const {
    return GetField<int16_t>(VT_LEVEL, 0);
  }
  int32_t exp() const {
    return GetField<int32_t>(VT_EXP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_EXP) &&
           verifier.EndTable();
  }
};

struct GuildLevelUpNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_level(int16_t level) {
    fbb_.AddElement<int16_t>(GuildLevelUpNotify::VT_LEVEL, level, 0);
  }
  void add_exp(int32_t exp) {
    fbb_.AddElement<int32_t>(GuildLevelUpNotify::VT_EXP, exp, 0);
  }
  explicit GuildLevelUpNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildLevelUpNotifyBuilder &operator=(const GuildLevelUpNotifyBuilder &);
  flatbuffers::Offset<GuildLevelUpNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildLevelUpNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildLevelUpNotify> CreateGuildLevelUpNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t level = 0,
    int32_t exp = 0) {
  GuildLevelUpNotifyBuilder builder_(_fbb);
  builder_.add_exp(exp);
  builder_.add_level(level);
  return builder_.Finish();
}

/// GUILD_CHANGE_MEMBER_GRADE_REQUEST
struct GuildChangeMemberGradeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCDBIDS = 4,
    VT_GRADE = 6
  };
  const flatbuffers::Vector<int64_t> *pcDbIds() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PCDBIDS);
  }
  int8_t grade() const {
    return GetField<int8_t>(VT_GRADE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PCDBIDS) &&
           verifier.VerifyVector(pcDbIds()) &&
           VerifyField<int8_t>(verifier, VT_GRADE) &&
           verifier.EndTable();
  }
};

struct GuildChangeMemberGradeRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcDbIds(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pcDbIds) {
    fbb_.AddOffset(GuildChangeMemberGradeRequest::VT_PCDBIDS, pcDbIds);
  }
  void add_grade(int8_t grade) {
    fbb_.AddElement<int8_t>(GuildChangeMemberGradeRequest::VT_GRADE, grade, 0);
  }
  explicit GuildChangeMemberGradeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildChangeMemberGradeRequestBuilder &operator=(const GuildChangeMemberGradeRequestBuilder &);
  flatbuffers::Offset<GuildChangeMemberGradeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildChangeMemberGradeRequest>(end);
    fbb_.Required(o, GuildChangeMemberGradeRequest::VT_PCDBIDS);
    return o;
  }
};

inline flatbuffers::Offset<GuildChangeMemberGradeRequest> CreateGuildChangeMemberGradeRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pcDbIds = 0,
    int8_t grade = 0) {
  GuildChangeMemberGradeRequestBuilder builder_(_fbb);
  builder_.add_pcDbIds(pcDbIds);
  builder_.add_grade(grade);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildChangeMemberGradeRequest> CreateGuildChangeMemberGradeRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *pcDbIds = nullptr,
    int8_t grade = 0) {
  return LeanPacket::CreateGuildChangeMemberGradeRequest(
      _fbb,
      pcDbIds ? _fbb.CreateVector<int64_t>(*pcDbIds) : 0,
      grade);
}

/// GUILD_CHANGE_MEMBER_GRADE_RESPONSE
struct GuildChangeMemberGradeResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_CHANGEDPCDBID = 6
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  const flatbuffers::Vector<int64_t> *changedPcDbId() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_CHANGEDPCDBID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyOffset(verifier, VT_CHANGEDPCDBID) &&
           verifier.VerifyVector(changedPcDbId()) &&
           verifier.EndTable();
  }
};

struct GuildChangeMemberGradeResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(GuildChangeMemberGradeResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  void add_changedPcDbId(flatbuffers::Offset<flatbuffers::Vector<int64_t>> changedPcDbId) {
    fbb_.AddOffset(GuildChangeMemberGradeResponse::VT_CHANGEDPCDBID, changedPcDbId);
  }
  explicit GuildChangeMemberGradeResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildChangeMemberGradeResponseBuilder &operator=(const GuildChangeMemberGradeResponseBuilder &);
  flatbuffers::Offset<GuildChangeMemberGradeResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildChangeMemberGradeResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildChangeMemberGradeResponse> CreateGuildChangeMemberGradeResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> changedPcDbId = 0) {
  GuildChangeMemberGradeResponseBuilder builder_(_fbb);
  builder_.add_changedPcDbId(changedPcDbId);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildChangeMemberGradeResponse> CreateGuildChangeMemberGradeResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE,
    const std::vector<int64_t> *changedPcDbId = nullptr) {
  return LeanPacket::CreateGuildChangeMemberGradeResponse(
      _fbb,
      errorCode,
      changedPcDbId ? _fbb.CreateVector<int64_t>(*changedPcDbId) : 0);
}

/// GUILD_CHANGE_MEMBER_GRADE_NOTIFY
struct GuildChangeMemberGradeNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PREVGRADE = 4,
    VT_NEWGRADE = 6
  };
  int8_t prevGrade() const {
    return GetField<int8_t>(VT_PREVGRADE, 0);
  }
  int8_t newGrade() const {
    return GetField<int8_t>(VT_NEWGRADE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PREVGRADE) &&
           VerifyField<int8_t>(verifier, VT_NEWGRADE) &&
           verifier.EndTable();
  }
};

struct GuildChangeMemberGradeNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_prevGrade(int8_t prevGrade) {
    fbb_.AddElement<int8_t>(GuildChangeMemberGradeNotify::VT_PREVGRADE, prevGrade, 0);
  }
  void add_newGrade(int8_t newGrade) {
    fbb_.AddElement<int8_t>(GuildChangeMemberGradeNotify::VT_NEWGRADE, newGrade, 0);
  }
  explicit GuildChangeMemberGradeNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildChangeMemberGradeNotifyBuilder &operator=(const GuildChangeMemberGradeNotifyBuilder &);
  flatbuffers::Offset<GuildChangeMemberGradeNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildChangeMemberGradeNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildChangeMemberGradeNotify> CreateGuildChangeMemberGradeNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t prevGrade = 0,
    int8_t newGrade = 0) {
  GuildChangeMemberGradeNotifyBuilder builder_(_fbb);
  builder_.add_newGrade(newGrade);
  builder_.add_prevGrade(prevGrade);
  return builder_.Finish();
}

/// GUILD_HISTORY_REQUEST
struct GuildHistoryRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CATEGORY = 4,
    VT_PAGE = 6
  };
  /// LeanData::eGuild_historyType
  int16_t category() const {
    return GetField<int16_t>(VT_CATEGORY, 0);
  }
  /// zero-based
  int16_t page() const {
    return GetField<int16_t>(VT_PAGE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_CATEGORY) &&
           VerifyField<int16_t>(verifier, VT_PAGE) &&
           verifier.EndTable();
  }
};

struct GuildHistoryRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_category(int16_t category) {
    fbb_.AddElement<int16_t>(GuildHistoryRequest::VT_CATEGORY, category, 0);
  }
  void add_page(int16_t page) {
    fbb_.AddElement<int16_t>(GuildHistoryRequest::VT_PAGE, page, 0);
  }
  explicit GuildHistoryRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildHistoryRequestBuilder &operator=(const GuildHistoryRequestBuilder &);
  flatbuffers::Offset<GuildHistoryRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildHistoryRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildHistoryRequest> CreateGuildHistoryRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t category = 0,
    int16_t page = 0) {
  GuildHistoryRequestBuilder builder_(_fbb);
  builder_.add_page(page);
  builder_.add_category(category);
  return builder_.Finish();
}

struct GuildHistoryItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_CREATETIME = 6,
    VT_STR1 = 8,
    VT_STR2 = 10,
    VT_INT1 = 12,
    VT_INT2 = 14,
    VT_INT3 = 16
  };
  /// LeanData::eGuild_historyContents
  int16_t type() const {
    return GetField<int16_t>(VT_TYPE, 0);
  }
  /// UTC
  int64_t createTime() const {
    return GetField<int64_t>(VT_CREATETIME, 0);
  }
  const flatbuffers::String *str1() const {
    return GetPointer<const flatbuffers::String *>(VT_STR1);
  }
  const flatbuffers::String *str2() const {
    return GetPointer<const flatbuffers::String *>(VT_STR2);
  }
  int32_t int1() const {
    return GetField<int32_t>(VT_INT1, 0);
  }
  int32_t int2() const {
    return GetField<int32_t>(VT_INT2, 0);
  }
  int32_t int3() const {
    return GetField<int32_t>(VT_INT3, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPE) &&
           VerifyField<int64_t>(verifier, VT_CREATETIME) &&
           VerifyOffset(verifier, VT_STR1) &&
           verifier.VerifyString(str1()) &&
           VerifyOffset(verifier, VT_STR2) &&
           verifier.VerifyString(str2()) &&
           VerifyField<int32_t>(verifier, VT_INT1) &&
           VerifyField<int32_t>(verifier, VT_INT2) &&
           VerifyField<int32_t>(verifier, VT_INT3) &&
           verifier.EndTable();
  }
};

struct GuildHistoryItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int16_t type) {
    fbb_.AddElement<int16_t>(GuildHistoryItem::VT_TYPE, type, 0);
  }
  void add_createTime(int64_t createTime) {
    fbb_.AddElement<int64_t>(GuildHistoryItem::VT_CREATETIME, createTime, 0);
  }
  void add_str1(flatbuffers::Offset<flatbuffers::String> str1) {
    fbb_.AddOffset(GuildHistoryItem::VT_STR1, str1);
  }
  void add_str2(flatbuffers::Offset<flatbuffers::String> str2) {
    fbb_.AddOffset(GuildHistoryItem::VT_STR2, str2);
  }
  void add_int1(int32_t int1) {
    fbb_.AddElement<int32_t>(GuildHistoryItem::VT_INT1, int1, 0);
  }
  void add_int2(int32_t int2) {
    fbb_.AddElement<int32_t>(GuildHistoryItem::VT_INT2, int2, 0);
  }
  void add_int3(int32_t int3) {
    fbb_.AddElement<int32_t>(GuildHistoryItem::VT_INT3, int3, 0);
  }
  explicit GuildHistoryItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildHistoryItemBuilder &operator=(const GuildHistoryItemBuilder &);
  flatbuffers::Offset<GuildHistoryItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildHistoryItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildHistoryItem> CreateGuildHistoryItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t type = 0,
    int64_t createTime = 0,
    flatbuffers::Offset<flatbuffers::String> str1 = 0,
    flatbuffers::Offset<flatbuffers::String> str2 = 0,
    int32_t int1 = 0,
    int32_t int2 = 0,
    int32_t int3 = 0) {
  GuildHistoryItemBuilder builder_(_fbb);
  builder_.add_createTime(createTime);
  builder_.add_int3(int3);
  builder_.add_int2(int2);
  builder_.add_int1(int1);
  builder_.add_str2(str2);
  builder_.add_str1(str1);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildHistoryItem> CreateGuildHistoryItemDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t type = 0,
    int64_t createTime = 0,
    const char *str1 = nullptr,
    const char *str2 = nullptr,
    int32_t int1 = 0,
    int32_t int2 = 0,
    int32_t int3 = 0) {
  return LeanPacket::CreateGuildHistoryItem(
      _fbb,
      type,
      createTime,
      str1 ? _fbb.CreateString(str1) : 0,
      str2 ? _fbb.CreateString(str2) : 0,
      int1,
      int2,
      int3);
}

/// GUILD_HISTORY_RESPONSE
struct GuildHistoryResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMS = 4,
    VT_PAGE = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<GuildHistoryItem>> *items() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GuildHistoryItem>> *>(VT_ITEMS);
  }
  /// zero-based
  int32_t page() const {
    return GetField<int32_t>(VT_PAGE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.VerifyVectorOfTables(items()) &&
           VerifyField<int32_t>(verifier, VT_PAGE) &&
           verifier.EndTable();
  }
};

struct GuildHistoryResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuildHistoryItem>>> items) {
    fbb_.AddOffset(GuildHistoryResponse::VT_ITEMS, items);
  }
  void add_page(int32_t page) {
    fbb_.AddElement<int32_t>(GuildHistoryResponse::VT_PAGE, page, 0);
  }
  explicit GuildHistoryResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildHistoryResponseBuilder &operator=(const GuildHistoryResponseBuilder &);
  flatbuffers::Offset<GuildHistoryResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildHistoryResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildHistoryResponse> CreateGuildHistoryResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuildHistoryItem>>> items = 0,
    int32_t page = 0) {
  GuildHistoryResponseBuilder builder_(_fbb);
  builder_.add_page(page);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildHistoryResponse> CreateGuildHistoryResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<GuildHistoryItem>> *items = nullptr,
    int32_t page = 0) {
  return LeanPacket::CreateGuildHistoryResponse(
      _fbb,
      items ? _fbb.CreateVector<flatbuffers::Offset<GuildHistoryItem>>(*items) : 0,
      page);
}

/// GUILD_BUFF_PURCHASE_REQUEST
struct GuildBuffPurchaseRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BUFFID = 4
  };
  int32_t buffId() const {
    return GetField<int32_t>(VT_BUFFID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BUFFID) &&
           verifier.EndTable();
  }
};

struct GuildBuffPurchaseRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_buffId(int32_t buffId) {
    fbb_.AddElement<int32_t>(GuildBuffPurchaseRequest::VT_BUFFID, buffId, 0);
  }
  explicit GuildBuffPurchaseRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildBuffPurchaseRequestBuilder &operator=(const GuildBuffPurchaseRequestBuilder &);
  flatbuffers::Offset<GuildBuffPurchaseRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildBuffPurchaseRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildBuffPurchaseRequest> CreateGuildBuffPurchaseRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t buffId = 0) {
  GuildBuffPurchaseRequestBuilder builder_(_fbb);
  builder_.add_buffId(buffId);
  return builder_.Finish();
}

/// GUILD_BUFF_PURCHASE_RESPONSE
struct GuildBuffPurchaseResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           verifier.EndTable();
  }
};

struct GuildBuffPurchaseResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(GuildBuffPurchaseResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  explicit GuildBuffPurchaseResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildBuffPurchaseResponseBuilder &operator=(const GuildBuffPurchaseResponseBuilder &);
  flatbuffers::Offset<GuildBuffPurchaseResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildBuffPurchaseResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildBuffPurchaseResponse> CreateGuildBuffPurchaseResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE) {
  GuildBuffPurchaseResponseBuilder builder_(_fbb);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

/// GUILD_CHANGE_LEADER_REQUEST
struct GuildChangeLeaderRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCDBID = 4
  };
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           verifier.EndTable();
  }
};

struct GuildChangeLeaderRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(GuildChangeLeaderRequest::VT_PCDBID, pcDbId, 0);
  }
  explicit GuildChangeLeaderRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildChangeLeaderRequestBuilder &operator=(const GuildChangeLeaderRequestBuilder &);
  flatbuffers::Offset<GuildChangeLeaderRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildChangeLeaderRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildChangeLeaderRequest> CreateGuildChangeLeaderRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcDbId = 0) {
  GuildChangeLeaderRequestBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  return builder_.Finish();
}

/// GUILD_CHANGE_LEADER_RESPONSE
struct GuildChangeLeaderResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           verifier.EndTable();
  }
};

struct GuildChangeLeaderResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(GuildChangeLeaderResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  explicit GuildChangeLeaderResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildChangeLeaderResponseBuilder &operator=(const GuildChangeLeaderResponseBuilder &);
  flatbuffers::Offset<GuildChangeLeaderResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildChangeLeaderResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildChangeLeaderResponse> CreateGuildChangeLeaderResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE) {
  GuildChangeLeaderResponseBuilder builder_(_fbb);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

/// GUILD_CANDIDATE_LEADER_LIST_REQUEST
struct GuildCandidateLeaderListRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GuildCandidateLeaderListRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GuildCandidateLeaderListRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildCandidateLeaderListRequestBuilder &operator=(const GuildCandidateLeaderListRequestBuilder &);
  flatbuffers::Offset<GuildCandidateLeaderListRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildCandidateLeaderListRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildCandidateLeaderListRequest> CreateGuildCandidateLeaderListRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GuildCandidateLeaderListRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// GUILD_CANDIDATE_LEADER_LIST_RESPONSE
struct GuildCandidateLeaderListResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_MEMBERS = 6
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<GuildMemberInfo>> *members() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GuildMemberInfo>> *>(VT_MEMBERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyOffset(verifier, VT_MEMBERS) &&
           verifier.VerifyVector(members()) &&
           verifier.VerifyVectorOfTables(members()) &&
           verifier.EndTable();
  }
};

struct GuildCandidateLeaderListResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(GuildCandidateLeaderListResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  void add_members(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuildMemberInfo>>> members) {
    fbb_.AddOffset(GuildCandidateLeaderListResponse::VT_MEMBERS, members);
  }
  explicit GuildCandidateLeaderListResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildCandidateLeaderListResponseBuilder &operator=(const GuildCandidateLeaderListResponseBuilder &);
  flatbuffers::Offset<GuildCandidateLeaderListResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildCandidateLeaderListResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildCandidateLeaderListResponse> CreateGuildCandidateLeaderListResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuildMemberInfo>>> members = 0) {
  GuildCandidateLeaderListResponseBuilder builder_(_fbb);
  builder_.add_members(members);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildCandidateLeaderListResponse> CreateGuildCandidateLeaderListResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE,
    const std::vector<flatbuffers::Offset<GuildMemberInfo>> *members = nullptr) {
  return LeanPacket::CreateGuildCandidateLeaderListResponse(
      _fbb,
      errorCode,
      members ? _fbb.CreateVector<flatbuffers::Offset<GuildMemberInfo>>(*members) : 0);
}

/// GUILD_CHANGE_CREST_REQUEST
struct GuildChangeCrestRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CREST = 4
  };
  const GuildCrest *crest() const {
    return GetPointer<const GuildCrest *>(VT_CREST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CREST) &&
           verifier.VerifyTable(crest()) &&
           verifier.EndTable();
  }
};

struct GuildChangeCrestRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_crest(flatbuffers::Offset<GuildCrest> crest) {
    fbb_.AddOffset(GuildChangeCrestRequest::VT_CREST, crest);
  }
  explicit GuildChangeCrestRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildChangeCrestRequestBuilder &operator=(const GuildChangeCrestRequestBuilder &);
  flatbuffers::Offset<GuildChangeCrestRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildChangeCrestRequest>(end);
    fbb_.Required(o, GuildChangeCrestRequest::VT_CREST);
    return o;
  }
};

inline flatbuffers::Offset<GuildChangeCrestRequest> CreateGuildChangeCrestRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GuildCrest> crest = 0) {
  GuildChangeCrestRequestBuilder builder_(_fbb);
  builder_.add_crest(crest);
  return builder_.Finish();
}

/// GUILD_CHANGE_CREST_RESPONSE
struct GuildChangeCrestResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           verifier.EndTable();
  }
};

struct GuildChangeCrestResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(GuildChangeCrestResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  explicit GuildChangeCrestResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildChangeCrestResponseBuilder &operator=(const GuildChangeCrestResponseBuilder &);
  flatbuffers::Offset<GuildChangeCrestResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildChangeCrestResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildChangeCrestResponse> CreateGuildChangeCrestResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE) {
  GuildChangeCrestResponseBuilder builder_(_fbb);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

struct GuildShareSettingData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GRADE = 4,
    VT_PERCENT = 6,
    VT_MEMBERCOUNT = 8
  };
  int8_t grade() const {
    return GetField<int8_t>(VT_GRADE, 0);
  }
  /// 0~100
  /// 총 합이 100을 넘기면 안됨
  int8_t percent() const {
    return GetField<int8_t>(VT_PERCENT, 0);
  }
  /// 현재 멤버 수
  int16_t memberCount() const {
    return GetField<int16_t>(VT_MEMBERCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_GRADE) &&
           VerifyField<int8_t>(verifier, VT_PERCENT) &&
           VerifyField<int16_t>(verifier, VT_MEMBERCOUNT) &&
           verifier.EndTable();
  }
};

struct GuildShareSettingDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_grade(int8_t grade) {
    fbb_.AddElement<int8_t>(GuildShareSettingData::VT_GRADE, grade, 0);
  }
  void add_percent(int8_t percent) {
    fbb_.AddElement<int8_t>(GuildShareSettingData::VT_PERCENT, percent, 0);
  }
  void add_memberCount(int16_t memberCount) {
    fbb_.AddElement<int16_t>(GuildShareSettingData::VT_MEMBERCOUNT, memberCount, 0);
  }
  explicit GuildShareSettingDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildShareSettingDataBuilder &operator=(const GuildShareSettingDataBuilder &);
  flatbuffers::Offset<GuildShareSettingData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildShareSettingData>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildShareSettingData> CreateGuildShareSettingData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t grade = 0,
    int8_t percent = 0,
    int16_t memberCount = 0) {
  GuildShareSettingDataBuilder builder_(_fbb);
  builder_.add_memberCount(memberCount);
  builder_.add_percent(percent);
  builder_.add_grade(grade);
  return builder_.Finish();
}

/// GUILD_SHARE_SETTING_INFO_REQUEST
struct GuildShareSettingInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GuildShareSettingInfoRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GuildShareSettingInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildShareSettingInfoRequestBuilder &operator=(const GuildShareSettingInfoRequestBuilder &);
  flatbuffers::Offset<GuildShareSettingInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildShareSettingInfoRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildShareSettingInfoRequest> CreateGuildShareSettingInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GuildShareSettingInfoRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// GUILD_SHARE_SETTING_INFO_RESPONSE
struct GuildShareSettingInfoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_SETTINGDATAS = 6
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<GuildShareSettingData>> *settingDatas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GuildShareSettingData>> *>(VT_SETTINGDATAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyOffsetRequired(verifier, VT_SETTINGDATAS) &&
           verifier.VerifyVector(settingDatas()) &&
           verifier.VerifyVectorOfTables(settingDatas()) &&
           verifier.EndTable();
  }
};

struct GuildShareSettingInfoResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(GuildShareSettingInfoResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  void add_settingDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuildShareSettingData>>> settingDatas) {
    fbb_.AddOffset(GuildShareSettingInfoResponse::VT_SETTINGDATAS, settingDatas);
  }
  explicit GuildShareSettingInfoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildShareSettingInfoResponseBuilder &operator=(const GuildShareSettingInfoResponseBuilder &);
  flatbuffers::Offset<GuildShareSettingInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildShareSettingInfoResponse>(end);
    fbb_.Required(o, GuildShareSettingInfoResponse::VT_SETTINGDATAS);
    return o;
  }
};

inline flatbuffers::Offset<GuildShareSettingInfoResponse> CreateGuildShareSettingInfoResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuildShareSettingData>>> settingDatas = 0) {
  GuildShareSettingInfoResponseBuilder builder_(_fbb);
  builder_.add_settingDatas(settingDatas);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildShareSettingInfoResponse> CreateGuildShareSettingInfoResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE,
    const std::vector<flatbuffers::Offset<GuildShareSettingData>> *settingDatas = nullptr) {
  return LeanPacket::CreateGuildShareSettingInfoResponse(
      _fbb,
      errorCode,
      settingDatas ? _fbb.CreateVector<flatbuffers::Offset<GuildShareSettingData>>(*settingDatas) : 0);
}

/// GUILD_SAVE_SHARE_SETTING_REQUEST
struct GuildSaveShareSettingRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SETTINGDATAS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<GuildShareSettingData>> *settingDatas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GuildShareSettingData>> *>(VT_SETTINGDATAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SETTINGDATAS) &&
           verifier.VerifyVector(settingDatas()) &&
           verifier.VerifyVectorOfTables(settingDatas()) &&
           verifier.EndTable();
  }
};

struct GuildSaveShareSettingRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_settingDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuildShareSettingData>>> settingDatas) {
    fbb_.AddOffset(GuildSaveShareSettingRequest::VT_SETTINGDATAS, settingDatas);
  }
  explicit GuildSaveShareSettingRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildSaveShareSettingRequestBuilder &operator=(const GuildSaveShareSettingRequestBuilder &);
  flatbuffers::Offset<GuildSaveShareSettingRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildSaveShareSettingRequest>(end);
    fbb_.Required(o, GuildSaveShareSettingRequest::VT_SETTINGDATAS);
    return o;
  }
};

inline flatbuffers::Offset<GuildSaveShareSettingRequest> CreateGuildSaveShareSettingRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuildShareSettingData>>> settingDatas = 0) {
  GuildSaveShareSettingRequestBuilder builder_(_fbb);
  builder_.add_settingDatas(settingDatas);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildSaveShareSettingRequest> CreateGuildSaveShareSettingRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<GuildShareSettingData>> *settingDatas = nullptr) {
  return LeanPacket::CreateGuildSaveShareSettingRequest(
      _fbb,
      settingDatas ? _fbb.CreateVector<flatbuffers::Offset<GuildShareSettingData>>(*settingDatas) : 0);
}

/// GUILD_SAVE_SHARE_SETTING_RESPONSE
struct GuildSaveShareSettingResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           verifier.EndTable();
  }
};

struct GuildSaveShareSettingResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(GuildSaveShareSettingResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  explicit GuildSaveShareSettingResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildSaveShareSettingResponseBuilder &operator=(const GuildSaveShareSettingResponseBuilder &);
  flatbuffers::Offset<GuildSaveShareSettingResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildSaveShareSettingResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildSaveShareSettingResponse> CreateGuildSaveShareSettingResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE) {
  GuildSaveShareSettingResponseBuilder builder_(_fbb);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

/// GUILD_INVITE_MESSAGE_REQUEST
struct GuildInviteMessageRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INVITEPCNAME = 4
  };
  const flatbuffers::String *invitePcName() const {
    return GetPointer<const flatbuffers::String *>(VT_INVITEPCNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_INVITEPCNAME) &&
           verifier.VerifyString(invitePcName()) &&
           verifier.EndTable();
  }
};

struct GuildInviteMessageRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_invitePcName(flatbuffers::Offset<flatbuffers::String> invitePcName) {
    fbb_.AddOffset(GuildInviteMessageRequest::VT_INVITEPCNAME, invitePcName);
  }
  explicit GuildInviteMessageRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildInviteMessageRequestBuilder &operator=(const GuildInviteMessageRequestBuilder &);
  flatbuffers::Offset<GuildInviteMessageRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildInviteMessageRequest>(end);
    fbb_.Required(o, GuildInviteMessageRequest::VT_INVITEPCNAME);
    return o;
  }
};

inline flatbuffers::Offset<GuildInviteMessageRequest> CreateGuildInviteMessageRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> invitePcName = 0) {
  GuildInviteMessageRequestBuilder builder_(_fbb);
  builder_.add_invitePcName(invitePcName);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildInviteMessageRequest> CreateGuildInviteMessageRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *invitePcName = nullptr) {
  return LeanPacket::CreateGuildInviteMessageRequest(
      _fbb,
      invitePcName ? _fbb.CreateString(invitePcName) : 0);
}

/// GUILD_INVITE_MESSAGE_RESPONSE
struct GuildInviteMessageResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_INVITEPCNAME = 6
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  const flatbuffers::String *invitePcName() const {
    return GetPointer<const flatbuffers::String *>(VT_INVITEPCNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyOffsetRequired(verifier, VT_INVITEPCNAME) &&
           verifier.VerifyString(invitePcName()) &&
           verifier.EndTable();
  }
};

struct GuildInviteMessageResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(GuildInviteMessageResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_invitePcName(flatbuffers::Offset<flatbuffers::String> invitePcName) {
    fbb_.AddOffset(GuildInviteMessageResponse::VT_INVITEPCNAME, invitePcName);
  }
  explicit GuildInviteMessageResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildInviteMessageResponseBuilder &operator=(const GuildInviteMessageResponseBuilder &);
  flatbuffers::Offset<GuildInviteMessageResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildInviteMessageResponse>(end);
    fbb_.Required(o, GuildInviteMessageResponse::VT_INVITEPCNAME);
    return o;
  }
};

inline flatbuffers::Offset<GuildInviteMessageResponse> CreateGuildInviteMessageResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    flatbuffers::Offset<flatbuffers::String> invitePcName = 0) {
  GuildInviteMessageResponseBuilder builder_(_fbb);
  builder_.add_invitePcName(invitePcName);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildInviteMessageResponse> CreateGuildInviteMessageResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    const char *invitePcName = nullptr) {
  return LeanPacket::CreateGuildInviteMessageResponse(
      _fbb,
      errorCode,
      invitePcName ? _fbb.CreateString(invitePcName) : 0);
}

/// GUILD_MEMBER_DETAIL_INFO_REQUEST
struct GuildMemberDetailInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct GuildMemberDetailInfoRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(GuildMemberDetailInfoRequest::VT_NAME, name);
  }
  explicit GuildMemberDetailInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildMemberDetailInfoRequestBuilder &operator=(const GuildMemberDetailInfoRequestBuilder &);
  flatbuffers::Offset<GuildMemberDetailInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildMemberDetailInfoRequest>(end);
    fbb_.Required(o, GuildMemberDetailInfoRequest::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<GuildMemberDetailInfoRequest> CreateGuildMemberDetailInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  GuildMemberDetailInfoRequestBuilder builder_(_fbb);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildMemberDetailInfoRequest> CreateGuildMemberDetailInfoRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr) {
  return LeanPacket::CreateGuildMemberDetailInfoRequest(
      _fbb,
      name ? _fbb.CreateString(name) : 0);
}

/// GUILD_MEMBER_DETAIL_INFO_RESPONSE
struct GuildMemberDetailInfoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_DETAILINFO = 6
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  const PcDetailInfo *detailInfo() const {
    return GetPointer<const PcDetailInfo *>(VT_DETAILINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyOffset(verifier, VT_DETAILINFO) &&
           verifier.VerifyTable(detailInfo()) &&
           verifier.EndTable();
  }
};

struct GuildMemberDetailInfoResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(GuildMemberDetailInfoResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  void add_detailInfo(flatbuffers::Offset<PcDetailInfo> detailInfo) {
    fbb_.AddOffset(GuildMemberDetailInfoResponse::VT_DETAILINFO, detailInfo);
  }
  explicit GuildMemberDetailInfoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildMemberDetailInfoResponseBuilder &operator=(const GuildMemberDetailInfoResponseBuilder &);
  flatbuffers::Offset<GuildMemberDetailInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildMemberDetailInfoResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildMemberDetailInfoResponse> CreateGuildMemberDetailInfoResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE,
    flatbuffers::Offset<PcDetailInfo> detailInfo = 0) {
  GuildMemberDetailInfoResponseBuilder builder_(_fbb);
  builder_.add_detailInfo(detailInfo);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

/// GUILD_REJECT_JOIN_REQ_NOTIFY
struct GuildRejectJoinReqNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GUILDID = 4
  };
  int32_t guildId() const {
    return GetField<int32_t>(VT_GUILDID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_GUILDID) &&
           verifier.EndTable();
  }
};

struct GuildRejectJoinReqNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_guildId(int32_t guildId) {
    fbb_.AddElement<int32_t>(GuildRejectJoinReqNotify::VT_GUILDID, guildId, 0);
  }
  explicit GuildRejectJoinReqNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildRejectJoinReqNotifyBuilder &operator=(const GuildRejectJoinReqNotifyBuilder &);
  flatbuffers::Offset<GuildRejectJoinReqNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildRejectJoinReqNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildRejectJoinReqNotify> CreateGuildRejectJoinReqNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t guildId = 0) {
  GuildRejectJoinReqNotifyBuilder builder_(_fbb);
  builder_.add_guildId(guildId);
  return builder_.Finish();
}

/// GUILD_CHANGE_NAME_REQUEST
struct GuildChangeNameRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NEWNAME = 4
  };
  const flatbuffers::String *newName() const {
    return GetPointer<const flatbuffers::String *>(VT_NEWNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NEWNAME) &&
           verifier.VerifyString(newName()) &&
           verifier.EndTable();
  }
};

struct GuildChangeNameRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_newName(flatbuffers::Offset<flatbuffers::String> newName) {
    fbb_.AddOffset(GuildChangeNameRequest::VT_NEWNAME, newName);
  }
  explicit GuildChangeNameRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildChangeNameRequestBuilder &operator=(const GuildChangeNameRequestBuilder &);
  flatbuffers::Offset<GuildChangeNameRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildChangeNameRequest>(end);
    fbb_.Required(o, GuildChangeNameRequest::VT_NEWNAME);
    return o;
  }
};

inline flatbuffers::Offset<GuildChangeNameRequest> CreateGuildChangeNameRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> newName = 0) {
  GuildChangeNameRequestBuilder builder_(_fbb);
  builder_.add_newName(newName);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildChangeNameRequest> CreateGuildChangeNameRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *newName = nullptr) {
  return LeanPacket::CreateGuildChangeNameRequest(
      _fbb,
      newName ? _fbb.CreateString(newName) : 0);
}

/// GUILD_CHANGE_NAME_RESPONSE
struct GuildChangeNameResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           verifier.EndTable();
  }
};

struct GuildChangeNameResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(GuildChangeNameResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  explicit GuildChangeNameResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildChangeNameResponseBuilder &operator=(const GuildChangeNameResponseBuilder &);
  flatbuffers::Offset<GuildChangeNameResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildChangeNameResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildChangeNameResponse> CreateGuildChangeNameResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE) {
  GuildChangeNameResponseBuilder builder_(_fbb);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

/// GUILD_CHANGE_NAME_NOTIFY
struct GuildChangeNameNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OLDNAME = 4,
    VT_NEWNAME = 6
  };
  const flatbuffers::String *oldName() const {
    return GetPointer<const flatbuffers::String *>(VT_OLDNAME);
  }
  const flatbuffers::String *newName() const {
    return GetPointer<const flatbuffers::String *>(VT_NEWNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_OLDNAME) &&
           verifier.VerifyString(oldName()) &&
           VerifyOffsetRequired(verifier, VT_NEWNAME) &&
           verifier.VerifyString(newName()) &&
           verifier.EndTable();
  }
};

struct GuildChangeNameNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_oldName(flatbuffers::Offset<flatbuffers::String> oldName) {
    fbb_.AddOffset(GuildChangeNameNotify::VT_OLDNAME, oldName);
  }
  void add_newName(flatbuffers::Offset<flatbuffers::String> newName) {
    fbb_.AddOffset(GuildChangeNameNotify::VT_NEWNAME, newName);
  }
  explicit GuildChangeNameNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildChangeNameNotifyBuilder &operator=(const GuildChangeNameNotifyBuilder &);
  flatbuffers::Offset<GuildChangeNameNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildChangeNameNotify>(end);
    fbb_.Required(o, GuildChangeNameNotify::VT_OLDNAME);
    fbb_.Required(o, GuildChangeNameNotify::VT_NEWNAME);
    return o;
  }
};

inline flatbuffers::Offset<GuildChangeNameNotify> CreateGuildChangeNameNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> oldName = 0,
    flatbuffers::Offset<flatbuffers::String> newName = 0) {
  GuildChangeNameNotifyBuilder builder_(_fbb);
  builder_.add_newName(newName);
  builder_.add_oldName(oldName);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildChangeNameNotify> CreateGuildChangeNameNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *oldName = nullptr,
    const char *newName = nullptr) {
  return LeanPacket::CreateGuildChangeNameNotify(
      _fbb,
      oldName ? _fbb.CreateString(oldName) : 0,
      newName ? _fbb.CreateString(newName) : 0);
}

/// GUILD_DUNGEON_SCORE_REQUEST
struct GuildDungeonScoreRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GuildDungeonScoreRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GuildDungeonScoreRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildDungeonScoreRequestBuilder &operator=(const GuildDungeonScoreRequestBuilder &);
  flatbuffers::Offset<GuildDungeonScoreRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildDungeonScoreRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildDungeonScoreRequest> CreateGuildDungeonScoreRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GuildDungeonScoreRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// GUILD_DUNGEON_SCORE_RESPONSE
struct GuildDungeonScoreResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RANK = 4,
    VT_SCORE = 6
  };
  int32_t rank() const {
    return GetField<int32_t>(VT_RANK, 0);
  }
  int64_t score() const {
    return GetField<int64_t>(VT_SCORE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RANK) &&
           VerifyField<int64_t>(verifier, VT_SCORE) &&
           verifier.EndTable();
  }
};

struct GuildDungeonScoreResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rank(int32_t rank) {
    fbb_.AddElement<int32_t>(GuildDungeonScoreResponse::VT_RANK, rank, 0);
  }
  void add_score(int64_t score) {
    fbb_.AddElement<int64_t>(GuildDungeonScoreResponse::VT_SCORE, score, 0);
  }
  explicit GuildDungeonScoreResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildDungeonScoreResponseBuilder &operator=(const GuildDungeonScoreResponseBuilder &);
  flatbuffers::Offset<GuildDungeonScoreResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildDungeonScoreResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildDungeonScoreResponse> CreateGuildDungeonScoreResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rank = 0,
    int64_t score = 0) {
  GuildDungeonScoreResponseBuilder builder_(_fbb);
  builder_.add_score(score);
  builder_.add_rank(rank);
  return builder_.Finish();
}

/// 길드 통합 랭킹 정보
struct GuildUnityRankingInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RANK = 4,
    VT_NAME = 6,
    VT_CREST = 8,
    VT_SERVER = 10,
    VT_SCORE = 12
  };
  /// 순위 (1 base)
  int32_t rank() const {
    return GetField<int32_t>(VT_RANK, 0);
  }
  /// 길드명
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  /// 길드 문양
  const GuildCrest *crest() const {
    return GetPointer<const GuildCrest *>(VT_CREST);
  }
  /// 서버 인덱스
  int16_t server() const {
    return GetField<int16_t>(VT_SERVER, 0);
  }
  /// 점수
  int64_t score() const {
    return GetField<int64_t>(VT_SCORE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RANK) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_CREST) &&
           verifier.VerifyTable(crest()) &&
           VerifyField<int16_t>(verifier, VT_SERVER) &&
           VerifyField<int64_t>(verifier, VT_SCORE) &&
           verifier.EndTable();
  }
};

struct GuildUnityRankingInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rank(int32_t rank) {
    fbb_.AddElement<int32_t>(GuildUnityRankingInfo::VT_RANK, rank, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(GuildUnityRankingInfo::VT_NAME, name);
  }
  void add_crest(flatbuffers::Offset<GuildCrest> crest) {
    fbb_.AddOffset(GuildUnityRankingInfo::VT_CREST, crest);
  }
  void add_server(int16_t server) {
    fbb_.AddElement<int16_t>(GuildUnityRankingInfo::VT_SERVER, server, 0);
  }
  void add_score(int64_t score) {
    fbb_.AddElement<int64_t>(GuildUnityRankingInfo::VT_SCORE, score, 0);
  }
  explicit GuildUnityRankingInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildUnityRankingInfoBuilder &operator=(const GuildUnityRankingInfoBuilder &);
  flatbuffers::Offset<GuildUnityRankingInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildUnityRankingInfo>(end);
    fbb_.Required(o, GuildUnityRankingInfo::VT_NAME);
    fbb_.Required(o, GuildUnityRankingInfo::VT_CREST);
    return o;
  }
};

inline flatbuffers::Offset<GuildUnityRankingInfo> CreateGuildUnityRankingInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rank = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<GuildCrest> crest = 0,
    int16_t server = 0,
    int64_t score = 0) {
  GuildUnityRankingInfoBuilder builder_(_fbb);
  builder_.add_score(score);
  builder_.add_crest(crest);
  builder_.add_name(name);
  builder_.add_rank(rank);
  builder_.add_server(server);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildUnityRankingInfo> CreateGuildUnityRankingInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rank = 0,
    const char *name = nullptr,
    flatbuffers::Offset<GuildCrest> crest = 0,
    int16_t server = 0,
    int64_t score = 0) {
  return LeanPacket::CreateGuildUnityRankingInfo(
      _fbb,
      rank,
      name ? _fbb.CreateString(name) : 0,
      crest,
      server,
      score);
}

/// GUILD_UNITY_RANKING_LIST_REQUEST
struct GuildUnityRankingListRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PAGE = 4,
    VT_SORTTYPE = 6
  };
  /// zero-based
  int32_t page() const {
    return GetField<int32_t>(VT_PAGE, 0);
  }
  GuildRankSortType sortType() const {
    return static_cast<GuildRankSortType>(GetField<int8_t>(VT_SORTTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PAGE) &&
           VerifyField<int8_t>(verifier, VT_SORTTYPE) &&
           verifier.EndTable();
  }
};

struct GuildUnityRankingListRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_page(int32_t page) {
    fbb_.AddElement<int32_t>(GuildUnityRankingListRequest::VT_PAGE, page, 0);
  }
  void add_sortType(GuildRankSortType sortType) {
    fbb_.AddElement<int8_t>(GuildUnityRankingListRequest::VT_SORTTYPE, static_cast<int8_t>(sortType), 0);
  }
  explicit GuildUnityRankingListRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildUnityRankingListRequestBuilder &operator=(const GuildUnityRankingListRequestBuilder &);
  flatbuffers::Offset<GuildUnityRankingListRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildUnityRankingListRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildUnityRankingListRequest> CreateGuildUnityRankingListRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t page = 0,
    GuildRankSortType sortType = GuildRankSortType_GuildRankSortType_Level) {
  GuildUnityRankingListRequestBuilder builder_(_fbb);
  builder_.add_page(page);
  builder_.add_sortType(sortType);
  return builder_.Finish();
}

/// GUILD_UNITY_RANKING_LIST_RESPONSE
struct GuildUnityRankingListResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_GUILDINFOS = 6,
    VT_PAGE = 8,
    VT_MYGUILDINFO = 10
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<GuildUnityRankingInfo>> *guildInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GuildUnityRankingInfo>> *>(VT_GUILDINFOS);
  }
  int32_t page() const {
    return GetField<int32_t>(VT_PAGE, 0);
  }
  /// 내 길드의 정보
  const GuildUnityRankingInfo *myGuildInfo() const {
    return GetPointer<const GuildUnityRankingInfo *>(VT_MYGUILDINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyOffset(verifier, VT_GUILDINFOS) &&
           verifier.VerifyVector(guildInfos()) &&
           verifier.VerifyVectorOfTables(guildInfos()) &&
           VerifyField<int32_t>(verifier, VT_PAGE) &&
           VerifyOffset(verifier, VT_MYGUILDINFO) &&
           verifier.VerifyTable(myGuildInfo()) &&
           verifier.EndTable();
  }
};

struct GuildUnityRankingListResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(GuildUnityRankingListResponse::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  void add_guildInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuildUnityRankingInfo>>> guildInfos) {
    fbb_.AddOffset(GuildUnityRankingListResponse::VT_GUILDINFOS, guildInfos);
  }
  void add_page(int32_t page) {
    fbb_.AddElement<int32_t>(GuildUnityRankingListResponse::VT_PAGE, page, 0);
  }
  void add_myGuildInfo(flatbuffers::Offset<GuildUnityRankingInfo> myGuildInfo) {
    fbb_.AddOffset(GuildUnityRankingListResponse::VT_MYGUILDINFO, myGuildInfo);
  }
  explicit GuildUnityRankingListResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildUnityRankingListResponseBuilder &operator=(const GuildUnityRankingListResponseBuilder &);
  flatbuffers::Offset<GuildUnityRankingListResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildUnityRankingListResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildUnityRankingListResponse> CreateGuildUnityRankingListResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuildUnityRankingInfo>>> guildInfos = 0,
    int32_t page = 0,
    flatbuffers::Offset<GuildUnityRankingInfo> myGuildInfo = 0) {
  GuildUnityRankingListResponseBuilder builder_(_fbb);
  builder_.add_myGuildInfo(myGuildInfo);
  builder_.add_page(page);
  builder_.add_guildInfos(guildInfos);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildUnityRankingListResponse> CreateGuildUnityRankingListResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE,
    const std::vector<flatbuffers::Offset<GuildUnityRankingInfo>> *guildInfos = nullptr,
    int32_t page = 0,
    flatbuffers::Offset<GuildUnityRankingInfo> myGuildInfo = 0) {
  return LeanPacket::CreateGuildUnityRankingListResponse(
      _fbb,
      errorCode,
      guildInfos ? _fbb.CreateVector<flatbuffers::Offset<GuildUnityRankingInfo>>(*guildInfos) : 0,
      page,
      myGuildInfo);
}

struct SeasonGuildInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_CREST = 6,
    VT_RANK = 8,
    VT_MONARCHPOINT = 10,
    VT_PREVRANK = 12,
    VT_LEADERGUILDCOUNT = 14
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const GuildCrest *crest() const {
    return GetPointer<const GuildCrest *>(VT_CREST);
  }
  /// 랭킹
  int32_t rank() const {
    return GetField<int32_t>(VT_RANK, 0);
  }
  /// 군주 포인트
  int64_t monarchPoint() const {
    return GetField<int64_t>(VT_MONARCHPOINT, 0);
  }
  /// 지난 시즌 랭킹 (지난 시즌 랭킹이 없으면 0)
  int32_t prevRank() const {
    return GetField<int32_t>(VT_PREVRANK, 0);
  }
  /// 군주 길드 횟수
  int32_t leaderGuildCount() const {
    return GetField<int32_t>(VT_LEADERGUILDCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_CREST) &&
           verifier.VerifyTable(crest()) &&
           VerifyField<int32_t>(verifier, VT_RANK) &&
           VerifyField<int64_t>(verifier, VT_MONARCHPOINT) &&
           VerifyField<int32_t>(verifier, VT_PREVRANK) &&
           VerifyField<int32_t>(verifier, VT_LEADERGUILDCOUNT) &&
           verifier.EndTable();
  }
};

struct SeasonGuildInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(SeasonGuildInfo::VT_NAME, name);
  }
  void add_crest(flatbuffers::Offset<GuildCrest> crest) {
    fbb_.AddOffset(SeasonGuildInfo::VT_CREST, crest);
  }
  void add_rank(int32_t rank) {
    fbb_.AddElement<int32_t>(SeasonGuildInfo::VT_RANK, rank, 0);
  }
  void add_monarchPoint(int64_t monarchPoint) {
    fbb_.AddElement<int64_t>(SeasonGuildInfo::VT_MONARCHPOINT, monarchPoint, 0);
  }
  void add_prevRank(int32_t prevRank) {
    fbb_.AddElement<int32_t>(SeasonGuildInfo::VT_PREVRANK, prevRank, 0);
  }
  void add_leaderGuildCount(int32_t leaderGuildCount) {
    fbb_.AddElement<int32_t>(SeasonGuildInfo::VT_LEADERGUILDCOUNT, leaderGuildCount, 0);
  }
  explicit SeasonGuildInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SeasonGuildInfoBuilder &operator=(const SeasonGuildInfoBuilder &);
  flatbuffers::Offset<SeasonGuildInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SeasonGuildInfo>(end);
    fbb_.Required(o, SeasonGuildInfo::VT_NAME);
    fbb_.Required(o, SeasonGuildInfo::VT_CREST);
    return o;
  }
};

inline flatbuffers::Offset<SeasonGuildInfo> CreateSeasonGuildInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<GuildCrest> crest = 0,
    int32_t rank = 0,
    int64_t monarchPoint = 0,
    int32_t prevRank = 0,
    int32_t leaderGuildCount = 0) {
  SeasonGuildInfoBuilder builder_(_fbb);
  builder_.add_monarchPoint(monarchPoint);
  builder_.add_leaderGuildCount(leaderGuildCount);
  builder_.add_prevRank(prevRank);
  builder_.add_rank(rank);
  builder_.add_crest(crest);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<SeasonGuildInfo> CreateSeasonGuildInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers::Offset<GuildCrest> crest = 0,
    int32_t rank = 0,
    int64_t monarchPoint = 0,
    int32_t prevRank = 0,
    int32_t leaderGuildCount = 0) {
  return LeanPacket::CreateSeasonGuildInfo(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      crest,
      rank,
      monarchPoint,
      prevRank,
      leaderGuildCount);
}

/// SEASON_CURRENT_INFO_REQUEST
struct SeasonCurrentInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SeasonCurrentInfoRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SeasonCurrentInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SeasonCurrentInfoRequestBuilder &operator=(const SeasonCurrentInfoRequestBuilder &);
  flatbuffers::Offset<SeasonCurrentInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SeasonCurrentInfoRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SeasonCurrentInfoRequest> CreateSeasonCurrentInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SeasonCurrentInfoRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// SEASON_CURRENT_INFO_RESPONSE
struct SeasonCurrentInfoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TOPGUILDINFOS = 4,
    VT_LEADERGUILDINFO = 6,
    VT_MYGUILDINFO = 8,
    VT_SEASONENDDATETIMEUTC = 10,
    VT_PCMONARCHPOINTTIER = 12
  };
  const flatbuffers::Vector<flatbuffers::Offset<SeasonGuildInfo>> *topGuildInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SeasonGuildInfo>> *>(VT_TOPGUILDINFOS);
  }
  /// 현재 군주 길드 (nullable)
  const SeasonGuildInfo *leaderGuildInfo() const {
    return GetPointer<const SeasonGuildInfo *>(VT_LEADERGUILDINFO);
  }
  /// 내 길드 정보 (nullable)
  const SeasonGuildInfo *myGuildInfo() const {
    return GetPointer<const SeasonGuildInfo *>(VT_MYGUILDINFO);
  }
  /// 시즌 종료 시간. 다음과 같이 변환해서 쓰세요
  /// new DateTime(ticks, DateTimeKind.Utc).ToLocalTime(); // local time
  int64_t seasonEndDateTimeUtc() const {
    return GetField<int64_t>(VT_SEASONENDDATETIMEUTC, 0);
  }
  /// pc의 군주포인트 등급
  int16_t pcMonarchPointTier() const {
    return GetField<int16_t>(VT_PCMONARCHPOINTTIER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TOPGUILDINFOS) &&
           verifier.VerifyVector(topGuildInfos()) &&
           verifier.VerifyVectorOfTables(topGuildInfos()) &&
           VerifyOffset(verifier, VT_LEADERGUILDINFO) &&
           verifier.VerifyTable(leaderGuildInfo()) &&
           VerifyOffset(verifier, VT_MYGUILDINFO) &&
           verifier.VerifyTable(myGuildInfo()) &&
           VerifyField<int64_t>(verifier, VT_SEASONENDDATETIMEUTC) &&
           VerifyField<int16_t>(verifier, VT_PCMONARCHPOINTTIER) &&
           verifier.EndTable();
  }
};

struct SeasonCurrentInfoResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_topGuildInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SeasonGuildInfo>>> topGuildInfos) {
    fbb_.AddOffset(SeasonCurrentInfoResponse::VT_TOPGUILDINFOS, topGuildInfos);
  }
  void add_leaderGuildInfo(flatbuffers::Offset<SeasonGuildInfo> leaderGuildInfo) {
    fbb_.AddOffset(SeasonCurrentInfoResponse::VT_LEADERGUILDINFO, leaderGuildInfo);
  }
  void add_myGuildInfo(flatbuffers::Offset<SeasonGuildInfo> myGuildInfo) {
    fbb_.AddOffset(SeasonCurrentInfoResponse::VT_MYGUILDINFO, myGuildInfo);
  }
  void add_seasonEndDateTimeUtc(int64_t seasonEndDateTimeUtc) {
    fbb_.AddElement<int64_t>(SeasonCurrentInfoResponse::VT_SEASONENDDATETIMEUTC, seasonEndDateTimeUtc, 0);
  }
  void add_pcMonarchPointTier(int16_t pcMonarchPointTier) {
    fbb_.AddElement<int16_t>(SeasonCurrentInfoResponse::VT_PCMONARCHPOINTTIER, pcMonarchPointTier, 0);
  }
  explicit SeasonCurrentInfoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SeasonCurrentInfoResponseBuilder &operator=(const SeasonCurrentInfoResponseBuilder &);
  flatbuffers::Offset<SeasonCurrentInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SeasonCurrentInfoResponse>(end);
    fbb_.Required(o, SeasonCurrentInfoResponse::VT_TOPGUILDINFOS);
    return o;
  }
};

inline flatbuffers::Offset<SeasonCurrentInfoResponse> CreateSeasonCurrentInfoResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SeasonGuildInfo>>> topGuildInfos = 0,
    flatbuffers::Offset<SeasonGuildInfo> leaderGuildInfo = 0,
    flatbuffers::Offset<SeasonGuildInfo> myGuildInfo = 0,
    int64_t seasonEndDateTimeUtc = 0,
    int16_t pcMonarchPointTier = 0) {
  SeasonCurrentInfoResponseBuilder builder_(_fbb);
  builder_.add_seasonEndDateTimeUtc(seasonEndDateTimeUtc);
  builder_.add_myGuildInfo(myGuildInfo);
  builder_.add_leaderGuildInfo(leaderGuildInfo);
  builder_.add_topGuildInfos(topGuildInfos);
  builder_.add_pcMonarchPointTier(pcMonarchPointTier);
  return builder_.Finish();
}

inline flatbuffers::Offset<SeasonCurrentInfoResponse> CreateSeasonCurrentInfoResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<SeasonGuildInfo>> *topGuildInfos = nullptr,
    flatbuffers::Offset<SeasonGuildInfo> leaderGuildInfo = 0,
    flatbuffers::Offset<SeasonGuildInfo> myGuildInfo = 0,
    int64_t seasonEndDateTimeUtc = 0,
    int16_t pcMonarchPointTier = 0) {
  return LeanPacket::CreateSeasonCurrentInfoResponse(
      _fbb,
      topGuildInfos ? _fbb.CreateVector<flatbuffers::Offset<SeasonGuildInfo>>(*topGuildInfos) : 0,
      leaderGuildInfo,
      myGuildInfo,
      seasonEndDateTimeUtc,
      pcMonarchPointTier);
}

/// SEASON_REWARD_INFO_REQUEST
struct SeasonRewardInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SeasonRewardInfoRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SeasonRewardInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SeasonRewardInfoRequestBuilder &operator=(const SeasonRewardInfoRequestBuilder &);
  flatbuffers::Offset<SeasonRewardInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SeasonRewardInfoRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SeasonRewardInfoRequest> CreateSeasonRewardInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SeasonRewardInfoRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// SEASON_REWARD_INFO_RESPONSE
struct SeasonRewardInfoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCUMMARKETCHARGEDIA = 4
  };
  /// 현재 시즌 누적 거래소 수수료
  int64_t accumMarketChargeDia() const {
    return GetField<int64_t>(VT_ACCUMMARKETCHARGEDIA, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ACCUMMARKETCHARGEDIA) &&
           verifier.EndTable();
  }
};

struct SeasonRewardInfoResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accumMarketChargeDia(int64_t accumMarketChargeDia) {
    fbb_.AddElement<int64_t>(SeasonRewardInfoResponse::VT_ACCUMMARKETCHARGEDIA, accumMarketChargeDia, 0);
  }
  explicit SeasonRewardInfoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SeasonRewardInfoResponseBuilder &operator=(const SeasonRewardInfoResponseBuilder &);
  flatbuffers::Offset<SeasonRewardInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SeasonRewardInfoResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<SeasonRewardInfoResponse> CreateSeasonRewardInfoResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t accumMarketChargeDia = 0) {
  SeasonRewardInfoResponseBuilder builder_(_fbb);
  builder_.add_accumMarketChargeDia(accumMarketChargeDia);
  return builder_.Finish();
}

/// SEASON_DUNGEON_INFO_REQUEST
struct SeasonDungeonInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SeasonDungeonInfoRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SeasonDungeonInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SeasonDungeonInfoRequestBuilder &operator=(const SeasonDungeonInfoRequestBuilder &);
  flatbuffers::Offset<SeasonDungeonInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SeasonDungeonInfoRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SeasonDungeonInfoRequest> CreateSeasonDungeonInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SeasonDungeonInfoRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// SEASON_DUNGEON_INFO_RESPONSE
struct SeasonDungeonInfoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TOPGUILDINFOS = 4,
    VT_MYGUILDINFO = 6,
    VT_SEASONENDDATETIMEUTC = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<GuildUnityRankingInfo>> *topGuildInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GuildUnityRankingInfo>> *>(VT_TOPGUILDINFOS);
  }
  /// 내 길드 정보 (nullable)
  const GuildUnityRankingInfo *myGuildInfo() const {
    return GetPointer<const GuildUnityRankingInfo *>(VT_MYGUILDINFO);
  }
  /// 시즌 종료 시간. 다음과 같이 변환해서 쓰세요
  /// new DateTime(ticks, DateTimeKind.Utc).ToLocalTime(); // local time
  int64_t seasonEndDateTimeUtc() const {
    return GetField<int64_t>(VT_SEASONENDDATETIMEUTC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TOPGUILDINFOS) &&
           verifier.VerifyVector(topGuildInfos()) &&
           verifier.VerifyVectorOfTables(topGuildInfos()) &&
           VerifyOffset(verifier, VT_MYGUILDINFO) &&
           verifier.VerifyTable(myGuildInfo()) &&
           VerifyField<int64_t>(verifier, VT_SEASONENDDATETIMEUTC) &&
           verifier.EndTable();
  }
};

struct SeasonDungeonInfoResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_topGuildInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuildUnityRankingInfo>>> topGuildInfos) {
    fbb_.AddOffset(SeasonDungeonInfoResponse::VT_TOPGUILDINFOS, topGuildInfos);
  }
  void add_myGuildInfo(flatbuffers::Offset<GuildUnityRankingInfo> myGuildInfo) {
    fbb_.AddOffset(SeasonDungeonInfoResponse::VT_MYGUILDINFO, myGuildInfo);
  }
  void add_seasonEndDateTimeUtc(int64_t seasonEndDateTimeUtc) {
    fbb_.AddElement<int64_t>(SeasonDungeonInfoResponse::VT_SEASONENDDATETIMEUTC, seasonEndDateTimeUtc, 0);
  }
  explicit SeasonDungeonInfoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SeasonDungeonInfoResponseBuilder &operator=(const SeasonDungeonInfoResponseBuilder &);
  flatbuffers::Offset<SeasonDungeonInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SeasonDungeonInfoResponse>(end);
    fbb_.Required(o, SeasonDungeonInfoResponse::VT_TOPGUILDINFOS);
    return o;
  }
};

inline flatbuffers::Offset<SeasonDungeonInfoResponse> CreateSeasonDungeonInfoResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuildUnityRankingInfo>>> topGuildInfos = 0,
    flatbuffers::Offset<GuildUnityRankingInfo> myGuildInfo = 0,
    int64_t seasonEndDateTimeUtc = 0) {
  SeasonDungeonInfoResponseBuilder builder_(_fbb);
  builder_.add_seasonEndDateTimeUtc(seasonEndDateTimeUtc);
  builder_.add_myGuildInfo(myGuildInfo);
  builder_.add_topGuildInfos(topGuildInfos);
  return builder_.Finish();
}

inline flatbuffers::Offset<SeasonDungeonInfoResponse> CreateSeasonDungeonInfoResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<GuildUnityRankingInfo>> *topGuildInfos = nullptr,
    flatbuffers::Offset<GuildUnityRankingInfo> myGuildInfo = 0,
    int64_t seasonEndDateTimeUtc = 0) {
  return LeanPacket::CreateSeasonDungeonInfoResponse(
      _fbb,
      topGuildInfos ? _fbb.CreateVector<flatbuffers::Offset<GuildUnityRankingInfo>>(*topGuildInfos) : 0,
      myGuildInfo,
      seasonEndDateTimeUtc);
}

struct Elixir FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_LEVEL = 6,
    VT_EXP = 8
  };
  int8_t type() const {
    return GetField<int8_t>(VT_TYPE, 0);
  }
  uint8_t level() const {
    return GetField<uint8_t>(VT_LEVEL, 0);
  }
  int16_t exp() const {
    return GetField<int16_t>(VT_EXP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_LEVEL) &&
           VerifyField<int16_t>(verifier, VT_EXP) &&
           verifier.EndTable();
  }
};

struct ElixirBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int8_t type) {
    fbb_.AddElement<int8_t>(Elixir::VT_TYPE, type, 0);
  }
  void add_level(uint8_t level) {
    fbb_.AddElement<uint8_t>(Elixir::VT_LEVEL, level, 0);
  }
  void add_exp(int16_t exp) {
    fbb_.AddElement<int16_t>(Elixir::VT_EXP, exp, 0);
  }
  explicit ElixirBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ElixirBuilder &operator=(const ElixirBuilder &);
  flatbuffers::Offset<Elixir> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Elixir>(end);
    return o;
  }
};

inline flatbuffers::Offset<Elixir> CreateElixir(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t type = 0,
    uint8_t level = 0,
    int16_t exp = 0) {
  ElixirBuilder builder_(_fbb);
  builder_.add_exp(exp);
  builder_.add_level(level);
  builder_.add_type(type);
  return builder_.Finish();
}

/// ELIXIR_LIST_NOTIFY
struct ElixirListNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ELIXIRS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Elixir>> *elixirs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Elixir>> *>(VT_ELIXIRS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ELIXIRS) &&
           verifier.VerifyVector(elixirs()) &&
           verifier.VerifyVectorOfTables(elixirs()) &&
           verifier.EndTable();
  }
};

struct ElixirListNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_elixirs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Elixir>>> elixirs) {
    fbb_.AddOffset(ElixirListNotify::VT_ELIXIRS, elixirs);
  }
  explicit ElixirListNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ElixirListNotifyBuilder &operator=(const ElixirListNotifyBuilder &);
  flatbuffers::Offset<ElixirListNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ElixirListNotify>(end);
    fbb_.Required(o, ElixirListNotify::VT_ELIXIRS);
    return o;
  }
};

inline flatbuffers::Offset<ElixirListNotify> CreateElixirListNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Elixir>>> elixirs = 0) {
  ElixirListNotifyBuilder builder_(_fbb);
  builder_.add_elixirs(elixirs);
  return builder_.Finish();
}

inline flatbuffers::Offset<ElixirListNotify> CreateElixirListNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Elixir>> *elixirs = nullptr) {
  return LeanPacket::CreateElixirListNotify(
      _fbb,
      elixirs ? _fbb.CreateVector<flatbuffers::Offset<Elixir>>(*elixirs) : 0);
}

/// ELIXIR_EHCNAHT_REQUEST
struct ElixirEnchantRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_COUNT = 6
  };
  int8_t type() const {
    return GetField<int8_t>(VT_TYPE, 0);
  }
  int16_t count() const {
    return GetField<int16_t>(VT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<int16_t>(verifier, VT_COUNT) &&
           verifier.EndTable();
  }
};

struct ElixirEnchantRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int8_t type) {
    fbb_.AddElement<int8_t>(ElixirEnchantRequest::VT_TYPE, type, 0);
  }
  void add_count(int16_t count) {
    fbb_.AddElement<int16_t>(ElixirEnchantRequest::VT_COUNT, count, 0);
  }
  explicit ElixirEnchantRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ElixirEnchantRequestBuilder &operator=(const ElixirEnchantRequestBuilder &);
  flatbuffers::Offset<ElixirEnchantRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ElixirEnchantRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ElixirEnchantRequest> CreateElixirEnchantRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t type = 0,
    int16_t count = 0) {
  ElixirEnchantRequestBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_type(type);
  return builder_.Finish();
}

/// ELIXIR_EHCNAHT_RESPONSE
struct ElixirEnchantResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_ERROR = 6,
    VT_LEVEL = 8,
    VT_EXP = 10
  };
  int8_t type() const {
    return GetField<int8_t>(VT_TYPE, 0);
  }
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  int8_t level() const {
    return GetField<int8_t>(VT_LEVEL, 0);
  }
  int16_t exp() const {
    return GetField<int16_t>(VT_EXP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           VerifyField<int8_t>(verifier, VT_LEVEL) &&
           VerifyField<int16_t>(verifier, VT_EXP) &&
           verifier.EndTable();
  }
};

struct ElixirEnchantResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int8_t type) {
    fbb_.AddElement<int8_t>(ElixirEnchantResponse::VT_TYPE, type, 0);
  }
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(ElixirEnchantResponse::VT_ERROR, error, 0);
  }
  void add_level(int8_t level) {
    fbb_.AddElement<int8_t>(ElixirEnchantResponse::VT_LEVEL, level, 0);
  }
  void add_exp(int16_t exp) {
    fbb_.AddElement<int16_t>(ElixirEnchantResponse::VT_EXP, exp, 0);
  }
  explicit ElixirEnchantResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ElixirEnchantResponseBuilder &operator=(const ElixirEnchantResponseBuilder &);
  flatbuffers::Offset<ElixirEnchantResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ElixirEnchantResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ElixirEnchantResponse> CreateElixirEnchantResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t type = 0,
    int32_t error = 0,
    int8_t level = 0,
    int16_t exp = 0) {
  ElixirEnchantResponseBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_exp(exp);
  builder_.add_level(level);
  builder_.add_type(type);
  return builder_.Finish();
}

struct TerraStone FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_LEVEL = 6
  };
  int8_t type() const {
    return GetField<int8_t>(VT_TYPE, 0);
  }
  int16_t level() const {
    return GetField<int16_t>(VT_LEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<int16_t>(verifier, VT_LEVEL) &&
           verifier.EndTable();
  }
};

struct TerraStoneBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int8_t type) {
    fbb_.AddElement<int8_t>(TerraStone::VT_TYPE, type, 0);
  }
  void add_level(int16_t level) {
    fbb_.AddElement<int16_t>(TerraStone::VT_LEVEL, level, 0);
  }
  explicit TerraStoneBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TerraStoneBuilder &operator=(const TerraStoneBuilder &);
  flatbuffers::Offset<TerraStone> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TerraStone>(end);
    return o;
  }
};

inline flatbuffers::Offset<TerraStone> CreateTerraStone(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t type = 0,
    int16_t level = 0) {
  TerraStoneBuilder builder_(_fbb);
  builder_.add_level(level);
  builder_.add_type(type);
  return builder_.Finish();
}

/// TERRASTONE_LIST_NOTIFY
struct TerraStoneListNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TERRASTONES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<TerraStone>> *terraStones() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TerraStone>> *>(VT_TERRASTONES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TERRASTONES) &&
           verifier.VerifyVector(terraStones()) &&
           verifier.VerifyVectorOfTables(terraStones()) &&
           verifier.EndTable();
  }
};

struct TerraStoneListNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_terraStones(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TerraStone>>> terraStones) {
    fbb_.AddOffset(TerraStoneListNotify::VT_TERRASTONES, terraStones);
  }
  explicit TerraStoneListNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TerraStoneListNotifyBuilder &operator=(const TerraStoneListNotifyBuilder &);
  flatbuffers::Offset<TerraStoneListNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TerraStoneListNotify>(end);
    fbb_.Required(o, TerraStoneListNotify::VT_TERRASTONES);
    return o;
  }
};

inline flatbuffers::Offset<TerraStoneListNotify> CreateTerraStoneListNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TerraStone>>> terraStones = 0) {
  TerraStoneListNotifyBuilder builder_(_fbb);
  builder_.add_terraStones(terraStones);
  return builder_.Finish();
}

inline flatbuffers::Offset<TerraStoneListNotify> CreateTerraStoneListNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<TerraStone>> *terraStones = nullptr) {
  return LeanPacket::CreateTerraStoneListNotify(
      _fbb,
      terraStones ? _fbb.CreateVector<flatbuffers::Offset<TerraStone>>(*terraStones) : 0);
}

/// TERRASTONE_ENCHANT_REQUEST
struct TerraStoneEnchantRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_COUNT = 6
  };
  int8_t type() const {
    return GetField<int8_t>(VT_TYPE, 0);
  }
  int16_t count() const {
    return GetField<int16_t>(VT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<int16_t>(verifier, VT_COUNT) &&
           verifier.EndTable();
  }
};

struct TerraStoneEnchantRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int8_t type) {
    fbb_.AddElement<int8_t>(TerraStoneEnchantRequest::VT_TYPE, type, 0);
  }
  void add_count(int16_t count) {
    fbb_.AddElement<int16_t>(TerraStoneEnchantRequest::VT_COUNT, count, 0);
  }
  explicit TerraStoneEnchantRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TerraStoneEnchantRequestBuilder &operator=(const TerraStoneEnchantRequestBuilder &);
  flatbuffers::Offset<TerraStoneEnchantRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TerraStoneEnchantRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<TerraStoneEnchantRequest> CreateTerraStoneEnchantRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t type = 0,
    int16_t count = 0) {
  TerraStoneEnchantRequestBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_type(type);
  return builder_.Finish();
}

/// TERRASTONE_ENCHANT_RESPONSE
struct TerraStoneEnchantResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_ERROR = 6,
    VT_LEVEL = 8
  };
  int8_t type() const {
    return GetField<int8_t>(VT_TYPE, 0);
  }
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  int16_t level() const {
    return GetField<int16_t>(VT_LEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           VerifyField<int16_t>(verifier, VT_LEVEL) &&
           verifier.EndTable();
  }
};

struct TerraStoneEnchantResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int8_t type) {
    fbb_.AddElement<int8_t>(TerraStoneEnchantResponse::VT_TYPE, type, 0);
  }
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(TerraStoneEnchantResponse::VT_ERROR, error, 0);
  }
  void add_level(int16_t level) {
    fbb_.AddElement<int16_t>(TerraStoneEnchantResponse::VT_LEVEL, level, 0);
  }
  explicit TerraStoneEnchantResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TerraStoneEnchantResponseBuilder &operator=(const TerraStoneEnchantResponseBuilder &);
  flatbuffers::Offset<TerraStoneEnchantResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TerraStoneEnchantResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<TerraStoneEnchantResponse> CreateTerraStoneEnchantResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t type = 0,
    int32_t error = 0,
    int16_t level = 0) {
  TerraStoneEnchantResponseBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_level(level);
  builder_.add_type(type);
  return builder_.Finish();
}

struct Research FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESEARCHID = 4,
    VT_LEVEL = 6
  };
  int32_t researchId() const {
    return GetField<int32_t>(VT_RESEARCHID, 0);
  }
  uint8_t level() const {
    return GetField<uint8_t>(VT_LEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESEARCHID) &&
           VerifyField<uint8_t>(verifier, VT_LEVEL) &&
           verifier.EndTable();
  }
};

struct ResearchBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_researchId(int32_t researchId) {
    fbb_.AddElement<int32_t>(Research::VT_RESEARCHID, researchId, 0);
  }
  void add_level(uint8_t level) {
    fbb_.AddElement<uint8_t>(Research::VT_LEVEL, level, 0);
  }
  explicit ResearchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResearchBuilder &operator=(const ResearchBuilder &);
  flatbuffers::Offset<Research> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Research>(end);
    return o;
  }
};

inline flatbuffers::Offset<Research> CreateResearch(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t researchId = 0,
    uint8_t level = 0) {
  ResearchBuilder builder_(_fbb);
  builder_.add_researchId(researchId);
  builder_.add_level(level);
  return builder_.Finish();
}

/// RESEARCH_LIST_NOTIFY
struct ResearchListNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESEARCHES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Research>> *researches() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Research>> *>(VT_RESEARCHES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_RESEARCHES) &&
           verifier.VerifyVector(researches()) &&
           verifier.VerifyVectorOfTables(researches()) &&
           verifier.EndTable();
  }
};

struct ResearchListNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_researches(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Research>>> researches) {
    fbb_.AddOffset(ResearchListNotify::VT_RESEARCHES, researches);
  }
  explicit ResearchListNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResearchListNotifyBuilder &operator=(const ResearchListNotifyBuilder &);
  flatbuffers::Offset<ResearchListNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResearchListNotify>(end);
    fbb_.Required(o, ResearchListNotify::VT_RESEARCHES);
    return o;
  }
};

inline flatbuffers::Offset<ResearchListNotify> CreateResearchListNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Research>>> researches = 0) {
  ResearchListNotifyBuilder builder_(_fbb);
  builder_.add_researches(researches);
  return builder_.Finish();
}

inline flatbuffers::Offset<ResearchListNotify> CreateResearchListNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Research>> *researches = nullptr) {
  return LeanPacket::CreateResearchListNotify(
      _fbb,
      researches ? _fbb.CreateVector<flatbuffers::Offset<Research>>(*researches) : 0);
}

/// RESEARCH_ENCHANT_REQUEST
struct ResearchEnchant FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESEARCHID = 4,
    VT_COUNT = 6
  };
  int32_t researchId() const {
    return GetField<int32_t>(VT_RESEARCHID, 0);
  }
  int16_t count() const {
    return GetField<int16_t>(VT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESEARCHID) &&
           VerifyField<int16_t>(verifier, VT_COUNT) &&
           verifier.EndTable();
  }
};

struct ResearchEnchantBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_researchId(int32_t researchId) {
    fbb_.AddElement<int32_t>(ResearchEnchant::VT_RESEARCHID, researchId, 0);
  }
  void add_count(int16_t count) {
    fbb_.AddElement<int16_t>(ResearchEnchant::VT_COUNT, count, 0);
  }
  explicit ResearchEnchantBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResearchEnchantBuilder &operator=(const ResearchEnchantBuilder &);
  flatbuffers::Offset<ResearchEnchant> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResearchEnchant>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResearchEnchant> CreateResearchEnchant(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t researchId = 0,
    int16_t count = 0) {
  ResearchEnchantBuilder builder_(_fbb);
  builder_.add_researchId(researchId);
  builder_.add_count(count);
  return builder_.Finish();
}

struct ResearchEnchantRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LIST = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<ResearchEnchant>> *list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ResearchEnchant>> *>(VT_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LIST) &&
           verifier.VerifyVector(list()) &&
           verifier.VerifyVectorOfTables(list()) &&
           verifier.EndTable();
  }
};

struct ResearchEnchantRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ResearchEnchant>>> list) {
    fbb_.AddOffset(ResearchEnchantRequest::VT_LIST, list);
  }
  explicit ResearchEnchantRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResearchEnchantRequestBuilder &operator=(const ResearchEnchantRequestBuilder &);
  flatbuffers::Offset<ResearchEnchantRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResearchEnchantRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResearchEnchantRequest> CreateResearchEnchantRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ResearchEnchant>>> list = 0) {
  ResearchEnchantRequestBuilder builder_(_fbb);
  builder_.add_list(list);
  return builder_.Finish();
}

inline flatbuffers::Offset<ResearchEnchantRequest> CreateResearchEnchantRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<ResearchEnchant>> *list = nullptr) {
  return LeanPacket::CreateResearchEnchantRequest(
      _fbb,
      list ? _fbb.CreateVector<flatbuffers::Offset<ResearchEnchant>>(*list) : 0);
}

/// RESEARCH_ENCHANT_RESPONSE
struct ResearchEnchantResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LIST = 4,
    VT_ERROR = 6,
    VT_UPDATE = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<ResearchEnchant>> *list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ResearchEnchant>> *>(VT_LIST);
  }
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Research>> *update() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Research>> *>(VT_UPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LIST) &&
           verifier.VerifyVector(list()) &&
           verifier.VerifyVectorOfTables(list()) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyVector(update()) &&
           verifier.VerifyVectorOfTables(update()) &&
           verifier.EndTable();
  }
};

struct ResearchEnchantResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ResearchEnchant>>> list) {
    fbb_.AddOffset(ResearchEnchantResponse::VT_LIST, list);
  }
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(ResearchEnchantResponse::VT_ERROR, error, 0);
  }
  void add_update(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Research>>> update) {
    fbb_.AddOffset(ResearchEnchantResponse::VT_UPDATE, update);
  }
  explicit ResearchEnchantResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResearchEnchantResponseBuilder &operator=(const ResearchEnchantResponseBuilder &);
  flatbuffers::Offset<ResearchEnchantResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResearchEnchantResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResearchEnchantResponse> CreateResearchEnchantResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ResearchEnchant>>> list = 0,
    int32_t error = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Research>>> update = 0) {
  ResearchEnchantResponseBuilder builder_(_fbb);
  builder_.add_update(update);
  builder_.add_error(error);
  builder_.add_list(list);
  return builder_.Finish();
}

inline flatbuffers::Offset<ResearchEnchantResponse> CreateResearchEnchantResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<ResearchEnchant>> *list = nullptr,
    int32_t error = 0,
    const std::vector<flatbuffers::Offset<Research>> *update = nullptr) {
  return LeanPacket::CreateResearchEnchantResponse(
      _fbb,
      list ? _fbb.CreateVector<flatbuffers::Offset<ResearchEnchant>>(*list) : 0,
      error,
      update ? _fbb.CreateVector<flatbuffers::Offset<Research>>(*update) : 0);
}

struct GuardianStar FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_GRADE = 6,
    VT_LEVEL = 8
  };
  int8_t type() const {
    return GetField<int8_t>(VT_TYPE, 0);
  }
  uint8_t grade() const {
    return GetField<uint8_t>(VT_GRADE, 0);
  }
  uint8_t level() const {
    return GetField<uint8_t>(VT_LEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_GRADE) &&
           VerifyField<uint8_t>(verifier, VT_LEVEL) &&
           verifier.EndTable();
  }
};

struct GuardianStarBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int8_t type) {
    fbb_.AddElement<int8_t>(GuardianStar::VT_TYPE, type, 0);
  }
  void add_grade(uint8_t grade) {
    fbb_.AddElement<uint8_t>(GuardianStar::VT_GRADE, grade, 0);
  }
  void add_level(uint8_t level) {
    fbb_.AddElement<uint8_t>(GuardianStar::VT_LEVEL, level, 0);
  }
  explicit GuardianStarBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuardianStarBuilder &operator=(const GuardianStarBuilder &);
  flatbuffers::Offset<GuardianStar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuardianStar>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuardianStar> CreateGuardianStar(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t type = 0,
    uint8_t grade = 0,
    uint8_t level = 0) {
  GuardianStarBuilder builder_(_fbb);
  builder_.add_level(level);
  builder_.add_grade(grade);
  builder_.add_type(type);
  return builder_.Finish();
}

/// GUARDIAN_STAR_LIST_NOTIFY
struct GuardianStarListNofity FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GUARDIANSTARS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<GuardianStar>> *guardianStars() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GuardianStar>> *>(VT_GUARDIANSTARS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_GUARDIANSTARS) &&
           verifier.VerifyVector(guardianStars()) &&
           verifier.VerifyVectorOfTables(guardianStars()) &&
           verifier.EndTable();
  }
};

struct GuardianStarListNofityBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_guardianStars(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuardianStar>>> guardianStars) {
    fbb_.AddOffset(GuardianStarListNofity::VT_GUARDIANSTARS, guardianStars);
  }
  explicit GuardianStarListNofityBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuardianStarListNofityBuilder &operator=(const GuardianStarListNofityBuilder &);
  flatbuffers::Offset<GuardianStarListNofity> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuardianStarListNofity>(end);
    fbb_.Required(o, GuardianStarListNofity::VT_GUARDIANSTARS);
    return o;
  }
};

inline flatbuffers::Offset<GuardianStarListNofity> CreateGuardianStarListNofity(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuardianStar>>> guardianStars = 0) {
  GuardianStarListNofityBuilder builder_(_fbb);
  builder_.add_guardianStars(guardianStars);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuardianStarListNofity> CreateGuardianStarListNofityDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<GuardianStar>> *guardianStars = nullptr) {
  return LeanPacket::CreateGuardianStarListNofity(
      _fbb,
      guardianStars ? _fbb.CreateVector<flatbuffers::Offset<GuardianStar>>(*guardianStars) : 0);
}

/// GUARDIAN_STAR_ENCHANT_REQUEST
struct GuardianStarEnchantRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_COUNT = 6
  };
  int8_t type() const {
    return GetField<int8_t>(VT_TYPE, 0);
  }
  int16_t count() const {
    return GetField<int16_t>(VT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<int16_t>(verifier, VT_COUNT) &&
           verifier.EndTable();
  }
};

struct GuardianStarEnchantRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int8_t type) {
    fbb_.AddElement<int8_t>(GuardianStarEnchantRequest::VT_TYPE, type, 0);
  }
  void add_count(int16_t count) {
    fbb_.AddElement<int16_t>(GuardianStarEnchantRequest::VT_COUNT, count, 0);
  }
  explicit GuardianStarEnchantRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuardianStarEnchantRequestBuilder &operator=(const GuardianStarEnchantRequestBuilder &);
  flatbuffers::Offset<GuardianStarEnchantRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuardianStarEnchantRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuardianStarEnchantRequest> CreateGuardianStarEnchantRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t type = 0,
    int16_t count = 0) {
  GuardianStarEnchantRequestBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_type(type);
  return builder_.Finish();
}

/// GUARDIAN_STAR_ENCHANT_RESPONSE
struct GuardianStarEnchantResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_ERROR = 6,
    VT_LEVEL = 8,
    VT_GRADE = 10
  };
  int8_t type() const {
    return GetField<int8_t>(VT_TYPE, 0);
  }
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  int8_t level() const {
    return GetField<int8_t>(VT_LEVEL, 0);
  }
  int8_t grade() const {
    return GetField<int8_t>(VT_GRADE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           VerifyField<int8_t>(verifier, VT_LEVEL) &&
           VerifyField<int8_t>(verifier, VT_GRADE) &&
           verifier.EndTable();
  }
};

struct GuardianStarEnchantResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int8_t type) {
    fbb_.AddElement<int8_t>(GuardianStarEnchantResponse::VT_TYPE, type, 0);
  }
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(GuardianStarEnchantResponse::VT_ERROR, error, 0);
  }
  void add_level(int8_t level) {
    fbb_.AddElement<int8_t>(GuardianStarEnchantResponse::VT_LEVEL, level, 0);
  }
  void add_grade(int8_t grade) {
    fbb_.AddElement<int8_t>(GuardianStarEnchantResponse::VT_GRADE, grade, 0);
  }
  explicit GuardianStarEnchantResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuardianStarEnchantResponseBuilder &operator=(const GuardianStarEnchantResponseBuilder &);
  flatbuffers::Offset<GuardianStarEnchantResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuardianStarEnchantResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuardianStarEnchantResponse> CreateGuardianStarEnchantResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t type = 0,
    int32_t error = 0,
    int8_t level = 0,
    int8_t grade = 0) {
  GuardianStarEnchantResponseBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_grade(grade);
  builder_.add_level(level);
  builder_.add_type(type);
  return builder_.Finish();
}

/// GUARDIAN_STAR_UPGRADE_REQUEST
struct GuardianStarUpgradeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4
  };
  int8_t type() const {
    return GetField<int8_t>(VT_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct GuardianStarUpgradeRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int8_t type) {
    fbb_.AddElement<int8_t>(GuardianStarUpgradeRequest::VT_TYPE, type, 0);
  }
  explicit GuardianStarUpgradeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuardianStarUpgradeRequestBuilder &operator=(const GuardianStarUpgradeRequestBuilder &);
  flatbuffers::Offset<GuardianStarUpgradeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuardianStarUpgradeRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuardianStarUpgradeRequest> CreateGuardianStarUpgradeRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t type = 0) {
  GuardianStarUpgradeRequestBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

/// GUARDIAN_STAR_UPGRADE_REQUEST
struct GuardianStarUpgradeResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_ERROR = 6,
    VT_GRADE = 8
  };
  int8_t type() const {
    return GetField<int8_t>(VT_TYPE, 0);
  }
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  int8_t grade() const {
    return GetField<int8_t>(VT_GRADE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           VerifyField<int8_t>(verifier, VT_GRADE) &&
           verifier.EndTable();
  }
};

struct GuardianStarUpgradeResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int8_t type) {
    fbb_.AddElement<int8_t>(GuardianStarUpgradeResponse::VT_TYPE, type, 0);
  }
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(GuardianStarUpgradeResponse::VT_ERROR, error, 0);
  }
  void add_grade(int8_t grade) {
    fbb_.AddElement<int8_t>(GuardianStarUpgradeResponse::VT_GRADE, grade, 0);
  }
  explicit GuardianStarUpgradeResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuardianStarUpgradeResponseBuilder &operator=(const GuardianStarUpgradeResponseBuilder &);
  flatbuffers::Offset<GuardianStarUpgradeResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuardianStarUpgradeResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuardianStarUpgradeResponse> CreateGuardianStarUpgradeResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t type = 0,
    int32_t error = 0,
    int8_t grade = 0) {
  GuardianStarUpgradeResponseBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_grade(grade);
  builder_.add_type(type);
  return builder_.Finish();
}

struct PassiveSkill FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PASSIVESKILLID = 4,
    VT_LEVEL = 6
  };
  int32_t passiveSkillId() const {
    return GetField<int32_t>(VT_PASSIVESKILLID, 0);
  }
  uint8_t level() const {
    return GetField<uint8_t>(VT_LEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PASSIVESKILLID) &&
           VerifyField<uint8_t>(verifier, VT_LEVEL) &&
           verifier.EndTable();
  }
};

struct PassiveSkillBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_passiveSkillId(int32_t passiveSkillId) {
    fbb_.AddElement<int32_t>(PassiveSkill::VT_PASSIVESKILLID, passiveSkillId, 0);
  }
  void add_level(uint8_t level) {
    fbb_.AddElement<uint8_t>(PassiveSkill::VT_LEVEL, level, 0);
  }
  explicit PassiveSkillBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PassiveSkillBuilder &operator=(const PassiveSkillBuilder &);
  flatbuffers::Offset<PassiveSkill> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PassiveSkill>(end);
    return o;
  }
};

inline flatbuffers::Offset<PassiveSkill> CreatePassiveSkill(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t passiveSkillId = 0,
    uint8_t level = 0) {
  PassiveSkillBuilder builder_(_fbb);
  builder_.add_passiveSkillId(passiveSkillId);
  builder_.add_level(level);
  return builder_.Finish();
}

/// PASSIVE_SKILL_LIST_NOTIFY
struct PassiveSkillListNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PASSIVESKILLS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<PassiveSkill>> *passiveSkills() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PassiveSkill>> *>(VT_PASSIVESKILLS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PASSIVESKILLS) &&
           verifier.VerifyVector(passiveSkills()) &&
           verifier.VerifyVectorOfTables(passiveSkills()) &&
           verifier.EndTable();
  }
};

struct PassiveSkillListNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_passiveSkills(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PassiveSkill>>> passiveSkills) {
    fbb_.AddOffset(PassiveSkillListNotify::VT_PASSIVESKILLS, passiveSkills);
  }
  explicit PassiveSkillListNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PassiveSkillListNotifyBuilder &operator=(const PassiveSkillListNotifyBuilder &);
  flatbuffers::Offset<PassiveSkillListNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PassiveSkillListNotify>(end);
    fbb_.Required(o, PassiveSkillListNotify::VT_PASSIVESKILLS);
    return o;
  }
};

inline flatbuffers::Offset<PassiveSkillListNotify> CreatePassiveSkillListNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PassiveSkill>>> passiveSkills = 0) {
  PassiveSkillListNotifyBuilder builder_(_fbb);
  builder_.add_passiveSkills(passiveSkills);
  return builder_.Finish();
}

inline flatbuffers::Offset<PassiveSkillListNotify> CreatePassiveSkillListNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<PassiveSkill>> *passiveSkills = nullptr) {
  return LeanPacket::CreatePassiveSkillListNotify(
      _fbb,
      passiveSkills ? _fbb.CreateVector<flatbuffers::Offset<PassiveSkill>>(*passiveSkills) : 0);
}

/// PASSIVE_SKILL_ENCHANT_REQUEST
struct PassiveSkillEnchantRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PASSIVESKILLID = 4
  };
  int32_t passiveSkillId() const {
    return GetField<int32_t>(VT_PASSIVESKILLID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PASSIVESKILLID) &&
           verifier.EndTable();
  }
};

struct PassiveSkillEnchantRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_passiveSkillId(int32_t passiveSkillId) {
    fbb_.AddElement<int32_t>(PassiveSkillEnchantRequest::VT_PASSIVESKILLID, passiveSkillId, 0);
  }
  explicit PassiveSkillEnchantRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PassiveSkillEnchantRequestBuilder &operator=(const PassiveSkillEnchantRequestBuilder &);
  flatbuffers::Offset<PassiveSkillEnchantRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PassiveSkillEnchantRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<PassiveSkillEnchantRequest> CreatePassiveSkillEnchantRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t passiveSkillId = 0) {
  PassiveSkillEnchantRequestBuilder builder_(_fbb);
  builder_.add_passiveSkillId(passiveSkillId);
  return builder_.Finish();
}

/// PASSIVE_SKILL_ENCHANT_RESPONSE
struct PassiveSkillEnchantResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PASSIVESKILLID = 4,
    VT_ERROR = 6,
    VT_LEVEL = 8
  };
  int32_t passiveSkillId() const {
    return GetField<int32_t>(VT_PASSIVESKILLID, 0);
  }
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  int8_t level() const {
    return GetField<int8_t>(VT_LEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PASSIVESKILLID) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           VerifyField<int8_t>(verifier, VT_LEVEL) &&
           verifier.EndTable();
  }
};

struct PassiveSkillEnchantResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_passiveSkillId(int32_t passiveSkillId) {
    fbb_.AddElement<int32_t>(PassiveSkillEnchantResponse::VT_PASSIVESKILLID, passiveSkillId, 0);
  }
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(PassiveSkillEnchantResponse::VT_ERROR, error, 0);
  }
  void add_level(int8_t level) {
    fbb_.AddElement<int8_t>(PassiveSkillEnchantResponse::VT_LEVEL, level, 0);
  }
  explicit PassiveSkillEnchantResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PassiveSkillEnchantResponseBuilder &operator=(const PassiveSkillEnchantResponseBuilder &);
  flatbuffers::Offset<PassiveSkillEnchantResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PassiveSkillEnchantResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<PassiveSkillEnchantResponse> CreatePassiveSkillEnchantResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t passiveSkillId = 0,
    int32_t error = 0,
    int8_t level = 0) {
  PassiveSkillEnchantResponseBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_passiveSkillId(passiveSkillId);
  builder_.add_level(level);
  return builder_.Finish();
}

struct PotionGrowth FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_LEVEL = 6,
    VT_EXP = 8
  };
  int8_t type() const {
    return GetField<int8_t>(VT_TYPE, 0);
  }
  int16_t level() const {
    return GetField<int16_t>(VT_LEVEL, 0);
  }
  int32_t exp() const {
    return GetField<int32_t>(VT_EXP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<int16_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_EXP) &&
           verifier.EndTable();
  }
};

struct PotionGrowthBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int8_t type) {
    fbb_.AddElement<int8_t>(PotionGrowth::VT_TYPE, type, 0);
  }
  void add_level(int16_t level) {
    fbb_.AddElement<int16_t>(PotionGrowth::VT_LEVEL, level, 0);
  }
  void add_exp(int32_t exp) {
    fbb_.AddElement<int32_t>(PotionGrowth::VT_EXP, exp, 0);
  }
  explicit PotionGrowthBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PotionGrowthBuilder &operator=(const PotionGrowthBuilder &);
  flatbuffers::Offset<PotionGrowth> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PotionGrowth>(end);
    return o;
  }
};

inline flatbuffers::Offset<PotionGrowth> CreatePotionGrowth(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t type = 0,
    int16_t level = 0,
    int32_t exp = 0) {
  PotionGrowthBuilder builder_(_fbb);
  builder_.add_exp(exp);
  builder_.add_level(level);
  builder_.add_type(type);
  return builder_.Finish();
}

/// POTION_GROWTH_LIST_NOTIFY
struct PotionGrowthListNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_POTIONGROWTHS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<PotionGrowth>> *potionGrowths() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PotionGrowth>> *>(VT_POTIONGROWTHS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_POTIONGROWTHS) &&
           verifier.VerifyVector(potionGrowths()) &&
           verifier.VerifyVectorOfTables(potionGrowths()) &&
           verifier.EndTable();
  }
};

struct PotionGrowthListNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_potionGrowths(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PotionGrowth>>> potionGrowths) {
    fbb_.AddOffset(PotionGrowthListNotify::VT_POTIONGROWTHS, potionGrowths);
  }
  explicit PotionGrowthListNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PotionGrowthListNotifyBuilder &operator=(const PotionGrowthListNotifyBuilder &);
  flatbuffers::Offset<PotionGrowthListNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PotionGrowthListNotify>(end);
    fbb_.Required(o, PotionGrowthListNotify::VT_POTIONGROWTHS);
    return o;
  }
};

inline flatbuffers::Offset<PotionGrowthListNotify> CreatePotionGrowthListNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PotionGrowth>>> potionGrowths = 0) {
  PotionGrowthListNotifyBuilder builder_(_fbb);
  builder_.add_potionGrowths(potionGrowths);
  return builder_.Finish();
}

inline flatbuffers::Offset<PotionGrowthListNotify> CreatePotionGrowthListNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<PotionGrowth>> *potionGrowths = nullptr) {
  return LeanPacket::CreatePotionGrowthListNotify(
      _fbb,
      potionGrowths ? _fbb.CreateVector<flatbuffers::Offset<PotionGrowth>>(*potionGrowths) : 0);
}

/// POTION_GROWTH_UPDATE_NOTIFY
struct PotionGrowthUpdateNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_UPDATE = 4
  };
  const PotionGrowth *update() const {
    return GetPointer<const PotionGrowth *>(VT_UPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           verifier.EndTable();
  }
};

struct PotionGrowthUpdateNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_update(flatbuffers::Offset<PotionGrowth> update) {
    fbb_.AddOffset(PotionGrowthUpdateNotify::VT_UPDATE, update);
  }
  explicit PotionGrowthUpdateNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PotionGrowthUpdateNotifyBuilder &operator=(const PotionGrowthUpdateNotifyBuilder &);
  flatbuffers::Offset<PotionGrowthUpdateNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PotionGrowthUpdateNotify>(end);
    fbb_.Required(o, PotionGrowthUpdateNotify::VT_UPDATE);
    return o;
  }
};

inline flatbuffers::Offset<PotionGrowthUpdateNotify> CreatePotionGrowthUpdateNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<PotionGrowth> update = 0) {
  PotionGrowthUpdateNotifyBuilder builder_(_fbb);
  builder_.add_update(update);
  return builder_.Finish();
}

/// POTION_GROWTH_LEVEL_UP_REQUEST
struct PotionGrowthLevelUpRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4
  };
  int8_t type() const {
    return GetField<int8_t>(VT_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct PotionGrowthLevelUpRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int8_t type) {
    fbb_.AddElement<int8_t>(PotionGrowthLevelUpRequest::VT_TYPE, type, 0);
  }
  explicit PotionGrowthLevelUpRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PotionGrowthLevelUpRequestBuilder &operator=(const PotionGrowthLevelUpRequestBuilder &);
  flatbuffers::Offset<PotionGrowthLevelUpRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PotionGrowthLevelUpRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<PotionGrowthLevelUpRequest> CreatePotionGrowthLevelUpRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t type = 0) {
  PotionGrowthLevelUpRequestBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

/// POTION_GROWTH_LEVEL_UP_RESPONSE
struct PotionGrowthLevelUpResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_ERROR = 6,
    VT_UPDATE = 8
  };
  int8_t type() const {
    return GetField<int8_t>(VT_TYPE, 0);
  }
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  const PotionGrowth *update() const {
    return GetPointer<const PotionGrowth *>(VT_UPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           verifier.EndTable();
  }
};

struct PotionGrowthLevelUpResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int8_t type) {
    fbb_.AddElement<int8_t>(PotionGrowthLevelUpResponse::VT_TYPE, type, 0);
  }
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(PotionGrowthLevelUpResponse::VT_ERROR, error, 0);
  }
  void add_update(flatbuffers::Offset<PotionGrowth> update) {
    fbb_.AddOffset(PotionGrowthLevelUpResponse::VT_UPDATE, update);
  }
  explicit PotionGrowthLevelUpResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PotionGrowthLevelUpResponseBuilder &operator=(const PotionGrowthLevelUpResponseBuilder &);
  flatbuffers::Offset<PotionGrowthLevelUpResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PotionGrowthLevelUpResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<PotionGrowthLevelUpResponse> CreatePotionGrowthLevelUpResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t type = 0,
    int32_t error = 0,
    flatbuffers::Offset<PotionGrowth> update = 0) {
  PotionGrowthLevelUpResponseBuilder builder_(_fbb);
  builder_.add_update(update);
  builder_.add_error(error);
  builder_.add_type(type);
  return builder_.Finish();
}

/// Upc 기본정보
struct UpcCacheInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_ACCOUNTDBID = 6,
    VT_PCDBID = 8,
    VT_DBSEVERID = 10,
    VT_PCNAME = 12,
    VT_LEVEL = 14,
    VT_CLASSTYPE = 16,
    VT_COMBATPOWER = 18,
    VT_CUSTOMIZINGINFO = 20,
    VT_PARTS = 22
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int64_t accountDbId() const {
    return GetField<int64_t>(VT_ACCOUNTDBID, 0);
  }
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  int16_t dbSeverId() const {
    return GetField<int16_t>(VT_DBSEVERID, 0);
  }
  const flatbuffers::String *pcName() const {
    return GetPointer<const flatbuffers::String *>(VT_PCNAME);
  }
  int16_t level() const {
    return GetField<int16_t>(VT_LEVEL, 0);
  }
  int16_t classType() const {
    return GetField<int16_t>(VT_CLASSTYPE, 0);
  }
  int32_t combatPower() const {
    return GetField<int32_t>(VT_COMBATPOWER, 0);
  }
  const CustomizeInfo *customizingInfo() const {
    return GetPointer<const CustomizeInfo *>(VT_CUSTOMIZINGINFO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ItemPartsInfo>> *parts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ItemPartsInfo>> *>(VT_PARTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int64_t>(verifier, VT_ACCOUNTDBID) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           VerifyField<int16_t>(verifier, VT_DBSEVERID) &&
           VerifyOffsetRequired(verifier, VT_PCNAME) &&
           verifier.VerifyString(pcName()) &&
           VerifyField<int16_t>(verifier, VT_LEVEL) &&
           VerifyField<int16_t>(verifier, VT_CLASSTYPE) &&
           VerifyField<int32_t>(verifier, VT_COMBATPOWER) &&
           VerifyOffsetRequired(verifier, VT_CUSTOMIZINGINFO) &&
           verifier.VerifyTable(customizingInfo()) &&
           VerifyOffsetRequired(verifier, VT_PARTS) &&
           verifier.VerifyVector(parts()) &&
           verifier.VerifyVectorOfTables(parts()) &&
           verifier.EndTable();
  }
};

struct UpcCacheInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(UpcCacheInfo::VT_OBJECTID, objectId, 0);
  }
  void add_accountDbId(int64_t accountDbId) {
    fbb_.AddElement<int64_t>(UpcCacheInfo::VT_ACCOUNTDBID, accountDbId, 0);
  }
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(UpcCacheInfo::VT_PCDBID, pcDbId, 0);
  }
  void add_dbSeverId(int16_t dbSeverId) {
    fbb_.AddElement<int16_t>(UpcCacheInfo::VT_DBSEVERID, dbSeverId, 0);
  }
  void add_pcName(flatbuffers::Offset<flatbuffers::String> pcName) {
    fbb_.AddOffset(UpcCacheInfo::VT_PCNAME, pcName);
  }
  void add_level(int16_t level) {
    fbb_.AddElement<int16_t>(UpcCacheInfo::VT_LEVEL, level, 0);
  }
  void add_classType(int16_t classType) {
    fbb_.AddElement<int16_t>(UpcCacheInfo::VT_CLASSTYPE, classType, 0);
  }
  void add_combatPower(int32_t combatPower) {
    fbb_.AddElement<int32_t>(UpcCacheInfo::VT_COMBATPOWER, combatPower, 0);
  }
  void add_customizingInfo(flatbuffers::Offset<CustomizeInfo> customizingInfo) {
    fbb_.AddOffset(UpcCacheInfo::VT_CUSTOMIZINGINFO, customizingInfo);
  }
  void add_parts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ItemPartsInfo>>> parts) {
    fbb_.AddOffset(UpcCacheInfo::VT_PARTS, parts);
  }
  explicit UpcCacheInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UpcCacheInfoBuilder &operator=(const UpcCacheInfoBuilder &);
  flatbuffers::Offset<UpcCacheInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UpcCacheInfo>(end);
    fbb_.Required(o, UpcCacheInfo::VT_PCNAME);
    fbb_.Required(o, UpcCacheInfo::VT_CUSTOMIZINGINFO);
    fbb_.Required(o, UpcCacheInfo::VT_PARTS);
    return o;
  }
};

inline flatbuffers::Offset<UpcCacheInfo> CreateUpcCacheInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int64_t accountDbId = 0,
    int64_t pcDbId = 0,
    int16_t dbSeverId = 0,
    flatbuffers::Offset<flatbuffers::String> pcName = 0,
    int16_t level = 0,
    int16_t classType = 0,
    int32_t combatPower = 0,
    flatbuffers::Offset<CustomizeInfo> customizingInfo = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ItemPartsInfo>>> parts = 0) {
  UpcCacheInfoBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  builder_.add_accountDbId(accountDbId);
  builder_.add_objectId(objectId);
  builder_.add_parts(parts);
  builder_.add_customizingInfo(customizingInfo);
  builder_.add_combatPower(combatPower);
  builder_.add_pcName(pcName);
  builder_.add_classType(classType);
  builder_.add_level(level);
  builder_.add_dbSeverId(dbSeverId);
  return builder_.Finish();
}

inline flatbuffers::Offset<UpcCacheInfo> CreateUpcCacheInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int64_t accountDbId = 0,
    int64_t pcDbId = 0,
    int16_t dbSeverId = 0,
    const char *pcName = nullptr,
    int16_t level = 0,
    int16_t classType = 0,
    int32_t combatPower = 0,
    flatbuffers::Offset<CustomizeInfo> customizingInfo = 0,
    const std::vector<flatbuffers::Offset<ItemPartsInfo>> *parts = nullptr) {
  return LeanPacket::CreateUpcCacheInfo(
      _fbb,
      objectId,
      accountDbId,
      pcDbId,
      dbSeverId,
      pcName ? _fbb.CreateString(pcName) : 0,
      level,
      classType,
      combatPower,
      customizingInfo,
      parts ? _fbb.CreateVector<flatbuffers::Offset<ItemPartsInfo>>(*parts) : 0);
}

/// RVR_STANDBY_INFO_REQUEST
struct RVRStandbyOrderRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RVRID = 4
  };
  int32_t rvrId() const {
    return GetField<int32_t>(VT_RVRID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RVRID) &&
           verifier.EndTable();
  }
};

struct RVRStandbyOrderRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rvrId(int32_t rvrId) {
    fbb_.AddElement<int32_t>(RVRStandbyOrderRequest::VT_RVRID, rvrId, 0);
  }
  explicit RVRStandbyOrderRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRStandbyOrderRequestBuilder &operator=(const RVRStandbyOrderRequestBuilder &);
  flatbuffers::Offset<RVRStandbyOrderRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRStandbyOrderRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRStandbyOrderRequest> CreateRVRStandbyOrderRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rvrId = 0) {
  RVRStandbyOrderRequestBuilder builder_(_fbb);
  builder_.add_rvrId(rvrId);
  return builder_.Finish();
}

/// RVR_STANDBY_INFO_RESPONSE
struct RVRStandbyOrderResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RVRID = 4,
    VT_CURPLAYERS = 6,
    VT_MAXPLAYERS = 8,
    VT_DUGOUT = 10,
    VT_STANDBY = 12,
    VT_ERRCODE = 14
  };
  int32_t rvrId() const {
    return GetField<int32_t>(VT_RVRID, 0);
  }
  int32_t curPlayers() const {
    return GetField<int32_t>(VT_CURPLAYERS, 0);
  }
  int32_t maxPlayers() const {
    return GetField<int32_t>(VT_MAXPLAYERS, 0);
  }
  int32_t dugout() const {
    return GetField<int32_t>(VT_DUGOUT, 0);
  }
  int32_t standby() const {
    return GetField<int32_t>(VT_STANDBY, 0);
  }
  ErrorCode errCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RVRID) &&
           VerifyField<int32_t>(verifier, VT_CURPLAYERS) &&
           VerifyField<int32_t>(verifier, VT_MAXPLAYERS) &&
           VerifyField<int32_t>(verifier, VT_DUGOUT) &&
           VerifyField<int32_t>(verifier, VT_STANDBY) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           verifier.EndTable();
  }
};

struct RVRStandbyOrderResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rvrId(int32_t rvrId) {
    fbb_.AddElement<int32_t>(RVRStandbyOrderResponse::VT_RVRID, rvrId, 0);
  }
  void add_curPlayers(int32_t curPlayers) {
    fbb_.AddElement<int32_t>(RVRStandbyOrderResponse::VT_CURPLAYERS, curPlayers, 0);
  }
  void add_maxPlayers(int32_t maxPlayers) {
    fbb_.AddElement<int32_t>(RVRStandbyOrderResponse::VT_MAXPLAYERS, maxPlayers, 0);
  }
  void add_dugout(int32_t dugout) {
    fbb_.AddElement<int32_t>(RVRStandbyOrderResponse::VT_DUGOUT, dugout, 0);
  }
  void add_standby(int32_t standby) {
    fbb_.AddElement<int32_t>(RVRStandbyOrderResponse::VT_STANDBY, standby, 0);
  }
  void add_errCode(ErrorCode errCode) {
    fbb_.AddElement<int32_t>(RVRStandbyOrderResponse::VT_ERRCODE, static_cast<int32_t>(errCode), 0);
  }
  explicit RVRStandbyOrderResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRStandbyOrderResponseBuilder &operator=(const RVRStandbyOrderResponseBuilder &);
  flatbuffers::Offset<RVRStandbyOrderResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRStandbyOrderResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRStandbyOrderResponse> CreateRVRStandbyOrderResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rvrId = 0,
    int32_t curPlayers = 0,
    int32_t maxPlayers = 0,
    int32_t dugout = 0,
    int32_t standby = 0,
    ErrorCode errCode = ErrorCode_NONE) {
  RVRStandbyOrderResponseBuilder builder_(_fbb);
  builder_.add_errCode(errCode);
  builder_.add_standby(standby);
  builder_.add_dugout(dugout);
  builder_.add_maxPlayers(maxPlayers);
  builder_.add_curPlayers(curPlayers);
  builder_.add_rvrId(rvrId);
  return builder_.Finish();
}

/// RVR_JOIN_REQUEST
struct RVRJoinRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RVRID = 4
  };
  int32_t rvrId() const {
    return GetField<int32_t>(VT_RVRID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RVRID) &&
           verifier.EndTable();
  }
};

struct RVRJoinRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rvrId(int32_t rvrId) {
    fbb_.AddElement<int32_t>(RVRJoinRequest::VT_RVRID, rvrId, 0);
  }
  explicit RVRJoinRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRJoinRequestBuilder &operator=(const RVRJoinRequestBuilder &);
  flatbuffers::Offset<RVRJoinRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRJoinRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRJoinRequest> CreateRVRJoinRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rvrId = 0) {
  RVRJoinRequestBuilder builder_(_fbb);
  builder_.add_rvrId(rvrId);
  return builder_.Finish();
}

///  RVR_JOIN_RESPONSE
struct RVRJoinResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RVRID = 4,
    VT_ERRCODE = 6,
    VT_TIMEINDEX = 8
  };
  int32_t rvrId() const {
    return GetField<int32_t>(VT_RVRID, 0);
  }
  ErrorCode errCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRCODE, 0));
  }
  int32_t timeIndex() const {
    return GetField<int32_t>(VT_TIMEINDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RVRID) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           VerifyField<int32_t>(verifier, VT_TIMEINDEX) &&
           verifier.EndTable();
  }
};

struct RVRJoinResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rvrId(int32_t rvrId) {
    fbb_.AddElement<int32_t>(RVRJoinResponse::VT_RVRID, rvrId, 0);
  }
  void add_errCode(ErrorCode errCode) {
    fbb_.AddElement<int32_t>(RVRJoinResponse::VT_ERRCODE, static_cast<int32_t>(errCode), 0);
  }
  void add_timeIndex(int32_t timeIndex) {
    fbb_.AddElement<int32_t>(RVRJoinResponse::VT_TIMEINDEX, timeIndex, 0);
  }
  explicit RVRJoinResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRJoinResponseBuilder &operator=(const RVRJoinResponseBuilder &);
  flatbuffers::Offset<RVRJoinResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRJoinResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRJoinResponse> CreateRVRJoinResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rvrId = 0,
    ErrorCode errCode = ErrorCode_NONE,
    int32_t timeIndex = 0) {
  RVRJoinResponseBuilder builder_(_fbb);
  builder_.add_timeIndex(timeIndex);
  builder_.add_errCode(errCode);
  builder_.add_rvrId(rvrId);
  return builder_.Finish();
}

/// RVR_RESERVATION_REQUEST 
struct RVRReservationRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RVRID = 4
  };
  int32_t rvrId() const {
    return GetField<int32_t>(VT_RVRID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RVRID) &&
           verifier.EndTable();
  }
};

struct RVRReservationRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rvrId(int32_t rvrId) {
    fbb_.AddElement<int32_t>(RVRReservationRequest::VT_RVRID, rvrId, 0);
  }
  explicit RVRReservationRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRReservationRequestBuilder &operator=(const RVRReservationRequestBuilder &);
  flatbuffers::Offset<RVRReservationRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRReservationRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRReservationRequest> CreateRVRReservationRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rvrId = 0) {
  RVRReservationRequestBuilder builder_(_fbb);
  builder_.add_rvrId(rvrId);
  return builder_.Finish();
}

///  RVR_RESERVATION_REQUEST 
struct RVRReservationResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RVRID = 4,
    VT_ERRCODE = 6
  };
  int32_t rvrId() const {
    return GetField<int32_t>(VT_RVRID, 0);
  }
  ErrorCode errCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RVRID) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           verifier.EndTable();
  }
};

struct RVRReservationResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rvrId(int32_t rvrId) {
    fbb_.AddElement<int32_t>(RVRReservationResponse::VT_RVRID, rvrId, 0);
  }
  void add_errCode(ErrorCode errCode) {
    fbb_.AddElement<int32_t>(RVRReservationResponse::VT_ERRCODE, static_cast<int32_t>(errCode), 0);
  }
  explicit RVRReservationResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRReservationResponseBuilder &operator=(const RVRReservationResponseBuilder &);
  flatbuffers::Offset<RVRReservationResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRReservationResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRReservationResponse> CreateRVRReservationResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rvrId = 0,
    ErrorCode errCode = ErrorCode_NONE) {
  RVRReservationResponseBuilder builder_(_fbb);
  builder_.add_errCode(errCode);
  builder_.add_rvrId(rvrId);
  return builder_.Finish();
}

/// RVR_CANCEL_REQUEST
struct RVRCancelRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RVRID = 4
  };
  int32_t rvrId() const {
    return GetField<int32_t>(VT_RVRID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RVRID) &&
           verifier.EndTable();
  }
};

struct RVRCancelRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rvrId(int32_t rvrId) {
    fbb_.AddElement<int32_t>(RVRCancelRequest::VT_RVRID, rvrId, 0);
  }
  explicit RVRCancelRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRCancelRequestBuilder &operator=(const RVRCancelRequestBuilder &);
  flatbuffers::Offset<RVRCancelRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRCancelRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRCancelRequest> CreateRVRCancelRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rvrId = 0) {
  RVRCancelRequestBuilder builder_(_fbb);
  builder_.add_rvrId(rvrId);
  return builder_.Finish();
}

///  RVR_CANCEL_REQUEST
struct RVRCancelResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RVRID = 4,
    VT_ERRCODE = 6
  };
  int32_t rvrId() const {
    return GetField<int32_t>(VT_RVRID, 0);
  }
  ErrorCode errCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RVRID) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           verifier.EndTable();
  }
};

struct RVRCancelResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rvrId(int32_t rvrId) {
    fbb_.AddElement<int32_t>(RVRCancelResponse::VT_RVRID, rvrId, 0);
  }
  void add_errCode(ErrorCode errCode) {
    fbb_.AddElement<int32_t>(RVRCancelResponse::VT_ERRCODE, static_cast<int32_t>(errCode), 0);
  }
  explicit RVRCancelResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRCancelResponseBuilder &operator=(const RVRCancelResponseBuilder &);
  flatbuffers::Offset<RVRCancelResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRCancelResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRCancelResponse> CreateRVRCancelResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rvrId = 0,
    ErrorCode errCode = ErrorCode_NONE) {
  RVRCancelResponseBuilder builder_(_fbb);
  builder_.add_errCode(errCode);
  builder_.add_rvrId(rvrId);
  return builder_.Finish();
}

/// RVR_LEAVE_BATTLE_SERVER_REQUEST
struct RVRLeaveBattleServerRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RVRLeaveBattleServerRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RVRLeaveBattleServerRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRLeaveBattleServerRequestBuilder &operator=(const RVRLeaveBattleServerRequestBuilder &);
  flatbuffers::Offset<RVRLeaveBattleServerRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRLeaveBattleServerRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRLeaveBattleServerRequest> CreateRVRLeaveBattleServerRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RVRLeaveBattleServerRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// RVR_LEAVE_BATTLE_SERVER_RESPONSE
struct RVRLeaveBattleServerResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRCODE = 4
  };
  ErrorCode errCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           verifier.EndTable();
  }
};

struct RVRLeaveBattleServerResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errCode(ErrorCode errCode) {
    fbb_.AddElement<int32_t>(RVRLeaveBattleServerResponse::VT_ERRCODE, static_cast<int32_t>(errCode), 0);
  }
  explicit RVRLeaveBattleServerResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRLeaveBattleServerResponseBuilder &operator=(const RVRLeaveBattleServerResponseBuilder &);
  flatbuffers::Offset<RVRLeaveBattleServerResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRLeaveBattleServerResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRLeaveBattleServerResponse> CreateRVRLeaveBattleServerResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errCode = ErrorCode_NONE) {
  RVRLeaveBattleServerResponseBuilder builder_(_fbb);
  builder_.add_errCode(errCode);
  return builder_.Finish();
}

/// RVR_RESERVATION_STATE_NOTIFY
struct RVRReservationStateNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RVRID = 4,
    VT_STANDBY = 6,
    VT_PLAYERS = 8,
    VT_AWAITERS = 10
  };
  int32_t rvrId() const {
    return GetField<int32_t>(VT_RVRID, 0);
  }
  int32_t standBy() const {
    return GetField<int32_t>(VT_STANDBY, 0);
  }
  int32_t players() const {
    return GetField<int32_t>(VT_PLAYERS, 0);
  }
  int32_t awaiters() const {
    return GetField<int32_t>(VT_AWAITERS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RVRID) &&
           VerifyField<int32_t>(verifier, VT_STANDBY) &&
           VerifyField<int32_t>(verifier, VT_PLAYERS) &&
           VerifyField<int32_t>(verifier, VT_AWAITERS) &&
           verifier.EndTable();
  }
};

struct RVRReservationStateNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rvrId(int32_t rvrId) {
    fbb_.AddElement<int32_t>(RVRReservationStateNotify::VT_RVRID, rvrId, 0);
  }
  void add_standBy(int32_t standBy) {
    fbb_.AddElement<int32_t>(RVRReservationStateNotify::VT_STANDBY, standBy, 0);
  }
  void add_players(int32_t players) {
    fbb_.AddElement<int32_t>(RVRReservationStateNotify::VT_PLAYERS, players, 0);
  }
  void add_awaiters(int32_t awaiters) {
    fbb_.AddElement<int32_t>(RVRReservationStateNotify::VT_AWAITERS, awaiters, 0);
  }
  explicit RVRReservationStateNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRReservationStateNotifyBuilder &operator=(const RVRReservationStateNotifyBuilder &);
  flatbuffers::Offset<RVRReservationStateNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRReservationStateNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRReservationStateNotify> CreateRVRReservationStateNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rvrId = 0,
    int32_t standBy = 0,
    int32_t players = 0,
    int32_t awaiters = 0) {
  RVRReservationStateNotifyBuilder builder_(_fbb);
  builder_.add_awaiters(awaiters);
  builder_.add_players(players);
  builder_.add_standBy(standBy);
  builder_.add_rvrId(rvrId);
  return builder_.Finish();
}

/// RVR_PASS_CHECK_STANDBY_ORDER_REQUEST
struct RVRPassCheckStandbyOrderRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCDBID = 4,
    VT_RVRID = 6,
    VT_REALMID = 8,
    VT_WORLDID = 10
  };
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  int32_t rvrId() const {
    return GetField<int32_t>(VT_RVRID, 0);
  }
  int32_t realmId() const {
    return GetField<int32_t>(VT_REALMID, 0);
  }
  int32_t worldId() const {
    return GetField<int32_t>(VT_WORLDID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           VerifyField<int32_t>(verifier, VT_RVRID) &&
           VerifyField<int32_t>(verifier, VT_REALMID) &&
           VerifyField<int32_t>(verifier, VT_WORLDID) &&
           verifier.EndTable();
  }
};

struct RVRPassCheckStandbyOrderRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(RVRPassCheckStandbyOrderRequest::VT_PCDBID, pcDbId, 0);
  }
  void add_rvrId(int32_t rvrId) {
    fbb_.AddElement<int32_t>(RVRPassCheckStandbyOrderRequest::VT_RVRID, rvrId, 0);
  }
  void add_realmId(int32_t realmId) {
    fbb_.AddElement<int32_t>(RVRPassCheckStandbyOrderRequest::VT_REALMID, realmId, 0);
  }
  void add_worldId(int32_t worldId) {
    fbb_.AddElement<int32_t>(RVRPassCheckStandbyOrderRequest::VT_WORLDID, worldId, 0);
  }
  explicit RVRPassCheckStandbyOrderRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRPassCheckStandbyOrderRequestBuilder &operator=(const RVRPassCheckStandbyOrderRequestBuilder &);
  flatbuffers::Offset<RVRPassCheckStandbyOrderRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRPassCheckStandbyOrderRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRPassCheckStandbyOrderRequest> CreateRVRPassCheckStandbyOrderRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcDbId = 0,
    int32_t rvrId = 0,
    int32_t realmId = 0,
    int32_t worldId = 0) {
  RVRPassCheckStandbyOrderRequestBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  builder_.add_worldId(worldId);
  builder_.add_realmId(realmId);
  builder_.add_rvrId(rvrId);
  return builder_.Finish();
}

/// RVR_RELAY_CHECK_STANDBY_ORDER_REQUEST
struct RVRRelayCheckStandbyOrderRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCDBID = 4,
    VT_RVRID = 6,
    VT_REALMID = 8,
    VT_SRCSERVERID = 10,
    VT_RELAYAGENTID = 12,
    VT_WORLDID = 14
  };
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  int32_t rvrId() const {
    return GetField<int32_t>(VT_RVRID, 0);
  }
  int32_t realmId() const {
    return GetField<int32_t>(VT_REALMID, 0);
  }
  int32_t srcServerId() const {
    return GetField<int32_t>(VT_SRCSERVERID, 0);
  }
  int32_t relayAgentId() const {
    return GetField<int32_t>(VT_RELAYAGENTID, 0);
  }
  int32_t worldId() const {
    return GetField<int32_t>(VT_WORLDID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           VerifyField<int32_t>(verifier, VT_RVRID) &&
           VerifyField<int32_t>(verifier, VT_REALMID) &&
           VerifyField<int32_t>(verifier, VT_SRCSERVERID) &&
           VerifyField<int32_t>(verifier, VT_RELAYAGENTID) &&
           VerifyField<int32_t>(verifier, VT_WORLDID) &&
           verifier.EndTable();
  }
};

struct RVRRelayCheckStandbyOrderRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(RVRRelayCheckStandbyOrderRequest::VT_PCDBID, pcDbId, 0);
  }
  void add_rvrId(int32_t rvrId) {
    fbb_.AddElement<int32_t>(RVRRelayCheckStandbyOrderRequest::VT_RVRID, rvrId, 0);
  }
  void add_realmId(int32_t realmId) {
    fbb_.AddElement<int32_t>(RVRRelayCheckStandbyOrderRequest::VT_REALMID, realmId, 0);
  }
  void add_srcServerId(int32_t srcServerId) {
    fbb_.AddElement<int32_t>(RVRRelayCheckStandbyOrderRequest::VT_SRCSERVERID, srcServerId, 0);
  }
  void add_relayAgentId(int32_t relayAgentId) {
    fbb_.AddElement<int32_t>(RVRRelayCheckStandbyOrderRequest::VT_RELAYAGENTID, relayAgentId, 0);
  }
  void add_worldId(int32_t worldId) {
    fbb_.AddElement<int32_t>(RVRRelayCheckStandbyOrderRequest::VT_WORLDID, worldId, 0);
  }
  explicit RVRRelayCheckStandbyOrderRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRRelayCheckStandbyOrderRequestBuilder &operator=(const RVRRelayCheckStandbyOrderRequestBuilder &);
  flatbuffers::Offset<RVRRelayCheckStandbyOrderRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRRelayCheckStandbyOrderRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRRelayCheckStandbyOrderRequest> CreateRVRRelayCheckStandbyOrderRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcDbId = 0,
    int32_t rvrId = 0,
    int32_t realmId = 0,
    int32_t srcServerId = 0,
    int32_t relayAgentId = 0,
    int32_t worldId = 0) {
  RVRRelayCheckStandbyOrderRequestBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  builder_.add_worldId(worldId);
  builder_.add_relayAgentId(relayAgentId);
  builder_.add_srcServerId(srcServerId);
  builder_.add_realmId(realmId);
  builder_.add_rvrId(rvrId);
  return builder_.Finish();
}

/// RVR_PASS_CHECK_STANDBY_ORDER_RESPONSE 
struct RVRPassCheckStandbyOrderResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCDBID = 4,
    VT_RVRID = 6,
    VT_STANDBY = 8,
    VT_PLAYERS = 10,
    VT_AWAITERS = 12,
    VT_ERRCODE = 14
  };
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  int32_t rvrId() const {
    return GetField<int32_t>(VT_RVRID, 0);
  }
  int32_t standBy() const {
    return GetField<int32_t>(VT_STANDBY, 0);
  }
  int32_t players() const {
    return GetField<int32_t>(VT_PLAYERS, 0);
  }
  int32_t awaiters() const {
    return GetField<int32_t>(VT_AWAITERS, 0);
  }
  ErrorCode errCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           VerifyField<int32_t>(verifier, VT_RVRID) &&
           VerifyField<int32_t>(verifier, VT_STANDBY) &&
           VerifyField<int32_t>(verifier, VT_PLAYERS) &&
           VerifyField<int32_t>(verifier, VT_AWAITERS) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           verifier.EndTable();
  }
};

struct RVRPassCheckStandbyOrderResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(RVRPassCheckStandbyOrderResponse::VT_PCDBID, pcDbId, 0);
  }
  void add_rvrId(int32_t rvrId) {
    fbb_.AddElement<int32_t>(RVRPassCheckStandbyOrderResponse::VT_RVRID, rvrId, 0);
  }
  void add_standBy(int32_t standBy) {
    fbb_.AddElement<int32_t>(RVRPassCheckStandbyOrderResponse::VT_STANDBY, standBy, 0);
  }
  void add_players(int32_t players) {
    fbb_.AddElement<int32_t>(RVRPassCheckStandbyOrderResponse::VT_PLAYERS, players, 0);
  }
  void add_awaiters(int32_t awaiters) {
    fbb_.AddElement<int32_t>(RVRPassCheckStandbyOrderResponse::VT_AWAITERS, awaiters, 0);
  }
  void add_errCode(ErrorCode errCode) {
    fbb_.AddElement<int32_t>(RVRPassCheckStandbyOrderResponse::VT_ERRCODE, static_cast<int32_t>(errCode), 0);
  }
  explicit RVRPassCheckStandbyOrderResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRPassCheckStandbyOrderResponseBuilder &operator=(const RVRPassCheckStandbyOrderResponseBuilder &);
  flatbuffers::Offset<RVRPassCheckStandbyOrderResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRPassCheckStandbyOrderResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRPassCheckStandbyOrderResponse> CreateRVRPassCheckStandbyOrderResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcDbId = 0,
    int32_t rvrId = 0,
    int32_t standBy = 0,
    int32_t players = 0,
    int32_t awaiters = 0,
    ErrorCode errCode = ErrorCode_NONE) {
  RVRPassCheckStandbyOrderResponseBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  builder_.add_errCode(errCode);
  builder_.add_awaiters(awaiters);
  builder_.add_players(players);
  builder_.add_standBy(standBy);
  builder_.add_rvrId(rvrId);
  return builder_.Finish();
}

/// RVR_RELAY_CHECK_STANDBY_ORDER_RESPONSE
struct RVRRelayCheckStandbyOrderResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCDBID = 4,
    VT_RVRID = 6,
    VT_STANDBY = 8,
    VT_PLAYERS = 10,
    VT_AWAITERS = 12,
    VT_ERRCODE = 14
  };
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  int32_t rvrId() const {
    return GetField<int32_t>(VT_RVRID, 0);
  }
  int32_t standBy() const {
    return GetField<int32_t>(VT_STANDBY, 0);
  }
  int32_t players() const {
    return GetField<int32_t>(VT_PLAYERS, 0);
  }
  int32_t awaiters() const {
    return GetField<int32_t>(VT_AWAITERS, 0);
  }
  ErrorCode errCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           VerifyField<int32_t>(verifier, VT_RVRID) &&
           VerifyField<int32_t>(verifier, VT_STANDBY) &&
           VerifyField<int32_t>(verifier, VT_PLAYERS) &&
           VerifyField<int32_t>(verifier, VT_AWAITERS) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           verifier.EndTable();
  }
};

struct RVRRelayCheckStandbyOrderResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(RVRRelayCheckStandbyOrderResponse::VT_PCDBID, pcDbId, 0);
  }
  void add_rvrId(int32_t rvrId) {
    fbb_.AddElement<int32_t>(RVRRelayCheckStandbyOrderResponse::VT_RVRID, rvrId, 0);
  }
  void add_standBy(int32_t standBy) {
    fbb_.AddElement<int32_t>(RVRRelayCheckStandbyOrderResponse::VT_STANDBY, standBy, 0);
  }
  void add_players(int32_t players) {
    fbb_.AddElement<int32_t>(RVRRelayCheckStandbyOrderResponse::VT_PLAYERS, players, 0);
  }
  void add_awaiters(int32_t awaiters) {
    fbb_.AddElement<int32_t>(RVRRelayCheckStandbyOrderResponse::VT_AWAITERS, awaiters, 0);
  }
  void add_errCode(ErrorCode errCode) {
    fbb_.AddElement<int32_t>(RVRRelayCheckStandbyOrderResponse::VT_ERRCODE, static_cast<int32_t>(errCode), 0);
  }
  explicit RVRRelayCheckStandbyOrderResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRRelayCheckStandbyOrderResponseBuilder &operator=(const RVRRelayCheckStandbyOrderResponseBuilder &);
  flatbuffers::Offset<RVRRelayCheckStandbyOrderResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRRelayCheckStandbyOrderResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRRelayCheckStandbyOrderResponse> CreateRVRRelayCheckStandbyOrderResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcDbId = 0,
    int32_t rvrId = 0,
    int32_t standBy = 0,
    int32_t players = 0,
    int32_t awaiters = 0,
    ErrorCode errCode = ErrorCode_NONE) {
  RVRRelayCheckStandbyOrderResponseBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  builder_.add_errCode(errCode);
  builder_.add_awaiters(awaiters);
  builder_.add_players(players);
  builder_.add_standBy(standBy);
  builder_.add_rvrId(rvrId);
  return builder_.Finish();
}

/// RVR_PERMISSION_TO_JOIN_PASS_REQUEST 
struct RVRPermissionToJoinPassRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCDBID = 4,
    VT_RVRID = 6,
    VT_REALMID = 8,
    VT_STANDBY = 10
  };
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  int32_t rvrId() const {
    return GetField<int32_t>(VT_RVRID, 0);
  }
  int32_t realmId() const {
    return GetField<int32_t>(VT_REALMID, 0);
  }
  int32_t standBy() const {
    return GetField<int32_t>(VT_STANDBY, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           VerifyField<int32_t>(verifier, VT_RVRID) &&
           VerifyField<int32_t>(verifier, VT_REALMID) &&
           VerifyField<int32_t>(verifier, VT_STANDBY) &&
           verifier.EndTable();
  }
};

struct RVRPermissionToJoinPassRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(RVRPermissionToJoinPassRequest::VT_PCDBID, pcDbId, 0);
  }
  void add_rvrId(int32_t rvrId) {
    fbb_.AddElement<int32_t>(RVRPermissionToJoinPassRequest::VT_RVRID, rvrId, 0);
  }
  void add_realmId(int32_t realmId) {
    fbb_.AddElement<int32_t>(RVRPermissionToJoinPassRequest::VT_REALMID, realmId, 0);
  }
  void add_standBy(int32_t standBy) {
    fbb_.AddElement<int32_t>(RVRPermissionToJoinPassRequest::VT_STANDBY, standBy, 0);
  }
  explicit RVRPermissionToJoinPassRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRPermissionToJoinPassRequestBuilder &operator=(const RVRPermissionToJoinPassRequestBuilder &);
  flatbuffers::Offset<RVRPermissionToJoinPassRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRPermissionToJoinPassRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRPermissionToJoinPassRequest> CreateRVRPermissionToJoinPassRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcDbId = 0,
    int32_t rvrId = 0,
    int32_t realmId = 0,
    int32_t standBy = 0) {
  RVRPermissionToJoinPassRequestBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  builder_.add_standBy(standBy);
  builder_.add_realmId(realmId);
  builder_.add_rvrId(rvrId);
  return builder_.Finish();
}

/// RVR_PERMISSION_TO_JOIN_RELAY_REQUEST 
struct RVRPermissionToJoinRelayRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCDBID = 4,
    VT_RVRID = 6,
    VT_REALMID = 8,
    VT_STANDBY = 10
  };
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  int32_t rvrId() const {
    return GetField<int32_t>(VT_RVRID, 0);
  }
  int32_t realmId() const {
    return GetField<int32_t>(VT_REALMID, 0);
  }
  int32_t standBy() const {
    return GetField<int32_t>(VT_STANDBY, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           VerifyField<int32_t>(verifier, VT_RVRID) &&
           VerifyField<int32_t>(verifier, VT_REALMID) &&
           VerifyField<int32_t>(verifier, VT_STANDBY) &&
           verifier.EndTable();
  }
};

struct RVRPermissionToJoinRelayRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(RVRPermissionToJoinRelayRequest::VT_PCDBID, pcDbId, 0);
  }
  void add_rvrId(int32_t rvrId) {
    fbb_.AddElement<int32_t>(RVRPermissionToJoinRelayRequest::VT_RVRID, rvrId, 0);
  }
  void add_realmId(int32_t realmId) {
    fbb_.AddElement<int32_t>(RVRPermissionToJoinRelayRequest::VT_REALMID, realmId, 0);
  }
  void add_standBy(int32_t standBy) {
    fbb_.AddElement<int32_t>(RVRPermissionToJoinRelayRequest::VT_STANDBY, standBy, 0);
  }
  explicit RVRPermissionToJoinRelayRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRPermissionToJoinRelayRequestBuilder &operator=(const RVRPermissionToJoinRelayRequestBuilder &);
  flatbuffers::Offset<RVRPermissionToJoinRelayRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRPermissionToJoinRelayRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRPermissionToJoinRelayRequest> CreateRVRPermissionToJoinRelayRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcDbId = 0,
    int32_t rvrId = 0,
    int32_t realmId = 0,
    int32_t standBy = 0) {
  RVRPermissionToJoinRelayRequestBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  builder_.add_standBy(standBy);
  builder_.add_realmId(realmId);
  builder_.add_rvrId(rvrId);
  return builder_.Finish();
}

/// RVR_PERMISSION_TO_JOIN_PASS_RESPONSE 
struct RVRPermissionToJoinPassResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCDBID = 4,
    VT_RVRID = 6,
    VT_STANDBY = 8,
    VT_DESTCHID = 10,
    VT_ERRCODE = 12,
    VT_TIMEINDEX = 14
  };
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  int32_t rvrId() const {
    return GetField<int32_t>(VT_RVRID, 0);
  }
  int32_t standBy() const {
    return GetField<int32_t>(VT_STANDBY, 0);
  }
  int32_t destChId() const {
    return GetField<int32_t>(VT_DESTCHID, 0);
  }
  ErrorCode errCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRCODE, 0));
  }
  int32_t timeIndex() const {
    return GetField<int32_t>(VT_TIMEINDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           VerifyField<int32_t>(verifier, VT_RVRID) &&
           VerifyField<int32_t>(verifier, VT_STANDBY) &&
           VerifyField<int32_t>(verifier, VT_DESTCHID) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           VerifyField<int32_t>(verifier, VT_TIMEINDEX) &&
           verifier.EndTable();
  }
};

struct RVRPermissionToJoinPassResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(RVRPermissionToJoinPassResponse::VT_PCDBID, pcDbId, 0);
  }
  void add_rvrId(int32_t rvrId) {
    fbb_.AddElement<int32_t>(RVRPermissionToJoinPassResponse::VT_RVRID, rvrId, 0);
  }
  void add_standBy(int32_t standBy) {
    fbb_.AddElement<int32_t>(RVRPermissionToJoinPassResponse::VT_STANDBY, standBy, 0);
  }
  void add_destChId(int32_t destChId) {
    fbb_.AddElement<int32_t>(RVRPermissionToJoinPassResponse::VT_DESTCHID, destChId, 0);
  }
  void add_errCode(ErrorCode errCode) {
    fbb_.AddElement<int32_t>(RVRPermissionToJoinPassResponse::VT_ERRCODE, static_cast<int32_t>(errCode), 0);
  }
  void add_timeIndex(int32_t timeIndex) {
    fbb_.AddElement<int32_t>(RVRPermissionToJoinPassResponse::VT_TIMEINDEX, timeIndex, 0);
  }
  explicit RVRPermissionToJoinPassResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRPermissionToJoinPassResponseBuilder &operator=(const RVRPermissionToJoinPassResponseBuilder &);
  flatbuffers::Offset<RVRPermissionToJoinPassResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRPermissionToJoinPassResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRPermissionToJoinPassResponse> CreateRVRPermissionToJoinPassResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcDbId = 0,
    int32_t rvrId = 0,
    int32_t standBy = 0,
    int32_t destChId = 0,
    ErrorCode errCode = ErrorCode_NONE,
    int32_t timeIndex = 0) {
  RVRPermissionToJoinPassResponseBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  builder_.add_timeIndex(timeIndex);
  builder_.add_errCode(errCode);
  builder_.add_destChId(destChId);
  builder_.add_standBy(standBy);
  builder_.add_rvrId(rvrId);
  return builder_.Finish();
}

/// RVR_PERMISSION_TO_JOIN_RELAY_RESPONSE 
struct RVRPermissionToJoinRelayResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCDBID = 4,
    VT_RVRID = 6,
    VT_STANDBY = 8,
    VT_DESTCHID = 10,
    VT_ERRCODE = 12,
    VT_TIMEINDEX = 14
  };
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  int32_t rvrId() const {
    return GetField<int32_t>(VT_RVRID, 0);
  }
  int32_t standBy() const {
    return GetField<int32_t>(VT_STANDBY, 0);
  }
  int32_t destChId() const {
    return GetField<int32_t>(VT_DESTCHID, 0);
  }
  ErrorCode errCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRCODE, 0));
  }
  int32_t timeIndex() const {
    return GetField<int32_t>(VT_TIMEINDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           VerifyField<int32_t>(verifier, VT_RVRID) &&
           VerifyField<int32_t>(verifier, VT_STANDBY) &&
           VerifyField<int32_t>(verifier, VT_DESTCHID) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           VerifyField<int32_t>(verifier, VT_TIMEINDEX) &&
           verifier.EndTable();
  }
};

struct RVRPermissionToJoinRelayResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(RVRPermissionToJoinRelayResponse::VT_PCDBID, pcDbId, 0);
  }
  void add_rvrId(int32_t rvrId) {
    fbb_.AddElement<int32_t>(RVRPermissionToJoinRelayResponse::VT_RVRID, rvrId, 0);
  }
  void add_standBy(int32_t standBy) {
    fbb_.AddElement<int32_t>(RVRPermissionToJoinRelayResponse::VT_STANDBY, standBy, 0);
  }
  void add_destChId(int32_t destChId) {
    fbb_.AddElement<int32_t>(RVRPermissionToJoinRelayResponse::VT_DESTCHID, destChId, 0);
  }
  void add_errCode(ErrorCode errCode) {
    fbb_.AddElement<int32_t>(RVRPermissionToJoinRelayResponse::VT_ERRCODE, static_cast<int32_t>(errCode), 0);
  }
  void add_timeIndex(int32_t timeIndex) {
    fbb_.AddElement<int32_t>(RVRPermissionToJoinRelayResponse::VT_TIMEINDEX, timeIndex, 0);
  }
  explicit RVRPermissionToJoinRelayResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRPermissionToJoinRelayResponseBuilder &operator=(const RVRPermissionToJoinRelayResponseBuilder &);
  flatbuffers::Offset<RVRPermissionToJoinRelayResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRPermissionToJoinRelayResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRPermissionToJoinRelayResponse> CreateRVRPermissionToJoinRelayResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcDbId = 0,
    int32_t rvrId = 0,
    int32_t standBy = 0,
    int32_t destChId = 0,
    ErrorCode errCode = ErrorCode_NONE,
    int32_t timeIndex = 0) {
  RVRPermissionToJoinRelayResponseBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  builder_.add_timeIndex(timeIndex);
  builder_.add_errCode(errCode);
  builder_.add_destChId(destChId);
  builder_.add_standBy(standBy);
  builder_.add_rvrId(rvrId);
  return builder_.Finish();
}

/// RVR_CANCEL_TO_JOIN_PASS_REQUEST
struct RVRCancelToJoinPassRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCDBID = 4,
    VT_RVRID = 6,
    VT_REALMID = 8
  };
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  int32_t rvrId() const {
    return GetField<int32_t>(VT_RVRID, 0);
  }
  int32_t realmId() const {
    return GetField<int32_t>(VT_REALMID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           VerifyField<int32_t>(verifier, VT_RVRID) &&
           VerifyField<int32_t>(verifier, VT_REALMID) &&
           verifier.EndTable();
  }
};

struct RVRCancelToJoinPassRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(RVRCancelToJoinPassRequest::VT_PCDBID, pcDbId, 0);
  }
  void add_rvrId(int32_t rvrId) {
    fbb_.AddElement<int32_t>(RVRCancelToJoinPassRequest::VT_RVRID, rvrId, 0);
  }
  void add_realmId(int32_t realmId) {
    fbb_.AddElement<int32_t>(RVRCancelToJoinPassRequest::VT_REALMID, realmId, 0);
  }
  explicit RVRCancelToJoinPassRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRCancelToJoinPassRequestBuilder &operator=(const RVRCancelToJoinPassRequestBuilder &);
  flatbuffers::Offset<RVRCancelToJoinPassRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRCancelToJoinPassRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRCancelToJoinPassRequest> CreateRVRCancelToJoinPassRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcDbId = 0,
    int32_t rvrId = 0,
    int32_t realmId = 0) {
  RVRCancelToJoinPassRequestBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  builder_.add_realmId(realmId);
  builder_.add_rvrId(rvrId);
  return builder_.Finish();
}

/// RVR_CANCEL_TO_JOIN_RELAY_REQUEST
struct RVRCancelToJoinRelayRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCDBID = 4,
    VT_RVRID = 6,
    VT_REALMID = 8,
    VT_RELAYAGENTID = 10
  };
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  int32_t rvrId() const {
    return GetField<int32_t>(VT_RVRID, 0);
  }
  int32_t realmId() const {
    return GetField<int32_t>(VT_REALMID, 0);
  }
  int32_t relayAgentId() const {
    return GetField<int32_t>(VT_RELAYAGENTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           VerifyField<int32_t>(verifier, VT_RVRID) &&
           VerifyField<int32_t>(verifier, VT_REALMID) &&
           VerifyField<int32_t>(verifier, VT_RELAYAGENTID) &&
           verifier.EndTable();
  }
};

struct RVRCancelToJoinRelayRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(RVRCancelToJoinRelayRequest::VT_PCDBID, pcDbId, 0);
  }
  void add_rvrId(int32_t rvrId) {
    fbb_.AddElement<int32_t>(RVRCancelToJoinRelayRequest::VT_RVRID, rvrId, 0);
  }
  void add_realmId(int32_t realmId) {
    fbb_.AddElement<int32_t>(RVRCancelToJoinRelayRequest::VT_REALMID, realmId, 0);
  }
  void add_relayAgentId(int32_t relayAgentId) {
    fbb_.AddElement<int32_t>(RVRCancelToJoinRelayRequest::VT_RELAYAGENTID, relayAgentId, 0);
  }
  explicit RVRCancelToJoinRelayRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRCancelToJoinRelayRequestBuilder &operator=(const RVRCancelToJoinRelayRequestBuilder &);
  flatbuffers::Offset<RVRCancelToJoinRelayRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRCancelToJoinRelayRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRCancelToJoinRelayRequest> CreateRVRCancelToJoinRelayRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcDbId = 0,
    int32_t rvrId = 0,
    int32_t realmId = 0,
    int32_t relayAgentId = 0) {
  RVRCancelToJoinRelayRequestBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  builder_.add_relayAgentId(relayAgentId);
  builder_.add_realmId(realmId);
  builder_.add_rvrId(rvrId);
  return builder_.Finish();
}

/// RVR_CANCEL_TO_JOIN_PASS_RESPONSE
struct RVRCancelToJoinPassResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCDBID = 4,
    VT_RVRID = 6,
    VT_ERRCODE = 8
  };
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  int32_t rvrId() const {
    return GetField<int32_t>(VT_RVRID, 0);
  }
  ErrorCode errCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           VerifyField<int32_t>(verifier, VT_RVRID) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           verifier.EndTable();
  }
};

struct RVRCancelToJoinPassResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(RVRCancelToJoinPassResponse::VT_PCDBID, pcDbId, 0);
  }
  void add_rvrId(int32_t rvrId) {
    fbb_.AddElement<int32_t>(RVRCancelToJoinPassResponse::VT_RVRID, rvrId, 0);
  }
  void add_errCode(ErrorCode errCode) {
    fbb_.AddElement<int32_t>(RVRCancelToJoinPassResponse::VT_ERRCODE, static_cast<int32_t>(errCode), 0);
  }
  explicit RVRCancelToJoinPassResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRCancelToJoinPassResponseBuilder &operator=(const RVRCancelToJoinPassResponseBuilder &);
  flatbuffers::Offset<RVRCancelToJoinPassResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRCancelToJoinPassResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRCancelToJoinPassResponse> CreateRVRCancelToJoinPassResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcDbId = 0,
    int32_t rvrId = 0,
    ErrorCode errCode = ErrorCode_NONE) {
  RVRCancelToJoinPassResponseBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  builder_.add_errCode(errCode);
  builder_.add_rvrId(rvrId);
  return builder_.Finish();
}

/// RVR_CANCEL_TO_JOIN_RELAY_RESPONSE
struct RVRCancelToJoinRelayResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCDBID = 4,
    VT_RVRID = 6,
    VT_ERRCODE = 8
  };
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  int32_t rvrId() const {
    return GetField<int32_t>(VT_RVRID, 0);
  }
  ErrorCode errCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           VerifyField<int32_t>(verifier, VT_RVRID) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           verifier.EndTable();
  }
};

struct RVRCancelToJoinRelayResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(RVRCancelToJoinRelayResponse::VT_PCDBID, pcDbId, 0);
  }
  void add_rvrId(int32_t rvrId) {
    fbb_.AddElement<int32_t>(RVRCancelToJoinRelayResponse::VT_RVRID, rvrId, 0);
  }
  void add_errCode(ErrorCode errCode) {
    fbb_.AddElement<int32_t>(RVRCancelToJoinRelayResponse::VT_ERRCODE, static_cast<int32_t>(errCode), 0);
  }
  explicit RVRCancelToJoinRelayResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRCancelToJoinRelayResponseBuilder &operator=(const RVRCancelToJoinRelayResponseBuilder &);
  flatbuffers::Offset<RVRCancelToJoinRelayResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRCancelToJoinRelayResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRCancelToJoinRelayResponse> CreateRVRCancelToJoinRelayResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcDbId = 0,
    int32_t rvrId = 0,
    ErrorCode errCode = ErrorCode_NONE) {
  RVRCancelToJoinRelayResponseBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  builder_.add_errCode(errCode);
  builder_.add_rvrId(rvrId);
  return builder_.Finish();
}

/// RVR_ASK_TO_STANDBY_PASS_REQUEST
struct RVRAskToStandbyPassRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCDBID = 4,
    VT_RVRID = 6,
    VT_REALMID = 8
  };
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  int32_t rvrId() const {
    return GetField<int32_t>(VT_RVRID, 0);
  }
  int32_t realmId() const {
    return GetField<int32_t>(VT_REALMID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           VerifyField<int32_t>(verifier, VT_RVRID) &&
           VerifyField<int32_t>(verifier, VT_REALMID) &&
           verifier.EndTable();
  }
};

struct RVRAskToStandbyPassRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(RVRAskToStandbyPassRequest::VT_PCDBID, pcDbId, 0);
  }
  void add_rvrId(int32_t rvrId) {
    fbb_.AddElement<int32_t>(RVRAskToStandbyPassRequest::VT_RVRID, rvrId, 0);
  }
  void add_realmId(int32_t realmId) {
    fbb_.AddElement<int32_t>(RVRAskToStandbyPassRequest::VT_REALMID, realmId, 0);
  }
  explicit RVRAskToStandbyPassRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRAskToStandbyPassRequestBuilder &operator=(const RVRAskToStandbyPassRequestBuilder &);
  flatbuffers::Offset<RVRAskToStandbyPassRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRAskToStandbyPassRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRAskToStandbyPassRequest> CreateRVRAskToStandbyPassRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcDbId = 0,
    int32_t rvrId = 0,
    int32_t realmId = 0) {
  RVRAskToStandbyPassRequestBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  builder_.add_realmId(realmId);
  builder_.add_rvrId(rvrId);
  return builder_.Finish();
}

/// RVR_ASK_TO_STANDBY_RELAY_REQUEST
struct RVRAskToStandbyRelayRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCDBID = 4,
    VT_RVRID = 6,
    VT_REALMID = 8,
    VT_RELAYAGENTID = 10
  };
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  int32_t rvrId() const {
    return GetField<int32_t>(VT_RVRID, 0);
  }
  int32_t realmId() const {
    return GetField<int32_t>(VT_REALMID, 0);
  }
  int32_t relayAgentId() const {
    return GetField<int32_t>(VT_RELAYAGENTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           VerifyField<int32_t>(verifier, VT_RVRID) &&
           VerifyField<int32_t>(verifier, VT_REALMID) &&
           VerifyField<int32_t>(verifier, VT_RELAYAGENTID) &&
           verifier.EndTable();
  }
};

struct RVRAskToStandbyRelayRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(RVRAskToStandbyRelayRequest::VT_PCDBID, pcDbId, 0);
  }
  void add_rvrId(int32_t rvrId) {
    fbb_.AddElement<int32_t>(RVRAskToStandbyRelayRequest::VT_RVRID, rvrId, 0);
  }
  void add_realmId(int32_t realmId) {
    fbb_.AddElement<int32_t>(RVRAskToStandbyRelayRequest::VT_REALMID, realmId, 0);
  }
  void add_relayAgentId(int32_t relayAgentId) {
    fbb_.AddElement<int32_t>(RVRAskToStandbyRelayRequest::VT_RELAYAGENTID, relayAgentId, 0);
  }
  explicit RVRAskToStandbyRelayRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRAskToStandbyRelayRequestBuilder &operator=(const RVRAskToStandbyRelayRequestBuilder &);
  flatbuffers::Offset<RVRAskToStandbyRelayRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRAskToStandbyRelayRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRAskToStandbyRelayRequest> CreateRVRAskToStandbyRelayRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcDbId = 0,
    int32_t rvrId = 0,
    int32_t realmId = 0,
    int32_t relayAgentId = 0) {
  RVRAskToStandbyRelayRequestBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  builder_.add_relayAgentId(relayAgentId);
  builder_.add_realmId(realmId);
  builder_.add_rvrId(rvrId);
  return builder_.Finish();
}

/// RVR_ASK_TO_STANDBY_PASS_RESPONSE
struct RVRAskToStandbyPassResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCDBID = 4,
    VT_RVRID = 6,
    VT_STANDBY = 8,
    VT_PLAYERS = 10,
    VT_AWAITERS = 12,
    VT_ERRCODE = 14
  };
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  int32_t rvrId() const {
    return GetField<int32_t>(VT_RVRID, 0);
  }
  int32_t standBy() const {
    return GetField<int32_t>(VT_STANDBY, 0);
  }
  int32_t players() const {
    return GetField<int32_t>(VT_PLAYERS, 0);
  }
  int32_t awaiters() const {
    return GetField<int32_t>(VT_AWAITERS, 0);
  }
  ErrorCode errCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           VerifyField<int32_t>(verifier, VT_RVRID) &&
           VerifyField<int32_t>(verifier, VT_STANDBY) &&
           VerifyField<int32_t>(verifier, VT_PLAYERS) &&
           VerifyField<int32_t>(verifier, VT_AWAITERS) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           verifier.EndTable();
  }
};

struct RVRAskToStandbyPassResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(RVRAskToStandbyPassResponse::VT_PCDBID, pcDbId, 0);
  }
  void add_rvrId(int32_t rvrId) {
    fbb_.AddElement<int32_t>(RVRAskToStandbyPassResponse::VT_RVRID, rvrId, 0);
  }
  void add_standBy(int32_t standBy) {
    fbb_.AddElement<int32_t>(RVRAskToStandbyPassResponse::VT_STANDBY, standBy, 0);
  }
  void add_players(int32_t players) {
    fbb_.AddElement<int32_t>(RVRAskToStandbyPassResponse::VT_PLAYERS, players, 0);
  }
  void add_awaiters(int32_t awaiters) {
    fbb_.AddElement<int32_t>(RVRAskToStandbyPassResponse::VT_AWAITERS, awaiters, 0);
  }
  void add_errCode(ErrorCode errCode) {
    fbb_.AddElement<int32_t>(RVRAskToStandbyPassResponse::VT_ERRCODE, static_cast<int32_t>(errCode), 0);
  }
  explicit RVRAskToStandbyPassResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRAskToStandbyPassResponseBuilder &operator=(const RVRAskToStandbyPassResponseBuilder &);
  flatbuffers::Offset<RVRAskToStandbyPassResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRAskToStandbyPassResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRAskToStandbyPassResponse> CreateRVRAskToStandbyPassResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcDbId = 0,
    int32_t rvrId = 0,
    int32_t standBy = 0,
    int32_t players = 0,
    int32_t awaiters = 0,
    ErrorCode errCode = ErrorCode_NONE) {
  RVRAskToStandbyPassResponseBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  builder_.add_errCode(errCode);
  builder_.add_awaiters(awaiters);
  builder_.add_players(players);
  builder_.add_standBy(standBy);
  builder_.add_rvrId(rvrId);
  return builder_.Finish();
}

///  RVR_ASK_TO_STANDBY_RELAY_RESPONSE
struct RVRAskToStandbyRelayResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCDBID = 4,
    VT_RVRID = 6,
    VT_STANDBY = 8,
    VT_PLAYERS = 10,
    VT_AWAITERS = 12,
    VT_ERRCODE = 14
  };
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  int32_t rvrId() const {
    return GetField<int32_t>(VT_RVRID, 0);
  }
  int32_t standBy() const {
    return GetField<int32_t>(VT_STANDBY, 0);
  }
  int32_t players() const {
    return GetField<int32_t>(VT_PLAYERS, 0);
  }
  int32_t awaiters() const {
    return GetField<int32_t>(VT_AWAITERS, 0);
  }
  ErrorCode errCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           VerifyField<int32_t>(verifier, VT_RVRID) &&
           VerifyField<int32_t>(verifier, VT_STANDBY) &&
           VerifyField<int32_t>(verifier, VT_PLAYERS) &&
           VerifyField<int32_t>(verifier, VT_AWAITERS) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           verifier.EndTable();
  }
};

struct RVRAskToStandbyRelayResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(RVRAskToStandbyRelayResponse::VT_PCDBID, pcDbId, 0);
  }
  void add_rvrId(int32_t rvrId) {
    fbb_.AddElement<int32_t>(RVRAskToStandbyRelayResponse::VT_RVRID, rvrId, 0);
  }
  void add_standBy(int32_t standBy) {
    fbb_.AddElement<int32_t>(RVRAskToStandbyRelayResponse::VT_STANDBY, standBy, 0);
  }
  void add_players(int32_t players) {
    fbb_.AddElement<int32_t>(RVRAskToStandbyRelayResponse::VT_PLAYERS, players, 0);
  }
  void add_awaiters(int32_t awaiters) {
    fbb_.AddElement<int32_t>(RVRAskToStandbyRelayResponse::VT_AWAITERS, awaiters, 0);
  }
  void add_errCode(ErrorCode errCode) {
    fbb_.AddElement<int32_t>(RVRAskToStandbyRelayResponse::VT_ERRCODE, static_cast<int32_t>(errCode), 0);
  }
  explicit RVRAskToStandbyRelayResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRAskToStandbyRelayResponseBuilder &operator=(const RVRAskToStandbyRelayResponseBuilder &);
  flatbuffers::Offset<RVRAskToStandbyRelayResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRAskToStandbyRelayResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRAskToStandbyRelayResponse> CreateRVRAskToStandbyRelayResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcDbId = 0,
    int32_t rvrId = 0,
    int32_t standBy = 0,
    int32_t players = 0,
    int32_t awaiters = 0,
    ErrorCode errCode = ErrorCode_NONE) {
  RVRAskToStandbyRelayResponseBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  builder_.add_errCode(errCode);
  builder_.add_awaiters(awaiters);
  builder_.add_players(players);
  builder_.add_standBy(standBy);
  builder_.add_rvrId(rvrId);
  return builder_.Finish();
}

/// RVR_QA_COMMAND_PASS_NOTIFY
struct RVRQaCommandPassNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCDBID = 4,
    VT_REAMID = 6,
    VT_COMMAND = 8,
    VT_PARAM1 = 10,
    VT_PARAM2 = 12
  };
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  int32_t reamId() const {
    return GetField<int32_t>(VT_REAMID, 0);
  }
  int32_t command() const {
    return GetField<int32_t>(VT_COMMAND, 0);
  }
  int32_t param1() const {
    return GetField<int32_t>(VT_PARAM1, 0);
  }
  int32_t param2() const {
    return GetField<int32_t>(VT_PARAM2, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           VerifyField<int32_t>(verifier, VT_REAMID) &&
           VerifyField<int32_t>(verifier, VT_COMMAND) &&
           VerifyField<int32_t>(verifier, VT_PARAM1) &&
           VerifyField<int32_t>(verifier, VT_PARAM2) &&
           verifier.EndTable();
  }
};

struct RVRQaCommandPassNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(RVRQaCommandPassNotify::VT_PCDBID, pcDbId, 0);
  }
  void add_reamId(int32_t reamId) {
    fbb_.AddElement<int32_t>(RVRQaCommandPassNotify::VT_REAMID, reamId, 0);
  }
  void add_command(int32_t command) {
    fbb_.AddElement<int32_t>(RVRQaCommandPassNotify::VT_COMMAND, command, 0);
  }
  void add_param1(int32_t param1) {
    fbb_.AddElement<int32_t>(RVRQaCommandPassNotify::VT_PARAM1, param1, 0);
  }
  void add_param2(int32_t param2) {
    fbb_.AddElement<int32_t>(RVRQaCommandPassNotify::VT_PARAM2, param2, 0);
  }
  explicit RVRQaCommandPassNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRQaCommandPassNotifyBuilder &operator=(const RVRQaCommandPassNotifyBuilder &);
  flatbuffers::Offset<RVRQaCommandPassNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRQaCommandPassNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRQaCommandPassNotify> CreateRVRQaCommandPassNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcDbId = 0,
    int32_t reamId = 0,
    int32_t command = 0,
    int32_t param1 = 0,
    int32_t param2 = 0) {
  RVRQaCommandPassNotifyBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  builder_.add_param2(param2);
  builder_.add_param1(param1);
  builder_.add_command(command);
  builder_.add_reamId(reamId);
  return builder_.Finish();
}

/// RVR_QA_COMMAND_RELAY_NOTIFY 
struct RVRQaCommandRelayNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCDBID = 4,
    VT_REAMID = 6,
    VT_COMMAND = 8,
    VT_PARAM1 = 10,
    VT_PARAM2 = 12
  };
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  int32_t reamId() const {
    return GetField<int32_t>(VT_REAMID, 0);
  }
  int32_t command() const {
    return GetField<int32_t>(VT_COMMAND, 0);
  }
  int32_t param1() const {
    return GetField<int32_t>(VT_PARAM1, 0);
  }
  int32_t param2() const {
    return GetField<int32_t>(VT_PARAM2, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           VerifyField<int32_t>(verifier, VT_REAMID) &&
           VerifyField<int32_t>(verifier, VT_COMMAND) &&
           VerifyField<int32_t>(verifier, VT_PARAM1) &&
           VerifyField<int32_t>(verifier, VT_PARAM2) &&
           verifier.EndTable();
  }
};

struct RVRQaCommandRelayNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(RVRQaCommandRelayNotify::VT_PCDBID, pcDbId, 0);
  }
  void add_reamId(int32_t reamId) {
    fbb_.AddElement<int32_t>(RVRQaCommandRelayNotify::VT_REAMID, reamId, 0);
  }
  void add_command(int32_t command) {
    fbb_.AddElement<int32_t>(RVRQaCommandRelayNotify::VT_COMMAND, command, 0);
  }
  void add_param1(int32_t param1) {
    fbb_.AddElement<int32_t>(RVRQaCommandRelayNotify::VT_PARAM1, param1, 0);
  }
  void add_param2(int32_t param2) {
    fbb_.AddElement<int32_t>(RVRQaCommandRelayNotify::VT_PARAM2, param2, 0);
  }
  explicit RVRQaCommandRelayNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRQaCommandRelayNotifyBuilder &operator=(const RVRQaCommandRelayNotifyBuilder &);
  flatbuffers::Offset<RVRQaCommandRelayNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRQaCommandRelayNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRQaCommandRelayNotify> CreateRVRQaCommandRelayNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pcDbId = 0,
    int32_t reamId = 0,
    int32_t command = 0,
    int32_t param1 = 0,
    int32_t param2 = 0) {
  RVRQaCommandRelayNotifyBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  builder_.add_param2(param2);
  builder_.add_param1(param1);
  builder_.add_command(command);
  builder_.add_reamId(reamId);
  return builder_.Finish();
}

/// RVR_MOVE_CLIENT_QUEST_LOC_REQUEST 
struct RVRMoveClientQuestLocRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_QUESTRVRID = 4
  };
  int32_t questRvRId() const {
    return GetField<int32_t>(VT_QUESTRVRID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_QUESTRVRID) &&
           verifier.EndTable();
  }
};

struct RVRMoveClientQuestLocRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_questRvRId(int32_t questRvRId) {
    fbb_.AddElement<int32_t>(RVRMoveClientQuestLocRequest::VT_QUESTRVRID, questRvRId, 0);
  }
  explicit RVRMoveClientQuestLocRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRMoveClientQuestLocRequestBuilder &operator=(const RVRMoveClientQuestLocRequestBuilder &);
  flatbuffers::Offset<RVRMoveClientQuestLocRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRMoveClientQuestLocRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRMoveClientQuestLocRequest> CreateRVRMoveClientQuestLocRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t questRvRId = 0) {
  RVRMoveClientQuestLocRequestBuilder builder_(_fbb);
  builder_.add_questRvRId(questRvRId);
  return builder_.Finish();
}

/// RVR_MOVE_CLIENT_QUEST_LOC_RESPONSE 
struct RVRMoveClientQuestLocResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_QUESTRVRID = 4,
    VT_ERRCODE = 6
  };
  int32_t questRvRId() const {
    return GetField<int32_t>(VT_QUESTRVRID, 0);
  }
  ErrorCode errCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_QUESTRVRID) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           verifier.EndTable();
  }
};

struct RVRMoveClientQuestLocResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_questRvRId(int32_t questRvRId) {
    fbb_.AddElement<int32_t>(RVRMoveClientQuestLocResponse::VT_QUESTRVRID, questRvRId, 0);
  }
  void add_errCode(ErrorCode errCode) {
    fbb_.AddElement<int32_t>(RVRMoveClientQuestLocResponse::VT_ERRCODE, static_cast<int32_t>(errCode), 0);
  }
  explicit RVRMoveClientQuestLocResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRMoveClientQuestLocResponseBuilder &operator=(const RVRMoveClientQuestLocResponseBuilder &);
  flatbuffers::Offset<RVRMoveClientQuestLocResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRMoveClientQuestLocResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRMoveClientQuestLocResponse> CreateRVRMoveClientQuestLocResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t questRvRId = 0,
    ErrorCode errCode = ErrorCode_NONE) {
  RVRMoveClientQuestLocResponseBuilder builder_(_fbb);
  builder_.add_errCode(errCode);
  builder_.add_questRvRId(questRvRId);
  return builder_.Finish();
}

/// RVR_MOVE_BASE_CAMP_REQUEST
struct RVRMoveBaseCampRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SMAPID = 4
  };
  int32_t smapId() const {
    return GetField<int32_t>(VT_SMAPID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SMAPID) &&
           verifier.EndTable();
  }
};

struct RVRMoveBaseCampRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_smapId(int32_t smapId) {
    fbb_.AddElement<int32_t>(RVRMoveBaseCampRequest::VT_SMAPID, smapId, 0);
  }
  explicit RVRMoveBaseCampRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRMoveBaseCampRequestBuilder &operator=(const RVRMoveBaseCampRequestBuilder &);
  flatbuffers::Offset<RVRMoveBaseCampRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRMoveBaseCampRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRMoveBaseCampRequest> CreateRVRMoveBaseCampRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t smapId = 0) {
  RVRMoveBaseCampRequestBuilder builder_(_fbb);
  builder_.add_smapId(smapId);
  return builder_.Finish();
}

/// RVR_MOVE_BASE_CAMP_RESPONSE
struct RVRMoveBaseCampResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SMAPID = 4,
    VT_ERRCODE = 6
  };
  int32_t smapId() const {
    return GetField<int32_t>(VT_SMAPID, 0);
  }
  ErrorCode errCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SMAPID) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           verifier.EndTable();
  }
};

struct RVRMoveBaseCampResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_smapId(int32_t smapId) {
    fbb_.AddElement<int32_t>(RVRMoveBaseCampResponse::VT_SMAPID, smapId, 0);
  }
  void add_errCode(ErrorCode errCode) {
    fbb_.AddElement<int32_t>(RVRMoveBaseCampResponse::VT_ERRCODE, static_cast<int32_t>(errCode), 0);
  }
  explicit RVRMoveBaseCampResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRMoveBaseCampResponseBuilder &operator=(const RVRMoveBaseCampResponseBuilder &);
  flatbuffers::Offset<RVRMoveBaseCampResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRMoveBaseCampResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRMoveBaseCampResponse> CreateRVRMoveBaseCampResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t smapId = 0,
    ErrorCode errCode = ErrorCode_NONE) {
  RVRMoveBaseCampResponseBuilder builder_(_fbb);
  builder_.add_errCode(errCode);
  builder_.add_smapId(smapId);
  return builder_.Finish();
}

/// 목표 대상 정보
struct WatchTargetInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_NPCID = 6,
    VT_CURHP = 8,
    VT_MAXHP = 10,
    VT_REALMID = 12
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int32_t npcId() const {
    return GetField<int32_t>(VT_NPCID, 0);
  }
  int32_t curHp() const {
    return GetField<int32_t>(VT_CURHP, 0);
  }
  int32_t maxHp() const {
    return GetField<int32_t>(VT_MAXHP, 0);
  }
  int32_t realmId() const {
    return GetField<int32_t>(VT_REALMID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int32_t>(verifier, VT_NPCID) &&
           VerifyField<int32_t>(verifier, VT_CURHP) &&
           VerifyField<int32_t>(verifier, VT_MAXHP) &&
           VerifyField<int32_t>(verifier, VT_REALMID) &&
           verifier.EndTable();
  }
};

struct WatchTargetInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(WatchTargetInfo::VT_OBJECTID, objectId, 0);
  }
  void add_npcId(int32_t npcId) {
    fbb_.AddElement<int32_t>(WatchTargetInfo::VT_NPCID, npcId, 0);
  }
  void add_curHp(int32_t curHp) {
    fbb_.AddElement<int32_t>(WatchTargetInfo::VT_CURHP, curHp, 0);
  }
  void add_maxHp(int32_t maxHp) {
    fbb_.AddElement<int32_t>(WatchTargetInfo::VT_MAXHP, maxHp, 0);
  }
  void add_realmId(int32_t realmId) {
    fbb_.AddElement<int32_t>(WatchTargetInfo::VT_REALMID, realmId, 0);
  }
  explicit WatchTargetInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WatchTargetInfoBuilder &operator=(const WatchTargetInfoBuilder &);
  flatbuffers::Offset<WatchTargetInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WatchTargetInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<WatchTargetInfo> CreateWatchTargetInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int32_t npcId = 0,
    int32_t curHp = 0,
    int32_t maxHp = 0,
    int32_t realmId = 0) {
  WatchTargetInfoBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_realmId(realmId);
  builder_.add_maxHp(maxHp);
  builder_.add_curHp(curHp);
  builder_.add_npcId(npcId);
  return builder_.Finish();
}

/// RVR_MAIN_HUD_INFO_NOTIFY
struct RVRMainHudInfoNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_WATCHTARGETS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<WatchTargetInfo>> *watchTargets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<WatchTargetInfo>> *>(VT_WATCHTARGETS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WATCHTARGETS) &&
           verifier.VerifyVector(watchTargets()) &&
           verifier.VerifyVectorOfTables(watchTargets()) &&
           verifier.EndTable();
  }
};

struct RVRMainHudInfoNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_watchTargets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<WatchTargetInfo>>> watchTargets) {
    fbb_.AddOffset(RVRMainHudInfoNotify::VT_WATCHTARGETS, watchTargets);
  }
  explicit RVRMainHudInfoNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRMainHudInfoNotifyBuilder &operator=(const RVRMainHudInfoNotifyBuilder &);
  flatbuffers::Offset<RVRMainHudInfoNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRMainHudInfoNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRMainHudInfoNotify> CreateRVRMainHudInfoNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<WatchTargetInfo>>> watchTargets = 0) {
  RVRMainHudInfoNotifyBuilder builder_(_fbb);
  builder_.add_watchTargets(watchTargets);
  return builder_.Finish();
}

inline flatbuffers::Offset<RVRMainHudInfoNotify> CreateRVRMainHudInfoNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<WatchTargetInfo>> *watchTargets = nullptr) {
  return LeanPacket::CreateRVRMainHudInfoNotify(
      _fbb,
      watchTargets ? _fbb.CreateVector<flatbuffers::Offset<WatchTargetInfo>>(*watchTargets) : 0);
}

/// RVR_EVENT_TOTAL_REWARD_NOTIFY
struct RvrEventTotalRewardNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EVENTSETID = 4,
    VT_EVENTID = 6,
    VT_WINREALMID = 8,
    VT_RESULTREWARDINFOS = 10,
    VT_MYGUILDCONTRIBUTION = 12,
    VT_RANKGUILDCONTRIBUTIONS = 14,
    VT_ORIGNRESULTREWARDINFOS = 16
  };
  int32_t eventSetId() const {
    return GetField<int32_t>(VT_EVENTSETID, 0);
  }
  int32_t eventId() const {
    return GetField<int32_t>(VT_EVENTID, 0);
  }
  int32_t winRealmId() const {
    return GetField<int32_t>(VT_WINREALMID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ResultRewardInfo>> *resultRewardInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ResultRewardInfo>> *>(VT_RESULTREWARDINFOS);
  }
  const BattleRealmGuildContribution *myGuildContribution() const {
    return GetPointer<const BattleRealmGuildContribution *>(VT_MYGUILDCONTRIBUTION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<BattleRealmGuildContribution>> *rankGuildContributions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BattleRealmGuildContribution>> *>(VT_RANKGUILDCONTRIBUTIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ResultRewardInfo>> *orignResultRewardInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ResultRewardInfo>> *>(VT_ORIGNRESULTREWARDINFOS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_EVENTSETID) &&
           VerifyField<int32_t>(verifier, VT_EVENTID) &&
           VerifyField<int32_t>(verifier, VT_WINREALMID) &&
           VerifyOffsetRequired(verifier, VT_RESULTREWARDINFOS) &&
           verifier.VerifyVector(resultRewardInfos()) &&
           verifier.VerifyVectorOfTables(resultRewardInfos()) &&
           VerifyOffsetRequired(verifier, VT_MYGUILDCONTRIBUTION) &&
           verifier.VerifyTable(myGuildContribution()) &&
           VerifyOffsetRequired(verifier, VT_RANKGUILDCONTRIBUTIONS) &&
           verifier.VerifyVector(rankGuildContributions()) &&
           verifier.VerifyVectorOfTables(rankGuildContributions()) &&
           VerifyOffsetRequired(verifier, VT_ORIGNRESULTREWARDINFOS) &&
           verifier.VerifyVector(orignResultRewardInfos()) &&
           verifier.VerifyVectorOfTables(orignResultRewardInfos()) &&
           verifier.EndTable();
  }
};

struct RvrEventTotalRewardNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eventSetId(int32_t eventSetId) {
    fbb_.AddElement<int32_t>(RvrEventTotalRewardNotify::VT_EVENTSETID, eventSetId, 0);
  }
  void add_eventId(int32_t eventId) {
    fbb_.AddElement<int32_t>(RvrEventTotalRewardNotify::VT_EVENTID, eventId, 0);
  }
  void add_winRealmId(int32_t winRealmId) {
    fbb_.AddElement<int32_t>(RvrEventTotalRewardNotify::VT_WINREALMID, winRealmId, 0);
  }
  void add_resultRewardInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ResultRewardInfo>>> resultRewardInfos) {
    fbb_.AddOffset(RvrEventTotalRewardNotify::VT_RESULTREWARDINFOS, resultRewardInfos);
  }
  void add_myGuildContribution(flatbuffers::Offset<BattleRealmGuildContribution> myGuildContribution) {
    fbb_.AddOffset(RvrEventTotalRewardNotify::VT_MYGUILDCONTRIBUTION, myGuildContribution);
  }
  void add_rankGuildContributions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BattleRealmGuildContribution>>> rankGuildContributions) {
    fbb_.AddOffset(RvrEventTotalRewardNotify::VT_RANKGUILDCONTRIBUTIONS, rankGuildContributions);
  }
  void add_orignResultRewardInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ResultRewardInfo>>> orignResultRewardInfos) {
    fbb_.AddOffset(RvrEventTotalRewardNotify::VT_ORIGNRESULTREWARDINFOS, orignResultRewardInfos);
  }
  explicit RvrEventTotalRewardNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RvrEventTotalRewardNotifyBuilder &operator=(const RvrEventTotalRewardNotifyBuilder &);
  flatbuffers::Offset<RvrEventTotalRewardNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RvrEventTotalRewardNotify>(end);
    fbb_.Required(o, RvrEventTotalRewardNotify::VT_RESULTREWARDINFOS);
    fbb_.Required(o, RvrEventTotalRewardNotify::VT_MYGUILDCONTRIBUTION);
    fbb_.Required(o, RvrEventTotalRewardNotify::VT_RANKGUILDCONTRIBUTIONS);
    fbb_.Required(o, RvrEventTotalRewardNotify::VT_ORIGNRESULTREWARDINFOS);
    return o;
  }
};

inline flatbuffers::Offset<RvrEventTotalRewardNotify> CreateRvrEventTotalRewardNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t eventSetId = 0,
    int32_t eventId = 0,
    int32_t winRealmId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ResultRewardInfo>>> resultRewardInfos = 0,
    flatbuffers::Offset<BattleRealmGuildContribution> myGuildContribution = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BattleRealmGuildContribution>>> rankGuildContributions = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ResultRewardInfo>>> orignResultRewardInfos = 0) {
  RvrEventTotalRewardNotifyBuilder builder_(_fbb);
  builder_.add_orignResultRewardInfos(orignResultRewardInfos);
  builder_.add_rankGuildContributions(rankGuildContributions);
  builder_.add_myGuildContribution(myGuildContribution);
  builder_.add_resultRewardInfos(resultRewardInfos);
  builder_.add_winRealmId(winRealmId);
  builder_.add_eventId(eventId);
  builder_.add_eventSetId(eventSetId);
  return builder_.Finish();
}

inline flatbuffers::Offset<RvrEventTotalRewardNotify> CreateRvrEventTotalRewardNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t eventSetId = 0,
    int32_t eventId = 0,
    int32_t winRealmId = 0,
    const std::vector<flatbuffers::Offset<ResultRewardInfo>> *resultRewardInfos = nullptr,
    flatbuffers::Offset<BattleRealmGuildContribution> myGuildContribution = 0,
    const std::vector<flatbuffers::Offset<BattleRealmGuildContribution>> *rankGuildContributions = nullptr,
    const std::vector<flatbuffers::Offset<ResultRewardInfo>> *orignResultRewardInfos = nullptr) {
  return LeanPacket::CreateRvrEventTotalRewardNotify(
      _fbb,
      eventSetId,
      eventId,
      winRealmId,
      resultRewardInfos ? _fbb.CreateVector<flatbuffers::Offset<ResultRewardInfo>>(*resultRewardInfos) : 0,
      myGuildContribution,
      rankGuildContributions ? _fbb.CreateVector<flatbuffers::Offset<BattleRealmGuildContribution>>(*rankGuildContributions) : 0,
      orignResultRewardInfos ? _fbb.CreateVector<flatbuffers::Offset<ResultRewardInfo>>(*orignResultRewardInfos) : 0);
}

/// NOTICE_NOTIFY
struct NoticeNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NOTICE = 4
  };
  const flatbuffers::String *notice() const {
    return GetPointer<const flatbuffers::String *>(VT_NOTICE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NOTICE) &&
           verifier.VerifyString(notice()) &&
           verifier.EndTable();
  }
};

struct NoticeNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_notice(flatbuffers::Offset<flatbuffers::String> notice) {
    fbb_.AddOffset(NoticeNotify::VT_NOTICE, notice);
  }
  explicit NoticeNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NoticeNotifyBuilder &operator=(const NoticeNotifyBuilder &);
  flatbuffers::Offset<NoticeNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NoticeNotify>(end);
    fbb_.Required(o, NoticeNotify::VT_NOTICE);
    return o;
  }
};

inline flatbuffers::Offset<NoticeNotify> CreateNoticeNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> notice = 0) {
  NoticeNotifyBuilder builder_(_fbb);
  builder_.add_notice(notice);
  return builder_.Finish();
}

inline flatbuffers::Offset<NoticeNotify> CreateNoticeNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *notice = nullptr) {
  return LeanPacket::CreateNoticeNotify(
      _fbb,
      notice ? _fbb.CreateString(notice) : 0);
}

/// CLIENT_DEBUG_MESSAGE_NOTIFY
struct ClientDebugMessageNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DEBUGMESSAGE = 4
  };
  const flatbuffers::String *debugMessage() const {
    return GetPointer<const flatbuffers::String *>(VT_DEBUGMESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DEBUGMESSAGE) &&
           verifier.VerifyString(debugMessage()) &&
           verifier.EndTable();
  }
};

struct ClientDebugMessageNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_debugMessage(flatbuffers::Offset<flatbuffers::String> debugMessage) {
    fbb_.AddOffset(ClientDebugMessageNotify::VT_DEBUGMESSAGE, debugMessage);
  }
  explicit ClientDebugMessageNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClientDebugMessageNotifyBuilder &operator=(const ClientDebugMessageNotifyBuilder &);
  flatbuffers::Offset<ClientDebugMessageNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientDebugMessageNotify>(end);
    fbb_.Required(o, ClientDebugMessageNotify::VT_DEBUGMESSAGE);
    return o;
  }
};

inline flatbuffers::Offset<ClientDebugMessageNotify> CreateClientDebugMessageNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> debugMessage = 0) {
  ClientDebugMessageNotifyBuilder builder_(_fbb);
  builder_.add_debugMessage(debugMessage);
  return builder_.Finish();
}

inline flatbuffers::Offset<ClientDebugMessageNotify> CreateClientDebugMessageNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *debugMessage = nullptr) {
  return LeanPacket::CreateClientDebugMessageNotify(
      _fbb,
      debugMessage ? _fbb.CreateString(debugMessage) : 0);
}

struct PcClientConfig FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PUSHNOTIFY = 4,
    VT_EVENTJOINSWITCHSTATE = 6,
    VT_GAMELANGUAGE = 8,
    VT_CONFIG = 10
  };
  bool pushNotify() const {
    return GetField<uint8_t>(VT_PUSHNOTIFY, 0) != 0;
  }
  bool eventJoinSwitchState() const {
    return GetField<uint8_t>(VT_EVENTJOINSWITCHSTATE, 0) != 0;
  }
  int32_t gameLanguage() const {
    return GetField<int32_t>(VT_GAMELANGUAGE, 0);
  }
  const flatbuffers::Vector<uint8_t> *config() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CONFIG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PUSHNOTIFY) &&
           VerifyField<uint8_t>(verifier, VT_EVENTJOINSWITCHSTATE) &&
           VerifyField<int32_t>(verifier, VT_GAMELANGUAGE) &&
           VerifyOffsetRequired(verifier, VT_CONFIG) &&
           verifier.VerifyVector(config()) &&
           verifier.EndTable();
  }
};

struct PcClientConfigBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pushNotify(bool pushNotify) {
    fbb_.AddElement<uint8_t>(PcClientConfig::VT_PUSHNOTIFY, static_cast<uint8_t>(pushNotify), 0);
  }
  void add_eventJoinSwitchState(bool eventJoinSwitchState) {
    fbb_.AddElement<uint8_t>(PcClientConfig::VT_EVENTJOINSWITCHSTATE, static_cast<uint8_t>(eventJoinSwitchState), 0);
  }
  void add_gameLanguage(int32_t gameLanguage) {
    fbb_.AddElement<int32_t>(PcClientConfig::VT_GAMELANGUAGE, gameLanguage, 0);
  }
  void add_config(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> config) {
    fbb_.AddOffset(PcClientConfig::VT_CONFIG, config);
  }
  explicit PcClientConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PcClientConfigBuilder &operator=(const PcClientConfigBuilder &);
  flatbuffers::Offset<PcClientConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PcClientConfig>(end);
    fbb_.Required(o, PcClientConfig::VT_CONFIG);
    return o;
  }
};

inline flatbuffers::Offset<PcClientConfig> CreatePcClientConfig(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool pushNotify = false,
    bool eventJoinSwitchState = false,
    int32_t gameLanguage = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> config = 0) {
  PcClientConfigBuilder builder_(_fbb);
  builder_.add_config(config);
  builder_.add_gameLanguage(gameLanguage);
  builder_.add_eventJoinSwitchState(eventJoinSwitchState);
  builder_.add_pushNotify(pushNotify);
  return builder_.Finish();
}

inline flatbuffers::Offset<PcClientConfig> CreatePcClientConfigDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool pushNotify = false,
    bool eventJoinSwitchState = false,
    int32_t gameLanguage = 0,
    const std::vector<uint8_t> *config = nullptr) {
  return LeanPacket::CreatePcClientConfig(
      _fbb,
      pushNotify,
      eventJoinSwitchState,
      gameLanguage,
      config ? _fbb.CreateVector<uint8_t>(*config) : 0);
}

/// PC_CLIENT_CONFIG_NOTIFY
struct PcClientConfigNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CLIENTCONFIG = 4
  };
  const PcClientConfig *clientConfig() const {
    return GetPointer<const PcClientConfig *>(VT_CLIENTCONFIG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CLIENTCONFIG) &&
           verifier.VerifyTable(clientConfig()) &&
           verifier.EndTable();
  }
};

struct PcClientConfigNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_clientConfig(flatbuffers::Offset<PcClientConfig> clientConfig) {
    fbb_.AddOffset(PcClientConfigNotify::VT_CLIENTCONFIG, clientConfig);
  }
  explicit PcClientConfigNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PcClientConfigNotifyBuilder &operator=(const PcClientConfigNotifyBuilder &);
  flatbuffers::Offset<PcClientConfigNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PcClientConfigNotify>(end);
    fbb_.Required(o, PcClientConfigNotify::VT_CLIENTCONFIG);
    return o;
  }
};

inline flatbuffers::Offset<PcClientConfigNotify> CreatePcClientConfigNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<PcClientConfig> clientConfig = 0) {
  PcClientConfigNotifyBuilder builder_(_fbb);
  builder_.add_clientConfig(clientConfig);
  return builder_.Finish();
}

/// PC_CLIENT_CONFIG_SAVE_REQUEST
struct PcClientConfigSaveRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CLIENTCONFIG = 4
  };
  const PcClientConfig *clientConfig() const {
    return GetPointer<const PcClientConfig *>(VT_CLIENTCONFIG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CLIENTCONFIG) &&
           verifier.VerifyTable(clientConfig()) &&
           verifier.EndTable();
  }
};

struct PcClientConfigSaveRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_clientConfig(flatbuffers::Offset<PcClientConfig> clientConfig) {
    fbb_.AddOffset(PcClientConfigSaveRequest::VT_CLIENTCONFIG, clientConfig);
  }
  explicit PcClientConfigSaveRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PcClientConfigSaveRequestBuilder &operator=(const PcClientConfigSaveRequestBuilder &);
  flatbuffers::Offset<PcClientConfigSaveRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PcClientConfigSaveRequest>(end);
    fbb_.Required(o, PcClientConfigSaveRequest::VT_CLIENTCONFIG);
    return o;
  }
};

inline flatbuffers::Offset<PcClientConfigSaveRequest> CreatePcClientConfigSaveRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<PcClientConfig> clientConfig = 0) {
  PcClientConfigSaveRequestBuilder builder_(_fbb);
  builder_.add_clientConfig(clientConfig);
  return builder_.Finish();
}

/// NOTICE_ITEM_NOTIFY
struct NoticeItemNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_WHO = 6,
    VT_ITEMID = 8,
    VT_GRADE = 10,
    VT_TIER = 12,
    VT_WHERE = 14,
    VT_TRANSCENDLEVEL = 16
  };
  int16_t type() const {
    return GetField<int16_t>(VT_TYPE, 0);
  }
  const flatbuffers::String *who() const {
    return GetPointer<const flatbuffers::String *>(VT_WHO);
  }
  int32_t itemId() const {
    return GetField<int32_t>(VT_ITEMID, 0);
  }
  int16_t grade() const {
    return GetField<int16_t>(VT_GRADE, 0);
  }
  int16_t tier() const {
    return GetField<int16_t>(VT_TIER, 0);
  }
  int16_t where() const {
    return GetField<int16_t>(VT_WHERE, 0);
  }
  int16_t transcendLevel() const {
    return GetField<int16_t>(VT_TRANSCENDLEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPE) &&
           VerifyOffsetRequired(verifier, VT_WHO) &&
           verifier.VerifyString(who()) &&
           VerifyField<int32_t>(verifier, VT_ITEMID) &&
           VerifyField<int16_t>(verifier, VT_GRADE) &&
           VerifyField<int16_t>(verifier, VT_TIER) &&
           VerifyField<int16_t>(verifier, VT_WHERE) &&
           VerifyField<int16_t>(verifier, VT_TRANSCENDLEVEL) &&
           verifier.EndTable();
  }
};

struct NoticeItemNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int16_t type) {
    fbb_.AddElement<int16_t>(NoticeItemNotify::VT_TYPE, type, 0);
  }
  void add_who(flatbuffers::Offset<flatbuffers::String> who) {
    fbb_.AddOffset(NoticeItemNotify::VT_WHO, who);
  }
  void add_itemId(int32_t itemId) {
    fbb_.AddElement<int32_t>(NoticeItemNotify::VT_ITEMID, itemId, 0);
  }
  void add_grade(int16_t grade) {
    fbb_.AddElement<int16_t>(NoticeItemNotify::VT_GRADE, grade, 0);
  }
  void add_tier(int16_t tier) {
    fbb_.AddElement<int16_t>(NoticeItemNotify::VT_TIER, tier, 0);
  }
  void add_where(int16_t where) {
    fbb_.AddElement<int16_t>(NoticeItemNotify::VT_WHERE, where, 0);
  }
  void add_transcendLevel(int16_t transcendLevel) {
    fbb_.AddElement<int16_t>(NoticeItemNotify::VT_TRANSCENDLEVEL, transcendLevel, 0);
  }
  explicit NoticeItemNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NoticeItemNotifyBuilder &operator=(const NoticeItemNotifyBuilder &);
  flatbuffers::Offset<NoticeItemNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NoticeItemNotify>(end);
    fbb_.Required(o, NoticeItemNotify::VT_WHO);
    return o;
  }
};

inline flatbuffers::Offset<NoticeItemNotify> CreateNoticeItemNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t type = 0,
    flatbuffers::Offset<flatbuffers::String> who = 0,
    int32_t itemId = 0,
    int16_t grade = 0,
    int16_t tier = 0,
    int16_t where = 0,
    int16_t transcendLevel = 0) {
  NoticeItemNotifyBuilder builder_(_fbb);
  builder_.add_itemId(itemId);
  builder_.add_who(who);
  builder_.add_transcendLevel(transcendLevel);
  builder_.add_where(where);
  builder_.add_tier(tier);
  builder_.add_grade(grade);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<NoticeItemNotify> CreateNoticeItemNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t type = 0,
    const char *who = nullptr,
    int32_t itemId = 0,
    int16_t grade = 0,
    int16_t tier = 0,
    int16_t where = 0,
    int16_t transcendLevel = 0) {
  return LeanPacket::CreateNoticeItemNotify(
      _fbb,
      type,
      who ? _fbb.CreateString(who) : 0,
      itemId,
      grade,
      tier,
      where,
      transcendLevel);
}

/// NOTICE_USER_NOTIFY
struct NoticeUserNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_CONDITION = 6,
    VT_WHO = 8,
    VT_PARAM1 = 10,
    VT_PARAM2 = 12
  };
  int16_t type() const {
    return GetField<int16_t>(VT_TYPE, 0);
  }
  int16_t condition() const {
    return GetField<int16_t>(VT_CONDITION, 0);
  }
  const flatbuffers::String *who() const {
    return GetPointer<const flatbuffers::String *>(VT_WHO);
  }
  int16_t param1() const {
    return GetField<int16_t>(VT_PARAM1, 0);
  }
  int16_t param2() const {
    return GetField<int16_t>(VT_PARAM2, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPE) &&
           VerifyField<int16_t>(verifier, VT_CONDITION) &&
           VerifyOffsetRequired(verifier, VT_WHO) &&
           verifier.VerifyString(who()) &&
           VerifyField<int16_t>(verifier, VT_PARAM1) &&
           VerifyField<int16_t>(verifier, VT_PARAM2) &&
           verifier.EndTable();
  }
};

struct NoticeUserNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int16_t type) {
    fbb_.AddElement<int16_t>(NoticeUserNotify::VT_TYPE, type, 0);
  }
  void add_condition(int16_t condition) {
    fbb_.AddElement<int16_t>(NoticeUserNotify::VT_CONDITION, condition, 0);
  }
  void add_who(flatbuffers::Offset<flatbuffers::String> who) {
    fbb_.AddOffset(NoticeUserNotify::VT_WHO, who);
  }
  void add_param1(int16_t param1) {
    fbb_.AddElement<int16_t>(NoticeUserNotify::VT_PARAM1, param1, 0);
  }
  void add_param2(int16_t param2) {
    fbb_.AddElement<int16_t>(NoticeUserNotify::VT_PARAM2, param2, 0);
  }
  explicit NoticeUserNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NoticeUserNotifyBuilder &operator=(const NoticeUserNotifyBuilder &);
  flatbuffers::Offset<NoticeUserNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NoticeUserNotify>(end);
    fbb_.Required(o, NoticeUserNotify::VT_WHO);
    return o;
  }
};

inline flatbuffers::Offset<NoticeUserNotify> CreateNoticeUserNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t type = 0,
    int16_t condition = 0,
    flatbuffers::Offset<flatbuffers::String> who = 0,
    int16_t param1 = 0,
    int16_t param2 = 0) {
  NoticeUserNotifyBuilder builder_(_fbb);
  builder_.add_who(who);
  builder_.add_param2(param2);
  builder_.add_param1(param1);
  builder_.add_condition(condition);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<NoticeUserNotify> CreateNoticeUserNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t type = 0,
    int16_t condition = 0,
    const char *who = nullptr,
    int16_t param1 = 0,
    int16_t param2 = 0) {
  return LeanPacket::CreateNoticeUserNotify(
      _fbb,
      type,
      condition,
      who ? _fbb.CreateString(who) : 0,
      param1,
      param2);
}

/// NOTICE_SHOP_PURCHASE_NOTIFY
struct NoticeShopPurchaseNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_WHO = 4,
    VT_GUILDNAME = 6,
    VT_GUILDMEMBERGRADE = 8,
    VT_PRODUCTID = 10
  };
  const flatbuffers::String *who() const {
    return GetPointer<const flatbuffers::String *>(VT_WHO);
  }
  const flatbuffers::String *guildName() const {
    return GetPointer<const flatbuffers::String *>(VT_GUILDNAME);
  }
  int8_t guildMemberGrade() const {
    return GetField<int8_t>(VT_GUILDMEMBERGRADE, 0);
  }
  int32_t productId() const {
    return GetField<int32_t>(VT_PRODUCTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_WHO) &&
           verifier.VerifyString(who()) &&
           VerifyOffsetRequired(verifier, VT_GUILDNAME) &&
           verifier.VerifyString(guildName()) &&
           VerifyField<int8_t>(verifier, VT_GUILDMEMBERGRADE) &&
           VerifyField<int32_t>(verifier, VT_PRODUCTID) &&
           verifier.EndTable();
  }
};

struct NoticeShopPurchaseNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_who(flatbuffers::Offset<flatbuffers::String> who) {
    fbb_.AddOffset(NoticeShopPurchaseNotify::VT_WHO, who);
  }
  void add_guildName(flatbuffers::Offset<flatbuffers::String> guildName) {
    fbb_.AddOffset(NoticeShopPurchaseNotify::VT_GUILDNAME, guildName);
  }
  void add_guildMemberGrade(int8_t guildMemberGrade) {
    fbb_.AddElement<int8_t>(NoticeShopPurchaseNotify::VT_GUILDMEMBERGRADE, guildMemberGrade, 0);
  }
  void add_productId(int32_t productId) {
    fbb_.AddElement<int32_t>(NoticeShopPurchaseNotify::VT_PRODUCTID, productId, 0);
  }
  explicit NoticeShopPurchaseNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NoticeShopPurchaseNotifyBuilder &operator=(const NoticeShopPurchaseNotifyBuilder &);
  flatbuffers::Offset<NoticeShopPurchaseNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NoticeShopPurchaseNotify>(end);
    fbb_.Required(o, NoticeShopPurchaseNotify::VT_WHO);
    fbb_.Required(o, NoticeShopPurchaseNotify::VT_GUILDNAME);
    return o;
  }
};

inline flatbuffers::Offset<NoticeShopPurchaseNotify> CreateNoticeShopPurchaseNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> who = 0,
    flatbuffers::Offset<flatbuffers::String> guildName = 0,
    int8_t guildMemberGrade = 0,
    int32_t productId = 0) {
  NoticeShopPurchaseNotifyBuilder builder_(_fbb);
  builder_.add_productId(productId);
  builder_.add_guildName(guildName);
  builder_.add_who(who);
  builder_.add_guildMemberGrade(guildMemberGrade);
  return builder_.Finish();
}

inline flatbuffers::Offset<NoticeShopPurchaseNotify> CreateNoticeShopPurchaseNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *who = nullptr,
    const char *guildName = nullptr,
    int8_t guildMemberGrade = 0,
    int32_t productId = 0) {
  return LeanPacket::CreateNoticeShopPurchaseNotify(
      _fbb,
      who ? _fbb.CreateString(who) : 0,
      guildName ? _fbb.CreateString(guildName) : 0,
      guildMemberGrade,
      productId);
}

/// NOTICE_PET_NOTIFY
struct NoticePetNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_WHO = 6,
    VT_PETGRADE = 8,
    VT_PETLOOKID = 10
  };
  int16_t type() const {
    return GetField<int16_t>(VT_TYPE, 0);
  }
  const flatbuffers::String *who() const {
    return GetPointer<const flatbuffers::String *>(VT_WHO);
  }
  int16_t petGrade() const {
    return GetField<int16_t>(VT_PETGRADE, 0);
  }
  int32_t petLookId() const {
    return GetField<int32_t>(VT_PETLOOKID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPE) &&
           VerifyOffsetRequired(verifier, VT_WHO) &&
           verifier.VerifyString(who()) &&
           VerifyField<int16_t>(verifier, VT_PETGRADE) &&
           VerifyField<int32_t>(verifier, VT_PETLOOKID) &&
           verifier.EndTable();
  }
};

struct NoticePetNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int16_t type) {
    fbb_.AddElement<int16_t>(NoticePetNotify::VT_TYPE, type, 0);
  }
  void add_who(flatbuffers::Offset<flatbuffers::String> who) {
    fbb_.AddOffset(NoticePetNotify::VT_WHO, who);
  }
  void add_petGrade(int16_t petGrade) {
    fbb_.AddElement<int16_t>(NoticePetNotify::VT_PETGRADE, petGrade, 0);
  }
  void add_petLookId(int32_t petLookId) {
    fbb_.AddElement<int32_t>(NoticePetNotify::VT_PETLOOKID, petLookId, 0);
  }
  explicit NoticePetNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NoticePetNotifyBuilder &operator=(const NoticePetNotifyBuilder &);
  flatbuffers::Offset<NoticePetNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NoticePetNotify>(end);
    fbb_.Required(o, NoticePetNotify::VT_WHO);
    return o;
  }
};

inline flatbuffers::Offset<NoticePetNotify> CreateNoticePetNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t type = 0,
    flatbuffers::Offset<flatbuffers::String> who = 0,
    int16_t petGrade = 0,
    int32_t petLookId = 0) {
  NoticePetNotifyBuilder builder_(_fbb);
  builder_.add_petLookId(petLookId);
  builder_.add_who(who);
  builder_.add_petGrade(petGrade);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<NoticePetNotify> CreateNoticePetNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t type = 0,
    const char *who = nullptr,
    int16_t petGrade = 0,
    int32_t petLookId = 0) {
  return LeanPacket::CreateNoticePetNotify(
      _fbb,
      type,
      who ? _fbb.CreateString(who) : 0,
      petGrade,
      petLookId);
}

/// RVR_BATTLE_FIELD_EVENT_START_NOTIFY  
struct RVRBattleFieldEventStartNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_REMAINSEC = 4
  };
  int32_t remainSec() const {
    return GetField<int32_t>(VT_REMAINSEC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_REMAINSEC) &&
           verifier.EndTable();
  }
};

struct RVRBattleFieldEventStartNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_remainSec(int32_t remainSec) {
    fbb_.AddElement<int32_t>(RVRBattleFieldEventStartNotify::VT_REMAINSEC, remainSec, 0);
  }
  explicit RVRBattleFieldEventStartNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRBattleFieldEventStartNotifyBuilder &operator=(const RVRBattleFieldEventStartNotifyBuilder &);
  flatbuffers::Offset<RVRBattleFieldEventStartNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRBattleFieldEventStartNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRBattleFieldEventStartNotify> CreateRVRBattleFieldEventStartNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t remainSec = 0) {
  RVRBattleFieldEventStartNotifyBuilder builder_(_fbb);
  builder_.add_remainSec(remainSec);
  return builder_.Finish();
}

/// RVR_BATTLE_FIELD_EVENT_END_NOTIFY
struct RVRBattleFieldEventEndNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_REMAINSEC = 4
  };
  int32_t remainSec() const {
    return GetField<int32_t>(VT_REMAINSEC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_REMAINSEC) &&
           verifier.EndTable();
  }
};

struct RVRBattleFieldEventEndNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_remainSec(int32_t remainSec) {
    fbb_.AddElement<int32_t>(RVRBattleFieldEventEndNotify::VT_REMAINSEC, remainSec, 0);
  }
  explicit RVRBattleFieldEventEndNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRBattleFieldEventEndNotifyBuilder &operator=(const RVRBattleFieldEventEndNotifyBuilder &);
  flatbuffers::Offset<RVRBattleFieldEventEndNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRBattleFieldEventEndNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRBattleFieldEventEndNotify> CreateRVRBattleFieldEventEndNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t remainSec = 0) {
  RVRBattleFieldEventEndNotifyBuilder builder_(_fbb);
  builder_.add_remainSec(remainSec);
  return builder_.Finish();
}

/// RVR_BATTLE_FIELD_CLOSE_NOTIFY
struct RVRBattleFieldCloseNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_REMAINSEC = 4
  };
  int32_t remainSec() const {
    return GetField<int32_t>(VT_REMAINSEC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_REMAINSEC) &&
           verifier.EndTable();
  }
};

struct RVRBattleFieldCloseNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_remainSec(int32_t remainSec) {
    fbb_.AddElement<int32_t>(RVRBattleFieldCloseNotify::VT_REMAINSEC, remainSec, 0);
  }
  explicit RVRBattleFieldCloseNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRBattleFieldCloseNotifyBuilder &operator=(const RVRBattleFieldCloseNotifyBuilder &);
  flatbuffers::Offset<RVRBattleFieldCloseNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRBattleFieldCloseNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRBattleFieldCloseNotify> CreateRVRBattleFieldCloseNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t remainSec = 0) {
  RVRBattleFieldCloseNotifyBuilder builder_(_fbb);
  builder_.add_remainSec(remainSec);
  return builder_.Finish();
}

/// RVR_BATTLE_FILED_TIME_INFO_REQUEST
struct RVRBattleFieldTimeInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RVRBattleFieldTimeInfoRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RVRBattleFieldTimeInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRBattleFieldTimeInfoRequestBuilder &operator=(const RVRBattleFieldTimeInfoRequestBuilder &);
  flatbuffers::Offset<RVRBattleFieldTimeInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRBattleFieldTimeInfoRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRBattleFieldTimeInfoRequest> CreateRVRBattleFieldTimeInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RVRBattleFieldTimeInfoRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// RVR_BATTLE_FILED_TIME_INFO_NOTIFY
struct RVRBattleFieldTimeInfoNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FREEREMAINSEC = 4,
    VT_PAIDREMAINSEC = 6
  };
  int32_t freeRemainSec() const {
    return GetField<int32_t>(VT_FREEREMAINSEC, 0);
  }
  int32_t paidRemainSec() const {
    return GetField<int32_t>(VT_PAIDREMAINSEC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FREEREMAINSEC) &&
           VerifyField<int32_t>(verifier, VT_PAIDREMAINSEC) &&
           verifier.EndTable();
  }
};

struct RVRBattleFieldTimeInfoNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_freeRemainSec(int32_t freeRemainSec) {
    fbb_.AddElement<int32_t>(RVRBattleFieldTimeInfoNotify::VT_FREEREMAINSEC, freeRemainSec, 0);
  }
  void add_paidRemainSec(int32_t paidRemainSec) {
    fbb_.AddElement<int32_t>(RVRBattleFieldTimeInfoNotify::VT_PAIDREMAINSEC, paidRemainSec, 0);
  }
  explicit RVRBattleFieldTimeInfoNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRBattleFieldTimeInfoNotifyBuilder &operator=(const RVRBattleFieldTimeInfoNotifyBuilder &);
  flatbuffers::Offset<RVRBattleFieldTimeInfoNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRBattleFieldTimeInfoNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRBattleFieldTimeInfoNotify> CreateRVRBattleFieldTimeInfoNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t freeRemainSec = 0,
    int32_t paidRemainSec = 0) {
  RVRBattleFieldTimeInfoNotifyBuilder builder_(_fbb);
  builder_.add_paidRemainSec(paidRemainSec);
  builder_.add_freeRemainSec(freeRemainSec);
  return builder_.Finish();
}

/// RVR_BATTLE_FILED_TIME_INFO_RESPONSE
struct RVRBattleFieldTimeInfoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FREEREMAINSEC = 4,
    VT_PAIDREMAINSEC = 6
  };
  int32_t freeRemainSec() const {
    return GetField<int32_t>(VT_FREEREMAINSEC, 0);
  }
  int32_t paidRemainSec() const {
    return GetField<int32_t>(VT_PAIDREMAINSEC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FREEREMAINSEC) &&
           VerifyField<int32_t>(verifier, VT_PAIDREMAINSEC) &&
           verifier.EndTable();
  }
};

struct RVRBattleFieldTimeInfoResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_freeRemainSec(int32_t freeRemainSec) {
    fbb_.AddElement<int32_t>(RVRBattleFieldTimeInfoResponse::VT_FREEREMAINSEC, freeRemainSec, 0);
  }
  void add_paidRemainSec(int32_t paidRemainSec) {
    fbb_.AddElement<int32_t>(RVRBattleFieldTimeInfoResponse::VT_PAIDREMAINSEC, paidRemainSec, 0);
  }
  explicit RVRBattleFieldTimeInfoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRBattleFieldTimeInfoResponseBuilder &operator=(const RVRBattleFieldTimeInfoResponseBuilder &);
  flatbuffers::Offset<RVRBattleFieldTimeInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRBattleFieldTimeInfoResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRBattleFieldTimeInfoResponse> CreateRVRBattleFieldTimeInfoResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t freeRemainSec = 0,
    int32_t paidRemainSec = 0) {
  RVRBattleFieldTimeInfoResponseBuilder builder_(_fbb);
  builder_.add_paidRemainSec(paidRemainSec);
  builder_.add_freeRemainSec(freeRemainSec);
  return builder_.Finish();
}

/// RVR_BATTLE_FILED_TIME_EXPIRED_NOTIFY
struct RVRBattleFieldTimeExpiredNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RVRBattleFieldTimeExpiredNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RVRBattleFieldTimeExpiredNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRBattleFieldTimeExpiredNotifyBuilder &operator=(const RVRBattleFieldTimeExpiredNotifyBuilder &);
  flatbuffers::Offset<RVRBattleFieldTimeExpiredNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRBattleFieldTimeExpiredNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRBattleFieldTimeExpiredNotify> CreateRVRBattleFieldTimeExpiredNotify(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RVRBattleFieldTimeExpiredNotifyBuilder builder_(_fbb);
  return builder_.Finish();
}

/// RVR_BATTLE_FILED_FREE_TIME_EXPIRED_NOTIFY
struct RVRBattleFieldFreeTimeExpiredNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RVRBattleFieldFreeTimeExpiredNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RVRBattleFieldFreeTimeExpiredNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRBattleFieldFreeTimeExpiredNotifyBuilder &operator=(const RVRBattleFieldFreeTimeExpiredNotifyBuilder &);
  flatbuffers::Offset<RVRBattleFieldFreeTimeExpiredNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRBattleFieldFreeTimeExpiredNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRBattleFieldFreeTimeExpiredNotify> CreateRVRBattleFieldFreeTimeExpiredNotify(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RVRBattleFieldFreeTimeExpiredNotifyBuilder builder_(_fbb);
  return builder_.Finish();
}

/// RVR_BATTLE_FILED_REMAIN_TIME_NOTIFY
struct RVRBattleFieldRemainTimeNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_REMAINSEC = 4
  };
  int32_t remainSec() const {
    return GetField<int32_t>(VT_REMAINSEC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_REMAINSEC) &&
           verifier.EndTable();
  }
};

struct RVRBattleFieldRemainTimeNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_remainSec(int32_t remainSec) {
    fbb_.AddElement<int32_t>(RVRBattleFieldRemainTimeNotify::VT_REMAINSEC, remainSec, 0);
  }
  explicit RVRBattleFieldRemainTimeNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRBattleFieldRemainTimeNotifyBuilder &operator=(const RVRBattleFieldRemainTimeNotifyBuilder &);
  flatbuffers::Offset<RVRBattleFieldRemainTimeNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRBattleFieldRemainTimeNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRBattleFieldRemainTimeNotify> CreateRVRBattleFieldRemainTimeNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t remainSec = 0) {
  RVRBattleFieldRemainTimeNotifyBuilder builder_(_fbb);
  builder_.add_remainSec(remainSec);
  return builder_.Finish();
}

/// RVR_BATTLE_FILED_PK_NOTIFY
struct RVRBattleFieldPKNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_KILLEROBJECTID = 4,
    VT_KILLEDOBJECTID = 6,
    VT_KILLERWORLDID = 8,
    VT_KILLEDWORLDID = 10
  };
  int64_t killerObjectId() const {
    return GetField<int64_t>(VT_KILLEROBJECTID, 0);
  }
  int64_t killedObjectId() const {
    return GetField<int64_t>(VT_KILLEDOBJECTID, 0);
  }
  int16_t killerWorldId() const {
    return GetField<int16_t>(VT_KILLERWORLDID, 0);
  }
  int16_t killedWorldId() const {
    return GetField<int16_t>(VT_KILLEDWORLDID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_KILLEROBJECTID) &&
           VerifyField<int64_t>(verifier, VT_KILLEDOBJECTID) &&
           VerifyField<int16_t>(verifier, VT_KILLERWORLDID) &&
           VerifyField<int16_t>(verifier, VT_KILLEDWORLDID) &&
           verifier.EndTable();
  }
};

struct RVRBattleFieldPKNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_killerObjectId(int64_t killerObjectId) {
    fbb_.AddElement<int64_t>(RVRBattleFieldPKNotify::VT_KILLEROBJECTID, killerObjectId, 0);
  }
  void add_killedObjectId(int64_t killedObjectId) {
    fbb_.AddElement<int64_t>(RVRBattleFieldPKNotify::VT_KILLEDOBJECTID, killedObjectId, 0);
  }
  void add_killerWorldId(int16_t killerWorldId) {
    fbb_.AddElement<int16_t>(RVRBattleFieldPKNotify::VT_KILLERWORLDID, killerWorldId, 0);
  }
  void add_killedWorldId(int16_t killedWorldId) {
    fbb_.AddElement<int16_t>(RVRBattleFieldPKNotify::VT_KILLEDWORLDID, killedWorldId, 0);
  }
  explicit RVRBattleFieldPKNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRBattleFieldPKNotifyBuilder &operator=(const RVRBattleFieldPKNotifyBuilder &);
  flatbuffers::Offset<RVRBattleFieldPKNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRBattleFieldPKNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRBattleFieldPKNotify> CreateRVRBattleFieldPKNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t killerObjectId = 0,
    int64_t killedObjectId = 0,
    int16_t killerWorldId = 0,
    int16_t killedWorldId = 0) {
  RVRBattleFieldPKNotifyBuilder builder_(_fbb);
  builder_.add_killedObjectId(killedObjectId);
  builder_.add_killerObjectId(killerObjectId);
  builder_.add_killedWorldId(killedWorldId);
  builder_.add_killerWorldId(killerWorldId);
  return builder_.Finish();
}

/// RVR_BATTLE_FIELD_SHORT_TERM_MAX_NOTIFY
struct RVRBattleFieldShortTermMaxNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SHORTTERMSTEPID = 4
  };
  int32_t shortTermStepId() const {
    return GetField<int32_t>(VT_SHORTTERMSTEPID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SHORTTERMSTEPID) &&
           verifier.EndTable();
  }
};

struct RVRBattleFieldShortTermMaxNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_shortTermStepId(int32_t shortTermStepId) {
    fbb_.AddElement<int32_t>(RVRBattleFieldShortTermMaxNotify::VT_SHORTTERMSTEPID, shortTermStepId, 0);
  }
  explicit RVRBattleFieldShortTermMaxNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRBattleFieldShortTermMaxNotifyBuilder &operator=(const RVRBattleFieldShortTermMaxNotifyBuilder &);
  flatbuffers::Offset<RVRBattleFieldShortTermMaxNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRBattleFieldShortTermMaxNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRBattleFieldShortTermMaxNotify> CreateRVRBattleFieldShortTermMaxNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t shortTermStepId = 0) {
  RVRBattleFieldShortTermMaxNotifyBuilder builder_(_fbb);
  builder_.add_shortTermStepId(shortTermStepId);
  return builder_.Finish();
}

/// RVR_BATTLE_FIELD_OTHER_PC_SHORT_TERM_MAX_NOTIFY
struct RVRBattleFieldOtherPcShortTermMaxNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCNAME = 4,
    VT_PCIFF = 6,
    VT_PCCLASSTYPE = 8,
    VT_SHORTTERMSTEPID = 10
  };
  const flatbuffers::String *pcName() const {
    return GetPointer<const flatbuffers::String *>(VT_PCNAME);
  }
  int32_t pcIff() const {
    return GetField<int32_t>(VT_PCIFF, 0);
  }
  int32_t pcClassType() const {
    return GetField<int32_t>(VT_PCCLASSTYPE, 0);
  }
  int32_t shortTermStepId() const {
    return GetField<int32_t>(VT_SHORTTERMSTEPID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PCNAME) &&
           verifier.VerifyString(pcName()) &&
           VerifyField<int32_t>(verifier, VT_PCIFF) &&
           VerifyField<int32_t>(verifier, VT_PCCLASSTYPE) &&
           VerifyField<int32_t>(verifier, VT_SHORTTERMSTEPID) &&
           verifier.EndTable();
  }
};

struct RVRBattleFieldOtherPcShortTermMaxNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcName(flatbuffers::Offset<flatbuffers::String> pcName) {
    fbb_.AddOffset(RVRBattleFieldOtherPcShortTermMaxNotify::VT_PCNAME, pcName);
  }
  void add_pcIff(int32_t pcIff) {
    fbb_.AddElement<int32_t>(RVRBattleFieldOtherPcShortTermMaxNotify::VT_PCIFF, pcIff, 0);
  }
  void add_pcClassType(int32_t pcClassType) {
    fbb_.AddElement<int32_t>(RVRBattleFieldOtherPcShortTermMaxNotify::VT_PCCLASSTYPE, pcClassType, 0);
  }
  void add_shortTermStepId(int32_t shortTermStepId) {
    fbb_.AddElement<int32_t>(RVRBattleFieldOtherPcShortTermMaxNotify::VT_SHORTTERMSTEPID, shortTermStepId, 0);
  }
  explicit RVRBattleFieldOtherPcShortTermMaxNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRBattleFieldOtherPcShortTermMaxNotifyBuilder &operator=(const RVRBattleFieldOtherPcShortTermMaxNotifyBuilder &);
  flatbuffers::Offset<RVRBattleFieldOtherPcShortTermMaxNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRBattleFieldOtherPcShortTermMaxNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRBattleFieldOtherPcShortTermMaxNotify> CreateRVRBattleFieldOtherPcShortTermMaxNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> pcName = 0,
    int32_t pcIff = 0,
    int32_t pcClassType = 0,
    int32_t shortTermStepId = 0) {
  RVRBattleFieldOtherPcShortTermMaxNotifyBuilder builder_(_fbb);
  builder_.add_shortTermStepId(shortTermStepId);
  builder_.add_pcClassType(pcClassType);
  builder_.add_pcIff(pcIff);
  builder_.add_pcName(pcName);
  return builder_.Finish();
}

inline flatbuffers::Offset<RVRBattleFieldOtherPcShortTermMaxNotify> CreateRVRBattleFieldOtherPcShortTermMaxNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *pcName = nullptr,
    int32_t pcIff = 0,
    int32_t pcClassType = 0,
    int32_t shortTermStepId = 0) {
  return LeanPacket::CreateRVRBattleFieldOtherPcShortTermMaxNotify(
      _fbb,
      pcName ? _fbb.CreateString(pcName) : 0,
      pcIff,
      pcClassType,
      shortTermStepId);
}

/// ARENA_REWARD_REQUEST
struct ArenaRewardRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ArenaRewardRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ArenaRewardRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArenaRewardRequestBuilder &operator=(const ArenaRewardRequestBuilder &);
  flatbuffers::Offset<ArenaRewardRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArenaRewardRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArenaRewardRequest> CreateArenaRewardRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ArenaRewardRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// ARENA_REWARD_RESPONSE
struct ArenaRewardResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULT = 4,
    VT_REMAINTRYCOUNT = 6
  };
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  int16_t remainTryCount() const {
    return GetField<int16_t>(VT_REMAINTRYCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           VerifyField<int16_t>(verifier, VT_REMAINTRYCOUNT) &&
           verifier.EndTable();
  }
};

struct ArenaRewardResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(ArenaRewardResponse::VT_RESULT, result, 0);
  }
  void add_remainTryCount(int16_t remainTryCount) {
    fbb_.AddElement<int16_t>(ArenaRewardResponse::VT_REMAINTRYCOUNT, remainTryCount, 0);
  }
  explicit ArenaRewardResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArenaRewardResponseBuilder &operator=(const ArenaRewardResponseBuilder &);
  flatbuffers::Offset<ArenaRewardResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArenaRewardResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArenaRewardResponse> CreateArenaRewardResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    int16_t remainTryCount = 0) {
  ArenaRewardResponseBuilder builder_(_fbb);
  builder_.add_result(result);
  builder_.add_remainTryCount(remainTryCount);
  return builder_.Finish();
}

/// CHANGE_REACTION_IMMUNE_INFO_NOTIFY
struct ChangeReactionImmuneInfoNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_CURGAGE = 6,
    VT_ISIMMUNE = 8,
    VT_SERVERFLOWEDIMMUNTIME = 10
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int32_t curGage() const {
    return GetField<int32_t>(VT_CURGAGE, 0);
  }
  bool isImmune() const {
    return GetField<uint8_t>(VT_ISIMMUNE, 0) != 0;
  }
  int32_t serverFlowedImmunTime() const {
    return GetField<int32_t>(VT_SERVERFLOWEDIMMUNTIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int32_t>(verifier, VT_CURGAGE) &&
           VerifyField<uint8_t>(verifier, VT_ISIMMUNE) &&
           VerifyField<int32_t>(verifier, VT_SERVERFLOWEDIMMUNTIME) &&
           verifier.EndTable();
  }
};

struct ChangeReactionImmuneInfoNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(ChangeReactionImmuneInfoNotify::VT_OBJECTID, objectId, 0);
  }
  void add_curGage(int32_t curGage) {
    fbb_.AddElement<int32_t>(ChangeReactionImmuneInfoNotify::VT_CURGAGE, curGage, 0);
  }
  void add_isImmune(bool isImmune) {
    fbb_.AddElement<uint8_t>(ChangeReactionImmuneInfoNotify::VT_ISIMMUNE, static_cast<uint8_t>(isImmune), 0);
  }
  void add_serverFlowedImmunTime(int32_t serverFlowedImmunTime) {
    fbb_.AddElement<int32_t>(ChangeReactionImmuneInfoNotify::VT_SERVERFLOWEDIMMUNTIME, serverFlowedImmunTime, 0);
  }
  explicit ChangeReactionImmuneInfoNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChangeReactionImmuneInfoNotifyBuilder &operator=(const ChangeReactionImmuneInfoNotifyBuilder &);
  flatbuffers::Offset<ChangeReactionImmuneInfoNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChangeReactionImmuneInfoNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChangeReactionImmuneInfoNotify> CreateChangeReactionImmuneInfoNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int32_t curGage = 0,
    bool isImmune = false,
    int32_t serverFlowedImmunTime = 0) {
  ChangeReactionImmuneInfoNotifyBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_serverFlowedImmunTime(serverFlowedImmunTime);
  builder_.add_curGage(curGage);
  builder_.add_isImmune(isImmune);
  return builder_.Finish();
}

/// ARENA_EXIT_REQUEST
struct ArenaExitRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DOSTAY = 4
  };
  bool doStay() const {
    return GetField<uint8_t>(VT_DOSTAY, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DOSTAY) &&
           verifier.EndTable();
  }
};

struct ArenaExitRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_doStay(bool doStay) {
    fbb_.AddElement<uint8_t>(ArenaExitRequest::VT_DOSTAY, static_cast<uint8_t>(doStay), 0);
  }
  explicit ArenaExitRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArenaExitRequestBuilder &operator=(const ArenaExitRequestBuilder &);
  flatbuffers::Offset<ArenaExitRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArenaExitRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArenaExitRequest> CreateArenaExitRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool doStay = false) {
  ArenaExitRequestBuilder builder_(_fbb);
  builder_.add_doStay(doStay);
  return builder_.Finish();
}

/// PUBLIC_KEY_NOTIFY
struct PublicKeyNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PUBLICKEY = 4
  };
  const flatbuffers::Vector<uint8_t> *publicKey() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PUBLICKEY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PUBLICKEY) &&
           verifier.VerifyVector(publicKey()) &&
           verifier.EndTable();
  }
};

struct PublicKeyNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_publicKey(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> publicKey) {
    fbb_.AddOffset(PublicKeyNotify::VT_PUBLICKEY, publicKey);
  }
  explicit PublicKeyNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PublicKeyNotifyBuilder &operator=(const PublicKeyNotifyBuilder &);
  flatbuffers::Offset<PublicKeyNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PublicKeyNotify>(end);
    fbb_.Required(o, PublicKeyNotify::VT_PUBLICKEY);
    return o;
  }
};

inline flatbuffers::Offset<PublicKeyNotify> CreatePublicKeyNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> publicKey = 0) {
  PublicKeyNotifyBuilder builder_(_fbb);
  builder_.add_publicKey(publicKey);
  return builder_.Finish();
}

inline flatbuffers::Offset<PublicKeyNotify> CreatePublicKeyNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *publicKey = nullptr) {
  return LeanPacket::CreatePublicKeyNotify(
      _fbb,
      publicKey ? _fbb.CreateVector<uint8_t>(*publicKey) : 0);
}

///
struct CryptKeyPair FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CLIENTKEY = 4,
    VT_SERVERKEY = 6,
    VT_CLIENTKEYNONCE = 8,
    VT_SERVERKEYNONCE = 10
  };
  const flatbuffers::Vector<uint8_t> *clientKey() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CLIENTKEY);
  }
  const flatbuffers::Vector<uint8_t> *serverKey() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SERVERKEY);
  }
  const flatbuffers::Vector<uint8_t> *clientKeyNonce() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CLIENTKEYNONCE);
  }
  const flatbuffers::Vector<uint8_t> *serverKeyNonce() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SERVERKEYNONCE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CLIENTKEY) &&
           verifier.VerifyVector(clientKey()) &&
           VerifyOffsetRequired(verifier, VT_SERVERKEY) &&
           verifier.VerifyVector(serverKey()) &&
           VerifyOffsetRequired(verifier, VT_CLIENTKEYNONCE) &&
           verifier.VerifyVector(clientKeyNonce()) &&
           VerifyOffsetRequired(verifier, VT_SERVERKEYNONCE) &&
           verifier.VerifyVector(serverKeyNonce()) &&
           verifier.EndTable();
  }
};

struct CryptKeyPairBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_clientKey(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> clientKey) {
    fbb_.AddOffset(CryptKeyPair::VT_CLIENTKEY, clientKey);
  }
  void add_serverKey(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> serverKey) {
    fbb_.AddOffset(CryptKeyPair::VT_SERVERKEY, serverKey);
  }
  void add_clientKeyNonce(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> clientKeyNonce) {
    fbb_.AddOffset(CryptKeyPair::VT_CLIENTKEYNONCE, clientKeyNonce);
  }
  void add_serverKeyNonce(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> serverKeyNonce) {
    fbb_.AddOffset(CryptKeyPair::VT_SERVERKEYNONCE, serverKeyNonce);
  }
  explicit CryptKeyPairBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CryptKeyPairBuilder &operator=(const CryptKeyPairBuilder &);
  flatbuffers::Offset<CryptKeyPair> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CryptKeyPair>(end);
    fbb_.Required(o, CryptKeyPair::VT_CLIENTKEY);
    fbb_.Required(o, CryptKeyPair::VT_SERVERKEY);
    fbb_.Required(o, CryptKeyPair::VT_CLIENTKEYNONCE);
    fbb_.Required(o, CryptKeyPair::VT_SERVERKEYNONCE);
    return o;
  }
};

inline flatbuffers::Offset<CryptKeyPair> CreateCryptKeyPair(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> clientKey = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> serverKey = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> clientKeyNonce = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> serverKeyNonce = 0) {
  CryptKeyPairBuilder builder_(_fbb);
  builder_.add_serverKeyNonce(serverKeyNonce);
  builder_.add_clientKeyNonce(clientKeyNonce);
  builder_.add_serverKey(serverKey);
  builder_.add_clientKey(clientKey);
  return builder_.Finish();
}

inline flatbuffers::Offset<CryptKeyPair> CreateCryptKeyPairDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *clientKey = nullptr,
    const std::vector<uint8_t> *serverKey = nullptr,
    const std::vector<uint8_t> *clientKeyNonce = nullptr,
    const std::vector<uint8_t> *serverKeyNonce = nullptr) {
  return LeanPacket::CreateCryptKeyPair(
      _fbb,
      clientKey ? _fbb.CreateVector<uint8_t>(*clientKey) : 0,
      serverKey ? _fbb.CreateVector<uint8_t>(*serverKey) : 0,
      clientKeyNonce ? _fbb.CreateVector<uint8_t>(*clientKeyNonce) : 0,
      serverKeyNonce ? _fbb.CreateVector<uint8_t>(*serverKeyNonce) : 0);
}

/// CRYPT_KEY_NOTIFY
struct CryptKeyNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CRYPTKEYPAIR = 4
  };
  const CryptKeyPair *cryptKeyPair() const {
    return GetPointer<const CryptKeyPair *>(VT_CRYPTKEYPAIR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CRYPTKEYPAIR) &&
           verifier.VerifyTable(cryptKeyPair()) &&
           verifier.EndTable();
  }
};

struct CryptKeyNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cryptKeyPair(flatbuffers::Offset<CryptKeyPair> cryptKeyPair) {
    fbb_.AddOffset(CryptKeyNotify::VT_CRYPTKEYPAIR, cryptKeyPair);
  }
  explicit CryptKeyNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CryptKeyNotifyBuilder &operator=(const CryptKeyNotifyBuilder &);
  flatbuffers::Offset<CryptKeyNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CryptKeyNotify>(end);
    fbb_.Required(o, CryptKeyNotify::VT_CRYPTKEYPAIR);
    return o;
  }
};

inline flatbuffers::Offset<CryptKeyNotify> CreateCryptKeyNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<CryptKeyPair> cryptKeyPair = 0) {
  CryptKeyNotifyBuilder builder_(_fbb);
  builder_.add_cryptKeyPair(cryptKeyPair);
  return builder_.Finish();
}

struct BattleFieldEventInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STATUS = 4,
    VT_EVENTTIMESEC = 6,
    VT_OCCUPYINGREALMID = 8,
    VT_OCCUPYINGGUILDID = 10,
    VT_OCCUPYINGGUILDNAME = 12,
    VT_OCCUPYINGGUILDCREST = 14,
    VT_OCCUPYINGWORLDID = 16
  };
  BattleFieldEventStatus status() const {
    return static_cast<BattleFieldEventStatus>(GetField<int16_t>(VT_STATUS, 0));
  }
  int32_t eventTimeSec() const {
    return GetField<int32_t>(VT_EVENTTIMESEC, 0);
  }
  int32_t occupyingRealmId() const {
    return GetField<int32_t>(VT_OCCUPYINGREALMID, 0);
  }
  int32_t occupyingGuildId() const {
    return GetField<int32_t>(VT_OCCUPYINGGUILDID, 0);
  }
  const flatbuffers::String *occupyingGuildName() const {
    return GetPointer<const flatbuffers::String *>(VT_OCCUPYINGGUILDNAME);
  }
  const GuildCrest *occupyingGuildCrest() const {
    return GetPointer<const GuildCrest *>(VT_OCCUPYINGGUILDCREST);
  }
  int16_t occupyingWorldId() const {
    return GetField<int16_t>(VT_OCCUPYINGWORLDID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_STATUS) &&
           VerifyField<int32_t>(verifier, VT_EVENTTIMESEC) &&
           VerifyField<int32_t>(verifier, VT_OCCUPYINGREALMID) &&
           VerifyField<int32_t>(verifier, VT_OCCUPYINGGUILDID) &&
           VerifyOffsetRequired(verifier, VT_OCCUPYINGGUILDNAME) &&
           verifier.VerifyString(occupyingGuildName()) &&
           VerifyOffsetRequired(verifier, VT_OCCUPYINGGUILDCREST) &&
           verifier.VerifyTable(occupyingGuildCrest()) &&
           VerifyField<int16_t>(verifier, VT_OCCUPYINGWORLDID) &&
           verifier.EndTable();
  }
};

struct BattleFieldEventInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status(BattleFieldEventStatus status) {
    fbb_.AddElement<int16_t>(BattleFieldEventInfo::VT_STATUS, static_cast<int16_t>(status), 0);
  }
  void add_eventTimeSec(int32_t eventTimeSec) {
    fbb_.AddElement<int32_t>(BattleFieldEventInfo::VT_EVENTTIMESEC, eventTimeSec, 0);
  }
  void add_occupyingRealmId(int32_t occupyingRealmId) {
    fbb_.AddElement<int32_t>(BattleFieldEventInfo::VT_OCCUPYINGREALMID, occupyingRealmId, 0);
  }
  void add_occupyingGuildId(int32_t occupyingGuildId) {
    fbb_.AddElement<int32_t>(BattleFieldEventInfo::VT_OCCUPYINGGUILDID, occupyingGuildId, 0);
  }
  void add_occupyingGuildName(flatbuffers::Offset<flatbuffers::String> occupyingGuildName) {
    fbb_.AddOffset(BattleFieldEventInfo::VT_OCCUPYINGGUILDNAME, occupyingGuildName);
  }
  void add_occupyingGuildCrest(flatbuffers::Offset<GuildCrest> occupyingGuildCrest) {
    fbb_.AddOffset(BattleFieldEventInfo::VT_OCCUPYINGGUILDCREST, occupyingGuildCrest);
  }
  void add_occupyingWorldId(int16_t occupyingWorldId) {
    fbb_.AddElement<int16_t>(BattleFieldEventInfo::VT_OCCUPYINGWORLDID, occupyingWorldId, 0);
  }
  explicit BattleFieldEventInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BattleFieldEventInfoBuilder &operator=(const BattleFieldEventInfoBuilder &);
  flatbuffers::Offset<BattleFieldEventInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BattleFieldEventInfo>(end);
    fbb_.Required(o, BattleFieldEventInfo::VT_OCCUPYINGGUILDNAME);
    fbb_.Required(o, BattleFieldEventInfo::VT_OCCUPYINGGUILDCREST);
    return o;
  }
};

inline flatbuffers::Offset<BattleFieldEventInfo> CreateBattleFieldEventInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    BattleFieldEventStatus status = BattleFieldEventStatus_BATTLE_FIELD_EVENT_STATUS_NONE,
    int32_t eventTimeSec = 0,
    int32_t occupyingRealmId = 0,
    int32_t occupyingGuildId = 0,
    flatbuffers::Offset<flatbuffers::String> occupyingGuildName = 0,
    flatbuffers::Offset<GuildCrest> occupyingGuildCrest = 0,
    int16_t occupyingWorldId = 0) {
  BattleFieldEventInfoBuilder builder_(_fbb);
  builder_.add_occupyingGuildCrest(occupyingGuildCrest);
  builder_.add_occupyingGuildName(occupyingGuildName);
  builder_.add_occupyingGuildId(occupyingGuildId);
  builder_.add_occupyingRealmId(occupyingRealmId);
  builder_.add_eventTimeSec(eventTimeSec);
  builder_.add_occupyingWorldId(occupyingWorldId);
  builder_.add_status(status);
  return builder_.Finish();
}

inline flatbuffers::Offset<BattleFieldEventInfo> CreateBattleFieldEventInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    BattleFieldEventStatus status = BattleFieldEventStatus_BATTLE_FIELD_EVENT_STATUS_NONE,
    int32_t eventTimeSec = 0,
    int32_t occupyingRealmId = 0,
    int32_t occupyingGuildId = 0,
    const char *occupyingGuildName = nullptr,
    flatbuffers::Offset<GuildCrest> occupyingGuildCrest = 0,
    int16_t occupyingWorldId = 0) {
  return LeanPacket::CreateBattleFieldEventInfo(
      _fbb,
      status,
      eventTimeSec,
      occupyingRealmId,
      occupyingGuildId,
      occupyingGuildName ? _fbb.CreateString(occupyingGuildName) : 0,
      occupyingGuildCrest,
      occupyingWorldId);
}

struct BattleFieldPlayerPerRealm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_REALMID = 4,
    VT_PLAYERCOUNT = 6
  };
  int32_t realmId() const {
    return GetField<int32_t>(VT_REALMID, 0);
  }
  int32_t playerCount() const {
    return GetField<int32_t>(VT_PLAYERCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_REALMID) &&
           VerifyField<int32_t>(verifier, VT_PLAYERCOUNT) &&
           verifier.EndTable();
  }
};

struct BattleFieldPlayerPerRealmBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_realmId(int32_t realmId) {
    fbb_.AddElement<int32_t>(BattleFieldPlayerPerRealm::VT_REALMID, realmId, 0);
  }
  void add_playerCount(int32_t playerCount) {
    fbb_.AddElement<int32_t>(BattleFieldPlayerPerRealm::VT_PLAYERCOUNT, playerCount, 0);
  }
  explicit BattleFieldPlayerPerRealmBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BattleFieldPlayerPerRealmBuilder &operator=(const BattleFieldPlayerPerRealmBuilder &);
  flatbuffers::Offset<BattleFieldPlayerPerRealm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BattleFieldPlayerPerRealm>(end);
    return o;
  }
};

inline flatbuffers::Offset<BattleFieldPlayerPerRealm> CreateBattleFieldPlayerPerRealm(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t realmId = 0,
    int32_t playerCount = 0) {
  BattleFieldPlayerPerRealmBuilder builder_(_fbb);
  builder_.add_playerCount(playerCount);
  builder_.add_realmId(realmId);
  return builder_.Finish();
}

struct BattleFieldChannelInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RVRID = 4,
    VT_OPENSTATE = 6,
    VT_EVENTINFO = 8,
    VT_PLAYERPERREALM = 10
  };
  int32_t rvrId() const {
    return GetField<int32_t>(VT_RVRID, 0);
  }
  bool openState() const {
    return GetField<uint8_t>(VT_OPENSTATE, 0) != 0;
  }
  const BattleFieldEventInfo *eventInfo() const {
    return GetPointer<const BattleFieldEventInfo *>(VT_EVENTINFO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<BattleFieldPlayerPerRealm>> *playerPerRealm() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BattleFieldPlayerPerRealm>> *>(VT_PLAYERPERREALM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RVRID) &&
           VerifyField<uint8_t>(verifier, VT_OPENSTATE) &&
           VerifyOffsetRequired(verifier, VT_EVENTINFO) &&
           verifier.VerifyTable(eventInfo()) &&
           VerifyOffsetRequired(verifier, VT_PLAYERPERREALM) &&
           verifier.VerifyVector(playerPerRealm()) &&
           verifier.VerifyVectorOfTables(playerPerRealm()) &&
           verifier.EndTable();
  }
};

struct BattleFieldChannelInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rvrId(int32_t rvrId) {
    fbb_.AddElement<int32_t>(BattleFieldChannelInfo::VT_RVRID, rvrId, 0);
  }
  void add_openState(bool openState) {
    fbb_.AddElement<uint8_t>(BattleFieldChannelInfo::VT_OPENSTATE, static_cast<uint8_t>(openState), 0);
  }
  void add_eventInfo(flatbuffers::Offset<BattleFieldEventInfo> eventInfo) {
    fbb_.AddOffset(BattleFieldChannelInfo::VT_EVENTINFO, eventInfo);
  }
  void add_playerPerRealm(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BattleFieldPlayerPerRealm>>> playerPerRealm) {
    fbb_.AddOffset(BattleFieldChannelInfo::VT_PLAYERPERREALM, playerPerRealm);
  }
  explicit BattleFieldChannelInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BattleFieldChannelInfoBuilder &operator=(const BattleFieldChannelInfoBuilder &);
  flatbuffers::Offset<BattleFieldChannelInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BattleFieldChannelInfo>(end);
    fbb_.Required(o, BattleFieldChannelInfo::VT_EVENTINFO);
    fbb_.Required(o, BattleFieldChannelInfo::VT_PLAYERPERREALM);
    return o;
  }
};

inline flatbuffers::Offset<BattleFieldChannelInfo> CreateBattleFieldChannelInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rvrId = 0,
    bool openState = false,
    flatbuffers::Offset<BattleFieldEventInfo> eventInfo = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BattleFieldPlayerPerRealm>>> playerPerRealm = 0) {
  BattleFieldChannelInfoBuilder builder_(_fbb);
  builder_.add_playerPerRealm(playerPerRealm);
  builder_.add_eventInfo(eventInfo);
  builder_.add_rvrId(rvrId);
  builder_.add_openState(openState);
  return builder_.Finish();
}

inline flatbuffers::Offset<BattleFieldChannelInfo> CreateBattleFieldChannelInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rvrId = 0,
    bool openState = false,
    flatbuffers::Offset<BattleFieldEventInfo> eventInfo = 0,
    const std::vector<flatbuffers::Offset<BattleFieldPlayerPerRealm>> *playerPerRealm = nullptr) {
  return LeanPacket::CreateBattleFieldChannelInfo(
      _fbb,
      rvrId,
      openState,
      eventInfo,
      playerPerRealm ? _fbb.CreateVector<flatbuffers::Offset<BattleFieldPlayerPerRealm>>(*playerPerRealm) : 0);
}

struct BattleFieldGuildPlayerPerRVR FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RVRID = 4,
    VT_GUILDMEMBERCOUNT = 6
  };
  int32_t rvrId() const {
    return GetField<int32_t>(VT_RVRID, 0);
  }
  int32_t guildMemberCount() const {
    return GetField<int32_t>(VT_GUILDMEMBERCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RVRID) &&
           VerifyField<int32_t>(verifier, VT_GUILDMEMBERCOUNT) &&
           verifier.EndTable();
  }
};

struct BattleFieldGuildPlayerPerRVRBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rvrId(int32_t rvrId) {
    fbb_.AddElement<int32_t>(BattleFieldGuildPlayerPerRVR::VT_RVRID, rvrId, 0);
  }
  void add_guildMemberCount(int32_t guildMemberCount) {
    fbb_.AddElement<int32_t>(BattleFieldGuildPlayerPerRVR::VT_GUILDMEMBERCOUNT, guildMemberCount, 0);
  }
  explicit BattleFieldGuildPlayerPerRVRBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BattleFieldGuildPlayerPerRVRBuilder &operator=(const BattleFieldGuildPlayerPerRVRBuilder &);
  flatbuffers::Offset<BattleFieldGuildPlayerPerRVR> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BattleFieldGuildPlayerPerRVR>(end);
    return o;
  }
};

inline flatbuffers::Offset<BattleFieldGuildPlayerPerRVR> CreateBattleFieldGuildPlayerPerRVR(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rvrId = 0,
    int32_t guildMemberCount = 0) {
  BattleFieldGuildPlayerPerRVRBuilder builder_(_fbb);
  builder_.add_guildMemberCount(guildMemberCount);
  builder_.add_rvrId(rvrId);
  return builder_.Finish();
}

struct BattleFieldPcInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESERVEDRVRID = 4,
    VT_GUILDPLAYERPERRVRS = 6
  };
  int32_t reservedRvrId() const {
    return GetField<int32_t>(VT_RESERVEDRVRID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<BattleFieldGuildPlayerPerRVR>> *guildPlayerPerRVRs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BattleFieldGuildPlayerPerRVR>> *>(VT_GUILDPLAYERPERRVRS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESERVEDRVRID) &&
           VerifyOffsetRequired(verifier, VT_GUILDPLAYERPERRVRS) &&
           verifier.VerifyVector(guildPlayerPerRVRs()) &&
           verifier.VerifyVectorOfTables(guildPlayerPerRVRs()) &&
           verifier.EndTable();
  }
};

struct BattleFieldPcInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_reservedRvrId(int32_t reservedRvrId) {
    fbb_.AddElement<int32_t>(BattleFieldPcInfo::VT_RESERVEDRVRID, reservedRvrId, 0);
  }
  void add_guildPlayerPerRVRs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BattleFieldGuildPlayerPerRVR>>> guildPlayerPerRVRs) {
    fbb_.AddOffset(BattleFieldPcInfo::VT_GUILDPLAYERPERRVRS, guildPlayerPerRVRs);
  }
  explicit BattleFieldPcInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BattleFieldPcInfoBuilder &operator=(const BattleFieldPcInfoBuilder &);
  flatbuffers::Offset<BattleFieldPcInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BattleFieldPcInfo>(end);
    fbb_.Required(o, BattleFieldPcInfo::VT_GUILDPLAYERPERRVRS);
    return o;
  }
};

inline flatbuffers::Offset<BattleFieldPcInfo> CreateBattleFieldPcInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t reservedRvrId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BattleFieldGuildPlayerPerRVR>>> guildPlayerPerRVRs = 0) {
  BattleFieldPcInfoBuilder builder_(_fbb);
  builder_.add_guildPlayerPerRVRs(guildPlayerPerRVRs);
  builder_.add_reservedRvrId(reservedRvrId);
  return builder_.Finish();
}

inline flatbuffers::Offset<BattleFieldPcInfo> CreateBattleFieldPcInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t reservedRvrId = 0,
    const std::vector<flatbuffers::Offset<BattleFieldGuildPlayerPerRVR>> *guildPlayerPerRVRs = nullptr) {
  return LeanPacket::CreateBattleFieldPcInfo(
      _fbb,
      reservedRvrId,
      guildPlayerPerRVRs ? _fbb.CreateVector<flatbuffers::Offset<BattleFieldGuildPlayerPerRVR>>(*guildPlayerPerRVRs) : 0);
}

/// RVR_BATTLE_FIELD_REMAIN_TIME_REQUEST
struct RVRBattleFieldRemainTimeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RVRBattleFieldRemainTimeRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RVRBattleFieldRemainTimeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRBattleFieldRemainTimeRequestBuilder &operator=(const RVRBattleFieldRemainTimeRequestBuilder &);
  flatbuffers::Offset<RVRBattleFieldRemainTimeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRBattleFieldRemainTimeRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRBattleFieldRemainTimeRequest> CreateRVRBattleFieldRemainTimeRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RVRBattleFieldRemainTimeRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// RVR_BATTLE_FIELD_REMAIN_TIME_RESPONSE
struct RVRBattleFieldRemainTimeResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STATUS = 4,
    VT_BATTLEFIELDREMAINSEC = 6
  };
  BattleFieldEventStatus status() const {
    return static_cast<BattleFieldEventStatus>(GetField<int16_t>(VT_STATUS, 0));
  }
  int32_t battleFieldRemainSec() const {
    return GetField<int32_t>(VT_BATTLEFIELDREMAINSEC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_STATUS) &&
           VerifyField<int32_t>(verifier, VT_BATTLEFIELDREMAINSEC) &&
           verifier.EndTable();
  }
};

struct RVRBattleFieldRemainTimeResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status(BattleFieldEventStatus status) {
    fbb_.AddElement<int16_t>(RVRBattleFieldRemainTimeResponse::VT_STATUS, static_cast<int16_t>(status), 0);
  }
  void add_battleFieldRemainSec(int32_t battleFieldRemainSec) {
    fbb_.AddElement<int32_t>(RVRBattleFieldRemainTimeResponse::VT_BATTLEFIELDREMAINSEC, battleFieldRemainSec, 0);
  }
  explicit RVRBattleFieldRemainTimeResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRBattleFieldRemainTimeResponseBuilder &operator=(const RVRBattleFieldRemainTimeResponseBuilder &);
  flatbuffers::Offset<RVRBattleFieldRemainTimeResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRBattleFieldRemainTimeResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRBattleFieldRemainTimeResponse> CreateRVRBattleFieldRemainTimeResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    BattleFieldEventStatus status = BattleFieldEventStatus_BATTLE_FIELD_EVENT_STATUS_NONE,
    int32_t battleFieldRemainSec = 0) {
  RVRBattleFieldRemainTimeResponseBuilder builder_(_fbb);
  builder_.add_battleFieldRemainSec(battleFieldRemainSec);
  builder_.add_status(status);
  return builder_.Finish();
}

/// RVR_BATTLE_FIELD_INFO_REQUEST
struct RVRBattleFieldInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RVRID = 4
  };
  int32_t rvrId() const {
    return GetField<int32_t>(VT_RVRID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RVRID) &&
           verifier.EndTable();
  }
};

struct RVRBattleFieldInfoRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rvrId(int32_t rvrId) {
    fbb_.AddElement<int32_t>(RVRBattleFieldInfoRequest::VT_RVRID, rvrId, 0);
  }
  explicit RVRBattleFieldInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRBattleFieldInfoRequestBuilder &operator=(const RVRBattleFieldInfoRequestBuilder &);
  flatbuffers::Offset<RVRBattleFieldInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRBattleFieldInfoRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRBattleFieldInfoRequest> CreateRVRBattleFieldInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rvrId = 0) {
  RVRBattleFieldInfoRequestBuilder builder_(_fbb);
  builder_.add_rvrId(rvrId);
  return builder_.Finish();
}

/// RVR_BATTLE_FIELD_INFO_RESPONSE
struct RVRBattleFieldInfoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RVRID = 4,
    VT_INFO = 6
  };
  int32_t rvrId() const {
    return GetField<int32_t>(VT_RVRID, 0);
  }
  const BattleFieldChannelInfo *info() const {
    return GetPointer<const BattleFieldChannelInfo *>(VT_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RVRID) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           verifier.EndTable();
  }
};

struct RVRBattleFieldInfoResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rvrId(int32_t rvrId) {
    fbb_.AddElement<int32_t>(RVRBattleFieldInfoResponse::VT_RVRID, rvrId, 0);
  }
  void add_info(flatbuffers::Offset<BattleFieldChannelInfo> info) {
    fbb_.AddOffset(RVRBattleFieldInfoResponse::VT_INFO, info);
  }
  explicit RVRBattleFieldInfoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRBattleFieldInfoResponseBuilder &operator=(const RVRBattleFieldInfoResponseBuilder &);
  flatbuffers::Offset<RVRBattleFieldInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRBattleFieldInfoResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRBattleFieldInfoResponse> CreateRVRBattleFieldInfoResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rvrId = 0,
    flatbuffers::Offset<BattleFieldChannelInfo> info = 0) {
  RVRBattleFieldInfoResponseBuilder builder_(_fbb);
  builder_.add_info(info);
  builder_.add_rvrId(rvrId);
  return builder_.Finish();
}

/// RVR_BATTLE_FIELD_ALL_INFOS_REQUEST
struct RVRBattleFieldAllInfosRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RVRBattleFieldAllInfosRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RVRBattleFieldAllInfosRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRBattleFieldAllInfosRequestBuilder &operator=(const RVRBattleFieldAllInfosRequestBuilder &);
  flatbuffers::Offset<RVRBattleFieldAllInfosRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRBattleFieldAllInfosRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRBattleFieldAllInfosRequest> CreateRVRBattleFieldAllInfosRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RVRBattleFieldAllInfosRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// RVR_BATTLE_FIELD_ALL_INFOS_RESPONSE
struct RVRBattleFieldAllInfosResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CHANNELINFOS = 4,
    VT_PCINFO = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<BattleFieldChannelInfo>> *channelInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BattleFieldChannelInfo>> *>(VT_CHANNELINFOS);
  }
  const BattleFieldPcInfo *pcInfo() const {
    return GetPointer<const BattleFieldPcInfo *>(VT_PCINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHANNELINFOS) &&
           verifier.VerifyVector(channelInfos()) &&
           verifier.VerifyVectorOfTables(channelInfos()) &&
           VerifyOffset(verifier, VT_PCINFO) &&
           verifier.VerifyTable(pcInfo()) &&
           verifier.EndTable();
  }
};

struct RVRBattleFieldAllInfosResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_channelInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BattleFieldChannelInfo>>> channelInfos) {
    fbb_.AddOffset(RVRBattleFieldAllInfosResponse::VT_CHANNELINFOS, channelInfos);
  }
  void add_pcInfo(flatbuffers::Offset<BattleFieldPcInfo> pcInfo) {
    fbb_.AddOffset(RVRBattleFieldAllInfosResponse::VT_PCINFO, pcInfo);
  }
  explicit RVRBattleFieldAllInfosResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRBattleFieldAllInfosResponseBuilder &operator=(const RVRBattleFieldAllInfosResponseBuilder &);
  flatbuffers::Offset<RVRBattleFieldAllInfosResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRBattleFieldAllInfosResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRBattleFieldAllInfosResponse> CreateRVRBattleFieldAllInfosResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BattleFieldChannelInfo>>> channelInfos = 0,
    flatbuffers::Offset<BattleFieldPcInfo> pcInfo = 0) {
  RVRBattleFieldAllInfosResponseBuilder builder_(_fbb);
  builder_.add_pcInfo(pcInfo);
  builder_.add_channelInfos(channelInfos);
  return builder_.Finish();
}

inline flatbuffers::Offset<RVRBattleFieldAllInfosResponse> CreateRVRBattleFieldAllInfosResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<BattleFieldChannelInfo>> *channelInfos = nullptr,
    flatbuffers::Offset<BattleFieldPcInfo> pcInfo = 0) {
  return LeanPacket::CreateRVRBattleFieldAllInfosResponse(
      _fbb,
      channelInfos ? _fbb.CreateVector<flatbuffers::Offset<BattleFieldChannelInfo>>(*channelInfos) : 0,
      pcInfo);
}

/// ARENA_STATE_NOTIFY
struct ArenaStateNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STATE = 4,
    VT_ELAPSEDTIME = 6,
    VT_ADDBOUNSTIME = 8
  };
  ArenaStateType state() const {
    return static_cast<ArenaStateType>(GetField<int32_t>(VT_STATE, 0));
  }
  int64_t elapsedTime() const {
    return GetField<int64_t>(VT_ELAPSEDTIME, 0);
  }
  int64_t addBounsTime() const {
    return GetField<int64_t>(VT_ADDBOUNSTIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STATE) &&
           VerifyField<int64_t>(verifier, VT_ELAPSEDTIME) &&
           VerifyField<int64_t>(verifier, VT_ADDBOUNSTIME) &&
           verifier.EndTable();
  }
};

struct ArenaStateNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_state(ArenaStateType state) {
    fbb_.AddElement<int32_t>(ArenaStateNotify::VT_STATE, static_cast<int32_t>(state), 0);
  }
  void add_elapsedTime(int64_t elapsedTime) {
    fbb_.AddElement<int64_t>(ArenaStateNotify::VT_ELAPSEDTIME, elapsedTime, 0);
  }
  void add_addBounsTime(int64_t addBounsTime) {
    fbb_.AddElement<int64_t>(ArenaStateNotify::VT_ADDBOUNSTIME, addBounsTime, 0);
  }
  explicit ArenaStateNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArenaStateNotifyBuilder &operator=(const ArenaStateNotifyBuilder &);
  flatbuffers::Offset<ArenaStateNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArenaStateNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArenaStateNotify> CreateArenaStateNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    ArenaStateType state = ArenaStateType_NOTHING,
    int64_t elapsedTime = 0,
    int64_t addBounsTime = 0) {
  ArenaStateNotifyBuilder builder_(_fbb);
  builder_.add_addBounsTime(addBounsTime);
  builder_.add_elapsedTime(elapsedTime);
  builder_.add_state(state);
  return builder_.Finish();
}

/// ARENA_MEMBER_LIST_REQUEST
struct ArenaMemberListRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_PCDBID = 6,
    VT_MYCLASSTYPE = 8,
    VT_EXCLUDES = 10,
    VT_TEAM_MINSEARCHRANGE = 12,
    VT_TEAM_MAXSEARCHRANGE = 14,
    VT_TEAMA = 16,
    VT_TEAMB = 18
  };
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  int16_t myClassType() const {
    return GetField<int16_t>(VT_MYCLASSTYPE, 0);
  }
  const flatbuffers::Vector<int64_t> *excludes() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_EXCLUDES);
  }
  int32_t team_minSearchRange() const {
    return GetField<int32_t>(VT_TEAM_MINSEARCHRANGE, 0);
  }
  int32_t team_maxSearchRange() const {
    return GetField<int32_t>(VT_TEAM_MAXSEARCHRANGE, 0);
  }
  const ArenaTeamClass *teamA() const {
    return GetPointer<const ArenaTeamClass *>(VT_TEAMA);
  }
  const ArenaTeamClass *teamB() const {
    return GetPointer<const ArenaTeamClass *>(VT_TEAMB);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           VerifyField<int16_t>(verifier, VT_MYCLASSTYPE) &&
           VerifyOffsetRequired(verifier, VT_EXCLUDES) &&
           verifier.VerifyVector(excludes()) &&
           VerifyField<int32_t>(verifier, VT_TEAM_MINSEARCHRANGE) &&
           VerifyField<int32_t>(verifier, VT_TEAM_MAXSEARCHRANGE) &&
           VerifyOffsetRequired(verifier, VT_TEAMA) &&
           verifier.VerifyTable(teamA()) &&
           VerifyOffsetRequired(verifier, VT_TEAMB) &&
           verifier.VerifyTable(teamB()) &&
           verifier.EndTable();
  }
};

struct ArenaMemberListRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(ArenaMemberListRequest::VT_OBJECTID, objectId, 0);
  }
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(ArenaMemberListRequest::VT_PCDBID, pcDbId, 0);
  }
  void add_myClassType(int16_t myClassType) {
    fbb_.AddElement<int16_t>(ArenaMemberListRequest::VT_MYCLASSTYPE, myClassType, 0);
  }
  void add_excludes(flatbuffers::Offset<flatbuffers::Vector<int64_t>> excludes) {
    fbb_.AddOffset(ArenaMemberListRequest::VT_EXCLUDES, excludes);
  }
  void add_team_minSearchRange(int32_t team_minSearchRange) {
    fbb_.AddElement<int32_t>(ArenaMemberListRequest::VT_TEAM_MINSEARCHRANGE, team_minSearchRange, 0);
  }
  void add_team_maxSearchRange(int32_t team_maxSearchRange) {
    fbb_.AddElement<int32_t>(ArenaMemberListRequest::VT_TEAM_MAXSEARCHRANGE, team_maxSearchRange, 0);
  }
  void add_teamA(flatbuffers::Offset<ArenaTeamClass> teamA) {
    fbb_.AddOffset(ArenaMemberListRequest::VT_TEAMA, teamA);
  }
  void add_teamB(flatbuffers::Offset<ArenaTeamClass> teamB) {
    fbb_.AddOffset(ArenaMemberListRequest::VT_TEAMB, teamB);
  }
  explicit ArenaMemberListRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArenaMemberListRequestBuilder &operator=(const ArenaMemberListRequestBuilder &);
  flatbuffers::Offset<ArenaMemberListRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArenaMemberListRequest>(end);
    fbb_.Required(o, ArenaMemberListRequest::VT_EXCLUDES);
    fbb_.Required(o, ArenaMemberListRequest::VT_TEAMA);
    fbb_.Required(o, ArenaMemberListRequest::VT_TEAMB);
    return o;
  }
};

inline flatbuffers::Offset<ArenaMemberListRequest> CreateArenaMemberListRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int64_t pcDbId = 0,
    int16_t myClassType = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> excludes = 0,
    int32_t team_minSearchRange = 0,
    int32_t team_maxSearchRange = 0,
    flatbuffers::Offset<ArenaTeamClass> teamA = 0,
    flatbuffers::Offset<ArenaTeamClass> teamB = 0) {
  ArenaMemberListRequestBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  builder_.add_objectId(objectId);
  builder_.add_teamB(teamB);
  builder_.add_teamA(teamA);
  builder_.add_team_maxSearchRange(team_maxSearchRange);
  builder_.add_team_minSearchRange(team_minSearchRange);
  builder_.add_excludes(excludes);
  builder_.add_myClassType(myClassType);
  return builder_.Finish();
}

inline flatbuffers::Offset<ArenaMemberListRequest> CreateArenaMemberListRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t objectId = 0,
    int64_t pcDbId = 0,
    int16_t myClassType = 0,
    const std::vector<int64_t> *excludes = nullptr,
    int32_t team_minSearchRange = 0,
    int32_t team_maxSearchRange = 0,
    flatbuffers::Offset<ArenaTeamClass> teamA = 0,
    flatbuffers::Offset<ArenaTeamClass> teamB = 0) {
  return LeanPacket::CreateArenaMemberListRequest(
      _fbb,
      objectId,
      pcDbId,
      myClassType,
      excludes ? _fbb.CreateVector<int64_t>(*excludes) : 0,
      team_minSearchRange,
      team_maxSearchRange,
      teamA,
      teamB);
}

/// ARENA_MEMBER_LIST_RESPONSE
struct ArenaMemberListResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULT = 4,
    VT_OBJECTID = 6,
    VT_TEAMA = 8,
    VT_TEAMB = 10
  };
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  int64_t objectId() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ArenaMemberBasic>> *teamA() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ArenaMemberBasic>> *>(VT_TEAMA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ArenaMemberBasic>> *teamB() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ArenaMemberBasic>> *>(VT_TEAMB);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           VerifyOffset(verifier, VT_TEAMA) &&
           verifier.VerifyVector(teamA()) &&
           verifier.VerifyVectorOfTables(teamA()) &&
           VerifyOffset(verifier, VT_TEAMB) &&
           verifier.VerifyVector(teamB()) &&
           verifier.VerifyVectorOfTables(teamB()) &&
           verifier.EndTable();
  }
};

struct ArenaMemberListResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(ArenaMemberListResponse::VT_RESULT, result, 0);
  }
  void add_objectId(int64_t objectId) {
    fbb_.AddElement<int64_t>(ArenaMemberListResponse::VT_OBJECTID, objectId, 0);
  }
  void add_teamA(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ArenaMemberBasic>>> teamA) {
    fbb_.AddOffset(ArenaMemberListResponse::VT_TEAMA, teamA);
  }
  void add_teamB(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ArenaMemberBasic>>> teamB) {
    fbb_.AddOffset(ArenaMemberListResponse::VT_TEAMB, teamB);
  }
  explicit ArenaMemberListResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArenaMemberListResponseBuilder &operator=(const ArenaMemberListResponseBuilder &);
  flatbuffers::Offset<ArenaMemberListResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArenaMemberListResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArenaMemberListResponse> CreateArenaMemberListResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    int64_t objectId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ArenaMemberBasic>>> teamA = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ArenaMemberBasic>>> teamB = 0) {
  ArenaMemberListResponseBuilder builder_(_fbb);
  builder_.add_objectId(objectId);
  builder_.add_teamB(teamB);
  builder_.add_teamA(teamA);
  builder_.add_result(result);
  return builder_.Finish();
}

inline flatbuffers::Offset<ArenaMemberListResponse> CreateArenaMemberListResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    int64_t objectId = 0,
    const std::vector<flatbuffers::Offset<ArenaMemberBasic>> *teamA = nullptr,
    const std::vector<flatbuffers::Offset<ArenaMemberBasic>> *teamB = nullptr) {
  return LeanPacket::CreateArenaMemberListResponse(
      _fbb,
      result,
      objectId,
      teamA ? _fbb.CreateVector<flatbuffers::Offset<ArenaMemberBasic>>(*teamA) : 0,
      teamB ? _fbb.CreateVector<flatbuffers::Offset<ArenaMemberBasic>>(*teamB) : 0);
}

struct ItemCoolData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMID = 4,
    VT_REMAINCOOLTIME = 6
  };
  int32_t itemId() const {
    return GetField<int32_t>(VT_ITEMID, 0);
  }
  int64_t remainCoolTime() const {
    return GetField<int64_t>(VT_REMAINCOOLTIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ITEMID) &&
           VerifyField<int64_t>(verifier, VT_REMAINCOOLTIME) &&
           verifier.EndTable();
  }
};

struct ItemCoolDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemId(int32_t itemId) {
    fbb_.AddElement<int32_t>(ItemCoolData::VT_ITEMID, itemId, 0);
  }
  void add_remainCoolTime(int64_t remainCoolTime) {
    fbb_.AddElement<int64_t>(ItemCoolData::VT_REMAINCOOLTIME, remainCoolTime, 0);
  }
  explicit ItemCoolDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ItemCoolDataBuilder &operator=(const ItemCoolDataBuilder &);
  flatbuffers::Offset<ItemCoolData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ItemCoolData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ItemCoolData> CreateItemCoolData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t itemId = 0,
    int64_t remainCoolTime = 0) {
  ItemCoolDataBuilder builder_(_fbb);
  builder_.add_remainCoolTime(remainCoolTime);
  builder_.add_itemId(itemId);
  return builder_.Finish();
}

///UPDATE_ITEM_COOLTIME_NOTIFY
struct UpdateItemCoolTimeNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COOLINFOS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<ItemCoolData>> *coolInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ItemCoolData>> *>(VT_COOLINFOS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COOLINFOS) &&
           verifier.VerifyVector(coolInfos()) &&
           verifier.VerifyVectorOfTables(coolInfos()) &&
           verifier.EndTable();
  }
};

struct UpdateItemCoolTimeNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_coolInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ItemCoolData>>> coolInfos) {
    fbb_.AddOffset(UpdateItemCoolTimeNotify::VT_COOLINFOS, coolInfos);
  }
  explicit UpdateItemCoolTimeNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UpdateItemCoolTimeNotifyBuilder &operator=(const UpdateItemCoolTimeNotifyBuilder &);
  flatbuffers::Offset<UpdateItemCoolTimeNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UpdateItemCoolTimeNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<UpdateItemCoolTimeNotify> CreateUpdateItemCoolTimeNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ItemCoolData>>> coolInfos = 0) {
  UpdateItemCoolTimeNotifyBuilder builder_(_fbb);
  builder_.add_coolInfos(coolInfos);
  return builder_.Finish();
}

inline flatbuffers::Offset<UpdateItemCoolTimeNotify> CreateUpdateItemCoolTimeNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<ItemCoolData>> *coolInfos = nullptr) {
  return LeanPacket::CreateUpdateItemCoolTimeNotify(
      _fbb,
      coolInfos ? _fbb.CreateVector<flatbuffers::Offset<ItemCoolData>>(*coolInfos) : 0);
}

///AGGRO_TICKER_INFO_NOTIFY
struct AggroTickerInfoNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_AGGROTARGETOBJID = 4,
    VT_AGGROSTATE = 6,
    VT_TIME = 8,
    VT_AGGROOBJID = 10
  };
  int64_t aggroTargetObjId() const {
    return GetField<int64_t>(VT_AGGROTARGETOBJID, 0);
  }
  int32_t aggroState() const {
    return GetField<int32_t>(VT_AGGROSTATE, 0);
  }
  int32_t time() const {
    return GetField<int32_t>(VT_TIME, 0);
  }
  int64_t aggroObjId() const {
    return GetField<int64_t>(VT_AGGROOBJID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_AGGROTARGETOBJID) &&
           VerifyField<int32_t>(verifier, VT_AGGROSTATE) &&
           VerifyField<int32_t>(verifier, VT_TIME) &&
           VerifyField<int64_t>(verifier, VT_AGGROOBJID) &&
           verifier.EndTable();
  }
};

struct AggroTickerInfoNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_aggroTargetObjId(int64_t aggroTargetObjId) {
    fbb_.AddElement<int64_t>(AggroTickerInfoNotify::VT_AGGROTARGETOBJID, aggroTargetObjId, 0);
  }
  void add_aggroState(int32_t aggroState) {
    fbb_.AddElement<int32_t>(AggroTickerInfoNotify::VT_AGGROSTATE, aggroState, 0);
  }
  void add_time(int32_t time) {
    fbb_.AddElement<int32_t>(AggroTickerInfoNotify::VT_TIME, time, 0);
  }
  void add_aggroObjId(int64_t aggroObjId) {
    fbb_.AddElement<int64_t>(AggroTickerInfoNotify::VT_AGGROOBJID, aggroObjId, 0);
  }
  explicit AggroTickerInfoNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AggroTickerInfoNotifyBuilder &operator=(const AggroTickerInfoNotifyBuilder &);
  flatbuffers::Offset<AggroTickerInfoNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AggroTickerInfoNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<AggroTickerInfoNotify> CreateAggroTickerInfoNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t aggroTargetObjId = 0,
    int32_t aggroState = 0,
    int32_t time = 0,
    int64_t aggroObjId = 0) {
  AggroTickerInfoNotifyBuilder builder_(_fbb);
  builder_.add_aggroObjId(aggroObjId);
  builder_.add_aggroTargetObjId(aggroTargetObjId);
  builder_.add_time(time);
  builder_.add_aggroState(aggroState);
  return builder_.Finish();
}

/// ITEM_FUSION_REQUEST
struct ItemFusionRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SOURCE = 4,
    VT_MATERIAL = 6
  };
  int64_t source() const {
    return GetField<int64_t>(VT_SOURCE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ClientSItem>> *material() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ClientSItem>> *>(VT_MATERIAL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SOURCE) &&
           VerifyOffsetRequired(verifier, VT_MATERIAL) &&
           verifier.VerifyVector(material()) &&
           verifier.VerifyVectorOfTables(material()) &&
           verifier.EndTable();
  }
};

struct ItemFusionRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_source(int64_t source) {
    fbb_.AddElement<int64_t>(ItemFusionRequest::VT_SOURCE, source, 0);
  }
  void add_material(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ClientSItem>>> material) {
    fbb_.AddOffset(ItemFusionRequest::VT_MATERIAL, material);
  }
  explicit ItemFusionRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ItemFusionRequestBuilder &operator=(const ItemFusionRequestBuilder &);
  flatbuffers::Offset<ItemFusionRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ItemFusionRequest>(end);
    fbb_.Required(o, ItemFusionRequest::VT_MATERIAL);
    return o;
  }
};

inline flatbuffers::Offset<ItemFusionRequest> CreateItemFusionRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t source = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ClientSItem>>> material = 0) {
  ItemFusionRequestBuilder builder_(_fbb);
  builder_.add_source(source);
  builder_.add_material(material);
  return builder_.Finish();
}

inline flatbuffers::Offset<ItemFusionRequest> CreateItemFusionRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t source = 0,
    const std::vector<flatbuffers::Offset<ClientSItem>> *material = nullptr) {
  return LeanPacket::CreateItemFusionRequest(
      _fbb,
      source,
      material ? _fbb.CreateVector<flatbuffers::Offset<ClientSItem>>(*material) : 0);
}

/// ITEM_FUSION_RESPONSE
struct ItemFusionResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERROR = 4,
    VT_RESULT = 6
  };
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  const ClientLItem *result() const {
    return GetPointer<const ClientLItem *>(VT_RESULT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyTable(result()) &&
           verifier.EndTable();
  }
};

struct ItemFusionResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(ItemFusionResponse::VT_ERROR, error, 0);
  }
  void add_result(flatbuffers::Offset<ClientLItem> result) {
    fbb_.AddOffset(ItemFusionResponse::VT_RESULT, result);
  }
  explicit ItemFusionResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ItemFusionResponseBuilder &operator=(const ItemFusionResponseBuilder &);
  flatbuffers::Offset<ItemFusionResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ItemFusionResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ItemFusionResponse> CreateItemFusionResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t error = 0,
    flatbuffers::Offset<ClientLItem> result = 0) {
  ItemFusionResponseBuilder builder_(_fbb);
  builder_.add_result(result);
  builder_.add_error(error);
  return builder_.Finish();
}

struct KillAssistCountInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_KILLCOUNT = 6,
    VT_ASSISTCOUNT = 8
  };
  PKContentsType type() const {
    return static_cast<PKContentsType>(GetField<int16_t>(VT_TYPE, 0));
  }
  int32_t killCount() const {
    return GetField<int32_t>(VT_KILLCOUNT, 0);
  }
  int32_t assistCount() const {
    return GetField<int32_t>(VT_ASSISTCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_KILLCOUNT) &&
           VerifyField<int32_t>(verifier, VT_ASSISTCOUNT) &&
           verifier.EndTable();
  }
};

struct KillAssistCountInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(PKContentsType type) {
    fbb_.AddElement<int16_t>(KillAssistCountInfo::VT_TYPE, static_cast<int16_t>(type), 0);
  }
  void add_killCount(int32_t killCount) {
    fbb_.AddElement<int32_t>(KillAssistCountInfo::VT_KILLCOUNT, killCount, 0);
  }
  void add_assistCount(int32_t assistCount) {
    fbb_.AddElement<int32_t>(KillAssistCountInfo::VT_ASSISTCOUNT, assistCount, 0);
  }
  explicit KillAssistCountInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  KillAssistCountInfoBuilder &operator=(const KillAssistCountInfoBuilder &);
  flatbuffers::Offset<KillAssistCountInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KillAssistCountInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<KillAssistCountInfo> CreateKillAssistCountInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    PKContentsType type = PKContentsType_PK_CONTENTS_NONE,
    int32_t killCount = 0,
    int32_t assistCount = 0) {
  KillAssistCountInfoBuilder builder_(_fbb);
  builder_.add_assistCount(assistCount);
  builder_.add_killCount(killCount);
  builder_.add_type(type);
  return builder_.Finish();
}

/// KILL_ASSIST_COUNT_NOTIFY
struct KillAssistCountNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATAS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<KillAssistCountInfo>> *datas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<KillAssistCountInfo>> *>(VT_DATAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATAS) &&
           verifier.VerifyVector(datas()) &&
           verifier.VerifyVectorOfTables(datas()) &&
           verifier.EndTable();
  }
};

struct KillAssistCountNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_datas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KillAssistCountInfo>>> datas) {
    fbb_.AddOffset(KillAssistCountNotify::VT_DATAS, datas);
  }
  explicit KillAssistCountNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  KillAssistCountNotifyBuilder &operator=(const KillAssistCountNotifyBuilder &);
  flatbuffers::Offset<KillAssistCountNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KillAssistCountNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<KillAssistCountNotify> CreateKillAssistCountNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KillAssistCountInfo>>> datas = 0) {
  KillAssistCountNotifyBuilder builder_(_fbb);
  builder_.add_datas(datas);
  return builder_.Finish();
}

inline flatbuffers::Offset<KillAssistCountNotify> CreateKillAssistCountNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<KillAssistCountInfo>> *datas = nullptr) {
  return LeanPacket::CreateKillAssistCountNotify(
      _fbb,
      datas ? _fbb.CreateVector<flatbuffers::Offset<KillAssistCountInfo>>(*datas) : 0);
}

/// PC_PK_HONOR_INFO_REQUEST
struct PCPKHonorInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCNAME = 4
  };
  const flatbuffers::String *pcName() const {
    return GetPointer<const flatbuffers::String *>(VT_PCNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PCNAME) &&
           verifier.VerifyString(pcName()) &&
           verifier.EndTable();
  }
};

struct PCPKHonorInfoRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcName(flatbuffers::Offset<flatbuffers::String> pcName) {
    fbb_.AddOffset(PCPKHonorInfoRequest::VT_PCNAME, pcName);
  }
  explicit PCPKHonorInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PCPKHonorInfoRequestBuilder &operator=(const PCPKHonorInfoRequestBuilder &);
  flatbuffers::Offset<PCPKHonorInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PCPKHonorInfoRequest>(end);
    fbb_.Required(o, PCPKHonorInfoRequest::VT_PCNAME);
    return o;
  }
};

inline flatbuffers::Offset<PCPKHonorInfoRequest> CreatePCPKHonorInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> pcName = 0) {
  PCPKHonorInfoRequestBuilder builder_(_fbb);
  builder_.add_pcName(pcName);
  return builder_.Finish();
}

inline flatbuffers::Offset<PCPKHonorInfoRequest> CreatePCPKHonorInfoRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *pcName = nullptr) {
  return LeanPacket::CreatePCPKHonorInfoRequest(
      _fbb,
      pcName ? _fbb.CreateString(pcName) : 0);
}

/// PC_PK_HONOR_INFO_RESPONSE
struct PCPKHonorInfoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRCODE = 4,
    VT_PCNAME = 6,
    VT_PVPPOINT = 8,
    VT_PVPCOINDAILY = 10,
    VT_PVPCOINPURSE = 12,
    VT_KILLASSISTINFO = 14
  };
  ErrorCode errCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRCODE, 0));
  }
  const flatbuffers::String *pcName() const {
    return GetPointer<const flatbuffers::String *>(VT_PCNAME);
  }
  int64_t pvpPoint() const {
    return GetField<int64_t>(VT_PVPPOINT, 0);
  }
  int64_t pvpCoinDaily() const {
    return GetField<int64_t>(VT_PVPCOINDAILY, 0);
  }
  int64_t pvpCoinPurse() const {
    return GetField<int64_t>(VT_PVPCOINPURSE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<KillAssistCountInfo>> *killAssistInfo() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<KillAssistCountInfo>> *>(VT_KILLASSISTINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           VerifyOffsetRequired(verifier, VT_PCNAME) &&
           verifier.VerifyString(pcName()) &&
           VerifyField<int64_t>(verifier, VT_PVPPOINT) &&
           VerifyField<int64_t>(verifier, VT_PVPCOINDAILY) &&
           VerifyField<int64_t>(verifier, VT_PVPCOINPURSE) &&
           VerifyOffset(verifier, VT_KILLASSISTINFO) &&
           verifier.VerifyVector(killAssistInfo()) &&
           verifier.VerifyVectorOfTables(killAssistInfo()) &&
           verifier.EndTable();
  }
};

struct PCPKHonorInfoResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errCode(ErrorCode errCode) {
    fbb_.AddElement<int32_t>(PCPKHonorInfoResponse::VT_ERRCODE, static_cast<int32_t>(errCode), 0);
  }
  void add_pcName(flatbuffers::Offset<flatbuffers::String> pcName) {
    fbb_.AddOffset(PCPKHonorInfoResponse::VT_PCNAME, pcName);
  }
  void add_pvpPoint(int64_t pvpPoint) {
    fbb_.AddElement<int64_t>(PCPKHonorInfoResponse::VT_PVPPOINT, pvpPoint, 0);
  }
  void add_pvpCoinDaily(int64_t pvpCoinDaily) {
    fbb_.AddElement<int64_t>(PCPKHonorInfoResponse::VT_PVPCOINDAILY, pvpCoinDaily, 0);
  }
  void add_pvpCoinPurse(int64_t pvpCoinPurse) {
    fbb_.AddElement<int64_t>(PCPKHonorInfoResponse::VT_PVPCOINPURSE, pvpCoinPurse, 0);
  }
  void add_killAssistInfo(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KillAssistCountInfo>>> killAssistInfo) {
    fbb_.AddOffset(PCPKHonorInfoResponse::VT_KILLASSISTINFO, killAssistInfo);
  }
  explicit PCPKHonorInfoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PCPKHonorInfoResponseBuilder &operator=(const PCPKHonorInfoResponseBuilder &);
  flatbuffers::Offset<PCPKHonorInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PCPKHonorInfoResponse>(end);
    fbb_.Required(o, PCPKHonorInfoResponse::VT_PCNAME);
    return o;
  }
};

inline flatbuffers::Offset<PCPKHonorInfoResponse> CreatePCPKHonorInfoResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errCode = ErrorCode_NONE,
    flatbuffers::Offset<flatbuffers::String> pcName = 0,
    int64_t pvpPoint = 0,
    int64_t pvpCoinDaily = 0,
    int64_t pvpCoinPurse = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KillAssistCountInfo>>> killAssistInfo = 0) {
  PCPKHonorInfoResponseBuilder builder_(_fbb);
  builder_.add_pvpCoinPurse(pvpCoinPurse);
  builder_.add_pvpCoinDaily(pvpCoinDaily);
  builder_.add_pvpPoint(pvpPoint);
  builder_.add_killAssistInfo(killAssistInfo);
  builder_.add_pcName(pcName);
  builder_.add_errCode(errCode);
  return builder_.Finish();
}

inline flatbuffers::Offset<PCPKHonorInfoResponse> CreatePCPKHonorInfoResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errCode = ErrorCode_NONE,
    const char *pcName = nullptr,
    int64_t pvpPoint = 0,
    int64_t pvpCoinDaily = 0,
    int64_t pvpCoinPurse = 0,
    const std::vector<flatbuffers::Offset<KillAssistCountInfo>> *killAssistInfo = nullptr) {
  return LeanPacket::CreatePCPKHonorInfoResponse(
      _fbb,
      errCode,
      pcName ? _fbb.CreateString(pcName) : 0,
      pvpPoint,
      pvpCoinDaily,
      pvpCoinPurse,
      killAssistInfo ? _fbb.CreateVector<flatbuffers::Offset<KillAssistCountInfo>>(*killAssistInfo) : 0);
}

/// 친구시스템
struct BuddyInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCNAME = 4,
    VT_PCCLASSTYPE = 6,
    VT_PCLEVEL = 8
  };
  const flatbuffers::String *pcName() const {
    return GetPointer<const flatbuffers::String *>(VT_PCNAME);
  }
  int32_t pcClassType() const {
    return GetField<int32_t>(VT_PCCLASSTYPE, 0);
  }
  int32_t pcLevel() const {
    return GetField<int32_t>(VT_PCLEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PCNAME) &&
           verifier.VerifyString(pcName()) &&
           VerifyField<int32_t>(verifier, VT_PCCLASSTYPE) &&
           VerifyField<int32_t>(verifier, VT_PCLEVEL) &&
           verifier.EndTable();
  }
};

struct BuddyInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcName(flatbuffers::Offset<flatbuffers::String> pcName) {
    fbb_.AddOffset(BuddyInfo::VT_PCNAME, pcName);
  }
  void add_pcClassType(int32_t pcClassType) {
    fbb_.AddElement<int32_t>(BuddyInfo::VT_PCCLASSTYPE, pcClassType, 0);
  }
  void add_pcLevel(int32_t pcLevel) {
    fbb_.AddElement<int32_t>(BuddyInfo::VT_PCLEVEL, pcLevel, 0);
  }
  explicit BuddyInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BuddyInfoBuilder &operator=(const BuddyInfoBuilder &);
  flatbuffers::Offset<BuddyInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BuddyInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<BuddyInfo> CreateBuddyInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> pcName = 0,
    int32_t pcClassType = 0,
    int32_t pcLevel = 0) {
  BuddyInfoBuilder builder_(_fbb);
  builder_.add_pcLevel(pcLevel);
  builder_.add_pcClassType(pcClassType);
  builder_.add_pcName(pcName);
  return builder_.Finish();
}

inline flatbuffers::Offset<BuddyInfo> CreateBuddyInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *pcName = nullptr,
    int32_t pcClassType = 0,
    int32_t pcLevel = 0) {
  return LeanPacket::CreateBuddyInfo(
      _fbb,
      pcName ? _fbb.CreateString(pcName) : 0,
      pcClassType,
      pcLevel);
}

struct BuddyReceiveInvitationInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_REMAINTICK = 4,
    VT_PCNAME = 6,
    VT_PCCLASSTYPE = 8,
    VT_PCLEVEL = 10
  };
  int64_t remainTick() const {
    return GetField<int64_t>(VT_REMAINTICK, 0);
  }
  const flatbuffers::String *pcName() const {
    return GetPointer<const flatbuffers::String *>(VT_PCNAME);
  }
  int32_t pcClassType() const {
    return GetField<int32_t>(VT_PCCLASSTYPE, 0);
  }
  int32_t pcLevel() const {
    return GetField<int32_t>(VT_PCLEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_REMAINTICK) &&
           VerifyOffset(verifier, VT_PCNAME) &&
           verifier.VerifyString(pcName()) &&
           VerifyField<int32_t>(verifier, VT_PCCLASSTYPE) &&
           VerifyField<int32_t>(verifier, VT_PCLEVEL) &&
           verifier.EndTable();
  }
};

struct BuddyReceiveInvitationInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_remainTick(int64_t remainTick) {
    fbb_.AddElement<int64_t>(BuddyReceiveInvitationInfo::VT_REMAINTICK, remainTick, 0);
  }
  void add_pcName(flatbuffers::Offset<flatbuffers::String> pcName) {
    fbb_.AddOffset(BuddyReceiveInvitationInfo::VT_PCNAME, pcName);
  }
  void add_pcClassType(int32_t pcClassType) {
    fbb_.AddElement<int32_t>(BuddyReceiveInvitationInfo::VT_PCCLASSTYPE, pcClassType, 0);
  }
  void add_pcLevel(int32_t pcLevel) {
    fbb_.AddElement<int32_t>(BuddyReceiveInvitationInfo::VT_PCLEVEL, pcLevel, 0);
  }
  explicit BuddyReceiveInvitationInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BuddyReceiveInvitationInfoBuilder &operator=(const BuddyReceiveInvitationInfoBuilder &);
  flatbuffers::Offset<BuddyReceiveInvitationInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BuddyReceiveInvitationInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<BuddyReceiveInvitationInfo> CreateBuddyReceiveInvitationInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t remainTick = 0,
    flatbuffers::Offset<flatbuffers::String> pcName = 0,
    int32_t pcClassType = 0,
    int32_t pcLevel = 0) {
  BuddyReceiveInvitationInfoBuilder builder_(_fbb);
  builder_.add_remainTick(remainTick);
  builder_.add_pcLevel(pcLevel);
  builder_.add_pcClassType(pcClassType);
  builder_.add_pcName(pcName);
  return builder_.Finish();
}

inline flatbuffers::Offset<BuddyReceiveInvitationInfo> CreateBuddyReceiveInvitationInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t remainTick = 0,
    const char *pcName = nullptr,
    int32_t pcClassType = 0,
    int32_t pcLevel = 0) {
  return LeanPacket::CreateBuddyReceiveInvitationInfo(
      _fbb,
      remainTick,
      pcName ? _fbb.CreateString(pcName) : 0,
      pcClassType,
      pcLevel);
}

struct BuddySendInvitationInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_REMAINTICK = 4,
    VT_PCNAME = 6
  };
  int64_t remainTick() const {
    return GetField<int64_t>(VT_REMAINTICK, 0);
  }
  const flatbuffers::String *pcName() const {
    return GetPointer<const flatbuffers::String *>(VT_PCNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_REMAINTICK) &&
           VerifyOffset(verifier, VT_PCNAME) &&
           verifier.VerifyString(pcName()) &&
           verifier.EndTable();
  }
};

struct BuddySendInvitationInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_remainTick(int64_t remainTick) {
    fbb_.AddElement<int64_t>(BuddySendInvitationInfo::VT_REMAINTICK, remainTick, 0);
  }
  void add_pcName(flatbuffers::Offset<flatbuffers::String> pcName) {
    fbb_.AddOffset(BuddySendInvitationInfo::VT_PCNAME, pcName);
  }
  explicit BuddySendInvitationInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BuddySendInvitationInfoBuilder &operator=(const BuddySendInvitationInfoBuilder &);
  flatbuffers::Offset<BuddySendInvitationInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BuddySendInvitationInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<BuddySendInvitationInfo> CreateBuddySendInvitationInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t remainTick = 0,
    flatbuffers::Offset<flatbuffers::String> pcName = 0) {
  BuddySendInvitationInfoBuilder builder_(_fbb);
  builder_.add_remainTick(remainTick);
  builder_.add_pcName(pcName);
  return builder_.Finish();
}

inline flatbuffers::Offset<BuddySendInvitationInfo> CreateBuddySendInvitationInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t remainTick = 0,
    const char *pcName = nullptr) {
  return LeanPacket::CreateBuddySendInvitationInfo(
      _fbb,
      remainTick,
      pcName ? _fbb.CreateString(pcName) : 0);
}

/// BUDDY_DATA_ALL_NOTIFY
struct BuddyDataAllNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BUDDYINFOS = 4,
    VT_RECEIVEINVITATIONS = 6,
    VT_SENDINVITATIONS = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<BuddyInfo>> *buddyInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BuddyInfo>> *>(VT_BUDDYINFOS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<BuddyReceiveInvitationInfo>> *receiveInvitations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BuddyReceiveInvitationInfo>> *>(VT_RECEIVEINVITATIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<BuddySendInvitationInfo>> *sendInvitations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BuddySendInvitationInfo>> *>(VT_SENDINVITATIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BUDDYINFOS) &&
           verifier.VerifyVector(buddyInfos()) &&
           verifier.VerifyVectorOfTables(buddyInfos()) &&
           VerifyOffset(verifier, VT_RECEIVEINVITATIONS) &&
           verifier.VerifyVector(receiveInvitations()) &&
           verifier.VerifyVectorOfTables(receiveInvitations()) &&
           VerifyOffset(verifier, VT_SENDINVITATIONS) &&
           verifier.VerifyVector(sendInvitations()) &&
           verifier.VerifyVectorOfTables(sendInvitations()) &&
           verifier.EndTable();
  }
};

struct BuddyDataAllNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_buddyInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BuddyInfo>>> buddyInfos) {
    fbb_.AddOffset(BuddyDataAllNotify::VT_BUDDYINFOS, buddyInfos);
  }
  void add_receiveInvitations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BuddyReceiveInvitationInfo>>> receiveInvitations) {
    fbb_.AddOffset(BuddyDataAllNotify::VT_RECEIVEINVITATIONS, receiveInvitations);
  }
  void add_sendInvitations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BuddySendInvitationInfo>>> sendInvitations) {
    fbb_.AddOffset(BuddyDataAllNotify::VT_SENDINVITATIONS, sendInvitations);
  }
  explicit BuddyDataAllNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BuddyDataAllNotifyBuilder &operator=(const BuddyDataAllNotifyBuilder &);
  flatbuffers::Offset<BuddyDataAllNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BuddyDataAllNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<BuddyDataAllNotify> CreateBuddyDataAllNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BuddyInfo>>> buddyInfos = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BuddyReceiveInvitationInfo>>> receiveInvitations = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BuddySendInvitationInfo>>> sendInvitations = 0) {
  BuddyDataAllNotifyBuilder builder_(_fbb);
  builder_.add_sendInvitations(sendInvitations);
  builder_.add_receiveInvitations(receiveInvitations);
  builder_.add_buddyInfos(buddyInfos);
  return builder_.Finish();
}

inline flatbuffers::Offset<BuddyDataAllNotify> CreateBuddyDataAllNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<BuddyInfo>> *buddyInfos = nullptr,
    const std::vector<flatbuffers::Offset<BuddyReceiveInvitationInfo>> *receiveInvitations = nullptr,
    const std::vector<flatbuffers::Offset<BuddySendInvitationInfo>> *sendInvitations = nullptr) {
  return LeanPacket::CreateBuddyDataAllNotify(
      _fbb,
      buddyInfos ? _fbb.CreateVector<flatbuffers::Offset<BuddyInfo>>(*buddyInfos) : 0,
      receiveInvitations ? _fbb.CreateVector<flatbuffers::Offset<BuddyReceiveInvitationInfo>>(*receiveInvitations) : 0,
      sendInvitations ? _fbb.CreateVector<flatbuffers::Offset<BuddySendInvitationInfo>>(*sendInvitations) : 0);
}

/// BUDDY_SEND_INVITATION_REQUEST 
struct BuddySendInvitationRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BUDDYPCNAME = 4
  };
  const flatbuffers::String *buddyPcName() const {
    return GetPointer<const flatbuffers::String *>(VT_BUDDYPCNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BUDDYPCNAME) &&
           verifier.VerifyString(buddyPcName()) &&
           verifier.EndTable();
  }
};

struct BuddySendInvitationRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_buddyPcName(flatbuffers::Offset<flatbuffers::String> buddyPcName) {
    fbb_.AddOffset(BuddySendInvitationRequest::VT_BUDDYPCNAME, buddyPcName);
  }
  explicit BuddySendInvitationRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BuddySendInvitationRequestBuilder &operator=(const BuddySendInvitationRequestBuilder &);
  flatbuffers::Offset<BuddySendInvitationRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BuddySendInvitationRequest>(end);
    fbb_.Required(o, BuddySendInvitationRequest::VT_BUDDYPCNAME);
    return o;
  }
};

inline flatbuffers::Offset<BuddySendInvitationRequest> CreateBuddySendInvitationRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> buddyPcName = 0) {
  BuddySendInvitationRequestBuilder builder_(_fbb);
  builder_.add_buddyPcName(buddyPcName);
  return builder_.Finish();
}

inline flatbuffers::Offset<BuddySendInvitationRequest> CreateBuddySendInvitationRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *buddyPcName = nullptr) {
  return LeanPacket::CreateBuddySendInvitationRequest(
      _fbb,
      buddyPcName ? _fbb.CreateString(buddyPcName) : 0);
}

/// BUDDY_SEND_INVITATION_RESPONSE 
struct BuddySendInvitationResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRCODE = 4,
    VT_SENDINVITATION = 6
  };
  ErrorCode errCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRCODE, 0));
  }
  const BuddySendInvitationInfo *sendInvitation() const {
    return GetPointer<const BuddySendInvitationInfo *>(VT_SENDINVITATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           VerifyOffset(verifier, VT_SENDINVITATION) &&
           verifier.VerifyTable(sendInvitation()) &&
           verifier.EndTable();
  }
};

struct BuddySendInvitationResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errCode(ErrorCode errCode) {
    fbb_.AddElement<int32_t>(BuddySendInvitationResponse::VT_ERRCODE, static_cast<int32_t>(errCode), 0);
  }
  void add_sendInvitation(flatbuffers::Offset<BuddySendInvitationInfo> sendInvitation) {
    fbb_.AddOffset(BuddySendInvitationResponse::VT_SENDINVITATION, sendInvitation);
  }
  explicit BuddySendInvitationResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BuddySendInvitationResponseBuilder &operator=(const BuddySendInvitationResponseBuilder &);
  flatbuffers::Offset<BuddySendInvitationResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BuddySendInvitationResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<BuddySendInvitationResponse> CreateBuddySendInvitationResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errCode = ErrorCode_NONE,
    flatbuffers::Offset<BuddySendInvitationInfo> sendInvitation = 0) {
  BuddySendInvitationResponseBuilder builder_(_fbb);
  builder_.add_sendInvitation(sendInvitation);
  builder_.add_errCode(errCode);
  return builder_.Finish();
}

/// BUDDY_ACCEPT_INVITATION_REQUEST
struct BuddyAcceptInvitationRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BUDDYPCNAME = 4
  };
  const flatbuffers::String *buddyPcName() const {
    return GetPointer<const flatbuffers::String *>(VT_BUDDYPCNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BUDDYPCNAME) &&
           verifier.VerifyString(buddyPcName()) &&
           verifier.EndTable();
  }
};

struct BuddyAcceptInvitationRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_buddyPcName(flatbuffers::Offset<flatbuffers::String> buddyPcName) {
    fbb_.AddOffset(BuddyAcceptInvitationRequest::VT_BUDDYPCNAME, buddyPcName);
  }
  explicit BuddyAcceptInvitationRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BuddyAcceptInvitationRequestBuilder &operator=(const BuddyAcceptInvitationRequestBuilder &);
  flatbuffers::Offset<BuddyAcceptInvitationRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BuddyAcceptInvitationRequest>(end);
    fbb_.Required(o, BuddyAcceptInvitationRequest::VT_BUDDYPCNAME);
    return o;
  }
};

inline flatbuffers::Offset<BuddyAcceptInvitationRequest> CreateBuddyAcceptInvitationRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> buddyPcName = 0) {
  BuddyAcceptInvitationRequestBuilder builder_(_fbb);
  builder_.add_buddyPcName(buddyPcName);
  return builder_.Finish();
}

inline flatbuffers::Offset<BuddyAcceptInvitationRequest> CreateBuddyAcceptInvitationRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *buddyPcName = nullptr) {
  return LeanPacket::CreateBuddyAcceptInvitationRequest(
      _fbb,
      buddyPcName ? _fbb.CreateString(buddyPcName) : 0);
}

/// BUDDY_ACCEPT_INVITATION_RESPONSE
struct BuddyAcceptInvitationResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRCODE = 4,
    VT_BUDDYINFO = 6,
    VT_ISBUDDYONLINE = 8
  };
  ErrorCode errCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRCODE, 0));
  }
  const BuddyInfo *buddyInfo() const {
    return GetPointer<const BuddyInfo *>(VT_BUDDYINFO);
  }
  bool isBuddyOnline() const {
    return GetField<uint8_t>(VT_ISBUDDYONLINE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           VerifyOffset(verifier, VT_BUDDYINFO) &&
           verifier.VerifyTable(buddyInfo()) &&
           VerifyField<uint8_t>(verifier, VT_ISBUDDYONLINE) &&
           verifier.EndTable();
  }
};

struct BuddyAcceptInvitationResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errCode(ErrorCode errCode) {
    fbb_.AddElement<int32_t>(BuddyAcceptInvitationResponse::VT_ERRCODE, static_cast<int32_t>(errCode), 0);
  }
  void add_buddyInfo(flatbuffers::Offset<BuddyInfo> buddyInfo) {
    fbb_.AddOffset(BuddyAcceptInvitationResponse::VT_BUDDYINFO, buddyInfo);
  }
  void add_isBuddyOnline(bool isBuddyOnline) {
    fbb_.AddElement<uint8_t>(BuddyAcceptInvitationResponse::VT_ISBUDDYONLINE, static_cast<uint8_t>(isBuddyOnline), 0);
  }
  explicit BuddyAcceptInvitationResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BuddyAcceptInvitationResponseBuilder &operator=(const BuddyAcceptInvitationResponseBuilder &);
  flatbuffers::Offset<BuddyAcceptInvitationResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BuddyAcceptInvitationResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<BuddyAcceptInvitationResponse> CreateBuddyAcceptInvitationResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errCode = ErrorCode_NONE,
    flatbuffers::Offset<BuddyInfo> buddyInfo = 0,
    bool isBuddyOnline = false) {
  BuddyAcceptInvitationResponseBuilder builder_(_fbb);
  builder_.add_buddyInfo(buddyInfo);
  builder_.add_errCode(errCode);
  builder_.add_isBuddyOnline(isBuddyOnline);
  return builder_.Finish();
}

/// BUDDY_REJECT_INVITATION_REQUEST
struct BuddyRejectInvitationRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BUDDYPCNAME = 4
  };
  const flatbuffers::String *buddyPcName() const {
    return GetPointer<const flatbuffers::String *>(VT_BUDDYPCNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BUDDYPCNAME) &&
           verifier.VerifyString(buddyPcName()) &&
           verifier.EndTable();
  }
};

struct BuddyRejectInvitationRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_buddyPcName(flatbuffers::Offset<flatbuffers::String> buddyPcName) {
    fbb_.AddOffset(BuddyRejectInvitationRequest::VT_BUDDYPCNAME, buddyPcName);
  }
  explicit BuddyRejectInvitationRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BuddyRejectInvitationRequestBuilder &operator=(const BuddyRejectInvitationRequestBuilder &);
  flatbuffers::Offset<BuddyRejectInvitationRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BuddyRejectInvitationRequest>(end);
    fbb_.Required(o, BuddyRejectInvitationRequest::VT_BUDDYPCNAME);
    return o;
  }
};

inline flatbuffers::Offset<BuddyRejectInvitationRequest> CreateBuddyRejectInvitationRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> buddyPcName = 0) {
  BuddyRejectInvitationRequestBuilder builder_(_fbb);
  builder_.add_buddyPcName(buddyPcName);
  return builder_.Finish();
}

inline flatbuffers::Offset<BuddyRejectInvitationRequest> CreateBuddyRejectInvitationRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *buddyPcName = nullptr) {
  return LeanPacket::CreateBuddyRejectInvitationRequest(
      _fbb,
      buddyPcName ? _fbb.CreateString(buddyPcName) : 0);
}

/// BUDDY_REJECT_INVITATION_RESPONSE
struct BuddyRejectInvitationResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRCODE = 4,
    VT_BUDDYPCNAME = 6
  };
  ErrorCode errCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRCODE, 0));
  }
  const flatbuffers::String *buddyPcName() const {
    return GetPointer<const flatbuffers::String *>(VT_BUDDYPCNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           VerifyOffset(verifier, VT_BUDDYPCNAME) &&
           verifier.VerifyString(buddyPcName()) &&
           verifier.EndTable();
  }
};

struct BuddyRejectInvitationResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errCode(ErrorCode errCode) {
    fbb_.AddElement<int32_t>(BuddyRejectInvitationResponse::VT_ERRCODE, static_cast<int32_t>(errCode), 0);
  }
  void add_buddyPcName(flatbuffers::Offset<flatbuffers::String> buddyPcName) {
    fbb_.AddOffset(BuddyRejectInvitationResponse::VT_BUDDYPCNAME, buddyPcName);
  }
  explicit BuddyRejectInvitationResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BuddyRejectInvitationResponseBuilder &operator=(const BuddyRejectInvitationResponseBuilder &);
  flatbuffers::Offset<BuddyRejectInvitationResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BuddyRejectInvitationResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<BuddyRejectInvitationResponse> CreateBuddyRejectInvitationResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errCode = ErrorCode_NONE,
    flatbuffers::Offset<flatbuffers::String> buddyPcName = 0) {
  BuddyRejectInvitationResponseBuilder builder_(_fbb);
  builder_.add_buddyPcName(buddyPcName);
  builder_.add_errCode(errCode);
  return builder_.Finish();
}

inline flatbuffers::Offset<BuddyRejectInvitationResponse> CreateBuddyRejectInvitationResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errCode = ErrorCode_NONE,
    const char *buddyPcName = nullptr) {
  return LeanPacket::CreateBuddyRejectInvitationResponse(
      _fbb,
      errCode,
      buddyPcName ? _fbb.CreateString(buddyPcName) : 0);
}

/// BUDDY_DELETE_REQUEST
struct BuddyDeleteRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BUDDYPCNAME = 4
  };
  const flatbuffers::String *buddyPcName() const {
    return GetPointer<const flatbuffers::String *>(VT_BUDDYPCNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BUDDYPCNAME) &&
           verifier.VerifyString(buddyPcName()) &&
           verifier.EndTable();
  }
};

struct BuddyDeleteRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_buddyPcName(flatbuffers::Offset<flatbuffers::String> buddyPcName) {
    fbb_.AddOffset(BuddyDeleteRequest::VT_BUDDYPCNAME, buddyPcName);
  }
  explicit BuddyDeleteRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BuddyDeleteRequestBuilder &operator=(const BuddyDeleteRequestBuilder &);
  flatbuffers::Offset<BuddyDeleteRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BuddyDeleteRequest>(end);
    fbb_.Required(o, BuddyDeleteRequest::VT_BUDDYPCNAME);
    return o;
  }
};

inline flatbuffers::Offset<BuddyDeleteRequest> CreateBuddyDeleteRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> buddyPcName = 0) {
  BuddyDeleteRequestBuilder builder_(_fbb);
  builder_.add_buddyPcName(buddyPcName);
  return builder_.Finish();
}

inline flatbuffers::Offset<BuddyDeleteRequest> CreateBuddyDeleteRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *buddyPcName = nullptr) {
  return LeanPacket::CreateBuddyDeleteRequest(
      _fbb,
      buddyPcName ? _fbb.CreateString(buddyPcName) : 0);
}

/// BUDDY_DELETE_RESPONSE
struct BuddyDeleteResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRCODE = 4,
    VT_BUDDYPCNAME = 6
  };
  ErrorCode errCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRCODE, 0));
  }
  const flatbuffers::String *buddyPcName() const {
    return GetPointer<const flatbuffers::String *>(VT_BUDDYPCNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           VerifyOffset(verifier, VT_BUDDYPCNAME) &&
           verifier.VerifyString(buddyPcName()) &&
           verifier.EndTable();
  }
};

struct BuddyDeleteResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errCode(ErrorCode errCode) {
    fbb_.AddElement<int32_t>(BuddyDeleteResponse::VT_ERRCODE, static_cast<int32_t>(errCode), 0);
  }
  void add_buddyPcName(flatbuffers::Offset<flatbuffers::String> buddyPcName) {
    fbb_.AddOffset(BuddyDeleteResponse::VT_BUDDYPCNAME, buddyPcName);
  }
  explicit BuddyDeleteResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BuddyDeleteResponseBuilder &operator=(const BuddyDeleteResponseBuilder &);
  flatbuffers::Offset<BuddyDeleteResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BuddyDeleteResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<BuddyDeleteResponse> CreateBuddyDeleteResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errCode = ErrorCode_NONE,
    flatbuffers::Offset<flatbuffers::String> buddyPcName = 0) {
  BuddyDeleteResponseBuilder builder_(_fbb);
  builder_.add_buddyPcName(buddyPcName);
  builder_.add_errCode(errCode);
  return builder_.Finish();
}

inline flatbuffers::Offset<BuddyDeleteResponse> CreateBuddyDeleteResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errCode = ErrorCode_NONE,
    const char *buddyPcName = nullptr) {
  return LeanPacket::CreateBuddyDeleteResponse(
      _fbb,
      errCode,
      buddyPcName ? _fbb.CreateString(buddyPcName) : 0);
}

/// BUDDY_RECEIVE_INVITATION_NOTIFY
struct BuddyReceiveInvitationNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RECEIVEINVITATION = 4
  };
  const BuddyReceiveInvitationInfo *receiveInvitation() const {
    return GetPointer<const BuddyReceiveInvitationInfo *>(VT_RECEIVEINVITATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_RECEIVEINVITATION) &&
           verifier.VerifyTable(receiveInvitation()) &&
           verifier.EndTable();
  }
};

struct BuddyReceiveInvitationNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_receiveInvitation(flatbuffers::Offset<BuddyReceiveInvitationInfo> receiveInvitation) {
    fbb_.AddOffset(BuddyReceiveInvitationNotify::VT_RECEIVEINVITATION, receiveInvitation);
  }
  explicit BuddyReceiveInvitationNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BuddyReceiveInvitationNotifyBuilder &operator=(const BuddyReceiveInvitationNotifyBuilder &);
  flatbuffers::Offset<BuddyReceiveInvitationNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BuddyReceiveInvitationNotify>(end);
    fbb_.Required(o, BuddyReceiveInvitationNotify::VT_RECEIVEINVITATION);
    return o;
  }
};

inline flatbuffers::Offset<BuddyReceiveInvitationNotify> CreateBuddyReceiveInvitationNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<BuddyReceiveInvitationInfo> receiveInvitation = 0) {
  BuddyReceiveInvitationNotifyBuilder builder_(_fbb);
  builder_.add_receiveInvitation(receiveInvitation);
  return builder_.Finish();
}

/// BUDDY_ADDED_NOTIFY
struct BuddyAddedNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BUDDYINFO = 4
  };
  const BuddyInfo *buddyInfo() const {
    return GetPointer<const BuddyInfo *>(VT_BUDDYINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BUDDYINFO) &&
           verifier.VerifyTable(buddyInfo()) &&
           verifier.EndTable();
  }
};

struct BuddyAddedNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_buddyInfo(flatbuffers::Offset<BuddyInfo> buddyInfo) {
    fbb_.AddOffset(BuddyAddedNotify::VT_BUDDYINFO, buddyInfo);
  }
  explicit BuddyAddedNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BuddyAddedNotifyBuilder &operator=(const BuddyAddedNotifyBuilder &);
  flatbuffers::Offset<BuddyAddedNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BuddyAddedNotify>(end);
    fbb_.Required(o, BuddyAddedNotify::VT_BUDDYINFO);
    return o;
  }
};

inline flatbuffers::Offset<BuddyAddedNotify> CreateBuddyAddedNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<BuddyInfo> buddyInfo = 0) {
  BuddyAddedNotifyBuilder builder_(_fbb);
  builder_.add_buddyInfo(buddyInfo);
  return builder_.Finish();
}

/// BUDDY_SEND_INVITATION_REJECTED_NOTIFY
struct BuddySendInvitationRejectedNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BUDDYPCNAME = 4
  };
  const flatbuffers::String *buddyPcName() const {
    return GetPointer<const flatbuffers::String *>(VT_BUDDYPCNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BUDDYPCNAME) &&
           verifier.VerifyString(buddyPcName()) &&
           verifier.EndTable();
  }
};

struct BuddySendInvitationRejectedNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_buddyPcName(flatbuffers::Offset<flatbuffers::String> buddyPcName) {
    fbb_.AddOffset(BuddySendInvitationRejectedNotify::VT_BUDDYPCNAME, buddyPcName);
  }
  explicit BuddySendInvitationRejectedNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BuddySendInvitationRejectedNotifyBuilder &operator=(const BuddySendInvitationRejectedNotifyBuilder &);
  flatbuffers::Offset<BuddySendInvitationRejectedNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BuddySendInvitationRejectedNotify>(end);
    fbb_.Required(o, BuddySendInvitationRejectedNotify::VT_BUDDYPCNAME);
    return o;
  }
};

inline flatbuffers::Offset<BuddySendInvitationRejectedNotify> CreateBuddySendInvitationRejectedNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> buddyPcName = 0) {
  BuddySendInvitationRejectedNotifyBuilder builder_(_fbb);
  builder_.add_buddyPcName(buddyPcName);
  return builder_.Finish();
}

inline flatbuffers::Offset<BuddySendInvitationRejectedNotify> CreateBuddySendInvitationRejectedNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *buddyPcName = nullptr) {
  return LeanPacket::CreateBuddySendInvitationRejectedNotify(
      _fbb,
      buddyPcName ? _fbb.CreateString(buddyPcName) : 0);
}

/// BUDDY_DELETED_NOTIFY
struct BuddyDeletedNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BUDDYPCNAME = 4
  };
  const flatbuffers::String *buddyPcName() const {
    return GetPointer<const flatbuffers::String *>(VT_BUDDYPCNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BUDDYPCNAME) &&
           verifier.VerifyString(buddyPcName()) &&
           verifier.EndTable();
  }
};

struct BuddyDeletedNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_buddyPcName(flatbuffers::Offset<flatbuffers::String> buddyPcName) {
    fbb_.AddOffset(BuddyDeletedNotify::VT_BUDDYPCNAME, buddyPcName);
  }
  explicit BuddyDeletedNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BuddyDeletedNotifyBuilder &operator=(const BuddyDeletedNotifyBuilder &);
  flatbuffers::Offset<BuddyDeletedNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BuddyDeletedNotify>(end);
    fbb_.Required(o, BuddyDeletedNotify::VT_BUDDYPCNAME);
    return o;
  }
};

inline flatbuffers::Offset<BuddyDeletedNotify> CreateBuddyDeletedNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> buddyPcName = 0) {
  BuddyDeletedNotifyBuilder builder_(_fbb);
  builder_.add_buddyPcName(buddyPcName);
  return builder_.Finish();
}

inline flatbuffers::Offset<BuddyDeletedNotify> CreateBuddyDeletedNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *buddyPcName = nullptr) {
  return LeanPacket::CreateBuddyDeletedNotify(
      _fbb,
      buddyPcName ? _fbb.CreateString(buddyPcName) : 0);
}

/// BUDDY_SEARCH_REQUEST
struct BuddySearchRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCNAME = 4
  };
  const flatbuffers::String *pcName() const {
    return GetPointer<const flatbuffers::String *>(VT_PCNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PCNAME) &&
           verifier.VerifyString(pcName()) &&
           verifier.EndTable();
  }
};

struct BuddySearchRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcName(flatbuffers::Offset<flatbuffers::String> pcName) {
    fbb_.AddOffset(BuddySearchRequest::VT_PCNAME, pcName);
  }
  explicit BuddySearchRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BuddySearchRequestBuilder &operator=(const BuddySearchRequestBuilder &);
  flatbuffers::Offset<BuddySearchRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BuddySearchRequest>(end);
    fbb_.Required(o, BuddySearchRequest::VT_PCNAME);
    return o;
  }
};

inline flatbuffers::Offset<BuddySearchRequest> CreateBuddySearchRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> pcName = 0) {
  BuddySearchRequestBuilder builder_(_fbb);
  builder_.add_pcName(pcName);
  return builder_.Finish();
}

inline flatbuffers::Offset<BuddySearchRequest> CreateBuddySearchRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *pcName = nullptr) {
  return LeanPacket::CreateBuddySearchRequest(
      _fbb,
      pcName ? _fbb.CreateString(pcName) : 0);
}

/// BUDDY_SEARCH_RESPONSE
struct BuddySearchResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRCODE = 4,
    VT_BUDDYINFO = 6
  };
  ErrorCode errCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRCODE, 0));
  }
  const BuddyInfo *buddyInfo() const {
    return GetPointer<const BuddyInfo *>(VT_BUDDYINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           VerifyOffset(verifier, VT_BUDDYINFO) &&
           verifier.VerifyTable(buddyInfo()) &&
           verifier.EndTable();
  }
};

struct BuddySearchResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errCode(ErrorCode errCode) {
    fbb_.AddElement<int32_t>(BuddySearchResponse::VT_ERRCODE, static_cast<int32_t>(errCode), 0);
  }
  void add_buddyInfo(flatbuffers::Offset<BuddyInfo> buddyInfo) {
    fbb_.AddOffset(BuddySearchResponse::VT_BUDDYINFO, buddyInfo);
  }
  explicit BuddySearchResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BuddySearchResponseBuilder &operator=(const BuddySearchResponseBuilder &);
  flatbuffers::Offset<BuddySearchResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BuddySearchResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<BuddySearchResponse> CreateBuddySearchResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errCode = ErrorCode_NONE,
    flatbuffers::Offset<BuddyInfo> buddyInfo = 0) {
  BuddySearchResponseBuilder builder_(_fbb);
  builder_.add_buddyInfo(buddyInfo);
  builder_.add_errCode(errCode);
  return builder_.Finish();
}

/// BUDDY_RECOMMEND_REQUEST
struct BuddyRecommendRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct BuddyRecommendRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BuddyRecommendRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BuddyRecommendRequestBuilder &operator=(const BuddyRecommendRequestBuilder &);
  flatbuffers::Offset<BuddyRecommendRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BuddyRecommendRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<BuddyRecommendRequest> CreateBuddyRecommendRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BuddyRecommendRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// BUDDY_RECOMMEND_RESPONSE
struct BuddyRecommendResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BUDDYINFOS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<BuddyInfo>> *buddyInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BuddyInfo>> *>(VT_BUDDYINFOS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BUDDYINFOS) &&
           verifier.VerifyVector(buddyInfos()) &&
           verifier.VerifyVectorOfTables(buddyInfos()) &&
           verifier.EndTable();
  }
};

struct BuddyRecommendResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_buddyInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BuddyInfo>>> buddyInfos) {
    fbb_.AddOffset(BuddyRecommendResponse::VT_BUDDYINFOS, buddyInfos);
  }
  explicit BuddyRecommendResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BuddyRecommendResponseBuilder &operator=(const BuddyRecommendResponseBuilder &);
  flatbuffers::Offset<BuddyRecommendResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BuddyRecommendResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<BuddyRecommendResponse> CreateBuddyRecommendResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BuddyInfo>>> buddyInfos = 0) {
  BuddyRecommendResponseBuilder builder_(_fbb);
  builder_.add_buddyInfos(buddyInfos);
  return builder_.Finish();
}

inline flatbuffers::Offset<BuddyRecommendResponse> CreateBuddyRecommendResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<BuddyInfo>> *buddyInfos = nullptr) {
  return LeanPacket::CreateBuddyRecommendResponse(
      _fbb,
      buddyInfos ? _fbb.CreateVector<flatbuffers::Offset<BuddyInfo>>(*buddyInfos) : 0);
}

struct BuddyRefreshInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BUDDYNAME = 4,
    VT_LEVEL = 6,
    VT_ISONLINE = 8
  };
  const flatbuffers::String *buddyName() const {
    return GetPointer<const flatbuffers::String *>(VT_BUDDYNAME);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  bool isOnline() const {
    return GetField<uint8_t>(VT_ISONLINE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BUDDYNAME) &&
           verifier.VerifyString(buddyName()) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<uint8_t>(verifier, VT_ISONLINE) &&
           verifier.EndTable();
  }
};

struct BuddyRefreshInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_buddyName(flatbuffers::Offset<flatbuffers::String> buddyName) {
    fbb_.AddOffset(BuddyRefreshInfo::VT_BUDDYNAME, buddyName);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(BuddyRefreshInfo::VT_LEVEL, level, 0);
  }
  void add_isOnline(bool isOnline) {
    fbb_.AddElement<uint8_t>(BuddyRefreshInfo::VT_ISONLINE, static_cast<uint8_t>(isOnline), 0);
  }
  explicit BuddyRefreshInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BuddyRefreshInfoBuilder &operator=(const BuddyRefreshInfoBuilder &);
  flatbuffers::Offset<BuddyRefreshInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BuddyRefreshInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<BuddyRefreshInfo> CreateBuddyRefreshInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> buddyName = 0,
    int32_t level = 0,
    bool isOnline = false) {
  BuddyRefreshInfoBuilder builder_(_fbb);
  builder_.add_level(level);
  builder_.add_buddyName(buddyName);
  builder_.add_isOnline(isOnline);
  return builder_.Finish();
}

inline flatbuffers::Offset<BuddyRefreshInfo> CreateBuddyRefreshInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *buddyName = nullptr,
    int32_t level = 0,
    bool isOnline = false) {
  return LeanPacket::CreateBuddyRefreshInfo(
      _fbb,
      buddyName ? _fbb.CreateString(buddyName) : 0,
      level,
      isOnline);
}

/// BUDDY_REFRESH_REQUEST
struct BuddyRefreshRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct BuddyRefreshRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BuddyRefreshRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BuddyRefreshRequestBuilder &operator=(const BuddyRefreshRequestBuilder &);
  flatbuffers::Offset<BuddyRefreshRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BuddyRefreshRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<BuddyRefreshRequest> CreateBuddyRefreshRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BuddyRefreshRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// BUDDY_REFRESH_RESPONSE
struct BuddyRefreshResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATAS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<BuddyRefreshInfo>> *datas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BuddyRefreshInfo>> *>(VT_DATAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATAS) &&
           verifier.VerifyVector(datas()) &&
           verifier.VerifyVectorOfTables(datas()) &&
           verifier.EndTable();
  }
};

struct BuddyRefreshResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_datas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BuddyRefreshInfo>>> datas) {
    fbb_.AddOffset(BuddyRefreshResponse::VT_DATAS, datas);
  }
  explicit BuddyRefreshResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BuddyRefreshResponseBuilder &operator=(const BuddyRefreshResponseBuilder &);
  flatbuffers::Offset<BuddyRefreshResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BuddyRefreshResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<BuddyRefreshResponse> CreateBuddyRefreshResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BuddyRefreshInfo>>> datas = 0) {
  BuddyRefreshResponseBuilder builder_(_fbb);
  builder_.add_datas(datas);
  return builder_.Finish();
}

inline flatbuffers::Offset<BuddyRefreshResponse> CreateBuddyRefreshResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<BuddyRefreshInfo>> *datas = nullptr) {
  return LeanPacket::CreateBuddyRefreshResponse(
      _fbb,
      datas ? _fbb.CreateVector<flatbuffers::Offset<BuddyRefreshInfo>>(*datas) : 0);
}

struct BuddyInvitationRefreshInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BUDDYNAME = 4,
    VT_LEVEL = 6
  };
  const flatbuffers::String *buddyName() const {
    return GetPointer<const flatbuffers::String *>(VT_BUDDYNAME);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BUDDYNAME) &&
           verifier.VerifyString(buddyName()) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           verifier.EndTable();
  }
};

struct BuddyInvitationRefreshInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_buddyName(flatbuffers::Offset<flatbuffers::String> buddyName) {
    fbb_.AddOffset(BuddyInvitationRefreshInfo::VT_BUDDYNAME, buddyName);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(BuddyInvitationRefreshInfo::VT_LEVEL, level, 0);
  }
  explicit BuddyInvitationRefreshInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BuddyInvitationRefreshInfoBuilder &operator=(const BuddyInvitationRefreshInfoBuilder &);
  flatbuffers::Offset<BuddyInvitationRefreshInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BuddyInvitationRefreshInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<BuddyInvitationRefreshInfo> CreateBuddyInvitationRefreshInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> buddyName = 0,
    int32_t level = 0) {
  BuddyInvitationRefreshInfoBuilder builder_(_fbb);
  builder_.add_level(level);
  builder_.add_buddyName(buddyName);
  return builder_.Finish();
}

inline flatbuffers::Offset<BuddyInvitationRefreshInfo> CreateBuddyInvitationRefreshInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *buddyName = nullptr,
    int32_t level = 0) {
  return LeanPacket::CreateBuddyInvitationRefreshInfo(
      _fbb,
      buddyName ? _fbb.CreateString(buddyName) : 0,
      level);
}

/// BUDDY_RECEIVE_INVIATION_REFRESH_REQUEST
struct BuddyReceiveInvitationRefreshRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct BuddyReceiveInvitationRefreshRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BuddyReceiveInvitationRefreshRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BuddyReceiveInvitationRefreshRequestBuilder &operator=(const BuddyReceiveInvitationRefreshRequestBuilder &);
  flatbuffers::Offset<BuddyReceiveInvitationRefreshRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BuddyReceiveInvitationRefreshRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<BuddyReceiveInvitationRefreshRequest> CreateBuddyReceiveInvitationRefreshRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BuddyReceiveInvitationRefreshRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// BUDDY_RECEIVE_INVIATION_REFRESH_RESPONSE
struct BuddyReceiveInvitationRefreshResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATAS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<BuddyInvitationRefreshInfo>> *datas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BuddyInvitationRefreshInfo>> *>(VT_DATAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATAS) &&
           verifier.VerifyVector(datas()) &&
           verifier.VerifyVectorOfTables(datas()) &&
           verifier.EndTable();
  }
};

struct BuddyReceiveInvitationRefreshResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_datas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BuddyInvitationRefreshInfo>>> datas) {
    fbb_.AddOffset(BuddyReceiveInvitationRefreshResponse::VT_DATAS, datas);
  }
  explicit BuddyReceiveInvitationRefreshResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BuddyReceiveInvitationRefreshResponseBuilder &operator=(const BuddyReceiveInvitationRefreshResponseBuilder &);
  flatbuffers::Offset<BuddyReceiveInvitationRefreshResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BuddyReceiveInvitationRefreshResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<BuddyReceiveInvitationRefreshResponse> CreateBuddyReceiveInvitationRefreshResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BuddyInvitationRefreshInfo>>> datas = 0) {
  BuddyReceiveInvitationRefreshResponseBuilder builder_(_fbb);
  builder_.add_datas(datas);
  return builder_.Finish();
}

inline flatbuffers::Offset<BuddyReceiveInvitationRefreshResponse> CreateBuddyReceiveInvitationRefreshResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<BuddyInvitationRefreshInfo>> *datas = nullptr) {
  return LeanPacket::CreateBuddyReceiveInvitationRefreshResponse(
      _fbb,
      datas ? _fbb.CreateVector<flatbuffers::Offset<BuddyInvitationRefreshInfo>>(*datas) : 0);
}

struct PcDetailInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCNAME = 4,
    VT_PCLEVEL = 6,
    VT_CLASSTYPE = 8,
    VT_ITEMINFOS = 10,
    VT_COSTUMEINFOS = 12,
    VT_PCGUILDINFO = 14,
    VT_MONARCHPOINT = 16,
    VT_ACTIONPOWER = 18,
    VT_ATTACKPOWER = 20,
    VT_SURVIVALPOWER = 22,
    VT_INFLUENCE = 24,
    VT_INFLUENCETIER = 26,
    VT_INFLUENCELEVEL = 28,
    VT_INFLUENCERANK = 30,
    VT_USEDSKILLPOINT = 32,
    VT_COMBATPOWER = 34,
    VT_CUSTOMIZINGINFO = 36,
    VT_SUMMONEDPETLOOKID = 38
  };
  const flatbuffers::String *pcName() const {
    return GetPointer<const flatbuffers::String *>(VT_PCNAME);
  }
  int32_t pcLevel() const {
    return GetField<int32_t>(VT_PCLEVEL, 0);
  }
  int32_t classType() const {
    return GetField<int32_t>(VT_CLASSTYPE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OtherPcItemInfo>> *itemInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OtherPcItemInfo>> *>(VT_ITEMINFOS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OtherPcCostumeInfo>> *costumeInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OtherPcCostumeInfo>> *>(VT_COSTUMEINFOS);
  }
  const PcGuildInfo *pcGuildInfo() const {
    return GetPointer<const PcGuildInfo *>(VT_PCGUILDINFO);
  }
  int32_t monarchPoint() const {
    return GetField<int32_t>(VT_MONARCHPOINT, 0);
  }
  int32_t actionPower() const {
    return GetField<int32_t>(VT_ACTIONPOWER, 0);
  }
  int32_t attackPower() const {
    return GetField<int32_t>(VT_ATTACKPOWER, 0);
  }
  int32_t survivalPower() const {
    return GetField<int32_t>(VT_SURVIVALPOWER, 0);
  }
  int64_t influence() const {
    return GetField<int64_t>(VT_INFLUENCE, 0);
  }
  int32_t influenceTier() const {
    return GetField<int32_t>(VT_INFLUENCETIER, 0);
  }
  int32_t influenceLevel() const {
    return GetField<int32_t>(VT_INFLUENCELEVEL, 0);
  }
  int32_t influenceRank() const {
    return GetField<int32_t>(VT_INFLUENCERANK, 0);
  }
  int32_t usedSkillPoint() const {
    return GetField<int32_t>(VT_USEDSKILLPOINT, 0);
  }
  int32_t combatPower() const {
    return GetField<int32_t>(VT_COMBATPOWER, 0);
  }
  const CustomizeInfo *customizingInfo() const {
    return GetPointer<const CustomizeInfo *>(VT_CUSTOMIZINGINFO);
  }
  int32_t summonedPetLookId() const {
    return GetField<int32_t>(VT_SUMMONEDPETLOOKID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PCNAME) &&
           verifier.VerifyString(pcName()) &&
           VerifyField<int32_t>(verifier, VT_PCLEVEL) &&
           VerifyField<int32_t>(verifier, VT_CLASSTYPE) &&
           VerifyOffset(verifier, VT_ITEMINFOS) &&
           verifier.VerifyVector(itemInfos()) &&
           verifier.VerifyVectorOfTables(itemInfos()) &&
           VerifyOffset(verifier, VT_COSTUMEINFOS) &&
           verifier.VerifyVector(costumeInfos()) &&
           verifier.VerifyVectorOfTables(costumeInfos()) &&
           VerifyOffset(verifier, VT_PCGUILDINFO) &&
           verifier.VerifyTable(pcGuildInfo()) &&
           VerifyField<int32_t>(verifier, VT_MONARCHPOINT) &&
           VerifyField<int32_t>(verifier, VT_ACTIONPOWER) &&
           VerifyField<int32_t>(verifier, VT_ATTACKPOWER) &&
           VerifyField<int32_t>(verifier, VT_SURVIVALPOWER) &&
           VerifyField<int64_t>(verifier, VT_INFLUENCE) &&
           VerifyField<int32_t>(verifier, VT_INFLUENCETIER) &&
           VerifyField<int32_t>(verifier, VT_INFLUENCELEVEL) &&
           VerifyField<int32_t>(verifier, VT_INFLUENCERANK) &&
           VerifyField<int32_t>(verifier, VT_USEDSKILLPOINT) &&
           VerifyField<int32_t>(verifier, VT_COMBATPOWER) &&
           VerifyOffset(verifier, VT_CUSTOMIZINGINFO) &&
           verifier.VerifyTable(customizingInfo()) &&
           VerifyField<int32_t>(verifier, VT_SUMMONEDPETLOOKID) &&
           verifier.EndTable();
  }
};

struct PcDetailInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcName(flatbuffers::Offset<flatbuffers::String> pcName) {
    fbb_.AddOffset(PcDetailInfo::VT_PCNAME, pcName);
  }
  void add_pcLevel(int32_t pcLevel) {
    fbb_.AddElement<int32_t>(PcDetailInfo::VT_PCLEVEL, pcLevel, 0);
  }
  void add_classType(int32_t classType) {
    fbb_.AddElement<int32_t>(PcDetailInfo::VT_CLASSTYPE, classType, 0);
  }
  void add_itemInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OtherPcItemInfo>>> itemInfos) {
    fbb_.AddOffset(PcDetailInfo::VT_ITEMINFOS, itemInfos);
  }
  void add_costumeInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OtherPcCostumeInfo>>> costumeInfos) {
    fbb_.AddOffset(PcDetailInfo::VT_COSTUMEINFOS, costumeInfos);
  }
  void add_pcGuildInfo(flatbuffers::Offset<PcGuildInfo> pcGuildInfo) {
    fbb_.AddOffset(PcDetailInfo::VT_PCGUILDINFO, pcGuildInfo);
  }
  void add_monarchPoint(int32_t monarchPoint) {
    fbb_.AddElement<int32_t>(PcDetailInfo::VT_MONARCHPOINT, monarchPoint, 0);
  }
  void add_actionPower(int32_t actionPower) {
    fbb_.AddElement<int32_t>(PcDetailInfo::VT_ACTIONPOWER, actionPower, 0);
  }
  void add_attackPower(int32_t attackPower) {
    fbb_.AddElement<int32_t>(PcDetailInfo::VT_ATTACKPOWER, attackPower, 0);
  }
  void add_survivalPower(int32_t survivalPower) {
    fbb_.AddElement<int32_t>(PcDetailInfo::VT_SURVIVALPOWER, survivalPower, 0);
  }
  void add_influence(int64_t influence) {
    fbb_.AddElement<int64_t>(PcDetailInfo::VT_INFLUENCE, influence, 0);
  }
  void add_influenceTier(int32_t influenceTier) {
    fbb_.AddElement<int32_t>(PcDetailInfo::VT_INFLUENCETIER, influenceTier, 0);
  }
  void add_influenceLevel(int32_t influenceLevel) {
    fbb_.AddElement<int32_t>(PcDetailInfo::VT_INFLUENCELEVEL, influenceLevel, 0);
  }
  void add_influenceRank(int32_t influenceRank) {
    fbb_.AddElement<int32_t>(PcDetailInfo::VT_INFLUENCERANK, influenceRank, 0);
  }
  void add_usedSkillPoint(int32_t usedSkillPoint) {
    fbb_.AddElement<int32_t>(PcDetailInfo::VT_USEDSKILLPOINT, usedSkillPoint, 0);
  }
  void add_combatPower(int32_t combatPower) {
    fbb_.AddElement<int32_t>(PcDetailInfo::VT_COMBATPOWER, combatPower, 0);
  }
  void add_customizingInfo(flatbuffers::Offset<CustomizeInfo> customizingInfo) {
    fbb_.AddOffset(PcDetailInfo::VT_CUSTOMIZINGINFO, customizingInfo);
  }
  void add_summonedPetLookId(int32_t summonedPetLookId) {
    fbb_.AddElement<int32_t>(PcDetailInfo::VT_SUMMONEDPETLOOKID, summonedPetLookId, 0);
  }
  explicit PcDetailInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PcDetailInfoBuilder &operator=(const PcDetailInfoBuilder &);
  flatbuffers::Offset<PcDetailInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PcDetailInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<PcDetailInfo> CreatePcDetailInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> pcName = 0,
    int32_t pcLevel = 0,
    int32_t classType = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OtherPcItemInfo>>> itemInfos = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OtherPcCostumeInfo>>> costumeInfos = 0,
    flatbuffers::Offset<PcGuildInfo> pcGuildInfo = 0,
    int32_t monarchPoint = 0,
    int32_t actionPower = 0,
    int32_t attackPower = 0,
    int32_t survivalPower = 0,
    int64_t influence = 0,
    int32_t influenceTier = 0,
    int32_t influenceLevel = 0,
    int32_t influenceRank = 0,
    int32_t usedSkillPoint = 0,
    int32_t combatPower = 0,
    flatbuffers::Offset<CustomizeInfo> customizingInfo = 0,
    int32_t summonedPetLookId = 0) {
  PcDetailInfoBuilder builder_(_fbb);
  builder_.add_influence(influence);
  builder_.add_summonedPetLookId(summonedPetLookId);
  builder_.add_customizingInfo(customizingInfo);
  builder_.add_combatPower(combatPower);
  builder_.add_usedSkillPoint(usedSkillPoint);
  builder_.add_influenceRank(influenceRank);
  builder_.add_influenceLevel(influenceLevel);
  builder_.add_influenceTier(influenceTier);
  builder_.add_survivalPower(survivalPower);
  builder_.add_attackPower(attackPower);
  builder_.add_actionPower(actionPower);
  builder_.add_monarchPoint(monarchPoint);
  builder_.add_pcGuildInfo(pcGuildInfo);
  builder_.add_costumeInfos(costumeInfos);
  builder_.add_itemInfos(itemInfos);
  builder_.add_classType(classType);
  builder_.add_pcLevel(pcLevel);
  builder_.add_pcName(pcName);
  return builder_.Finish();
}

inline flatbuffers::Offset<PcDetailInfo> CreatePcDetailInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *pcName = nullptr,
    int32_t pcLevel = 0,
    int32_t classType = 0,
    const std::vector<flatbuffers::Offset<OtherPcItemInfo>> *itemInfos = nullptr,
    const std::vector<flatbuffers::Offset<OtherPcCostumeInfo>> *costumeInfos = nullptr,
    flatbuffers::Offset<PcGuildInfo> pcGuildInfo = 0,
    int32_t monarchPoint = 0,
    int32_t actionPower = 0,
    int32_t attackPower = 0,
    int32_t survivalPower = 0,
    int64_t influence = 0,
    int32_t influenceTier = 0,
    int32_t influenceLevel = 0,
    int32_t influenceRank = 0,
    int32_t usedSkillPoint = 0,
    int32_t combatPower = 0,
    flatbuffers::Offset<CustomizeInfo> customizingInfo = 0,
    int32_t summonedPetLookId = 0) {
  return LeanPacket::CreatePcDetailInfo(
      _fbb,
      pcName ? _fbb.CreateString(pcName) : 0,
      pcLevel,
      classType,
      itemInfos ? _fbb.CreateVector<flatbuffers::Offset<OtherPcItemInfo>>(*itemInfos) : 0,
      costumeInfos ? _fbb.CreateVector<flatbuffers::Offset<OtherPcCostumeInfo>>(*costumeInfos) : 0,
      pcGuildInfo,
      monarchPoint,
      actionPower,
      attackPower,
      survivalPower,
      influence,
      influenceTier,
      influenceLevel,
      influenceRank,
      usedSkillPoint,
      combatPower,
      customizingInfo,
      summonedPetLookId);
}

/// BUDDY_DETAIL_INFO_REQUEST
struct BuddyDetailInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BUDDYNAME = 4
  };
  const flatbuffers::String *buddyName() const {
    return GetPointer<const flatbuffers::String *>(VT_BUDDYNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BUDDYNAME) &&
           verifier.VerifyString(buddyName()) &&
           verifier.EndTable();
  }
};

struct BuddyDetailInfoRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_buddyName(flatbuffers::Offset<flatbuffers::String> buddyName) {
    fbb_.AddOffset(BuddyDetailInfoRequest::VT_BUDDYNAME, buddyName);
  }
  explicit BuddyDetailInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BuddyDetailInfoRequestBuilder &operator=(const BuddyDetailInfoRequestBuilder &);
  flatbuffers::Offset<BuddyDetailInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BuddyDetailInfoRequest>(end);
    fbb_.Required(o, BuddyDetailInfoRequest::VT_BUDDYNAME);
    return o;
  }
};

inline flatbuffers::Offset<BuddyDetailInfoRequest> CreateBuddyDetailInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> buddyName = 0) {
  BuddyDetailInfoRequestBuilder builder_(_fbb);
  builder_.add_buddyName(buddyName);
  return builder_.Finish();
}

inline flatbuffers::Offset<BuddyDetailInfoRequest> CreateBuddyDetailInfoRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *buddyName = nullptr) {
  return LeanPacket::CreateBuddyDetailInfoRequest(
      _fbb,
      buddyName ? _fbb.CreateString(buddyName) : 0);
}

/// TARGET_PC_DETAIL_INFO_REQUEST
struct TargetPcDetailInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TARGETOBJECTID = 4
  };
  int64_t targetObjectId() const {
    return GetField<int64_t>(VT_TARGETOBJECTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TARGETOBJECTID) &&
           verifier.EndTable();
  }
};

struct TargetPcDetailInfoRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_targetObjectId(int64_t targetObjectId) {
    fbb_.AddElement<int64_t>(TargetPcDetailInfoRequest::VT_TARGETOBJECTID, targetObjectId, 0);
  }
  explicit TargetPcDetailInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TargetPcDetailInfoRequestBuilder &operator=(const TargetPcDetailInfoRequestBuilder &);
  flatbuffers::Offset<TargetPcDetailInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TargetPcDetailInfoRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<TargetPcDetailInfoRequest> CreateTargetPcDetailInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t targetObjectId = 0) {
  TargetPcDetailInfoRequestBuilder builder_(_fbb);
  builder_.add_targetObjectId(targetObjectId);
  return builder_.Finish();
}

/// TARGET_PC_DETAIL_INFO_RESPONSE
struct TargetPcDetailInfoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRCODE = 4,
    VT_DETAILINFO = 6
  };
  ErrorCode errCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRCODE, 0));
  }
  const PcDetailInfo *detailInfo() const {
    return GetPointer<const PcDetailInfo *>(VT_DETAILINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           VerifyOffset(verifier, VT_DETAILINFO) &&
           verifier.VerifyTable(detailInfo()) &&
           verifier.EndTable();
  }
};

struct TargetPcDetailInfoResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errCode(ErrorCode errCode) {
    fbb_.AddElement<int32_t>(TargetPcDetailInfoResponse::VT_ERRCODE, static_cast<int32_t>(errCode), 0);
  }
  void add_detailInfo(flatbuffers::Offset<PcDetailInfo> detailInfo) {
    fbb_.AddOffset(TargetPcDetailInfoResponse::VT_DETAILINFO, detailInfo);
  }
  explicit TargetPcDetailInfoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TargetPcDetailInfoResponseBuilder &operator=(const TargetPcDetailInfoResponseBuilder &);
  flatbuffers::Offset<TargetPcDetailInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TargetPcDetailInfoResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<TargetPcDetailInfoResponse> CreateTargetPcDetailInfoResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errCode = ErrorCode_NONE,
    flatbuffers::Offset<PcDetailInfo> detailInfo = 0) {
  TargetPcDetailInfoResponseBuilder builder_(_fbb);
  builder_.add_detailInfo(detailInfo);
  builder_.add_errCode(errCode);
  return builder_.Finish();
}

struct DeniedInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_PCDBID = 6,
    VT_WORLDID = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  int16_t worldId() const {
    return GetField<int16_t>(VT_WORLDID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           VerifyField<int16_t>(verifier, VT_WORLDID) &&
           verifier.EndTable();
  }
};

struct DeniedInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(DeniedInfo::VT_NAME, name);
  }
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(DeniedInfo::VT_PCDBID, pcDbId, 0);
  }
  void add_worldId(int16_t worldId) {
    fbb_.AddElement<int16_t>(DeniedInfo::VT_WORLDID, worldId, 0);
  }
  explicit DeniedInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeniedInfoBuilder &operator=(const DeniedInfoBuilder &);
  flatbuffers::Offset<DeniedInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeniedInfo>(end);
    fbb_.Required(o, DeniedInfo::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<DeniedInfo> CreateDeniedInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int64_t pcDbId = 0,
    int16_t worldId = 0) {
  DeniedInfoBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  builder_.add_name(name);
  builder_.add_worldId(worldId);
  return builder_.Finish();
}

inline flatbuffers::Offset<DeniedInfo> CreateDeniedInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int64_t pcDbId = 0,
    int16_t worldId = 0) {
  return LeanPacket::CreateDeniedInfo(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      pcDbId,
      worldId);
}

/// PLAYER_DENIED_REQUEST
struct PlayerDeniedRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_PCDBID = 6,
    VT_WORLDID = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int64_t pcDbId() const {
    return GetField<int64_t>(VT_PCDBID, 0);
  }
  int16_t worldId() const {
    return GetField<int16_t>(VT_WORLDID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int64_t>(verifier, VT_PCDBID) &&
           VerifyField<int16_t>(verifier, VT_WORLDID) &&
           verifier.EndTable();
  }
};

struct PlayerDeniedRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(PlayerDeniedRequest::VT_NAME, name);
  }
  void add_pcDbId(int64_t pcDbId) {
    fbb_.AddElement<int64_t>(PlayerDeniedRequest::VT_PCDBID, pcDbId, 0);
  }
  void add_worldId(int16_t worldId) {
    fbb_.AddElement<int16_t>(PlayerDeniedRequest::VT_WORLDID, worldId, 0);
  }
  explicit PlayerDeniedRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlayerDeniedRequestBuilder &operator=(const PlayerDeniedRequestBuilder &);
  flatbuffers::Offset<PlayerDeniedRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlayerDeniedRequest>(end);
    fbb_.Required(o, PlayerDeniedRequest::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<PlayerDeniedRequest> CreatePlayerDeniedRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int64_t pcDbId = 0,
    int16_t worldId = 0) {
  PlayerDeniedRequestBuilder builder_(_fbb);
  builder_.add_pcDbId(pcDbId);
  builder_.add_name(name);
  builder_.add_worldId(worldId);
  return builder_.Finish();
}

inline flatbuffers::Offset<PlayerDeniedRequest> CreatePlayerDeniedRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int64_t pcDbId = 0,
    int16_t worldId = 0) {
  return LeanPacket::CreatePlayerDeniedRequest(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      pcDbId,
      worldId);
}

/// PLAYER_DENIED_RESPONSE
struct PlayerDeniedResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERROR = 4,
    VT_INFO = 6
  };
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  const DeniedInfo *info() const {
    return GetPointer<const DeniedInfo *>(VT_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           verifier.EndTable();
  }
};

struct PlayerDeniedResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(PlayerDeniedResponse::VT_ERROR, error, 0);
  }
  void add_info(flatbuffers::Offset<DeniedInfo> info) {
    fbb_.AddOffset(PlayerDeniedResponse::VT_INFO, info);
  }
  explicit PlayerDeniedResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlayerDeniedResponseBuilder &operator=(const PlayerDeniedResponseBuilder &);
  flatbuffers::Offset<PlayerDeniedResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlayerDeniedResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<PlayerDeniedResponse> CreatePlayerDeniedResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t error = 0,
    flatbuffers::Offset<DeniedInfo> info = 0) {
  PlayerDeniedResponseBuilder builder_(_fbb);
  builder_.add_info(info);
  builder_.add_error(error);
  return builder_.Finish();
}

/// PLAYER_UNDENIED_REQUEST	
struct PlayerUndeniedRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DENIEDID = 4
  };
  int64_t deniedId() const {
    return GetField<int64_t>(VT_DENIEDID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_DENIEDID) &&
           verifier.EndTable();
  }
};

struct PlayerUndeniedRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_deniedId(int64_t deniedId) {
    fbb_.AddElement<int64_t>(PlayerUndeniedRequest::VT_DENIEDID, deniedId, 0);
  }
  explicit PlayerUndeniedRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlayerUndeniedRequestBuilder &operator=(const PlayerUndeniedRequestBuilder &);
  flatbuffers::Offset<PlayerUndeniedRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlayerUndeniedRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<PlayerUndeniedRequest> CreatePlayerUndeniedRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t deniedId = 0) {
  PlayerUndeniedRequestBuilder builder_(_fbb);
  builder_.add_deniedId(deniedId);
  return builder_.Finish();
}

/// PLAYER_UNDENIED_RESPONSE
struct PlayerUndeniedResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERROR = 4,
    VT_DENIEDID = 6
  };
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  int64_t deniedId() const {
    return GetField<int64_t>(VT_DENIEDID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           VerifyField<int64_t>(verifier, VT_DENIEDID) &&
           verifier.EndTable();
  }
};

struct PlayerUndeniedResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(PlayerUndeniedResponse::VT_ERROR, error, 0);
  }
  void add_deniedId(int64_t deniedId) {
    fbb_.AddElement<int64_t>(PlayerUndeniedResponse::VT_DENIEDID, deniedId, 0);
  }
  explicit PlayerUndeniedResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlayerUndeniedResponseBuilder &operator=(const PlayerUndeniedResponseBuilder &);
  flatbuffers::Offset<PlayerUndeniedResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlayerUndeniedResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<PlayerUndeniedResponse> CreatePlayerUndeniedResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t error = 0,
    int64_t deniedId = 0) {
  PlayerUndeniedResponseBuilder builder_(_fbb);
  builder_.add_deniedId(deniedId);
  builder_.add_error(error);
  return builder_.Finish();
}

/// PLAYER_DENIED_LIST_NOTIFY
struct PlayerDeniedListNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DENIEDINFOS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<DeniedInfo>> *deniedInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DeniedInfo>> *>(VT_DENIEDINFOS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DENIEDINFOS) &&
           verifier.VerifyVector(deniedInfos()) &&
           verifier.VerifyVectorOfTables(deniedInfos()) &&
           verifier.EndTable();
  }
};

struct PlayerDeniedListNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_deniedInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DeniedInfo>>> deniedInfos) {
    fbb_.AddOffset(PlayerDeniedListNotify::VT_DENIEDINFOS, deniedInfos);
  }
  explicit PlayerDeniedListNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlayerDeniedListNotifyBuilder &operator=(const PlayerDeniedListNotifyBuilder &);
  flatbuffers::Offset<PlayerDeniedListNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlayerDeniedListNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<PlayerDeniedListNotify> CreatePlayerDeniedListNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DeniedInfo>>> deniedInfos = 0) {
  PlayerDeniedListNotifyBuilder builder_(_fbb);
  builder_.add_deniedInfos(deniedInfos);
  return builder_.Finish();
}

inline flatbuffers::Offset<PlayerDeniedListNotify> CreatePlayerDeniedListNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<DeniedInfo>> *deniedInfos = nullptr) {
  return LeanPacket::CreatePlayerDeniedListNotify(
      _fbb,
      deniedInfos ? _fbb.CreateVector<flatbuffers::Offset<DeniedInfo>>(*deniedInfos) : 0);
}

struct PcStatHardCapData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STATTYPE = 4,
    VT_HARDCAPVALUE = 6
  };
  int32_t statType() const {
    return GetField<int32_t>(VT_STATTYPE, 0);
  }
  int32_t hardCapValue() const {
    return GetField<int32_t>(VT_HARDCAPVALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STATTYPE) &&
           VerifyField<int32_t>(verifier, VT_HARDCAPVALUE) &&
           verifier.EndTable();
  }
};

struct PcStatHardCapDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_statType(int32_t statType) {
    fbb_.AddElement<int32_t>(PcStatHardCapData::VT_STATTYPE, statType, 0);
  }
  void add_hardCapValue(int32_t hardCapValue) {
    fbb_.AddElement<int32_t>(PcStatHardCapData::VT_HARDCAPVALUE, hardCapValue, 0);
  }
  explicit PcStatHardCapDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PcStatHardCapDataBuilder &operator=(const PcStatHardCapDataBuilder &);
  flatbuffers::Offset<PcStatHardCapData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PcStatHardCapData>(end);
    return o;
  }
};

inline flatbuffers::Offset<PcStatHardCapData> CreatePcStatHardCapData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t statType = 0,
    int32_t hardCapValue = 0) {
  PcStatHardCapDataBuilder builder_(_fbb);
  builder_.add_hardCapValue(hardCapValue);
  builder_.add_statType(statType);
  return builder_.Finish();
}

///PC_STAT_HARDCAP_DATA_NOTIFY
struct PcStatHardCapDataNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCSTATHARDCAPDATAS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<PcStatHardCapData>> *PcStatHardCapDatas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PcStatHardCapData>> *>(VT_PCSTATHARDCAPDATAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PCSTATHARDCAPDATAS) &&
           verifier.VerifyVector(PcStatHardCapDatas()) &&
           verifier.VerifyVectorOfTables(PcStatHardCapDatas()) &&
           verifier.EndTable();
  }
};

struct PcStatHardCapDataNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_PcStatHardCapDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PcStatHardCapData>>> PcStatHardCapDatas) {
    fbb_.AddOffset(PcStatHardCapDataNotify::VT_PCSTATHARDCAPDATAS, PcStatHardCapDatas);
  }
  explicit PcStatHardCapDataNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PcStatHardCapDataNotifyBuilder &operator=(const PcStatHardCapDataNotifyBuilder &);
  flatbuffers::Offset<PcStatHardCapDataNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PcStatHardCapDataNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<PcStatHardCapDataNotify> CreatePcStatHardCapDataNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PcStatHardCapData>>> PcStatHardCapDatas = 0) {
  PcStatHardCapDataNotifyBuilder builder_(_fbb);
  builder_.add_PcStatHardCapDatas(PcStatHardCapDatas);
  return builder_.Finish();
}

inline flatbuffers::Offset<PcStatHardCapDataNotify> CreatePcStatHardCapDataNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<PcStatHardCapData>> *PcStatHardCapDatas = nullptr) {
  return LeanPacket::CreatePcStatHardCapDataNotify(
      _fbb,
      PcStatHardCapDatas ? _fbb.CreateVector<flatbuffers::Offset<PcStatHardCapData>>(*PcStatHardCapDatas) : 0);
}

/// SUMMON_REQUEST
struct SummonRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCNAMES = 4,
    VT_TARGETTYPE = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *pcNames() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_PCNAMES);
  }
  SummonTargetType targetType() const {
    return static_cast<SummonTargetType>(GetField<int8_t>(VT_TARGETTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PCNAMES) &&
           verifier.VerifyVector(pcNames()) &&
           verifier.VerifyVectorOfStrings(pcNames()) &&
           VerifyField<int8_t>(verifier, VT_TARGETTYPE) &&
           verifier.EndTable();
  }
};

struct SummonRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcNames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> pcNames) {
    fbb_.AddOffset(SummonRequest::VT_PCNAMES, pcNames);
  }
  void add_targetType(SummonTargetType targetType) {
    fbb_.AddElement<int8_t>(SummonRequest::VT_TARGETTYPE, static_cast<int8_t>(targetType), 0);
  }
  explicit SummonRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SummonRequestBuilder &operator=(const SummonRequestBuilder &);
  flatbuffers::Offset<SummonRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SummonRequest>(end);
    fbb_.Required(o, SummonRequest::VT_PCNAMES);
    return o;
  }
};

inline flatbuffers::Offset<SummonRequest> CreateSummonRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> pcNames = 0,
    SummonTargetType targetType = SummonTargetType_SummonTargetType_Buddy) {
  SummonRequestBuilder builder_(_fbb);
  builder_.add_pcNames(pcNames);
  builder_.add_targetType(targetType);
  return builder_.Finish();
}

inline flatbuffers::Offset<SummonRequest> CreateSummonRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *pcNames = nullptr,
    SummonTargetType targetType = SummonTargetType_SummonTargetType_Buddy) {
  return LeanPacket::CreateSummonRequest(
      _fbb,
      pcNames ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*pcNames) : 0,
      targetType);
}

/// SUMMON_RESPONSE
struct SummonResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERR = 4,
    VT_PCNAME = 6,
    VT_REMAINTICK = 8
  };
  ErrorCode err() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERR, 0));
  }
  const flatbuffers::String *pcName() const {
    return GetPointer<const flatbuffers::String *>(VT_PCNAME);
  }
  int64_t remainTick() const {
    return GetField<int64_t>(VT_REMAINTICK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERR) &&
           VerifyOffset(verifier, VT_PCNAME) &&
           verifier.VerifyString(pcName()) &&
           VerifyField<int64_t>(verifier, VT_REMAINTICK) &&
           verifier.EndTable();
  }
};

struct SummonResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_err(ErrorCode err) {
    fbb_.AddElement<int32_t>(SummonResponse::VT_ERR, static_cast<int32_t>(err), 0);
  }
  void add_pcName(flatbuffers::Offset<flatbuffers::String> pcName) {
    fbb_.AddOffset(SummonResponse::VT_PCNAME, pcName);
  }
  void add_remainTick(int64_t remainTick) {
    fbb_.AddElement<int64_t>(SummonResponse::VT_REMAINTICK, remainTick, 0);
  }
  explicit SummonResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SummonResponseBuilder &operator=(const SummonResponseBuilder &);
  flatbuffers::Offset<SummonResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SummonResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<SummonResponse> CreateSummonResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode err = ErrorCode_NONE,
    flatbuffers::Offset<flatbuffers::String> pcName = 0,
    int64_t remainTick = 0) {
  SummonResponseBuilder builder_(_fbb);
  builder_.add_remainTick(remainTick);
  builder_.add_pcName(pcName);
  builder_.add_err(err);
  return builder_.Finish();
}

inline flatbuffers::Offset<SummonResponse> CreateSummonResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode err = ErrorCode_NONE,
    const char *pcName = nullptr,
    int64_t remainTick = 0) {
  return LeanPacket::CreateSummonResponse(
      _fbb,
      err,
      pcName ? _fbb.CreateString(pcName) : 0,
      remainTick);
}

/// SUMMON_ACCEPT_REQUEST
struct SummonAcceptRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCNAME = 4
  };
  const flatbuffers::String *pcName() const {
    return GetPointer<const flatbuffers::String *>(VT_PCNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PCNAME) &&
           verifier.VerifyString(pcName()) &&
           verifier.EndTable();
  }
};

struct SummonAcceptRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcName(flatbuffers::Offset<flatbuffers::String> pcName) {
    fbb_.AddOffset(SummonAcceptRequest::VT_PCNAME, pcName);
  }
  explicit SummonAcceptRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SummonAcceptRequestBuilder &operator=(const SummonAcceptRequestBuilder &);
  flatbuffers::Offset<SummonAcceptRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SummonAcceptRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SummonAcceptRequest> CreateSummonAcceptRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> pcName = 0) {
  SummonAcceptRequestBuilder builder_(_fbb);
  builder_.add_pcName(pcName);
  return builder_.Finish();
}

inline flatbuffers::Offset<SummonAcceptRequest> CreateSummonAcceptRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *pcName = nullptr) {
  return LeanPacket::CreateSummonAcceptRequest(
      _fbb,
      pcName ? _fbb.CreateString(pcName) : 0);
}

/// SUMMON_ACCEPT_RESPONSE
struct SummonAcceptResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERR = 4,
    VT_PCNAME = 6
  };
  ErrorCode err() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERR, 0));
  }
  const flatbuffers::String *pcName() const {
    return GetPointer<const flatbuffers::String *>(VT_PCNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERR) &&
           VerifyOffset(verifier, VT_PCNAME) &&
           verifier.VerifyString(pcName()) &&
           verifier.EndTable();
  }
};

struct SummonAcceptResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_err(ErrorCode err) {
    fbb_.AddElement<int32_t>(SummonAcceptResponse::VT_ERR, static_cast<int32_t>(err), 0);
  }
  void add_pcName(flatbuffers::Offset<flatbuffers::String> pcName) {
    fbb_.AddOffset(SummonAcceptResponse::VT_PCNAME, pcName);
  }
  explicit SummonAcceptResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SummonAcceptResponseBuilder &operator=(const SummonAcceptResponseBuilder &);
  flatbuffers::Offset<SummonAcceptResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SummonAcceptResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<SummonAcceptResponse> CreateSummonAcceptResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode err = ErrorCode_NONE,
    flatbuffers::Offset<flatbuffers::String> pcName = 0) {
  SummonAcceptResponseBuilder builder_(_fbb);
  builder_.add_pcName(pcName);
  builder_.add_err(err);
  return builder_.Finish();
}

inline flatbuffers::Offset<SummonAcceptResponse> CreateSummonAcceptResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode err = ErrorCode_NONE,
    const char *pcName = nullptr) {
  return LeanPacket::CreateSummonAcceptResponse(
      _fbb,
      err,
      pcName ? _fbb.CreateString(pcName) : 0);
}

/// SUMMON_RECEIVED_NOTIFY
struct SummonReceivedNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCNAME = 4,
    VT_PCLEVEL = 6,
    VT_PCCLASSTYPE = 8,
    VT_TYPE = 10,
    VT_SMAPID = 12,
    VT_REMAINTICK = 14
  };
  const flatbuffers::String *pcName() const {
    return GetPointer<const flatbuffers::String *>(VT_PCNAME);
  }
  int32_t pcLevel() const {
    return GetField<int32_t>(VT_PCLEVEL, 0);
  }
  int32_t pcClassType() const {
    return GetField<int32_t>(VT_PCCLASSTYPE, 0);
  }
  ContentsType type() const {
    return static_cast<ContentsType>(GetField<int32_t>(VT_TYPE, 0));
  }
  int32_t sMapId() const {
    return GetField<int32_t>(VT_SMAPID, 0);
  }
  int64_t remainTick() const {
    return GetField<int64_t>(VT_REMAINTICK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PCNAME) &&
           verifier.VerifyString(pcName()) &&
           VerifyField<int32_t>(verifier, VT_PCLEVEL) &&
           VerifyField<int32_t>(verifier, VT_PCCLASSTYPE) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_SMAPID) &&
           VerifyField<int64_t>(verifier, VT_REMAINTICK) &&
           verifier.EndTable();
  }
};

struct SummonReceivedNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcName(flatbuffers::Offset<flatbuffers::String> pcName) {
    fbb_.AddOffset(SummonReceivedNotify::VT_PCNAME, pcName);
  }
  void add_pcLevel(int32_t pcLevel) {
    fbb_.AddElement<int32_t>(SummonReceivedNotify::VT_PCLEVEL, pcLevel, 0);
  }
  void add_pcClassType(int32_t pcClassType) {
    fbb_.AddElement<int32_t>(SummonReceivedNotify::VT_PCCLASSTYPE, pcClassType, 0);
  }
  void add_type(ContentsType type) {
    fbb_.AddElement<int32_t>(SummonReceivedNotify::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  void add_sMapId(int32_t sMapId) {
    fbb_.AddElement<int32_t>(SummonReceivedNotify::VT_SMAPID, sMapId, 0);
  }
  void add_remainTick(int64_t remainTick) {
    fbb_.AddElement<int64_t>(SummonReceivedNotify::VT_REMAINTICK, remainTick, 0);
  }
  explicit SummonReceivedNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SummonReceivedNotifyBuilder &operator=(const SummonReceivedNotifyBuilder &);
  flatbuffers::Offset<SummonReceivedNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SummonReceivedNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<SummonReceivedNotify> CreateSummonReceivedNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> pcName = 0,
    int32_t pcLevel = 0,
    int32_t pcClassType = 0,
    ContentsType type = ContentsType_CONTENTS_TYPE_NONE,
    int32_t sMapId = 0,
    int64_t remainTick = 0) {
  SummonReceivedNotifyBuilder builder_(_fbb);
  builder_.add_remainTick(remainTick);
  builder_.add_sMapId(sMapId);
  builder_.add_type(type);
  builder_.add_pcClassType(pcClassType);
  builder_.add_pcLevel(pcLevel);
  builder_.add_pcName(pcName);
  return builder_.Finish();
}

inline flatbuffers::Offset<SummonReceivedNotify> CreateSummonReceivedNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *pcName = nullptr,
    int32_t pcLevel = 0,
    int32_t pcClassType = 0,
    ContentsType type = ContentsType_CONTENTS_TYPE_NONE,
    int32_t sMapId = 0,
    int64_t remainTick = 0) {
  return LeanPacket::CreateSummonReceivedNotify(
      _fbb,
      pcName ? _fbb.CreateString(pcName) : 0,
      pcLevel,
      pcClassType,
      type,
      sMapId,
      remainTick);
}

/// SUMMON_ACCEPTED_NOTIFY
struct SummonAcceptedNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCNAME = 4
  };
  const flatbuffers::String *pcName() const {
    return GetPointer<const flatbuffers::String *>(VT_PCNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PCNAME) &&
           verifier.VerifyString(pcName()) &&
           verifier.EndTable();
  }
};

struct SummonAcceptedNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcName(flatbuffers::Offset<flatbuffers::String> pcName) {
    fbb_.AddOffset(SummonAcceptedNotify::VT_PCNAME, pcName);
  }
  explicit SummonAcceptedNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SummonAcceptedNotifyBuilder &operator=(const SummonAcceptedNotifyBuilder &);
  flatbuffers::Offset<SummonAcceptedNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SummonAcceptedNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<SummonAcceptedNotify> CreateSummonAcceptedNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> pcName = 0) {
  SummonAcceptedNotifyBuilder builder_(_fbb);
  builder_.add_pcName(pcName);
  return builder_.Finish();
}

inline flatbuffers::Offset<SummonAcceptedNotify> CreateSummonAcceptedNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *pcName = nullptr) {
  return LeanPacket::CreateSummonAcceptedNotify(
      _fbb,
      pcName ? _fbb.CreateString(pcName) : 0);
}

/// SUMMON_ABLE_STATE_NOTIFY
struct SummonAbleStateNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SummonAbleStateNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SummonAbleStateNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SummonAbleStateNotifyBuilder &operator=(const SummonAbleStateNotifyBuilder &);
  flatbuffers::Offset<SummonAbleStateNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SummonAbleStateNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<SummonAbleStateNotify> CreateSummonAbleStateNotify(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SummonAbleStateNotifyBuilder builder_(_fbb);
  return builder_.Finish();
}

/// MOVE_TO_PC_REQUEST
struct MoveToPcRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCNAME = 4,
    VT_TARGETTYPE = 6
  };
  const flatbuffers::String *pcName() const {
    return GetPointer<const flatbuffers::String *>(VT_PCNAME);
  }
  SummonTargetType targetType() const {
    return static_cast<SummonTargetType>(GetField<int8_t>(VT_TARGETTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PCNAME) &&
           verifier.VerifyString(pcName()) &&
           VerifyField<int8_t>(verifier, VT_TARGETTYPE) &&
           verifier.EndTable();
  }
};

struct MoveToPcRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcName(flatbuffers::Offset<flatbuffers::String> pcName) {
    fbb_.AddOffset(MoveToPcRequest::VT_PCNAME, pcName);
  }
  void add_targetType(SummonTargetType targetType) {
    fbb_.AddElement<int8_t>(MoveToPcRequest::VT_TARGETTYPE, static_cast<int8_t>(targetType), 0);
  }
  explicit MoveToPcRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MoveToPcRequestBuilder &operator=(const MoveToPcRequestBuilder &);
  flatbuffers::Offset<MoveToPcRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MoveToPcRequest>(end);
    fbb_.Required(o, MoveToPcRequest::VT_PCNAME);
    return o;
  }
};

inline flatbuffers::Offset<MoveToPcRequest> CreateMoveToPcRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> pcName = 0,
    SummonTargetType targetType = SummonTargetType_SummonTargetType_Buddy) {
  MoveToPcRequestBuilder builder_(_fbb);
  builder_.add_pcName(pcName);
  builder_.add_targetType(targetType);
  return builder_.Finish();
}

inline flatbuffers::Offset<MoveToPcRequest> CreateMoveToPcRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *pcName = nullptr,
    SummonTargetType targetType = SummonTargetType_SummonTargetType_Buddy) {
  return LeanPacket::CreateMoveToPcRequest(
      _fbb,
      pcName ? _fbb.CreateString(pcName) : 0,
      targetType);
}

/// MOVE_TO_PC_RESPONSE
struct MoveToPcResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERR = 4,
    VT_PCNAME = 6
  };
  ErrorCode err() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERR, 0));
  }
  const flatbuffers::String *pcName() const {
    return GetPointer<const flatbuffers::String *>(VT_PCNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERR) &&
           VerifyOffset(verifier, VT_PCNAME) &&
           verifier.VerifyString(pcName()) &&
           verifier.EndTable();
  }
};

struct MoveToPcResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_err(ErrorCode err) {
    fbb_.AddElement<int32_t>(MoveToPcResponse::VT_ERR, static_cast<int32_t>(err), 0);
  }
  void add_pcName(flatbuffers::Offset<flatbuffers::String> pcName) {
    fbb_.AddOffset(MoveToPcResponse::VT_PCNAME, pcName);
  }
  explicit MoveToPcResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MoveToPcResponseBuilder &operator=(const MoveToPcResponseBuilder &);
  flatbuffers::Offset<MoveToPcResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MoveToPcResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<MoveToPcResponse> CreateMoveToPcResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode err = ErrorCode_NONE,
    flatbuffers::Offset<flatbuffers::String> pcName = 0) {
  MoveToPcResponseBuilder builder_(_fbb);
  builder_.add_pcName(pcName);
  builder_.add_err(err);
  return builder_.Finish();
}

inline flatbuffers::Offset<MoveToPcResponse> CreateMoveToPcResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode err = ErrorCode_NONE,
    const char *pcName = nullptr) {
  return LeanPacket::CreateMoveToPcResponse(
      _fbb,
      err,
      pcName ? _fbb.CreateString(pcName) : 0);
}

struct ShortTermRewardData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_COUNT = 6,
    VT_ISTAKE = 8
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int16_t count() const {
    return GetField<int16_t>(VT_COUNT, 0);
  }
  bool isTake() const {
    return GetField<uint8_t>(VT_ISTAKE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<int16_t>(verifier, VT_COUNT) &&
           VerifyField<uint8_t>(verifier, VT_ISTAKE) &&
           verifier.EndTable();
  }
};

struct ShortTermRewardDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(ShortTermRewardData::VT_ID, id, 0);
  }
  void add_count(int16_t count) {
    fbb_.AddElement<int16_t>(ShortTermRewardData::VT_COUNT, count, 0);
  }
  void add_isTake(bool isTake) {
    fbb_.AddElement<uint8_t>(ShortTermRewardData::VT_ISTAKE, static_cast<uint8_t>(isTake), 0);
  }
  explicit ShortTermRewardDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShortTermRewardDataBuilder &operator=(const ShortTermRewardDataBuilder &);
  flatbuffers::Offset<ShortTermRewardData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShortTermRewardData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShortTermRewardData> CreateShortTermRewardData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int16_t count = 0,
    bool isTake = false) {
  ShortTermRewardDataBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_count(count);
  builder_.add_isTake(isTake);
  return builder_.Finish();
}

/// SHORT_TERM_REWARD_DATA_NOTIFY
struct ShortTermDataNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATA = 4
  };
  const ShortTermRewardData *data() const {
    return GetPointer<const ShortTermRewardData *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyTable(data()) &&
           verifier.EndTable();
  }
};

struct ShortTermDataNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<ShortTermRewardData> data) {
    fbb_.AddOffset(ShortTermDataNotify::VT_DATA, data);
  }
  explicit ShortTermDataNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShortTermDataNotifyBuilder &operator=(const ShortTermDataNotifyBuilder &);
  flatbuffers::Offset<ShortTermDataNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShortTermDataNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShortTermDataNotify> CreateShortTermDataNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ShortTermRewardData> data = 0) {
  ShortTermDataNotifyBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

/// SHORT_TERM_REWARD_DATA_ALL_NOTIFY
struct ShortTermDataAllNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATAS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<ShortTermRewardData>> *datas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ShortTermRewardData>> *>(VT_DATAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATAS) &&
           verifier.VerifyVector(datas()) &&
           verifier.VerifyVectorOfTables(datas()) &&
           verifier.EndTable();
  }
};

struct ShortTermDataAllNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_datas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShortTermRewardData>>> datas) {
    fbb_.AddOffset(ShortTermDataAllNotify::VT_DATAS, datas);
  }
  explicit ShortTermDataAllNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShortTermDataAllNotifyBuilder &operator=(const ShortTermDataAllNotifyBuilder &);
  flatbuffers::Offset<ShortTermDataAllNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShortTermDataAllNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShortTermDataAllNotify> CreateShortTermDataAllNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShortTermRewardData>>> datas = 0) {
  ShortTermDataAllNotifyBuilder builder_(_fbb);
  builder_.add_datas(datas);
  return builder_.Finish();
}

inline flatbuffers::Offset<ShortTermDataAllNotify> CreateShortTermDataAllNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<ShortTermRewardData>> *datas = nullptr) {
  return LeanPacket::CreateShortTermDataAllNotify(
      _fbb,
      datas ? _fbb.CreateVector<flatbuffers::Offset<ShortTermRewardData>>(*datas) : 0);
}

/// SHORT_TERM_REWARD_GIVE_REQUSET
struct ShortTermRewardGiveRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STAGEID = 4
  };
  int32_t stageId() const {
    return GetField<int32_t>(VT_STAGEID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STAGEID) &&
           verifier.EndTable();
  }
};

struct ShortTermRewardGiveRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stageId(int32_t stageId) {
    fbb_.AddElement<int32_t>(ShortTermRewardGiveRequest::VT_STAGEID, stageId, 0);
  }
  explicit ShortTermRewardGiveRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShortTermRewardGiveRequestBuilder &operator=(const ShortTermRewardGiveRequestBuilder &);
  flatbuffers::Offset<ShortTermRewardGiveRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShortTermRewardGiveRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShortTermRewardGiveRequest> CreateShortTermRewardGiveRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t stageId = 0) {
  ShortTermRewardGiveRequestBuilder builder_(_fbb);
  builder_.add_stageId(stageId);
  return builder_.Finish();
}

/// SHORT_TERM_REWARD_GIVE_RESPONSE
struct ShortTermRewardGiveResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STAGEID = 4,
    VT_ERR = 6
  };
  int32_t stageId() const {
    return GetField<int32_t>(VT_STAGEID, 0);
  }
  ErrorCode err() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERR, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STAGEID) &&
           VerifyField<int32_t>(verifier, VT_ERR) &&
           verifier.EndTable();
  }
};

struct ShortTermRewardGiveResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stageId(int32_t stageId) {
    fbb_.AddElement<int32_t>(ShortTermRewardGiveResponse::VT_STAGEID, stageId, 0);
  }
  void add_err(ErrorCode err) {
    fbb_.AddElement<int32_t>(ShortTermRewardGiveResponse::VT_ERR, static_cast<int32_t>(err), 0);
  }
  explicit ShortTermRewardGiveResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShortTermRewardGiveResponseBuilder &operator=(const ShortTermRewardGiveResponseBuilder &);
  flatbuffers::Offset<ShortTermRewardGiveResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShortTermRewardGiveResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShortTermRewardGiveResponse> CreateShortTermRewardGiveResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t stageId = 0,
    ErrorCode err = ErrorCode_NONE) {
  ShortTermRewardGiveResponseBuilder builder_(_fbb);
  builder_.add_err(err);
  builder_.add_stageId(stageId);
  return builder_.Finish();
}

/// SHORT_TERM_REWARD_DATA_ALL_REQUSET
struct ShortTermRewardDataAllRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ShortTermRewardDataAllRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ShortTermRewardDataAllRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShortTermRewardDataAllRequestBuilder &operator=(const ShortTermRewardDataAllRequestBuilder &);
  flatbuffers::Offset<ShortTermRewardDataAllRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShortTermRewardDataAllRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShortTermRewardDataAllRequest> CreateShortTermRewardDataAllRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ShortTermRewardDataAllRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// SHORT_TERM_REWARD_DATA_ALL_RESPONSE
struct ShortTermRewardDataAllResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERR = 4,
    VT_DATAS = 6
  };
  ErrorCode err() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERR, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<ShortTermRewardData>> *datas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ShortTermRewardData>> *>(VT_DATAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERR) &&
           VerifyOffset(verifier, VT_DATAS) &&
           verifier.VerifyVector(datas()) &&
           verifier.VerifyVectorOfTables(datas()) &&
           verifier.EndTable();
  }
};

struct ShortTermRewardDataAllResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_err(ErrorCode err) {
    fbb_.AddElement<int32_t>(ShortTermRewardDataAllResponse::VT_ERR, static_cast<int32_t>(err), 0);
  }
  void add_datas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShortTermRewardData>>> datas) {
    fbb_.AddOffset(ShortTermRewardDataAllResponse::VT_DATAS, datas);
  }
  explicit ShortTermRewardDataAllResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShortTermRewardDataAllResponseBuilder &operator=(const ShortTermRewardDataAllResponseBuilder &);
  flatbuffers::Offset<ShortTermRewardDataAllResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShortTermRewardDataAllResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShortTermRewardDataAllResponse> CreateShortTermRewardDataAllResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode err = ErrorCode_NONE,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShortTermRewardData>>> datas = 0) {
  ShortTermRewardDataAllResponseBuilder builder_(_fbb);
  builder_.add_datas(datas);
  builder_.add_err(err);
  return builder_.Finish();
}

inline flatbuffers::Offset<ShortTermRewardDataAllResponse> CreateShortTermRewardDataAllResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode err = ErrorCode_NONE,
    const std::vector<flatbuffers::Offset<ShortTermRewardData>> *datas = nullptr) {
  return LeanPacket::CreateShortTermRewardDataAllResponse(
      _fbb,
      err,
      datas ? _fbb.CreateVector<flatbuffers::Offset<ShortTermRewardData>>(*datas) : 0);
}

struct KillerData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_KILLERPCNAME = 4,
    VT_KILLEDTIME = 6
  };
  const flatbuffers::String *killerPcName() const {
    return GetPointer<const flatbuffers::String *>(VT_KILLERPCNAME);
  }
  int64_t killedTime() const {
    return GetField<int64_t>(VT_KILLEDTIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KILLERPCNAME) &&
           verifier.VerifyString(killerPcName()) &&
           VerifyField<int64_t>(verifier, VT_KILLEDTIME) &&
           verifier.EndTable();
  }
};

struct KillerDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_killerPcName(flatbuffers::Offset<flatbuffers::String> killerPcName) {
    fbb_.AddOffset(KillerData::VT_KILLERPCNAME, killerPcName);
  }
  void add_killedTime(int64_t killedTime) {
    fbb_.AddElement<int64_t>(KillerData::VT_KILLEDTIME, killedTime, 0);
  }
  explicit KillerDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  KillerDataBuilder &operator=(const KillerDataBuilder &);
  flatbuffers::Offset<KillerData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KillerData>(end);
    return o;
  }
};

inline flatbuffers::Offset<KillerData> CreateKillerData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> killerPcName = 0,
    int64_t killedTime = 0) {
  KillerDataBuilder builder_(_fbb);
  builder_.add_killedTime(killedTime);
  builder_.add_killerPcName(killerPcName);
  return builder_.Finish();
}

inline flatbuffers::Offset<KillerData> CreateKillerDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *killerPcName = nullptr,
    int64_t killedTime = 0) {
  return LeanPacket::CreateKillerData(
      _fbb,
      killerPcName ? _fbb.CreateString(killerPcName) : 0,
      killedTime);
}

/// KILLER_DATA_NOTIFY
struct KillerDataNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATA = 4
  };
  const KillerData *data() const {
    return GetPointer<const KillerData *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyTable(data()) &&
           verifier.EndTable();
  }
};

struct KillerDataNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<KillerData> data) {
    fbb_.AddOffset(KillerDataNotify::VT_DATA, data);
  }
  explicit KillerDataNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  KillerDataNotifyBuilder &operator=(const KillerDataNotifyBuilder &);
  flatbuffers::Offset<KillerDataNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KillerDataNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<KillerDataNotify> CreateKillerDataNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<KillerData> data = 0) {
  KillerDataNotifyBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

/// KILLER_DATA_ALL_NOTIFY
struct KillerDataAllNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATAS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<KillerData>> *datas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<KillerData>> *>(VT_DATAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATAS) &&
           verifier.VerifyVector(datas()) &&
           verifier.VerifyVectorOfTables(datas()) &&
           verifier.EndTable();
  }
};

struct KillerDataAllNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_datas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KillerData>>> datas) {
    fbb_.AddOffset(KillerDataAllNotify::VT_DATAS, datas);
  }
  explicit KillerDataAllNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  KillerDataAllNotifyBuilder &operator=(const KillerDataAllNotifyBuilder &);
  flatbuffers::Offset<KillerDataAllNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KillerDataAllNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<KillerDataAllNotify> CreateKillerDataAllNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KillerData>>> datas = 0) {
  KillerDataAllNotifyBuilder builder_(_fbb);
  builder_.add_datas(datas);
  return builder_.Finish();
}

inline flatbuffers::Offset<KillerDataAllNotify> CreateKillerDataAllNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<KillerData>> *datas = nullptr) {
  return LeanPacket::CreateKillerDataAllNotify(
      _fbb,
      datas ? _fbb.CreateVector<flatbuffers::Offset<KillerData>>(*datas) : 0);
}

/// FIND_RESERVED_NICK_NAME_REQUEST
struct FindReservedNickNameRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CODE = 4
  };
  const flatbuffers::String *code() const {
    return GetPointer<const flatbuffers::String *>(VT_CODE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CODE) &&
           verifier.VerifyString(code()) &&
           verifier.EndTable();
  }
};

struct FindReservedNickNameRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(flatbuffers::Offset<flatbuffers::String> code) {
    fbb_.AddOffset(FindReservedNickNameRequest::VT_CODE, code);
  }
  explicit FindReservedNickNameRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FindReservedNickNameRequestBuilder &operator=(const FindReservedNickNameRequestBuilder &);
  flatbuffers::Offset<FindReservedNickNameRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FindReservedNickNameRequest>(end);
    fbb_.Required(o, FindReservedNickNameRequest::VT_CODE);
    return o;
  }
};

inline flatbuffers::Offset<FindReservedNickNameRequest> CreateFindReservedNickNameRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> code = 0) {
  FindReservedNickNameRequestBuilder builder_(_fbb);
  builder_.add_code(code);
  return builder_.Finish();
}

inline flatbuffers::Offset<FindReservedNickNameRequest> CreateFindReservedNickNameRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *code = nullptr) {
  return LeanPacket::CreateFindReservedNickNameRequest(
      _fbb,
      code ? _fbb.CreateString(code) : 0);
}

/// FIND_RESERVED_NICK_NAME_RESPONSE
struct FindReservedNickNameResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERROR = 4,
    VT_CODE = 6,
    VT_COLONY = 8,
    VT_REALM = 10,
    VT_NICKNAME = 12
  };
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  const flatbuffers::String *code() const {
    return GetPointer<const flatbuffers::String *>(VT_CODE);
  }
  int16_t colony() const {
    return GetField<int16_t>(VT_COLONY, 0);
  }
  int16_t realm() const {
    return GetField<int16_t>(VT_REALM, 0);
  }
  const flatbuffers::String *nickName() const {
    return GetPointer<const flatbuffers::String *>(VT_NICKNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           VerifyOffset(verifier, VT_CODE) &&
           verifier.VerifyString(code()) &&
           VerifyField<int16_t>(verifier, VT_COLONY) &&
           VerifyField<int16_t>(verifier, VT_REALM) &&
           VerifyOffset(verifier, VT_NICKNAME) &&
           verifier.VerifyString(nickName()) &&
           verifier.EndTable();
  }
};

struct FindReservedNickNameResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(FindReservedNickNameResponse::VT_ERROR, error, 0);
  }
  void add_code(flatbuffers::Offset<flatbuffers::String> code) {
    fbb_.AddOffset(FindReservedNickNameResponse::VT_CODE, code);
  }
  void add_colony(int16_t colony) {
    fbb_.AddElement<int16_t>(FindReservedNickNameResponse::VT_COLONY, colony, 0);
  }
  void add_realm(int16_t realm) {
    fbb_.AddElement<int16_t>(FindReservedNickNameResponse::VT_REALM, realm, 0);
  }
  void add_nickName(flatbuffers::Offset<flatbuffers::String> nickName) {
    fbb_.AddOffset(FindReservedNickNameResponse::VT_NICKNAME, nickName);
  }
  explicit FindReservedNickNameResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FindReservedNickNameResponseBuilder &operator=(const FindReservedNickNameResponseBuilder &);
  flatbuffers::Offset<FindReservedNickNameResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FindReservedNickNameResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<FindReservedNickNameResponse> CreateFindReservedNickNameResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t error = 0,
    flatbuffers::Offset<flatbuffers::String> code = 0,
    int16_t colony = 0,
    int16_t realm = 0,
    flatbuffers::Offset<flatbuffers::String> nickName = 0) {
  FindReservedNickNameResponseBuilder builder_(_fbb);
  builder_.add_nickName(nickName);
  builder_.add_code(code);
  builder_.add_error(error);
  builder_.add_realm(realm);
  builder_.add_colony(colony);
  return builder_.Finish();
}

inline flatbuffers::Offset<FindReservedNickNameResponse> CreateFindReservedNickNameResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t error = 0,
    const char *code = nullptr,
    int16_t colony = 0,
    int16_t realm = 0,
    const char *nickName = nullptr) {
  return LeanPacket::CreateFindReservedNickNameResponse(
      _fbb,
      error,
      code ? _fbb.CreateString(code) : 0,
      colony,
      realm,
      nickName ? _fbb.CreateString(nickName) : 0);
}

/// SELECT_RESERVED_NICK_NAME_REQUSET
struct SelectReservedNickNameRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CODE = 4
  };
  const flatbuffers::String *code() const {
    return GetPointer<const flatbuffers::String *>(VT_CODE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CODE) &&
           verifier.VerifyString(code()) &&
           verifier.EndTable();
  }
};

struct SelectReservedNickNameRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(flatbuffers::Offset<flatbuffers::String> code) {
    fbb_.AddOffset(SelectReservedNickNameRequest::VT_CODE, code);
  }
  explicit SelectReservedNickNameRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SelectReservedNickNameRequestBuilder &operator=(const SelectReservedNickNameRequestBuilder &);
  flatbuffers::Offset<SelectReservedNickNameRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SelectReservedNickNameRequest>(end);
    fbb_.Required(o, SelectReservedNickNameRequest::VT_CODE);
    return o;
  }
};

inline flatbuffers::Offset<SelectReservedNickNameRequest> CreateSelectReservedNickNameRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> code = 0) {
  SelectReservedNickNameRequestBuilder builder_(_fbb);
  builder_.add_code(code);
  return builder_.Finish();
}

inline flatbuffers::Offset<SelectReservedNickNameRequest> CreateSelectReservedNickNameRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *code = nullptr) {
  return LeanPacket::CreateSelectReservedNickNameRequest(
      _fbb,
      code ? _fbb.CreateString(code) : 0);
}

/// SELECT_RESERVED_NICK_NAME_RESPONSE
struct SelectReservedNickNameResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERROR = 4
  };
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           verifier.EndTable();
  }
};

struct SelectReservedNickNameResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(SelectReservedNickNameResponse::VT_ERROR, error, 0);
  }
  explicit SelectReservedNickNameResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SelectReservedNickNameResponseBuilder &operator=(const SelectReservedNickNameResponseBuilder &);
  flatbuffers::Offset<SelectReservedNickNameResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SelectReservedNickNameResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<SelectReservedNickNameResponse> CreateSelectReservedNickNameResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t error = 0) {
  SelectReservedNickNameResponseBuilder builder_(_fbb);
  builder_.add_error(error);
  return builder_.Finish();
}

/// FIND_RESERVED_CHAR_REQUEST
struct FindReservedCharRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CODE = 4
  };
  const flatbuffers::String *code() const {
    return GetPointer<const flatbuffers::String *>(VT_CODE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CODE) &&
           verifier.VerifyString(code()) &&
           verifier.EndTable();
  }
};

struct FindReservedCharRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(flatbuffers::Offset<flatbuffers::String> code) {
    fbb_.AddOffset(FindReservedCharRequest::VT_CODE, code);
  }
  explicit FindReservedCharRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FindReservedCharRequestBuilder &operator=(const FindReservedCharRequestBuilder &);
  flatbuffers::Offset<FindReservedCharRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FindReservedCharRequest>(end);
    fbb_.Required(o, FindReservedCharRequest::VT_CODE);
    return o;
  }
};

inline flatbuffers::Offset<FindReservedCharRequest> CreateFindReservedCharRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> code = 0) {
  FindReservedCharRequestBuilder builder_(_fbb);
  builder_.add_code(code);
  return builder_.Finish();
}

inline flatbuffers::Offset<FindReservedCharRequest> CreateFindReservedCharRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *code = nullptr) {
  return LeanPacket::CreateFindReservedCharRequest(
      _fbb,
      code ? _fbb.CreateString(code) : 0);
}

/// FIND_RESERVED_CHAR_RESPONSE
struct FindReservedCharResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERROR = 4,
    VT_CODE = 6,
    VT_COLONY = 8,
    VT_REALM = 10,
    VT_NAME = 12
  };
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  const flatbuffers::String *code() const {
    return GetPointer<const flatbuffers::String *>(VT_CODE);
  }
  int16_t colony() const {
    return GetField<int16_t>(VT_COLONY, 0);
  }
  int16_t realm() const {
    return GetField<int16_t>(VT_REALM, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           VerifyOffset(verifier, VT_CODE) &&
           verifier.VerifyString(code()) &&
           VerifyField<int16_t>(verifier, VT_COLONY) &&
           VerifyField<int16_t>(verifier, VT_REALM) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct FindReservedCharResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(FindReservedCharResponse::VT_ERROR, error, 0);
  }
  void add_code(flatbuffers::Offset<flatbuffers::String> code) {
    fbb_.AddOffset(FindReservedCharResponse::VT_CODE, code);
  }
  void add_colony(int16_t colony) {
    fbb_.AddElement<int16_t>(FindReservedCharResponse::VT_COLONY, colony, 0);
  }
  void add_realm(int16_t realm) {
    fbb_.AddElement<int16_t>(FindReservedCharResponse::VT_REALM, realm, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(FindReservedCharResponse::VT_NAME, name);
  }
  explicit FindReservedCharResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FindReservedCharResponseBuilder &operator=(const FindReservedCharResponseBuilder &);
  flatbuffers::Offset<FindReservedCharResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FindReservedCharResponse>(end);
    fbb_.Required(o, FindReservedCharResponse::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<FindReservedCharResponse> CreateFindReservedCharResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t error = 0,
    flatbuffers::Offset<flatbuffers::String> code = 0,
    int16_t colony = 0,
    int16_t realm = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  FindReservedCharResponseBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_code(code);
  builder_.add_error(error);
  builder_.add_realm(realm);
  builder_.add_colony(colony);
  return builder_.Finish();
}

inline flatbuffers::Offset<FindReservedCharResponse> CreateFindReservedCharResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t error = 0,
    const char *code = nullptr,
    int16_t colony = 0,
    int16_t realm = 0,
    const char *name = nullptr) {
  return LeanPacket::CreateFindReservedCharResponse(
      _fbb,
      error,
      code ? _fbb.CreateString(code) : 0,
      colony,
      realm,
      name ? _fbb.CreateString(name) : 0);
}

/// SELECT_RESERVED_CHAR_REQUEST
struct SelectReservedCharRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CODE = 4
  };
  const flatbuffers::String *code() const {
    return GetPointer<const flatbuffers::String *>(VT_CODE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CODE) &&
           verifier.VerifyString(code()) &&
           verifier.EndTable();
  }
};

struct SelectReservedCharRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(flatbuffers::Offset<flatbuffers::String> code) {
    fbb_.AddOffset(SelectReservedCharRequest::VT_CODE, code);
  }
  explicit SelectReservedCharRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SelectReservedCharRequestBuilder &operator=(const SelectReservedCharRequestBuilder &);
  flatbuffers::Offset<SelectReservedCharRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SelectReservedCharRequest>(end);
    fbb_.Required(o, SelectReservedCharRequest::VT_CODE);
    return o;
  }
};

inline flatbuffers::Offset<SelectReservedCharRequest> CreateSelectReservedCharRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> code = 0) {
  SelectReservedCharRequestBuilder builder_(_fbb);
  builder_.add_code(code);
  return builder_.Finish();
}

inline flatbuffers::Offset<SelectReservedCharRequest> CreateSelectReservedCharRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *code = nullptr) {
  return LeanPacket::CreateSelectReservedCharRequest(
      _fbb,
      code ? _fbb.CreateString(code) : 0);
}

/// SELECT_RESERVED_CHAR_RESPONSE
struct SelectReservedCharResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERROR = 4
  };
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           verifier.EndTable();
  }
};

struct SelectReservedCharResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(SelectReservedCharResponse::VT_ERROR, error, 0);
  }
  explicit SelectReservedCharResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SelectReservedCharResponseBuilder &operator=(const SelectReservedCharResponseBuilder &);
  flatbuffers::Offset<SelectReservedCharResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SelectReservedCharResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<SelectReservedCharResponse> CreateSelectReservedCharResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t error = 0) {
  SelectReservedCharResponseBuilder builder_(_fbb);
  builder_.add_error(error);
  return builder_.Finish();
}

///SWITCH_SKILL_SLOT_REQUEST
struct SwitchSkillSlotRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SKILLID = 4,
    VT_OBJECTID = 6
  };
  int32_t skillId() const {
    return GetField<int32_t>(VT_SKILLID, 0);
  }
  int64_t objectid() const {
    return GetField<int64_t>(VT_OBJECTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SKILLID) &&
           VerifyField<int64_t>(verifier, VT_OBJECTID) &&
           verifier.EndTable();
  }
};

struct SwitchSkillSlotRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_skillId(int32_t skillId) {
    fbb_.AddElement<int32_t>(SwitchSkillSlotRequest::VT_SKILLID, skillId, 0);
  }
  void add_objectid(int64_t objectid) {
    fbb_.AddElement<int64_t>(SwitchSkillSlotRequest::VT_OBJECTID, objectid, 0);
  }
  explicit SwitchSkillSlotRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SwitchSkillSlotRequestBuilder &operator=(const SwitchSkillSlotRequestBuilder &);
  flatbuffers::Offset<SwitchSkillSlotRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SwitchSkillSlotRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SwitchSkillSlotRequest> CreateSwitchSkillSlotRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t skillId = 0,
    int64_t objectid = 0) {
  SwitchSkillSlotRequestBuilder builder_(_fbb);
  builder_.add_objectid(objectid);
  builder_.add_skillId(skillId);
  return builder_.Finish();
}

///ContentConfig
struct ContentConfig FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_VALUE = 6
  };
  LeanType::ContentConfigType type() const {
    return static_cast<LeanType::ContentConfigType>(GetField<int16_t>(VT_TYPE, 0));
  }
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct ContentConfigBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(LeanType::ContentConfigType type) {
    fbb_.AddElement<int16_t>(ContentConfig::VT_TYPE, static_cast<int16_t>(type), 0);
  }
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(ContentConfig::VT_VALUE, value, 0);
  }
  explicit ContentConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ContentConfigBuilder &operator=(const ContentConfigBuilder &);
  flatbuffers::Offset<ContentConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ContentConfig>(end);
    return o;
  }
};

inline flatbuffers::Offset<ContentConfig> CreateContentConfig(
    flatbuffers::FlatBufferBuilder &_fbb,
    LeanType::ContentConfigType type = LeanType::ContentConfigType_CCT_RESERVED_NICK_NAME,
    int32_t value = 0) {
  ContentConfigBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_type(type);
  return builder_.Finish();
}

struct ContentConfigList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATAS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<ContentConfig>> *datas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ContentConfig>> *>(VT_DATAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DATAS) &&
           verifier.VerifyVector(datas()) &&
           verifier.VerifyVectorOfTables(datas()) &&
           verifier.EndTable();
  }
};

struct ContentConfigListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_datas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ContentConfig>>> datas) {
    fbb_.AddOffset(ContentConfigList::VT_DATAS, datas);
  }
  explicit ContentConfigListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ContentConfigListBuilder &operator=(const ContentConfigListBuilder &);
  flatbuffers::Offset<ContentConfigList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ContentConfigList>(end);
    fbb_.Required(o, ContentConfigList::VT_DATAS);
    return o;
  }
};

inline flatbuffers::Offset<ContentConfigList> CreateContentConfigList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ContentConfig>>> datas = 0) {
  ContentConfigListBuilder builder_(_fbb);
  builder_.add_datas(datas);
  return builder_.Finish();
}

inline flatbuffers::Offset<ContentConfigList> CreateContentConfigListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<ContentConfig>> *datas = nullptr) {
  return LeanPacket::CreateContentConfigList(
      _fbb,
      datas ? _fbb.CreateVector<flatbuffers::Offset<ContentConfig>>(*datas) : 0);
}

/// USE_ITEM_CONTENTS_EFFECT_REQUEST
struct UseItemContentsEffectRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TARGET = 4
  };
  uint64_t target() const {
    return GetField<uint64_t>(VT_TARGET, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TARGET) &&
           verifier.EndTable();
  }
};

struct UseItemContentsEffectRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_target(uint64_t target) {
    fbb_.AddElement<uint64_t>(UseItemContentsEffectRequest::VT_TARGET, target, 0);
  }
  explicit UseItemContentsEffectRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UseItemContentsEffectRequestBuilder &operator=(const UseItemContentsEffectRequestBuilder &);
  flatbuffers::Offset<UseItemContentsEffectRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UseItemContentsEffectRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<UseItemContentsEffectRequest> CreateUseItemContentsEffectRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t target = 0) {
  UseItemContentsEffectRequestBuilder builder_(_fbb);
  builder_.add_target(target);
  return builder_.Finish();
}

/// USE_ITEM_CONTENTS_EFFECT_RESPONSE
struct UseItemContentsEffectResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TARGET = 4,
    VT_ITEMID = 6,
    VT_ERROR = 8
  };
  uint64_t target() const {
    return GetField<uint64_t>(VT_TARGET, 0);
  }
  int32_t itemId() const {
    return GetField<int32_t>(VT_ITEMID, 0);
  }
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TARGET) &&
           VerifyField<int32_t>(verifier, VT_ITEMID) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           verifier.EndTable();
  }
};

struct UseItemContentsEffectResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_target(uint64_t target) {
    fbb_.AddElement<uint64_t>(UseItemContentsEffectResponse::VT_TARGET, target, 0);
  }
  void add_itemId(int32_t itemId) {
    fbb_.AddElement<int32_t>(UseItemContentsEffectResponse::VT_ITEMID, itemId, 0);
  }
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(UseItemContentsEffectResponse::VT_ERROR, error, 0);
  }
  explicit UseItemContentsEffectResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UseItemContentsEffectResponseBuilder &operator=(const UseItemContentsEffectResponseBuilder &);
  flatbuffers::Offset<UseItemContentsEffectResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UseItemContentsEffectResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<UseItemContentsEffectResponse> CreateUseItemContentsEffectResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t target = 0,
    int32_t itemId = 0,
    int32_t error = 0) {
  UseItemContentsEffectResponseBuilder builder_(_fbb);
  builder_.add_target(target);
  builder_.add_error(error);
  builder_.add_itemId(itemId);
  return builder_.Finish();
}

struct TranscendStat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STATGROUPID = 4,
    VT_STATTYPE = 6,
    VT_STATVALUE = 8
  };
  int32_t statGroupId() const {
    return GetField<int32_t>(VT_STATGROUPID, 0);
  }
  uint8_t statType() const {
    return GetField<uint8_t>(VT_STATTYPE, 0);
  }
  int32_t statValue() const {
    return GetField<int32_t>(VT_STATVALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STATGROUPID) &&
           VerifyField<uint8_t>(verifier, VT_STATTYPE) &&
           VerifyField<int32_t>(verifier, VT_STATVALUE) &&
           verifier.EndTable();
  }
};

struct TranscendStatBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_statGroupId(int32_t statGroupId) {
    fbb_.AddElement<int32_t>(TranscendStat::VT_STATGROUPID, statGroupId, 0);
  }
  void add_statType(uint8_t statType) {
    fbb_.AddElement<uint8_t>(TranscendStat::VT_STATTYPE, statType, 0);
  }
  void add_statValue(int32_t statValue) {
    fbb_.AddElement<int32_t>(TranscendStat::VT_STATVALUE, statValue, 0);
  }
  explicit TranscendStatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TranscendStatBuilder &operator=(const TranscendStatBuilder &);
  flatbuffers::Offset<TranscendStat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TranscendStat>(end);
    return o;
  }
};

inline flatbuffers::Offset<TranscendStat> CreateTranscendStat(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t statGroupId = 0,
    uint8_t statType = 0,
    int32_t statValue = 0) {
  TranscendStatBuilder builder_(_fbb);
  builder_.add_statValue(statValue);
  builder_.add_statGroupId(statGroupId);
  builder_.add_statType(statType);
  return builder_.Finish();
}

/// TRANSCEND_ITEM_REQUEST
struct TranscendItemRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMOBJECTID = 4,
    VT_SUCCESSSTONECOUNT = 6
  };
  uint64_t itemObjectId() const {
    return GetField<uint64_t>(VT_ITEMOBJECTID, 0);
  }
  int16_t successStoneCount() const {
    return GetField<int16_t>(VT_SUCCESSSTONECOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ITEMOBJECTID) &&
           VerifyField<int16_t>(verifier, VT_SUCCESSSTONECOUNT) &&
           verifier.EndTable();
  }
};

struct TranscendItemRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemObjectId(uint64_t itemObjectId) {
    fbb_.AddElement<uint64_t>(TranscendItemRequest::VT_ITEMOBJECTID, itemObjectId, 0);
  }
  void add_successStoneCount(int16_t successStoneCount) {
    fbb_.AddElement<int16_t>(TranscendItemRequest::VT_SUCCESSSTONECOUNT, successStoneCount, 0);
  }
  explicit TranscendItemRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TranscendItemRequestBuilder &operator=(const TranscendItemRequestBuilder &);
  flatbuffers::Offset<TranscendItemRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TranscendItemRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<TranscendItemRequest> CreateTranscendItemRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t itemObjectId = 0,
    int16_t successStoneCount = 0) {
  TranscendItemRequestBuilder builder_(_fbb);
  builder_.add_itemObjectId(itemObjectId);
  builder_.add_successStoneCount(successStoneCount);
  return builder_.Finish();
}

/// TRANSCEND_ITEM_RESPONSE
struct TranscendItemResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_ITEMOBJECTID = 6,
    VT_ISSUCCESS = 8,
    VT_LEVEL = 10,
    VT_STATS = 12
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  uint64_t itemObjectId() const {
    return GetField<uint64_t>(VT_ITEMOBJECTID, 0);
  }
  bool isSuccess() const {
    return GetField<uint8_t>(VT_ISSUCCESS, 0) != 0;
  }
  int16_t level() const {
    return GetField<int16_t>(VT_LEVEL, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TranscendStat>> *stats() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TranscendStat>> *>(VT_STATS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<uint64_t>(verifier, VT_ITEMOBJECTID) &&
           VerifyField<uint8_t>(verifier, VT_ISSUCCESS) &&
           VerifyField<int16_t>(verifier, VT_LEVEL) &&
           VerifyOffset(verifier, VT_STATS) &&
           verifier.VerifyVector(stats()) &&
           verifier.VerifyVectorOfTables(stats()) &&
           verifier.EndTable();
  }
};

struct TranscendItemResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(TranscendItemResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_itemObjectId(uint64_t itemObjectId) {
    fbb_.AddElement<uint64_t>(TranscendItemResponse::VT_ITEMOBJECTID, itemObjectId, 0);
  }
  void add_isSuccess(bool isSuccess) {
    fbb_.AddElement<uint8_t>(TranscendItemResponse::VT_ISSUCCESS, static_cast<uint8_t>(isSuccess), 0);
  }
  void add_level(int16_t level) {
    fbb_.AddElement<int16_t>(TranscendItemResponse::VT_LEVEL, level, 0);
  }
  void add_stats(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TranscendStat>>> stats) {
    fbb_.AddOffset(TranscendItemResponse::VT_STATS, stats);
  }
  explicit TranscendItemResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TranscendItemResponseBuilder &operator=(const TranscendItemResponseBuilder &);
  flatbuffers::Offset<TranscendItemResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TranscendItemResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<TranscendItemResponse> CreateTranscendItemResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    uint64_t itemObjectId = 0,
    bool isSuccess = false,
    int16_t level = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TranscendStat>>> stats = 0) {
  TranscendItemResponseBuilder builder_(_fbb);
  builder_.add_itemObjectId(itemObjectId);
  builder_.add_stats(stats);
  builder_.add_errorCode(errorCode);
  builder_.add_level(level);
  builder_.add_isSuccess(isSuccess);
  return builder_.Finish();
}

inline flatbuffers::Offset<TranscendItemResponse> CreateTranscendItemResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    uint64_t itemObjectId = 0,
    bool isSuccess = false,
    int16_t level = 0,
    const std::vector<flatbuffers::Offset<TranscendStat>> *stats = nullptr) {
  return LeanPacket::CreateTranscendItemResponse(
      _fbb,
      errorCode,
      itemObjectId,
      isSuccess,
      level,
      stats ? _fbb.CreateVector<flatbuffers::Offset<TranscendStat>>(*stats) : 0);
}

/// TRANSCEND_CHANGE_STAT_REQUEST
struct TranscendChangeStatRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMOBJECTID = 4,
    VT_CHANGESTATS = 6
  };
  uint64_t itemObjectId() const {
    return GetField<uint64_t>(VT_ITEMOBJECTID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TranscendStat>> *changeStats() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TranscendStat>> *>(VT_CHANGESTATS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ITEMOBJECTID) &&
           VerifyOffset(verifier, VT_CHANGESTATS) &&
           verifier.VerifyVector(changeStats()) &&
           verifier.VerifyVectorOfTables(changeStats()) &&
           verifier.EndTable();
  }
};

struct TranscendChangeStatRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemObjectId(uint64_t itemObjectId) {
    fbb_.AddElement<uint64_t>(TranscendChangeStatRequest::VT_ITEMOBJECTID, itemObjectId, 0);
  }
  void add_changeStats(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TranscendStat>>> changeStats) {
    fbb_.AddOffset(TranscendChangeStatRequest::VT_CHANGESTATS, changeStats);
  }
  explicit TranscendChangeStatRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TranscendChangeStatRequestBuilder &operator=(const TranscendChangeStatRequestBuilder &);
  flatbuffers::Offset<TranscendChangeStatRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TranscendChangeStatRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<TranscendChangeStatRequest> CreateTranscendChangeStatRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t itemObjectId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TranscendStat>>> changeStats = 0) {
  TranscendChangeStatRequestBuilder builder_(_fbb);
  builder_.add_itemObjectId(itemObjectId);
  builder_.add_changeStats(changeStats);
  return builder_.Finish();
}

inline flatbuffers::Offset<TranscendChangeStatRequest> CreateTranscendChangeStatRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t itemObjectId = 0,
    const std::vector<flatbuffers::Offset<TranscendStat>> *changeStats = nullptr) {
  return LeanPacket::CreateTranscendChangeStatRequest(
      _fbb,
      itemObjectId,
      changeStats ? _fbb.CreateVector<flatbuffers::Offset<TranscendStat>>(*changeStats) : 0);
}

/// TRANSCEND_CHANGE_STAT_RESPONSE
struct TranscendChangeStatResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_ITEMOBJECTID = 6,
    VT_CHANGESTATS = 8
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  uint64_t itemObjectId() const {
    return GetField<uint64_t>(VT_ITEMOBJECTID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TranscendStat>> *changeStats() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TranscendStat>> *>(VT_CHANGESTATS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<uint64_t>(verifier, VT_ITEMOBJECTID) &&
           VerifyOffset(verifier, VT_CHANGESTATS) &&
           verifier.VerifyVector(changeStats()) &&
           verifier.VerifyVectorOfTables(changeStats()) &&
           verifier.EndTable();
  }
};

struct TranscendChangeStatResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(TranscendChangeStatResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_itemObjectId(uint64_t itemObjectId) {
    fbb_.AddElement<uint64_t>(TranscendChangeStatResponse::VT_ITEMOBJECTID, itemObjectId, 0);
  }
  void add_changeStats(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TranscendStat>>> changeStats) {
    fbb_.AddOffset(TranscendChangeStatResponse::VT_CHANGESTATS, changeStats);
  }
  explicit TranscendChangeStatResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TranscendChangeStatResponseBuilder &operator=(const TranscendChangeStatResponseBuilder &);
  flatbuffers::Offset<TranscendChangeStatResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TranscendChangeStatResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<TranscendChangeStatResponse> CreateTranscendChangeStatResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    uint64_t itemObjectId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TranscendStat>>> changeStats = 0) {
  TranscendChangeStatResponseBuilder builder_(_fbb);
  builder_.add_itemObjectId(itemObjectId);
  builder_.add_changeStats(changeStats);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

inline flatbuffers::Offset<TranscendChangeStatResponse> CreateTranscendChangeStatResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    uint64_t itemObjectId = 0,
    const std::vector<flatbuffers::Offset<TranscendStat>> *changeStats = nullptr) {
  return LeanPacket::CreateTranscendChangeStatResponse(
      _fbb,
      errorCode,
      itemObjectId,
      changeStats ? _fbb.CreateVector<flatbuffers::Offset<TranscendStat>>(*changeStats) : 0);
}

struct BattleFieldCollection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GROUPID = 4,
    VT_COUNT = 6
  };
  int16_t groupId() const {
    return GetField<int16_t>(VT_GROUPID, 0);
  }
  int16_t count() const {
    return GetField<int16_t>(VT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_GROUPID) &&
           VerifyField<int16_t>(verifier, VT_COUNT) &&
           verifier.EndTable();
  }
};

struct BattleFieldCollectionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_groupId(int16_t groupId) {
    fbb_.AddElement<int16_t>(BattleFieldCollection::VT_GROUPID, groupId, 0);
  }
  void add_count(int16_t count) {
    fbb_.AddElement<int16_t>(BattleFieldCollection::VT_COUNT, count, 0);
  }
  explicit BattleFieldCollectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BattleFieldCollectionBuilder &operator=(const BattleFieldCollectionBuilder &);
  flatbuffers::Offset<BattleFieldCollection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BattleFieldCollection>(end);
    return o;
  }
};

inline flatbuffers::Offset<BattleFieldCollection> CreateBattleFieldCollection(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t groupId = 0,
    int16_t count = 0) {
  BattleFieldCollectionBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_groupId(groupId);
  return builder_.Finish();
}

/// BATTLE_FIELD_COLLECTION_NOTIFY
struct BattleFieldCollectionNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATAS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<BattleFieldCollection>> *datas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BattleFieldCollection>> *>(VT_DATAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATAS) &&
           verifier.VerifyVector(datas()) &&
           verifier.VerifyVectorOfTables(datas()) &&
           verifier.EndTable();
  }
};

struct BattleFieldCollectionNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_datas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BattleFieldCollection>>> datas) {
    fbb_.AddOffset(BattleFieldCollectionNotify::VT_DATAS, datas);
  }
  explicit BattleFieldCollectionNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BattleFieldCollectionNotifyBuilder &operator=(const BattleFieldCollectionNotifyBuilder &);
  flatbuffers::Offset<BattleFieldCollectionNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BattleFieldCollectionNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<BattleFieldCollectionNotify> CreateBattleFieldCollectionNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BattleFieldCollection>>> datas = 0) {
  BattleFieldCollectionNotifyBuilder builder_(_fbb);
  builder_.add_datas(datas);
  return builder_.Finish();
}

inline flatbuffers::Offset<BattleFieldCollectionNotify> CreateBattleFieldCollectionNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<BattleFieldCollection>> *datas = nullptr) {
  return LeanPacket::CreateBattleFieldCollectionNotify(
      _fbb,
      datas ? _fbb.CreateVector<flatbuffers::Offset<BattleFieldCollection>>(*datas) : 0);
}

/// PUSH_CREATE_NOTIFY
struct PushCreateNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PUSHID = 4,
    VT_PUSHSTATE = 6,
    VT_PUSHREMAINTICK = 8,
    VT_EVENTSETTYPE = 10,
    VT_CONTENTSID = 12
  };
  int64_t pushId() const {
    return GetField<int64_t>(VT_PUSHID, 0);
  }
  PushState pushState() const {
    return static_cast<PushState>(GetField<int32_t>(VT_PUSHSTATE, 0));
  }
  int32_t pushRemainTick() const {
    return GetField<int32_t>(VT_PUSHREMAINTICK, 0);
  }
  int32_t eventSetType() const {
    return GetField<int32_t>(VT_EVENTSETTYPE, 0);
  }
  int32_t contentsId() const {
    return GetField<int32_t>(VT_CONTENTSID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PUSHID) &&
           VerifyField<int32_t>(verifier, VT_PUSHSTATE) &&
           VerifyField<int32_t>(verifier, VT_PUSHREMAINTICK) &&
           VerifyField<int32_t>(verifier, VT_EVENTSETTYPE) &&
           VerifyField<int32_t>(verifier, VT_CONTENTSID) &&
           verifier.EndTable();
  }
};

struct PushCreateNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pushId(int64_t pushId) {
    fbb_.AddElement<int64_t>(PushCreateNotify::VT_PUSHID, pushId, 0);
  }
  void add_pushState(PushState pushState) {
    fbb_.AddElement<int32_t>(PushCreateNotify::VT_PUSHSTATE, static_cast<int32_t>(pushState), 0);
  }
  void add_pushRemainTick(int32_t pushRemainTick) {
    fbb_.AddElement<int32_t>(PushCreateNotify::VT_PUSHREMAINTICK, pushRemainTick, 0);
  }
  void add_eventSetType(int32_t eventSetType) {
    fbb_.AddElement<int32_t>(PushCreateNotify::VT_EVENTSETTYPE, eventSetType, 0);
  }
  void add_contentsId(int32_t contentsId) {
    fbb_.AddElement<int32_t>(PushCreateNotify::VT_CONTENTSID, contentsId, 0);
  }
  explicit PushCreateNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PushCreateNotifyBuilder &operator=(const PushCreateNotifyBuilder &);
  flatbuffers::Offset<PushCreateNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PushCreateNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<PushCreateNotify> CreatePushCreateNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pushId = 0,
    PushState pushState = PushState_PUSH_STATE_READY,
    int32_t pushRemainTick = 0,
    int32_t eventSetType = 0,
    int32_t contentsId = 0) {
  PushCreateNotifyBuilder builder_(_fbb);
  builder_.add_pushId(pushId);
  builder_.add_contentsId(contentsId);
  builder_.add_eventSetType(eventSetType);
  builder_.add_pushRemainTick(pushRemainTick);
  builder_.add_pushState(pushState);
  return builder_.Finish();
}

/// PUSH_UPDATE_NOTIFY
struct PushUpdateNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PUSHID = 4,
    VT_PUSHSTATE = 6,
    VT_PUSHREMAINTICK = 8,
    VT_EVENTSETTYPE = 10,
    VT_CONTENTSID = 12
  };
  int64_t pushId() const {
    return GetField<int64_t>(VT_PUSHID, 0);
  }
  PushState pushState() const {
    return static_cast<PushState>(GetField<int32_t>(VT_PUSHSTATE, 0));
  }
  int32_t pushRemainTick() const {
    return GetField<int32_t>(VT_PUSHREMAINTICK, 0);
  }
  int32_t eventSetType() const {
    return GetField<int32_t>(VT_EVENTSETTYPE, 0);
  }
  int32_t contentsId() const {
    return GetField<int32_t>(VT_CONTENTSID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PUSHID) &&
           VerifyField<int32_t>(verifier, VT_PUSHSTATE) &&
           VerifyField<int32_t>(verifier, VT_PUSHREMAINTICK) &&
           VerifyField<int32_t>(verifier, VT_EVENTSETTYPE) &&
           VerifyField<int32_t>(verifier, VT_CONTENTSID) &&
           verifier.EndTable();
  }
};

struct PushUpdateNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pushId(int64_t pushId) {
    fbb_.AddElement<int64_t>(PushUpdateNotify::VT_PUSHID, pushId, 0);
  }
  void add_pushState(PushState pushState) {
    fbb_.AddElement<int32_t>(PushUpdateNotify::VT_PUSHSTATE, static_cast<int32_t>(pushState), 0);
  }
  void add_pushRemainTick(int32_t pushRemainTick) {
    fbb_.AddElement<int32_t>(PushUpdateNotify::VT_PUSHREMAINTICK, pushRemainTick, 0);
  }
  void add_eventSetType(int32_t eventSetType) {
    fbb_.AddElement<int32_t>(PushUpdateNotify::VT_EVENTSETTYPE, eventSetType, 0);
  }
  void add_contentsId(int32_t contentsId) {
    fbb_.AddElement<int32_t>(PushUpdateNotify::VT_CONTENTSID, contentsId, 0);
  }
  explicit PushUpdateNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PushUpdateNotifyBuilder &operator=(const PushUpdateNotifyBuilder &);
  flatbuffers::Offset<PushUpdateNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PushUpdateNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<PushUpdateNotify> CreatePushUpdateNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pushId = 0,
    PushState pushState = PushState_PUSH_STATE_READY,
    int32_t pushRemainTick = 0,
    int32_t eventSetType = 0,
    int32_t contentsId = 0) {
  PushUpdateNotifyBuilder builder_(_fbb);
  builder_.add_pushId(pushId);
  builder_.add_contentsId(contentsId);
  builder_.add_eventSetType(eventSetType);
  builder_.add_pushRemainTick(pushRemainTick);
  builder_.add_pushState(pushState);
  return builder_.Finish();
}

/// PUSH_ALONE_JOIN_REQUEST
struct PushAloneJoinRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PUSHID = 4,
    VT_EVENTSETTYPE = 6,
    VT_CONTENTSID = 8
  };
  int64_t pushId() const {
    return GetField<int64_t>(VT_PUSHID, 0);
  }
  int32_t eventSetType() const {
    return GetField<int32_t>(VT_EVENTSETTYPE, 0);
  }
  int32_t contentsId() const {
    return GetField<int32_t>(VT_CONTENTSID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PUSHID) &&
           VerifyField<int32_t>(verifier, VT_EVENTSETTYPE) &&
           VerifyField<int32_t>(verifier, VT_CONTENTSID) &&
           verifier.EndTable();
  }
};

struct PushAloneJoinRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pushId(int64_t pushId) {
    fbb_.AddElement<int64_t>(PushAloneJoinRequest::VT_PUSHID, pushId, 0);
  }
  void add_eventSetType(int32_t eventSetType) {
    fbb_.AddElement<int32_t>(PushAloneJoinRequest::VT_EVENTSETTYPE, eventSetType, 0);
  }
  void add_contentsId(int32_t contentsId) {
    fbb_.AddElement<int32_t>(PushAloneJoinRequest::VT_CONTENTSID, contentsId, 0);
  }
  explicit PushAloneJoinRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PushAloneJoinRequestBuilder &operator=(const PushAloneJoinRequestBuilder &);
  flatbuffers::Offset<PushAloneJoinRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PushAloneJoinRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<PushAloneJoinRequest> CreatePushAloneJoinRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pushId = 0,
    int32_t eventSetType = 0,
    int32_t contentsId = 0) {
  PushAloneJoinRequestBuilder builder_(_fbb);
  builder_.add_pushId(pushId);
  builder_.add_contentsId(contentsId);
  builder_.add_eventSetType(eventSetType);
  return builder_.Finish();
}

/// PUSH_ALONE_JOIN_RESPONSE
struct PushAloneJoinResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERR = 4,
    VT_PUSHID = 6
  };
  ErrorCode err() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERR, 0));
  }
  int64_t pushId() const {
    return GetField<int64_t>(VT_PUSHID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERR) &&
           VerifyField<int64_t>(verifier, VT_PUSHID) &&
           verifier.EndTable();
  }
};

struct PushAloneJoinResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_err(ErrorCode err) {
    fbb_.AddElement<int32_t>(PushAloneJoinResponse::VT_ERR, static_cast<int32_t>(err), 0);
  }
  void add_pushId(int64_t pushId) {
    fbb_.AddElement<int64_t>(PushAloneJoinResponse::VT_PUSHID, pushId, 0);
  }
  explicit PushAloneJoinResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PushAloneJoinResponseBuilder &operator=(const PushAloneJoinResponseBuilder &);
  flatbuffers::Offset<PushAloneJoinResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PushAloneJoinResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<PushAloneJoinResponse> CreatePushAloneJoinResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode err = ErrorCode_NONE,
    int64_t pushId = 0) {
  PushAloneJoinResponseBuilder builder_(_fbb);
  builder_.add_pushId(pushId);
  builder_.add_err(err);
  return builder_.Finish();
}

/// PUSH_QUICK_MATCHING_JOIN_REQUEST
struct PushMatchingQuickJoinRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PUSHID = 4,
    VT_MATCHID = 6,
    VT_EVENTSETTYPE = 8,
    VT_CONTENTSID = 10,
    VT_ISPREVCANCEL = 12
  };
  int64_t pushId() const {
    return GetField<int64_t>(VT_PUSHID, 0);
  }
  uint32_t matchId() const {
    return GetField<uint32_t>(VT_MATCHID, 0);
  }
  int32_t eventSetType() const {
    return GetField<int32_t>(VT_EVENTSETTYPE, 0);
  }
  int32_t contentsId() const {
    return GetField<int32_t>(VT_CONTENTSID, 0);
  }
  bool isPrevCancel() const {
    return GetField<uint8_t>(VT_ISPREVCANCEL, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PUSHID) &&
           VerifyField<uint32_t>(verifier, VT_MATCHID) &&
           VerifyField<int32_t>(verifier, VT_EVENTSETTYPE) &&
           VerifyField<int32_t>(verifier, VT_CONTENTSID) &&
           VerifyField<uint8_t>(verifier, VT_ISPREVCANCEL) &&
           verifier.EndTable();
  }
};

struct PushMatchingQuickJoinRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pushId(int64_t pushId) {
    fbb_.AddElement<int64_t>(PushMatchingQuickJoinRequest::VT_PUSHID, pushId, 0);
  }
  void add_matchId(uint32_t matchId) {
    fbb_.AddElement<uint32_t>(PushMatchingQuickJoinRequest::VT_MATCHID, matchId, 0);
  }
  void add_eventSetType(int32_t eventSetType) {
    fbb_.AddElement<int32_t>(PushMatchingQuickJoinRequest::VT_EVENTSETTYPE, eventSetType, 0);
  }
  void add_contentsId(int32_t contentsId) {
    fbb_.AddElement<int32_t>(PushMatchingQuickJoinRequest::VT_CONTENTSID, contentsId, 0);
  }
  void add_isPrevCancel(bool isPrevCancel) {
    fbb_.AddElement<uint8_t>(PushMatchingQuickJoinRequest::VT_ISPREVCANCEL, static_cast<uint8_t>(isPrevCancel), 0);
  }
  explicit PushMatchingQuickJoinRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PushMatchingQuickJoinRequestBuilder &operator=(const PushMatchingQuickJoinRequestBuilder &);
  flatbuffers::Offset<PushMatchingQuickJoinRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PushMatchingQuickJoinRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<PushMatchingQuickJoinRequest> CreatePushMatchingQuickJoinRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pushId = 0,
    uint32_t matchId = 0,
    int32_t eventSetType = 0,
    int32_t contentsId = 0,
    bool isPrevCancel = false) {
  PushMatchingQuickJoinRequestBuilder builder_(_fbb);
  builder_.add_pushId(pushId);
  builder_.add_contentsId(contentsId);
  builder_.add_eventSetType(eventSetType);
  builder_.add_matchId(matchId);
  builder_.add_isPrevCancel(isPrevCancel);
  return builder_.Finish();
}

/// PUSH_QUICK_MATCHING_JOIN_RESPONSE
struct PushQuickMatchingJoinResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERR = 4,
    VT_PUSHID = 6,
    VT_MATCHID = 8
  };
  ErrorCode err() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERR, 0));
  }
  int64_t pushId() const {
    return GetField<int64_t>(VT_PUSHID, 0);
  }
  uint32_t matchId() const {
    return GetField<uint32_t>(VT_MATCHID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERR) &&
           VerifyField<int64_t>(verifier, VT_PUSHID) &&
           VerifyField<uint32_t>(verifier, VT_MATCHID) &&
           verifier.EndTable();
  }
};

struct PushQuickMatchingJoinResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_err(ErrorCode err) {
    fbb_.AddElement<int32_t>(PushQuickMatchingJoinResponse::VT_ERR, static_cast<int32_t>(err), 0);
  }
  void add_pushId(int64_t pushId) {
    fbb_.AddElement<int64_t>(PushQuickMatchingJoinResponse::VT_PUSHID, pushId, 0);
  }
  void add_matchId(uint32_t matchId) {
    fbb_.AddElement<uint32_t>(PushQuickMatchingJoinResponse::VT_MATCHID, matchId, 0);
  }
  explicit PushQuickMatchingJoinResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PushQuickMatchingJoinResponseBuilder &operator=(const PushQuickMatchingJoinResponseBuilder &);
  flatbuffers::Offset<PushQuickMatchingJoinResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PushQuickMatchingJoinResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<PushQuickMatchingJoinResponse> CreatePushQuickMatchingJoinResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode err = ErrorCode_NONE,
    int64_t pushId = 0,
    uint32_t matchId = 0) {
  PushQuickMatchingJoinResponseBuilder builder_(_fbb);
  builder_.add_pushId(pushId);
  builder_.add_matchId(matchId);
  builder_.add_err(err);
  return builder_.Finish();
}

/// PUSH_QUICK_MATCHING_LEAVE_REQUEST
struct PushQuickMatchingLeaveRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PUSHID = 4,
    VT_MATCHID = 6
  };
  int64_t pushId() const {
    return GetField<int64_t>(VT_PUSHID, 0);
  }
  uint32_t matchId() const {
    return GetField<uint32_t>(VT_MATCHID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PUSHID) &&
           VerifyField<uint32_t>(verifier, VT_MATCHID) &&
           verifier.EndTable();
  }
};

struct PushQuickMatchingLeaveRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pushId(int64_t pushId) {
    fbb_.AddElement<int64_t>(PushQuickMatchingLeaveRequest::VT_PUSHID, pushId, 0);
  }
  void add_matchId(uint32_t matchId) {
    fbb_.AddElement<uint32_t>(PushQuickMatchingLeaveRequest::VT_MATCHID, matchId, 0);
  }
  explicit PushQuickMatchingLeaveRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PushQuickMatchingLeaveRequestBuilder &operator=(const PushQuickMatchingLeaveRequestBuilder &);
  flatbuffers::Offset<PushQuickMatchingLeaveRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PushQuickMatchingLeaveRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<PushQuickMatchingLeaveRequest> CreatePushQuickMatchingLeaveRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pushId = 0,
    uint32_t matchId = 0) {
  PushQuickMatchingLeaveRequestBuilder builder_(_fbb);
  builder_.add_pushId(pushId);
  builder_.add_matchId(matchId);
  return builder_.Finish();
}

/// PUSH_MATCHING_ADDED_NOTIFY
struct PushMatchingAddedNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PUSHID = 4,
    VT_MATCHID = 6,
    VT_JOINEDCLASSES = 8,
    VT_ISGROUPMATCHING = 10
  };
  int64_t pushId() const {
    return GetField<int64_t>(VT_PUSHID, 0);
  }
  uint32_t matchId() const {
    return GetField<uint32_t>(VT_MATCHID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<JoinedClassElem>> *joinedClasses() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<JoinedClassElem>> *>(VT_JOINEDCLASSES);
  }
  bool isGroupMatching() const {
    return GetField<uint8_t>(VT_ISGROUPMATCHING, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PUSHID) &&
           VerifyField<uint32_t>(verifier, VT_MATCHID) &&
           VerifyOffset(verifier, VT_JOINEDCLASSES) &&
           verifier.VerifyVector(joinedClasses()) &&
           verifier.VerifyVectorOfTables(joinedClasses()) &&
           VerifyField<uint8_t>(verifier, VT_ISGROUPMATCHING) &&
           verifier.EndTable();
  }
};

struct PushMatchingAddedNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pushId(int64_t pushId) {
    fbb_.AddElement<int64_t>(PushMatchingAddedNotify::VT_PUSHID, pushId, 0);
  }
  void add_matchId(uint32_t matchId) {
    fbb_.AddElement<uint32_t>(PushMatchingAddedNotify::VT_MATCHID, matchId, 0);
  }
  void add_joinedClasses(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<JoinedClassElem>>> joinedClasses) {
    fbb_.AddOffset(PushMatchingAddedNotify::VT_JOINEDCLASSES, joinedClasses);
  }
  void add_isGroupMatching(bool isGroupMatching) {
    fbb_.AddElement<uint8_t>(PushMatchingAddedNotify::VT_ISGROUPMATCHING, static_cast<uint8_t>(isGroupMatching), 0);
  }
  explicit PushMatchingAddedNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PushMatchingAddedNotifyBuilder &operator=(const PushMatchingAddedNotifyBuilder &);
  flatbuffers::Offset<PushMatchingAddedNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PushMatchingAddedNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<PushMatchingAddedNotify> CreatePushMatchingAddedNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pushId = 0,
    uint32_t matchId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<JoinedClassElem>>> joinedClasses = 0,
    bool isGroupMatching = false) {
  PushMatchingAddedNotifyBuilder builder_(_fbb);
  builder_.add_pushId(pushId);
  builder_.add_joinedClasses(joinedClasses);
  builder_.add_matchId(matchId);
  builder_.add_isGroupMatching(isGroupMatching);
  return builder_.Finish();
}

inline flatbuffers::Offset<PushMatchingAddedNotify> CreatePushMatchingAddedNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pushId = 0,
    uint32_t matchId = 0,
    const std::vector<flatbuffers::Offset<JoinedClassElem>> *joinedClasses = nullptr,
    bool isGroupMatching = false) {
  return LeanPacket::CreatePushMatchingAddedNotify(
      _fbb,
      pushId,
      matchId,
      joinedClasses ? _fbb.CreateVector<flatbuffers::Offset<JoinedClassElem>>(*joinedClasses) : 0,
      isGroupMatching);
}

/// PUSH_MATCHING_REMOVED_NOTIFY
struct PushMatchingRemovedNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PUSHID = 4,
    VT_MATCHID = 6,
    VT_ISGROUPMATCHING = 8
  };
  int64_t pushId() const {
    return GetField<int64_t>(VT_PUSHID, 0);
  }
  uint32_t matchId() const {
    return GetField<uint32_t>(VT_MATCHID, 0);
  }
  bool isGroupMatching() const {
    return GetField<uint8_t>(VT_ISGROUPMATCHING, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PUSHID) &&
           VerifyField<uint32_t>(verifier, VT_MATCHID) &&
           VerifyField<uint8_t>(verifier, VT_ISGROUPMATCHING) &&
           verifier.EndTable();
  }
};

struct PushMatchingRemovedNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pushId(int64_t pushId) {
    fbb_.AddElement<int64_t>(PushMatchingRemovedNotify::VT_PUSHID, pushId, 0);
  }
  void add_matchId(uint32_t matchId) {
    fbb_.AddElement<uint32_t>(PushMatchingRemovedNotify::VT_MATCHID, matchId, 0);
  }
  void add_isGroupMatching(bool isGroupMatching) {
    fbb_.AddElement<uint8_t>(PushMatchingRemovedNotify::VT_ISGROUPMATCHING, static_cast<uint8_t>(isGroupMatching), 0);
  }
  explicit PushMatchingRemovedNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PushMatchingRemovedNotifyBuilder &operator=(const PushMatchingRemovedNotifyBuilder &);
  flatbuffers::Offset<PushMatchingRemovedNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PushMatchingRemovedNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<PushMatchingRemovedNotify> CreatePushMatchingRemovedNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pushId = 0,
    uint32_t matchId = 0,
    bool isGroupMatching = false) {
  PushMatchingRemovedNotifyBuilder builder_(_fbb);
  builder_.add_pushId(pushId);
  builder_.add_matchId(matchId);
  builder_.add_isGroupMatching(isGroupMatching);
  return builder_.Finish();
}

struct JoinedClassElem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CLASSTYPE = 4,
    VT_COUNT = 6
  };
  int16_t classType() const {
    return GetField<int16_t>(VT_CLASSTYPE, 0);
  }
  int16_t count() const {
    return GetField<int16_t>(VT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_CLASSTYPE) &&
           VerifyField<int16_t>(verifier, VT_COUNT) &&
           verifier.EndTable();
  }
};

struct JoinedClassElemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_classType(int16_t classType) {
    fbb_.AddElement<int16_t>(JoinedClassElem::VT_CLASSTYPE, classType, 0);
  }
  void add_count(int16_t count) {
    fbb_.AddElement<int16_t>(JoinedClassElem::VT_COUNT, count, 0);
  }
  explicit JoinedClassElemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  JoinedClassElemBuilder &operator=(const JoinedClassElemBuilder &);
  flatbuffers::Offset<JoinedClassElem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<JoinedClassElem>(end);
    return o;
  }
};

inline flatbuffers::Offset<JoinedClassElem> CreateJoinedClassElem(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t classType = 0,
    int16_t count = 0) {
  JoinedClassElemBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_classType(classType);
  return builder_.Finish();
}

/// PUSH_MATCHING_JOINED_PC_CLASS_UPDATE
struct PushMatchingJoinedPcClassUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PUSHID = 4,
    VT_MATCHID = 6,
    VT_JOINEDCLASSES = 8
  };
  int64_t pushId() const {
    return GetField<int64_t>(VT_PUSHID, 0);
  }
  uint32_t matchId() const {
    return GetField<uint32_t>(VT_MATCHID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<JoinedClassElem>> *joinedClasses() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<JoinedClassElem>> *>(VT_JOINEDCLASSES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PUSHID) &&
           VerifyField<uint32_t>(verifier, VT_MATCHID) &&
           VerifyOffset(verifier, VT_JOINEDCLASSES) &&
           verifier.VerifyVector(joinedClasses()) &&
           verifier.VerifyVectorOfTables(joinedClasses()) &&
           verifier.EndTable();
  }
};

struct PushMatchingJoinedPcClassUpdateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pushId(int64_t pushId) {
    fbb_.AddElement<int64_t>(PushMatchingJoinedPcClassUpdate::VT_PUSHID, pushId, 0);
  }
  void add_matchId(uint32_t matchId) {
    fbb_.AddElement<uint32_t>(PushMatchingJoinedPcClassUpdate::VT_MATCHID, matchId, 0);
  }
  void add_joinedClasses(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<JoinedClassElem>>> joinedClasses) {
    fbb_.AddOffset(PushMatchingJoinedPcClassUpdate::VT_JOINEDCLASSES, joinedClasses);
  }
  explicit PushMatchingJoinedPcClassUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PushMatchingJoinedPcClassUpdateBuilder &operator=(const PushMatchingJoinedPcClassUpdateBuilder &);
  flatbuffers::Offset<PushMatchingJoinedPcClassUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PushMatchingJoinedPcClassUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<PushMatchingJoinedPcClassUpdate> CreatePushMatchingJoinedPcClassUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pushId = 0,
    uint32_t matchId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<JoinedClassElem>>> joinedClasses = 0) {
  PushMatchingJoinedPcClassUpdateBuilder builder_(_fbb);
  builder_.add_pushId(pushId);
  builder_.add_joinedClasses(joinedClasses);
  builder_.add_matchId(matchId);
  return builder_.Finish();
}

inline flatbuffers::Offset<PushMatchingJoinedPcClassUpdate> CreatePushMatchingJoinedPcClassUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pushId = 0,
    uint32_t matchId = 0,
    const std::vector<flatbuffers::Offset<JoinedClassElem>> *joinedClasses = nullptr) {
  return LeanPacket::CreatePushMatchingJoinedPcClassUpdate(
      _fbb,
      pushId,
      matchId,
      joinedClasses ? _fbb.CreateVector<flatbuffers::Offset<JoinedClassElem>>(*joinedClasses) : 0);
}

/// PUSH_MATCHED_SUCCESS_NOTIFY
struct PushMatchedSuccessNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PUSHID = 4,
    VT_MATCHID = 6,
    VT_REMAINTICK = 8,
    VT_JOINEDPCS = 10
  };
  int64_t pushId() const {
    return GetField<int64_t>(VT_PUSHID, 0);
  }
  uint32_t matchId() const {
    return GetField<uint32_t>(VT_MATCHID, 0);
  }
  int32_t remainTick() const {
    return GetField<int32_t>(VT_REMAINTICK, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<JoinedClassElem>> *joinedPcs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<JoinedClassElem>> *>(VT_JOINEDPCS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PUSHID) &&
           VerifyField<uint32_t>(verifier, VT_MATCHID) &&
           VerifyField<int32_t>(verifier, VT_REMAINTICK) &&
           VerifyOffsetRequired(verifier, VT_JOINEDPCS) &&
           verifier.VerifyVector(joinedPcs()) &&
           verifier.VerifyVectorOfTables(joinedPcs()) &&
           verifier.EndTable();
  }
};

struct PushMatchedSuccessNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pushId(int64_t pushId) {
    fbb_.AddElement<int64_t>(PushMatchedSuccessNotify::VT_PUSHID, pushId, 0);
  }
  void add_matchId(uint32_t matchId) {
    fbb_.AddElement<uint32_t>(PushMatchedSuccessNotify::VT_MATCHID, matchId, 0);
  }
  void add_remainTick(int32_t remainTick) {
    fbb_.AddElement<int32_t>(PushMatchedSuccessNotify::VT_REMAINTICK, remainTick, 0);
  }
  void add_joinedPcs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<JoinedClassElem>>> joinedPcs) {
    fbb_.AddOffset(PushMatchedSuccessNotify::VT_JOINEDPCS, joinedPcs);
  }
  explicit PushMatchedSuccessNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PushMatchedSuccessNotifyBuilder &operator=(const PushMatchedSuccessNotifyBuilder &);
  flatbuffers::Offset<PushMatchedSuccessNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PushMatchedSuccessNotify>(end);
    fbb_.Required(o, PushMatchedSuccessNotify::VT_JOINEDPCS);
    return o;
  }
};

inline flatbuffers::Offset<PushMatchedSuccessNotify> CreatePushMatchedSuccessNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pushId = 0,
    uint32_t matchId = 0,
    int32_t remainTick = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<JoinedClassElem>>> joinedPcs = 0) {
  PushMatchedSuccessNotifyBuilder builder_(_fbb);
  builder_.add_pushId(pushId);
  builder_.add_joinedPcs(joinedPcs);
  builder_.add_remainTick(remainTick);
  builder_.add_matchId(matchId);
  return builder_.Finish();
}

inline flatbuffers::Offset<PushMatchedSuccessNotify> CreatePushMatchedSuccessNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pushId = 0,
    uint32_t matchId = 0,
    int32_t remainTick = 0,
    const std::vector<flatbuffers::Offset<JoinedClassElem>> *joinedPcs = nullptr) {
  return LeanPacket::CreatePushMatchedSuccessNotify(
      _fbb,
      pushId,
      matchId,
      remainTick,
      joinedPcs ? _fbb.CreateVector<flatbuffers::Offset<JoinedClassElem>>(*joinedPcs) : 0);
}

/// PUSH_MATCHING_FAILED_NOTIFY
struct PushMatchingFailedNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERR = 4,
    VT_PUSHID = 6,
    VT_MATCHID = 8
  };
  ErrorCode err() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERR, 0));
  }
  int64_t pushId() const {
    return GetField<int64_t>(VT_PUSHID, 0);
  }
  uint32_t matchId() const {
    return GetField<uint32_t>(VT_MATCHID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERR) &&
           VerifyField<int64_t>(verifier, VT_PUSHID) &&
           VerifyField<uint32_t>(verifier, VT_MATCHID) &&
           verifier.EndTable();
  }
};

struct PushMatchingFailedNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_err(ErrorCode err) {
    fbb_.AddElement<int32_t>(PushMatchingFailedNotify::VT_ERR, static_cast<int32_t>(err), 0);
  }
  void add_pushId(int64_t pushId) {
    fbb_.AddElement<int64_t>(PushMatchingFailedNotify::VT_PUSHID, pushId, 0);
  }
  void add_matchId(uint32_t matchId) {
    fbb_.AddElement<uint32_t>(PushMatchingFailedNotify::VT_MATCHID, matchId, 0);
  }
  explicit PushMatchingFailedNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PushMatchingFailedNotifyBuilder &operator=(const PushMatchingFailedNotifyBuilder &);
  flatbuffers::Offset<PushMatchingFailedNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PushMatchingFailedNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<PushMatchingFailedNotify> CreatePushMatchingFailedNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode err = ErrorCode_NONE,
    int64_t pushId = 0,
    uint32_t matchId = 0) {
  PushMatchingFailedNotifyBuilder builder_(_fbb);
  builder_.add_pushId(pushId);
  builder_.add_matchId(matchId);
  builder_.add_err(err);
  return builder_.Finish();
}

struct PushPromotionRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PUSHID = 4
  };
  int64_t pushId() const {
    return GetField<int64_t>(VT_PUSHID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PUSHID) &&
           verifier.EndTable();
  }
};

struct PushPromotionRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pushId(int64_t pushId) {
    fbb_.AddElement<int64_t>(PushPromotionRequest::VT_PUSHID, pushId, 0);
  }
  explicit PushPromotionRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PushPromotionRequestBuilder &operator=(const PushPromotionRequestBuilder &);
  flatbuffers::Offset<PushPromotionRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PushPromotionRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<PushPromotionRequest> CreatePushPromotionRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pushId = 0) {
  PushPromotionRequestBuilder builder_(_fbb);
  builder_.add_pushId(pushId);
  return builder_.Finish();
}

struct PushPromotionResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PUSHID = 4,
    VT_ERRCODE = 6
  };
  int64_t pushId() const {
    return GetField<int64_t>(VT_PUSHID, 0);
  }
  ErrorCode errCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PUSHID) &&
           VerifyField<int32_t>(verifier, VT_ERRCODE) &&
           verifier.EndTable();
  }
};

struct PushPromotionResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pushId(int64_t pushId) {
    fbb_.AddElement<int64_t>(PushPromotionResponse::VT_PUSHID, pushId, 0);
  }
  void add_errCode(ErrorCode errCode) {
    fbb_.AddElement<int32_t>(PushPromotionResponse::VT_ERRCODE, static_cast<int32_t>(errCode), 0);
  }
  explicit PushPromotionResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PushPromotionResponseBuilder &operator=(const PushPromotionResponseBuilder &);
  flatbuffers::Offset<PushPromotionResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PushPromotionResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<PushPromotionResponse> CreatePushPromotionResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pushId = 0,
    ErrorCode errCode = ErrorCode_NONE) {
  PushPromotionResponseBuilder builder_(_fbb);
  builder_.add_pushId(pushId);
  builder_.add_errCode(errCode);
  return builder_.Finish();
}

/// GROUP_MATCHING_MAKE_REQEUST
struct GroupMatchingMakeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PUSHID = 4,
    VT_EVENTSETTYPE = 6,
    VT_CONTENTSID = 8
  };
  int64_t pushId() const {
    return GetField<int64_t>(VT_PUSHID, 0);
  }
  int32_t eventSetType() const {
    return GetField<int32_t>(VT_EVENTSETTYPE, 0);
  }
  int32_t contentsId() const {
    return GetField<int32_t>(VT_CONTENTSID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PUSHID) &&
           VerifyField<int32_t>(verifier, VT_EVENTSETTYPE) &&
           VerifyField<int32_t>(verifier, VT_CONTENTSID) &&
           verifier.EndTable();
  }
};

struct GroupMatchingMakeRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pushId(int64_t pushId) {
    fbb_.AddElement<int64_t>(GroupMatchingMakeRequest::VT_PUSHID, pushId, 0);
  }
  void add_eventSetType(int32_t eventSetType) {
    fbb_.AddElement<int32_t>(GroupMatchingMakeRequest::VT_EVENTSETTYPE, eventSetType, 0);
  }
  void add_contentsId(int32_t contentsId) {
    fbb_.AddElement<int32_t>(GroupMatchingMakeRequest::VT_CONTENTSID, contentsId, 0);
  }
  explicit GroupMatchingMakeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GroupMatchingMakeRequestBuilder &operator=(const GroupMatchingMakeRequestBuilder &);
  flatbuffers::Offset<GroupMatchingMakeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GroupMatchingMakeRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GroupMatchingMakeRequest> CreateGroupMatchingMakeRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pushId = 0,
    int32_t eventSetType = 0,
    int32_t contentsId = 0) {
  GroupMatchingMakeRequestBuilder builder_(_fbb);
  builder_.add_pushId(pushId);
  builder_.add_contentsId(contentsId);
  builder_.add_eventSetType(eventSetType);
  return builder_.Finish();
}

struct GroupMatchingInvitee FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CLASSTYPE = 4,
    VT_NAME = 6,
    VT_LEVEL = 8,
    VT_COMBATPOWER = 10
  };
  int16_t classType() const {
    return GetField<int16_t>(VT_CLASSTYPE, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int32_t combatPower() const {
    return GetField<int32_t>(VT_COMBATPOWER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_CLASSTYPE) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_COMBATPOWER) &&
           verifier.EndTable();
  }
};

struct GroupMatchingInviteeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_classType(int16_t classType) {
    fbb_.AddElement<int16_t>(GroupMatchingInvitee::VT_CLASSTYPE, classType, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(GroupMatchingInvitee::VT_NAME, name);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(GroupMatchingInvitee::VT_LEVEL, level, 0);
  }
  void add_combatPower(int32_t combatPower) {
    fbb_.AddElement<int32_t>(GroupMatchingInvitee::VT_COMBATPOWER, combatPower, 0);
  }
  explicit GroupMatchingInviteeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GroupMatchingInviteeBuilder &operator=(const GroupMatchingInviteeBuilder &);
  flatbuffers::Offset<GroupMatchingInvitee> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GroupMatchingInvitee>(end);
    return o;
  }
};

inline flatbuffers::Offset<GroupMatchingInvitee> CreateGroupMatchingInvitee(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t classType = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t level = 0,
    int32_t combatPower = 0) {
  GroupMatchingInviteeBuilder builder_(_fbb);
  builder_.add_combatPower(combatPower);
  builder_.add_level(level);
  builder_.add_name(name);
  builder_.add_classType(classType);
  return builder_.Finish();
}

inline flatbuffers::Offset<GroupMatchingInvitee> CreateGroupMatchingInviteeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t classType = 0,
    const char *name = nullptr,
    int32_t level = 0,
    int32_t combatPower = 0) {
  return LeanPacket::CreateGroupMatchingInvitee(
      _fbb,
      classType,
      name ? _fbb.CreateString(name) : 0,
      level,
      combatPower);
}

/// GROUP_MATCHING_MAKE_RESPONSE
struct GroupMatchingMakeResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERR = 4,
    VT_PUSHID = 6,
    VT_MATCHID = 8,
    VT_GUILDMEMBERLIST = 10,
    VT_BUDDYLIST = 12
  };
  ErrorCode err() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERR, 0));
  }
  int64_t pushId() const {
    return GetField<int64_t>(VT_PUSHID, 0);
  }
  uint32_t matchId() const {
    return GetField<uint32_t>(VT_MATCHID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GroupMatchingInvitee>> *guildMemberList() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GroupMatchingInvitee>> *>(VT_GUILDMEMBERLIST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GroupMatchingInvitee>> *buddyList() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GroupMatchingInvitee>> *>(VT_BUDDYLIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERR) &&
           VerifyField<int64_t>(verifier, VT_PUSHID) &&
           VerifyField<uint32_t>(verifier, VT_MATCHID) &&
           VerifyOffset(verifier, VT_GUILDMEMBERLIST) &&
           verifier.VerifyVector(guildMemberList()) &&
           verifier.VerifyVectorOfTables(guildMemberList()) &&
           VerifyOffset(verifier, VT_BUDDYLIST) &&
           verifier.VerifyVector(buddyList()) &&
           verifier.VerifyVectorOfTables(buddyList()) &&
           verifier.EndTable();
  }
};

struct GroupMatchingMakeResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_err(ErrorCode err) {
    fbb_.AddElement<int32_t>(GroupMatchingMakeResponse::VT_ERR, static_cast<int32_t>(err), 0);
  }
  void add_pushId(int64_t pushId) {
    fbb_.AddElement<int64_t>(GroupMatchingMakeResponse::VT_PUSHID, pushId, 0);
  }
  void add_matchId(uint32_t matchId) {
    fbb_.AddElement<uint32_t>(GroupMatchingMakeResponse::VT_MATCHID, matchId, 0);
  }
  void add_guildMemberList(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GroupMatchingInvitee>>> guildMemberList) {
    fbb_.AddOffset(GroupMatchingMakeResponse::VT_GUILDMEMBERLIST, guildMemberList);
  }
  void add_buddyList(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GroupMatchingInvitee>>> buddyList) {
    fbb_.AddOffset(GroupMatchingMakeResponse::VT_BUDDYLIST, buddyList);
  }
  explicit GroupMatchingMakeResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GroupMatchingMakeResponseBuilder &operator=(const GroupMatchingMakeResponseBuilder &);
  flatbuffers::Offset<GroupMatchingMakeResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GroupMatchingMakeResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GroupMatchingMakeResponse> CreateGroupMatchingMakeResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode err = ErrorCode_NONE,
    int64_t pushId = 0,
    uint32_t matchId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GroupMatchingInvitee>>> guildMemberList = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GroupMatchingInvitee>>> buddyList = 0) {
  GroupMatchingMakeResponseBuilder builder_(_fbb);
  builder_.add_pushId(pushId);
  builder_.add_buddyList(buddyList);
  builder_.add_guildMemberList(guildMemberList);
  builder_.add_matchId(matchId);
  builder_.add_err(err);
  return builder_.Finish();
}

inline flatbuffers::Offset<GroupMatchingMakeResponse> CreateGroupMatchingMakeResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode err = ErrorCode_NONE,
    int64_t pushId = 0,
    uint32_t matchId = 0,
    const std::vector<flatbuffers::Offset<GroupMatchingInvitee>> *guildMemberList = nullptr,
    const std::vector<flatbuffers::Offset<GroupMatchingInvitee>> *buddyList = nullptr) {
  return LeanPacket::CreateGroupMatchingMakeResponse(
      _fbb,
      err,
      pushId,
      matchId,
      guildMemberList ? _fbb.CreateVector<flatbuffers::Offset<GroupMatchingInvitee>>(*guildMemberList) : 0,
      buddyList ? _fbb.CreateVector<flatbuffers::Offset<GroupMatchingInvitee>>(*buddyList) : 0);
}

/// GROUP_MATCHING_LEAVE_REQUEST
struct GroupMatchingLeaveRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PUSHID = 4,
    VT_MATCHID = 6
  };
  int64_t pushId() const {
    return GetField<int64_t>(VT_PUSHID, 0);
  }
  uint32_t matchId() const {
    return GetField<uint32_t>(VT_MATCHID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PUSHID) &&
           VerifyField<uint32_t>(verifier, VT_MATCHID) &&
           verifier.EndTable();
  }
};

struct GroupMatchingLeaveRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pushId(int64_t pushId) {
    fbb_.AddElement<int64_t>(GroupMatchingLeaveRequest::VT_PUSHID, pushId, 0);
  }
  void add_matchId(uint32_t matchId) {
    fbb_.AddElement<uint32_t>(GroupMatchingLeaveRequest::VT_MATCHID, matchId, 0);
  }
  explicit GroupMatchingLeaveRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GroupMatchingLeaveRequestBuilder &operator=(const GroupMatchingLeaveRequestBuilder &);
  flatbuffers::Offset<GroupMatchingLeaveRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GroupMatchingLeaveRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GroupMatchingLeaveRequest> CreateGroupMatchingLeaveRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pushId = 0,
    uint32_t matchId = 0) {
  GroupMatchingLeaveRequestBuilder builder_(_fbb);
  builder_.add_pushId(pushId);
  builder_.add_matchId(matchId);
  return builder_.Finish();
}

/// GROUP_MATCHING_GUILD_MEMBER_LIST_REQUEST
struct GroupMatchingGuildMemberListRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GroupMatchingGuildMemberListRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GroupMatchingGuildMemberListRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GroupMatchingGuildMemberListRequestBuilder &operator=(const GroupMatchingGuildMemberListRequestBuilder &);
  flatbuffers::Offset<GroupMatchingGuildMemberListRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GroupMatchingGuildMemberListRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GroupMatchingGuildMemberListRequest> CreateGroupMatchingGuildMemberListRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GroupMatchingGuildMemberListRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// GROUP_MATCHING_GUILD_MEMBER_LIST_RESPONSE
struct GroupMatchingGuildMemberListResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GUILDMEMBERLIST = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<GroupMatchingInvitee>> *guildMemberList() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GroupMatchingInvitee>> *>(VT_GUILDMEMBERLIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GUILDMEMBERLIST) &&
           verifier.VerifyVector(guildMemberList()) &&
           verifier.VerifyVectorOfTables(guildMemberList()) &&
           verifier.EndTable();
  }
};

struct GroupMatchingGuildMemberListResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_guildMemberList(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GroupMatchingInvitee>>> guildMemberList) {
    fbb_.AddOffset(GroupMatchingGuildMemberListResponse::VT_GUILDMEMBERLIST, guildMemberList);
  }
  explicit GroupMatchingGuildMemberListResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GroupMatchingGuildMemberListResponseBuilder &operator=(const GroupMatchingGuildMemberListResponseBuilder &);
  flatbuffers::Offset<GroupMatchingGuildMemberListResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GroupMatchingGuildMemberListResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GroupMatchingGuildMemberListResponse> CreateGroupMatchingGuildMemberListResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GroupMatchingInvitee>>> guildMemberList = 0) {
  GroupMatchingGuildMemberListResponseBuilder builder_(_fbb);
  builder_.add_guildMemberList(guildMemberList);
  return builder_.Finish();
}

inline flatbuffers::Offset<GroupMatchingGuildMemberListResponse> CreateGroupMatchingGuildMemberListResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<GroupMatchingInvitee>> *guildMemberList = nullptr) {
  return LeanPacket::CreateGroupMatchingGuildMemberListResponse(
      _fbb,
      guildMemberList ? _fbb.CreateVector<flatbuffers::Offset<GroupMatchingInvitee>>(*guildMemberList) : 0);
}

/// GROUP_MATCHING_BUDDY_LIST_REQUEST
struct GroupMatchingBuddyListRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GroupMatchingBuddyListRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GroupMatchingBuddyListRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GroupMatchingBuddyListRequestBuilder &operator=(const GroupMatchingBuddyListRequestBuilder &);
  flatbuffers::Offset<GroupMatchingBuddyListRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GroupMatchingBuddyListRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GroupMatchingBuddyListRequest> CreateGroupMatchingBuddyListRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GroupMatchingBuddyListRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// GROUP_MATCHING_BUDDY_LIST_RESPONSE
struct GroupMatchingBuddyListResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BUDDYLIST = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<GroupMatchingInvitee>> *buddyList() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GroupMatchingInvitee>> *>(VT_BUDDYLIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BUDDYLIST) &&
           verifier.VerifyVector(buddyList()) &&
           verifier.VerifyVectorOfTables(buddyList()) &&
           verifier.EndTable();
  }
};

struct GroupMatchingBuddyListResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_buddyList(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GroupMatchingInvitee>>> buddyList) {
    fbb_.AddOffset(GroupMatchingBuddyListResponse::VT_BUDDYLIST, buddyList);
  }
  explicit GroupMatchingBuddyListResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GroupMatchingBuddyListResponseBuilder &operator=(const GroupMatchingBuddyListResponseBuilder &);
  flatbuffers::Offset<GroupMatchingBuddyListResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GroupMatchingBuddyListResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GroupMatchingBuddyListResponse> CreateGroupMatchingBuddyListResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GroupMatchingInvitee>>> buddyList = 0) {
  GroupMatchingBuddyListResponseBuilder builder_(_fbb);
  builder_.add_buddyList(buddyList);
  return builder_.Finish();
}

inline flatbuffers::Offset<GroupMatchingBuddyListResponse> CreateGroupMatchingBuddyListResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<GroupMatchingInvitee>> *buddyList = nullptr) {
  return LeanPacket::CreateGroupMatchingBuddyListResponse(
      _fbb,
      buddyList ? _fbb.CreateVector<flatbuffers::Offset<GroupMatchingInvitee>>(*buddyList) : 0);
}

/// GROUP_MATCHING_INVITE_REQUEST
struct GroupMatchingInviteRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PUSHID = 4,
    VT_MATCHID = 6,
    VT_INVITETYPE = 8,
    VT_INVITEENAME = 10
  };
  int64_t pushId() const {
    return GetField<int64_t>(VT_PUSHID, 0);
  }
  uint32_t matchId() const {
    return GetField<uint32_t>(VT_MATCHID, 0);
  }
  GroupMatchingInviteType inviteType() const {
    return static_cast<GroupMatchingInviteType>(GetField<int16_t>(VT_INVITETYPE, 0));
  }
  const flatbuffers::String *inviteeName() const {
    return GetPointer<const flatbuffers::String *>(VT_INVITEENAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PUSHID) &&
           VerifyField<uint32_t>(verifier, VT_MATCHID) &&
           VerifyField<int16_t>(verifier, VT_INVITETYPE) &&
           VerifyOffset(verifier, VT_INVITEENAME) &&
           verifier.VerifyString(inviteeName()) &&
           verifier.EndTable();
  }
};

struct GroupMatchingInviteRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pushId(int64_t pushId) {
    fbb_.AddElement<int64_t>(GroupMatchingInviteRequest::VT_PUSHID, pushId, 0);
  }
  void add_matchId(uint32_t matchId) {
    fbb_.AddElement<uint32_t>(GroupMatchingInviteRequest::VT_MATCHID, matchId, 0);
  }
  void add_inviteType(GroupMatchingInviteType inviteType) {
    fbb_.AddElement<int16_t>(GroupMatchingInviteRequest::VT_INVITETYPE, static_cast<int16_t>(inviteType), 0);
  }
  void add_inviteeName(flatbuffers::Offset<flatbuffers::String> inviteeName) {
    fbb_.AddOffset(GroupMatchingInviteRequest::VT_INVITEENAME, inviteeName);
  }
  explicit GroupMatchingInviteRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GroupMatchingInviteRequestBuilder &operator=(const GroupMatchingInviteRequestBuilder &);
  flatbuffers::Offset<GroupMatchingInviteRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GroupMatchingInviteRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GroupMatchingInviteRequest> CreateGroupMatchingInviteRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pushId = 0,
    uint32_t matchId = 0,
    GroupMatchingInviteType inviteType = GroupMatchingInviteType_GROUP_MATCHING_TYPE_NONE,
    flatbuffers::Offset<flatbuffers::String> inviteeName = 0) {
  GroupMatchingInviteRequestBuilder builder_(_fbb);
  builder_.add_pushId(pushId);
  builder_.add_inviteeName(inviteeName);
  builder_.add_matchId(matchId);
  builder_.add_inviteType(inviteType);
  return builder_.Finish();
}

inline flatbuffers::Offset<GroupMatchingInviteRequest> CreateGroupMatchingInviteRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pushId = 0,
    uint32_t matchId = 0,
    GroupMatchingInviteType inviteType = GroupMatchingInviteType_GROUP_MATCHING_TYPE_NONE,
    const char *inviteeName = nullptr) {
  return LeanPacket::CreateGroupMatchingInviteRequest(
      _fbb,
      pushId,
      matchId,
      inviteType,
      inviteeName ? _fbb.CreateString(inviteeName) : 0);
}

/// GROUP_MATCHING_INVITE_RESPONSE
struct GroupMatchingInviteResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERR = 4,
    VT_PUSHID = 6,
    VT_MATCHID = 8,
    VT_INVITETYPE = 10,
    VT_INVITEENAME = 12
  };
  ErrorCode err() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERR, 0));
  }
  int64_t pushId() const {
    return GetField<int64_t>(VT_PUSHID, 0);
  }
  uint32_t matchId() const {
    return GetField<uint32_t>(VT_MATCHID, 0);
  }
  GroupMatchingInviteType inviteType() const {
    return static_cast<GroupMatchingInviteType>(GetField<int16_t>(VT_INVITETYPE, 0));
  }
  const flatbuffers::String *inviteeName() const {
    return GetPointer<const flatbuffers::String *>(VT_INVITEENAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERR) &&
           VerifyField<int64_t>(verifier, VT_PUSHID) &&
           VerifyField<uint32_t>(verifier, VT_MATCHID) &&
           VerifyField<int16_t>(verifier, VT_INVITETYPE) &&
           VerifyOffset(verifier, VT_INVITEENAME) &&
           verifier.VerifyString(inviteeName()) &&
           verifier.EndTable();
  }
};

struct GroupMatchingInviteResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_err(ErrorCode err) {
    fbb_.AddElement<int32_t>(GroupMatchingInviteResponse::VT_ERR, static_cast<int32_t>(err), 0);
  }
  void add_pushId(int64_t pushId) {
    fbb_.AddElement<int64_t>(GroupMatchingInviteResponse::VT_PUSHID, pushId, 0);
  }
  void add_matchId(uint32_t matchId) {
    fbb_.AddElement<uint32_t>(GroupMatchingInviteResponse::VT_MATCHID, matchId, 0);
  }
  void add_inviteType(GroupMatchingInviteType inviteType) {
    fbb_.AddElement<int16_t>(GroupMatchingInviteResponse::VT_INVITETYPE, static_cast<int16_t>(inviteType), 0);
  }
  void add_inviteeName(flatbuffers::Offset<flatbuffers::String> inviteeName) {
    fbb_.AddOffset(GroupMatchingInviteResponse::VT_INVITEENAME, inviteeName);
  }
  explicit GroupMatchingInviteResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GroupMatchingInviteResponseBuilder &operator=(const GroupMatchingInviteResponseBuilder &);
  flatbuffers::Offset<GroupMatchingInviteResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GroupMatchingInviteResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GroupMatchingInviteResponse> CreateGroupMatchingInviteResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode err = ErrorCode_NONE,
    int64_t pushId = 0,
    uint32_t matchId = 0,
    GroupMatchingInviteType inviteType = GroupMatchingInviteType_GROUP_MATCHING_TYPE_NONE,
    flatbuffers::Offset<flatbuffers::String> inviteeName = 0) {
  GroupMatchingInviteResponseBuilder builder_(_fbb);
  builder_.add_pushId(pushId);
  builder_.add_inviteeName(inviteeName);
  builder_.add_matchId(matchId);
  builder_.add_err(err);
  builder_.add_inviteType(inviteType);
  return builder_.Finish();
}

inline flatbuffers::Offset<GroupMatchingInviteResponse> CreateGroupMatchingInviteResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode err = ErrorCode_NONE,
    int64_t pushId = 0,
    uint32_t matchId = 0,
    GroupMatchingInviteType inviteType = GroupMatchingInviteType_GROUP_MATCHING_TYPE_NONE,
    const char *inviteeName = nullptr) {
  return LeanPacket::CreateGroupMatchingInviteResponse(
      _fbb,
      err,
      pushId,
      matchId,
      inviteType,
      inviteeName ? _fbb.CreateString(inviteeName) : 0);
}

/// GROUP_MATCHING_MEMBER_LEAVE_NOTIFY
struct GroupMatchingMemberLeaveNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INVITEENAME = 4,
    VT_PUSHID = 6,
    VT_MATCHID = 8
  };
  const flatbuffers::String *inviteeName() const {
    return GetPointer<const flatbuffers::String *>(VT_INVITEENAME);
  }
  int64_t pushId() const {
    return GetField<int64_t>(VT_PUSHID, 0);
  }
  uint32_t matchId() const {
    return GetField<uint32_t>(VT_MATCHID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INVITEENAME) &&
           verifier.VerifyString(inviteeName()) &&
           VerifyField<int64_t>(verifier, VT_PUSHID) &&
           VerifyField<uint32_t>(verifier, VT_MATCHID) &&
           verifier.EndTable();
  }
};

struct GroupMatchingMemberLeaveNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_inviteeName(flatbuffers::Offset<flatbuffers::String> inviteeName) {
    fbb_.AddOffset(GroupMatchingMemberLeaveNotify::VT_INVITEENAME, inviteeName);
  }
  void add_pushId(int64_t pushId) {
    fbb_.AddElement<int64_t>(GroupMatchingMemberLeaveNotify::VT_PUSHID, pushId, 0);
  }
  void add_matchId(uint32_t matchId) {
    fbb_.AddElement<uint32_t>(GroupMatchingMemberLeaveNotify::VT_MATCHID, matchId, 0);
  }
  explicit GroupMatchingMemberLeaveNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GroupMatchingMemberLeaveNotifyBuilder &operator=(const GroupMatchingMemberLeaveNotifyBuilder &);
  flatbuffers::Offset<GroupMatchingMemberLeaveNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GroupMatchingMemberLeaveNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<GroupMatchingMemberLeaveNotify> CreateGroupMatchingMemberLeaveNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> inviteeName = 0,
    int64_t pushId = 0,
    uint32_t matchId = 0) {
  GroupMatchingMemberLeaveNotifyBuilder builder_(_fbb);
  builder_.add_pushId(pushId);
  builder_.add_matchId(matchId);
  builder_.add_inviteeName(inviteeName);
  return builder_.Finish();
}

inline flatbuffers::Offset<GroupMatchingMemberLeaveNotify> CreateGroupMatchingMemberLeaveNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *inviteeName = nullptr,
    int64_t pushId = 0,
    uint32_t matchId = 0) {
  return LeanPacket::CreateGroupMatchingMemberLeaveNotify(
      _fbb,
      inviteeName ? _fbb.CreateString(inviteeName) : 0,
      pushId,
      matchId);
}

/// GROUP_MATCHING_INVITATION_ADD_NOTIFY
struct GroupMatchingInvitationAddNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INVITETYPE = 4,
    VT_INVITERPCNAME = 6,
    VT_INVITERPCLEVEL = 8,
    VT_INVITERPCCLASSTYPE = 10,
    VT_PUSHID = 12,
    VT_MATCHID = 14,
    VT_REMAINSEC = 16
  };
  GroupMatchingInviteType inviteType() const {
    return static_cast<GroupMatchingInviteType>(GetField<int16_t>(VT_INVITETYPE, 0));
  }
  const flatbuffers::String *inviterPcName() const {
    return GetPointer<const flatbuffers::String *>(VT_INVITERPCNAME);
  }
  int32_t inviterPcLevel() const {
    return GetField<int32_t>(VT_INVITERPCLEVEL, 0);
  }
  int32_t inviterPcClassType() const {
    return GetField<int32_t>(VT_INVITERPCCLASSTYPE, 0);
  }
  int64_t pushId() const {
    return GetField<int64_t>(VT_PUSHID, 0);
  }
  uint32_t matchId() const {
    return GetField<uint32_t>(VT_MATCHID, 0);
  }
  int16_t remainSec() const {
    return GetField<int16_t>(VT_REMAINSEC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_INVITETYPE) &&
           VerifyOffset(verifier, VT_INVITERPCNAME) &&
           verifier.VerifyString(inviterPcName()) &&
           VerifyField<int32_t>(verifier, VT_INVITERPCLEVEL) &&
           VerifyField<int32_t>(verifier, VT_INVITERPCCLASSTYPE) &&
           VerifyField<int64_t>(verifier, VT_PUSHID) &&
           VerifyField<uint32_t>(verifier, VT_MATCHID) &&
           VerifyField<int16_t>(verifier, VT_REMAINSEC) &&
           verifier.EndTable();
  }
};

struct GroupMatchingInvitationAddNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_inviteType(GroupMatchingInviteType inviteType) {
    fbb_.AddElement<int16_t>(GroupMatchingInvitationAddNotify::VT_INVITETYPE, static_cast<int16_t>(inviteType), 0);
  }
  void add_inviterPcName(flatbuffers::Offset<flatbuffers::String> inviterPcName) {
    fbb_.AddOffset(GroupMatchingInvitationAddNotify::VT_INVITERPCNAME, inviterPcName);
  }
  void add_inviterPcLevel(int32_t inviterPcLevel) {
    fbb_.AddElement<int32_t>(GroupMatchingInvitationAddNotify::VT_INVITERPCLEVEL, inviterPcLevel, 0);
  }
  void add_inviterPcClassType(int32_t inviterPcClassType) {
    fbb_.AddElement<int32_t>(GroupMatchingInvitationAddNotify::VT_INVITERPCCLASSTYPE, inviterPcClassType, 0);
  }
  void add_pushId(int64_t pushId) {
    fbb_.AddElement<int64_t>(GroupMatchingInvitationAddNotify::VT_PUSHID, pushId, 0);
  }
  void add_matchId(uint32_t matchId) {
    fbb_.AddElement<uint32_t>(GroupMatchingInvitationAddNotify::VT_MATCHID, matchId, 0);
  }
  void add_remainSec(int16_t remainSec) {
    fbb_.AddElement<int16_t>(GroupMatchingInvitationAddNotify::VT_REMAINSEC, remainSec, 0);
  }
  explicit GroupMatchingInvitationAddNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GroupMatchingInvitationAddNotifyBuilder &operator=(const GroupMatchingInvitationAddNotifyBuilder &);
  flatbuffers::Offset<GroupMatchingInvitationAddNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GroupMatchingInvitationAddNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<GroupMatchingInvitationAddNotify> CreateGroupMatchingInvitationAddNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    GroupMatchingInviteType inviteType = GroupMatchingInviteType_GROUP_MATCHING_TYPE_NONE,
    flatbuffers::Offset<flatbuffers::String> inviterPcName = 0,
    int32_t inviterPcLevel = 0,
    int32_t inviterPcClassType = 0,
    int64_t pushId = 0,
    uint32_t matchId = 0,
    int16_t remainSec = 0) {
  GroupMatchingInvitationAddNotifyBuilder builder_(_fbb);
  builder_.add_pushId(pushId);
  builder_.add_matchId(matchId);
  builder_.add_inviterPcClassType(inviterPcClassType);
  builder_.add_inviterPcLevel(inviterPcLevel);
  builder_.add_inviterPcName(inviterPcName);
  builder_.add_remainSec(remainSec);
  builder_.add_inviteType(inviteType);
  return builder_.Finish();
}

inline flatbuffers::Offset<GroupMatchingInvitationAddNotify> CreateGroupMatchingInvitationAddNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    GroupMatchingInviteType inviteType = GroupMatchingInviteType_GROUP_MATCHING_TYPE_NONE,
    const char *inviterPcName = nullptr,
    int32_t inviterPcLevel = 0,
    int32_t inviterPcClassType = 0,
    int64_t pushId = 0,
    uint32_t matchId = 0,
    int16_t remainSec = 0) {
  return LeanPacket::CreateGroupMatchingInvitationAddNotify(
      _fbb,
      inviteType,
      inviterPcName ? _fbb.CreateString(inviterPcName) : 0,
      inviterPcLevel,
      inviterPcClassType,
      pushId,
      matchId,
      remainSec);
}

/// GROUP_MATCHING_INVITATION_REMOVE_NOTIFY
struct GroupMatchingInvitationRemoveNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INVITETYPE = 4,
    VT_INVITERNAME = 6,
    VT_PUSHID = 8,
    VT_MATCHID = 10
  };
  GroupMatchingInviteType inviteType() const {
    return static_cast<GroupMatchingInviteType>(GetField<int16_t>(VT_INVITETYPE, 0));
  }
  const flatbuffers::String *inviterName() const {
    return GetPointer<const flatbuffers::String *>(VT_INVITERNAME);
  }
  int64_t pushId() const {
    return GetField<int64_t>(VT_PUSHID, 0);
  }
  uint32_t matchId() const {
    return GetField<uint32_t>(VT_MATCHID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_INVITETYPE) &&
           VerifyOffset(verifier, VT_INVITERNAME) &&
           verifier.VerifyString(inviterName()) &&
           VerifyField<int64_t>(verifier, VT_PUSHID) &&
           VerifyField<uint32_t>(verifier, VT_MATCHID) &&
           verifier.EndTable();
  }
};

struct GroupMatchingInvitationRemoveNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_inviteType(GroupMatchingInviteType inviteType) {
    fbb_.AddElement<int16_t>(GroupMatchingInvitationRemoveNotify::VT_INVITETYPE, static_cast<int16_t>(inviteType), 0);
  }
  void add_inviterName(flatbuffers::Offset<flatbuffers::String> inviterName) {
    fbb_.AddOffset(GroupMatchingInvitationRemoveNotify::VT_INVITERNAME, inviterName);
  }
  void add_pushId(int64_t pushId) {
    fbb_.AddElement<int64_t>(GroupMatchingInvitationRemoveNotify::VT_PUSHID, pushId, 0);
  }
  void add_matchId(uint32_t matchId) {
    fbb_.AddElement<uint32_t>(GroupMatchingInvitationRemoveNotify::VT_MATCHID, matchId, 0);
  }
  explicit GroupMatchingInvitationRemoveNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GroupMatchingInvitationRemoveNotifyBuilder &operator=(const GroupMatchingInvitationRemoveNotifyBuilder &);
  flatbuffers::Offset<GroupMatchingInvitationRemoveNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GroupMatchingInvitationRemoveNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<GroupMatchingInvitationRemoveNotify> CreateGroupMatchingInvitationRemoveNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    GroupMatchingInviteType inviteType = GroupMatchingInviteType_GROUP_MATCHING_TYPE_NONE,
    flatbuffers::Offset<flatbuffers::String> inviterName = 0,
    int64_t pushId = 0,
    uint32_t matchId = 0) {
  GroupMatchingInvitationRemoveNotifyBuilder builder_(_fbb);
  builder_.add_pushId(pushId);
  builder_.add_matchId(matchId);
  builder_.add_inviterName(inviterName);
  builder_.add_inviteType(inviteType);
  return builder_.Finish();
}

inline flatbuffers::Offset<GroupMatchingInvitationRemoveNotify> CreateGroupMatchingInvitationRemoveNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    GroupMatchingInviteType inviteType = GroupMatchingInviteType_GROUP_MATCHING_TYPE_NONE,
    const char *inviterName = nullptr,
    int64_t pushId = 0,
    uint32_t matchId = 0) {
  return LeanPacket::CreateGroupMatchingInvitationRemoveNotify(
      _fbb,
      inviteType,
      inviterName ? _fbb.CreateString(inviterName) : 0,
      pushId,
      matchId);
}

/// GROUP_MATCHING_INVITATION_ACCEPTED_NOTIFY
struct GroupMatchingInvitationAcceptedNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INVITETYPE = 4,
    VT_INVITEENAME = 6,
    VT_PUSHID = 8,
    VT_MATCHID = 10
  };
  GroupMatchingInviteType inviteType() const {
    return static_cast<GroupMatchingInviteType>(GetField<int16_t>(VT_INVITETYPE, 0));
  }
  const flatbuffers::String *inviteeName() const {
    return GetPointer<const flatbuffers::String *>(VT_INVITEENAME);
  }
  int64_t pushId() const {
    return GetField<int64_t>(VT_PUSHID, 0);
  }
  uint32_t matchId() const {
    return GetField<uint32_t>(VT_MATCHID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_INVITETYPE) &&
           VerifyOffset(verifier, VT_INVITEENAME) &&
           verifier.VerifyString(inviteeName()) &&
           VerifyField<int64_t>(verifier, VT_PUSHID) &&
           VerifyField<uint32_t>(verifier, VT_MATCHID) &&
           verifier.EndTable();
  }
};

struct GroupMatchingInvitationAcceptedNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_inviteType(GroupMatchingInviteType inviteType) {
    fbb_.AddElement<int16_t>(GroupMatchingInvitationAcceptedNotify::VT_INVITETYPE, static_cast<int16_t>(inviteType), 0);
  }
  void add_inviteeName(flatbuffers::Offset<flatbuffers::String> inviteeName) {
    fbb_.AddOffset(GroupMatchingInvitationAcceptedNotify::VT_INVITEENAME, inviteeName);
  }
  void add_pushId(int64_t pushId) {
    fbb_.AddElement<int64_t>(GroupMatchingInvitationAcceptedNotify::VT_PUSHID, pushId, 0);
  }
  void add_matchId(uint32_t matchId) {
    fbb_.AddElement<uint32_t>(GroupMatchingInvitationAcceptedNotify::VT_MATCHID, matchId, 0);
  }
  explicit GroupMatchingInvitationAcceptedNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GroupMatchingInvitationAcceptedNotifyBuilder &operator=(const GroupMatchingInvitationAcceptedNotifyBuilder &);
  flatbuffers::Offset<GroupMatchingInvitationAcceptedNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GroupMatchingInvitationAcceptedNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<GroupMatchingInvitationAcceptedNotify> CreateGroupMatchingInvitationAcceptedNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    GroupMatchingInviteType inviteType = GroupMatchingInviteType_GROUP_MATCHING_TYPE_NONE,
    flatbuffers::Offset<flatbuffers::String> inviteeName = 0,
    int64_t pushId = 0,
    uint32_t matchId = 0) {
  GroupMatchingInvitationAcceptedNotifyBuilder builder_(_fbb);
  builder_.add_pushId(pushId);
  builder_.add_matchId(matchId);
  builder_.add_inviteeName(inviteeName);
  builder_.add_inviteType(inviteType);
  return builder_.Finish();
}

inline flatbuffers::Offset<GroupMatchingInvitationAcceptedNotify> CreateGroupMatchingInvitationAcceptedNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    GroupMatchingInviteType inviteType = GroupMatchingInviteType_GROUP_MATCHING_TYPE_NONE,
    const char *inviteeName = nullptr,
    int64_t pushId = 0,
    uint32_t matchId = 0) {
  return LeanPacket::CreateGroupMatchingInvitationAcceptedNotify(
      _fbb,
      inviteType,
      inviteeName ? _fbb.CreateString(inviteeName) : 0,
      pushId,
      matchId);
}

/// GROUP_MATCHING_INVITATION_REJECTED_NOTIFY
struct GroupMatchingInvitationRejectedNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INVITETYPE = 4,
    VT_INVITEENAME = 6,
    VT_PUSHID = 8,
    VT_MATCHID = 10
  };
  GroupMatchingInviteType inviteType() const {
    return static_cast<GroupMatchingInviteType>(GetField<int16_t>(VT_INVITETYPE, 0));
  }
  const flatbuffers::String *inviteeName() const {
    return GetPointer<const flatbuffers::String *>(VT_INVITEENAME);
  }
  int64_t pushId() const {
    return GetField<int64_t>(VT_PUSHID, 0);
  }
  uint32_t matchId() const {
    return GetField<uint32_t>(VT_MATCHID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_INVITETYPE) &&
           VerifyOffset(verifier, VT_INVITEENAME) &&
           verifier.VerifyString(inviteeName()) &&
           VerifyField<int64_t>(verifier, VT_PUSHID) &&
           VerifyField<uint32_t>(verifier, VT_MATCHID) &&
           verifier.EndTable();
  }
};

struct GroupMatchingInvitationRejectedNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_inviteType(GroupMatchingInviteType inviteType) {
    fbb_.AddElement<int16_t>(GroupMatchingInvitationRejectedNotify::VT_INVITETYPE, static_cast<int16_t>(inviteType), 0);
  }
  void add_inviteeName(flatbuffers::Offset<flatbuffers::String> inviteeName) {
    fbb_.AddOffset(GroupMatchingInvitationRejectedNotify::VT_INVITEENAME, inviteeName);
  }
  void add_pushId(int64_t pushId) {
    fbb_.AddElement<int64_t>(GroupMatchingInvitationRejectedNotify::VT_PUSHID, pushId, 0);
  }
  void add_matchId(uint32_t matchId) {
    fbb_.AddElement<uint32_t>(GroupMatchingInvitationRejectedNotify::VT_MATCHID, matchId, 0);
  }
  explicit GroupMatchingInvitationRejectedNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GroupMatchingInvitationRejectedNotifyBuilder &operator=(const GroupMatchingInvitationRejectedNotifyBuilder &);
  flatbuffers::Offset<GroupMatchingInvitationRejectedNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GroupMatchingInvitationRejectedNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<GroupMatchingInvitationRejectedNotify> CreateGroupMatchingInvitationRejectedNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    GroupMatchingInviteType inviteType = GroupMatchingInviteType_GROUP_MATCHING_TYPE_NONE,
    flatbuffers::Offset<flatbuffers::String> inviteeName = 0,
    int64_t pushId = 0,
    uint32_t matchId = 0) {
  GroupMatchingInvitationRejectedNotifyBuilder builder_(_fbb);
  builder_.add_pushId(pushId);
  builder_.add_matchId(matchId);
  builder_.add_inviteeName(inviteeName);
  builder_.add_inviteType(inviteType);
  return builder_.Finish();
}

inline flatbuffers::Offset<GroupMatchingInvitationRejectedNotify> CreateGroupMatchingInvitationRejectedNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    GroupMatchingInviteType inviteType = GroupMatchingInviteType_GROUP_MATCHING_TYPE_NONE,
    const char *inviteeName = nullptr,
    int64_t pushId = 0,
    uint32_t matchId = 0) {
  return LeanPacket::CreateGroupMatchingInvitationRejectedNotify(
      _fbb,
      inviteType,
      inviteeName ? _fbb.CreateString(inviteeName) : 0,
      pushId,
      matchId);
}

/// GROUP_MATCHING_INVITE_ACCEPT_REQUEST
struct GroupMatchingInviteAcceptRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PUSHID = 4,
    VT_MATCHID = 6,
    VT_EVENTSETTYPE = 8,
    VT_CONTENTSID = 10
  };
  int64_t pushId() const {
    return GetField<int64_t>(VT_PUSHID, 0);
  }
  uint32_t matchId() const {
    return GetField<uint32_t>(VT_MATCHID, 0);
  }
  int32_t eventSetType() const {
    return GetField<int32_t>(VT_EVENTSETTYPE, 0);
  }
  int32_t contentsId() const {
    return GetField<int32_t>(VT_CONTENTSID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PUSHID) &&
           VerifyField<uint32_t>(verifier, VT_MATCHID) &&
           VerifyField<int32_t>(verifier, VT_EVENTSETTYPE) &&
           VerifyField<int32_t>(verifier, VT_CONTENTSID) &&
           verifier.EndTable();
  }
};

struct GroupMatchingInviteAcceptRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pushId(int64_t pushId) {
    fbb_.AddElement<int64_t>(GroupMatchingInviteAcceptRequest::VT_PUSHID, pushId, 0);
  }
  void add_matchId(uint32_t matchId) {
    fbb_.AddElement<uint32_t>(GroupMatchingInviteAcceptRequest::VT_MATCHID, matchId, 0);
  }
  void add_eventSetType(int32_t eventSetType) {
    fbb_.AddElement<int32_t>(GroupMatchingInviteAcceptRequest::VT_EVENTSETTYPE, eventSetType, 0);
  }
  void add_contentsId(int32_t contentsId) {
    fbb_.AddElement<int32_t>(GroupMatchingInviteAcceptRequest::VT_CONTENTSID, contentsId, 0);
  }
  explicit GroupMatchingInviteAcceptRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GroupMatchingInviteAcceptRequestBuilder &operator=(const GroupMatchingInviteAcceptRequestBuilder &);
  flatbuffers::Offset<GroupMatchingInviteAcceptRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GroupMatchingInviteAcceptRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GroupMatchingInviteAcceptRequest> CreateGroupMatchingInviteAcceptRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pushId = 0,
    uint32_t matchId = 0,
    int32_t eventSetType = 0,
    int32_t contentsId = 0) {
  GroupMatchingInviteAcceptRequestBuilder builder_(_fbb);
  builder_.add_pushId(pushId);
  builder_.add_contentsId(contentsId);
  builder_.add_eventSetType(eventSetType);
  builder_.add_matchId(matchId);
  return builder_.Finish();
}

/// GROUP_MATCHING_INVITE_ACCEPT_RESPONSE
struct GroupMatchingInviteAcceptResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERR = 4,
    VT_PUSHID = 6,
    VT_MATCHID = 8
  };
  ErrorCode err() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERR, 0));
  }
  int64_t pushId() const {
    return GetField<int64_t>(VT_PUSHID, 0);
  }
  uint32_t matchId() const {
    return GetField<uint32_t>(VT_MATCHID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERR) &&
           VerifyField<int64_t>(verifier, VT_PUSHID) &&
           VerifyField<uint32_t>(verifier, VT_MATCHID) &&
           verifier.EndTable();
  }
};

struct GroupMatchingInviteAcceptResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_err(ErrorCode err) {
    fbb_.AddElement<int32_t>(GroupMatchingInviteAcceptResponse::VT_ERR, static_cast<int32_t>(err), 0);
  }
  void add_pushId(int64_t pushId) {
    fbb_.AddElement<int64_t>(GroupMatchingInviteAcceptResponse::VT_PUSHID, pushId, 0);
  }
  void add_matchId(uint32_t matchId) {
    fbb_.AddElement<uint32_t>(GroupMatchingInviteAcceptResponse::VT_MATCHID, matchId, 0);
  }
  explicit GroupMatchingInviteAcceptResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GroupMatchingInviteAcceptResponseBuilder &operator=(const GroupMatchingInviteAcceptResponseBuilder &);
  flatbuffers::Offset<GroupMatchingInviteAcceptResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GroupMatchingInviteAcceptResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GroupMatchingInviteAcceptResponse> CreateGroupMatchingInviteAcceptResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode err = ErrorCode_NONE,
    int64_t pushId = 0,
    uint32_t matchId = 0) {
  GroupMatchingInviteAcceptResponseBuilder builder_(_fbb);
  builder_.add_pushId(pushId);
  builder_.add_matchId(matchId);
  builder_.add_err(err);
  return builder_.Finish();
}

/// GROUP_MATCHING_INVITE_REJECT_REQUEST
struct GroupMatchingInviteRejectRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PUSHID = 4,
    VT_MATCHID = 6
  };
  int64_t pushId() const {
    return GetField<int64_t>(VT_PUSHID, 0);
  }
  uint32_t matchId() const {
    return GetField<uint32_t>(VT_MATCHID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PUSHID) &&
           VerifyField<uint32_t>(verifier, VT_MATCHID) &&
           verifier.EndTable();
  }
};

struct GroupMatchingInviteRejectRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pushId(int64_t pushId) {
    fbb_.AddElement<int64_t>(GroupMatchingInviteRejectRequest::VT_PUSHID, pushId, 0);
  }
  void add_matchId(uint32_t matchId) {
    fbb_.AddElement<uint32_t>(GroupMatchingInviteRejectRequest::VT_MATCHID, matchId, 0);
  }
  explicit GroupMatchingInviteRejectRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GroupMatchingInviteRejectRequestBuilder &operator=(const GroupMatchingInviteRejectRequestBuilder &);
  flatbuffers::Offset<GroupMatchingInviteRejectRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GroupMatchingInviteRejectRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GroupMatchingInviteRejectRequest> CreateGroupMatchingInviteRejectRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pushId = 0,
    uint32_t matchId = 0) {
  GroupMatchingInviteRejectRequestBuilder builder_(_fbb);
  builder_.add_pushId(pushId);
  builder_.add_matchId(matchId);
  return builder_.Finish();
}

/// GROUP_MATCHING_INVITE_REJECT_RESPONSE
struct GroupMatchingInviteRejectResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERR = 4,
    VT_PUSHID = 6,
    VT_MATCHID = 8
  };
  ErrorCode err() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERR, 0));
  }
  int64_t pushId() const {
    return GetField<int64_t>(VT_PUSHID, 0);
  }
  uint32_t matchId() const {
    return GetField<uint32_t>(VT_MATCHID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERR) &&
           VerifyField<int64_t>(verifier, VT_PUSHID) &&
           VerifyField<uint32_t>(verifier, VT_MATCHID) &&
           verifier.EndTable();
  }
};

struct GroupMatchingInviteRejectResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_err(ErrorCode err) {
    fbb_.AddElement<int32_t>(GroupMatchingInviteRejectResponse::VT_ERR, static_cast<int32_t>(err), 0);
  }
  void add_pushId(int64_t pushId) {
    fbb_.AddElement<int64_t>(GroupMatchingInviteRejectResponse::VT_PUSHID, pushId, 0);
  }
  void add_matchId(uint32_t matchId) {
    fbb_.AddElement<uint32_t>(GroupMatchingInviteRejectResponse::VT_MATCHID, matchId, 0);
  }
  explicit GroupMatchingInviteRejectResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GroupMatchingInviteRejectResponseBuilder &operator=(const GroupMatchingInviteRejectResponseBuilder &);
  flatbuffers::Offset<GroupMatchingInviteRejectResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GroupMatchingInviteRejectResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GroupMatchingInviteRejectResponse> CreateGroupMatchingInviteRejectResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode err = ErrorCode_NONE,
    int64_t pushId = 0,
    uint32_t matchId = 0) {
  GroupMatchingInviteRejectResponseBuilder builder_(_fbb);
  builder_.add_pushId(pushId);
  builder_.add_matchId(matchId);
  builder_.add_err(err);
  return builder_.Finish();
}

/// GROUP_MATCHING_START_REQUEST
struct GroupMatchingStartRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PUSHID = 4,
    VT_MATCHID = 6
  };
  int64_t pushId() const {
    return GetField<int64_t>(VT_PUSHID, 0);
  }
  uint32_t matchId() const {
    return GetField<uint32_t>(VT_MATCHID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PUSHID) &&
           VerifyField<uint32_t>(verifier, VT_MATCHID) &&
           verifier.EndTable();
  }
};

struct GroupMatchingStartRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pushId(int64_t pushId) {
    fbb_.AddElement<int64_t>(GroupMatchingStartRequest::VT_PUSHID, pushId, 0);
  }
  void add_matchId(uint32_t matchId) {
    fbb_.AddElement<uint32_t>(GroupMatchingStartRequest::VT_MATCHID, matchId, 0);
  }
  explicit GroupMatchingStartRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GroupMatchingStartRequestBuilder &operator=(const GroupMatchingStartRequestBuilder &);
  flatbuffers::Offset<GroupMatchingStartRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GroupMatchingStartRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GroupMatchingStartRequest> CreateGroupMatchingStartRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pushId = 0,
    uint32_t matchId = 0) {
  GroupMatchingStartRequestBuilder builder_(_fbb);
  builder_.add_pushId(pushId);
  builder_.add_matchId(matchId);
  return builder_.Finish();
}

/// GROUP_MATCHING_START_RESPONSE
struct GroupMatchingStartResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERR = 4,
    VT_PUSHID = 6,
    VT_MATCHID = 8
  };
  ErrorCode err() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERR, 0));
  }
  int64_t pushId() const {
    return GetField<int64_t>(VT_PUSHID, 0);
  }
  uint32_t matchId() const {
    return GetField<uint32_t>(VT_MATCHID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERR) &&
           VerifyField<int64_t>(verifier, VT_PUSHID) &&
           VerifyField<uint32_t>(verifier, VT_MATCHID) &&
           verifier.EndTable();
  }
};

struct GroupMatchingStartResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_err(ErrorCode err) {
    fbb_.AddElement<int32_t>(GroupMatchingStartResponse::VT_ERR, static_cast<int32_t>(err), 0);
  }
  void add_pushId(int64_t pushId) {
    fbb_.AddElement<int64_t>(GroupMatchingStartResponse::VT_PUSHID, pushId, 0);
  }
  void add_matchId(uint32_t matchId) {
    fbb_.AddElement<uint32_t>(GroupMatchingStartResponse::VT_MATCHID, matchId, 0);
  }
  explicit GroupMatchingStartResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GroupMatchingStartResponseBuilder &operator=(const GroupMatchingStartResponseBuilder &);
  flatbuffers::Offset<GroupMatchingStartResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GroupMatchingStartResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GroupMatchingStartResponse> CreateGroupMatchingStartResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode err = ErrorCode_NONE,
    int64_t pushId = 0,
    uint32_t matchId = 0) {
  GroupMatchingStartResponseBuilder builder_(_fbb);
  builder_.add_pushId(pushId);
  builder_.add_matchId(matchId);
  builder_.add_err(err);
  return builder_.Finish();
}

/// GROUP_MATCHING_CONVERT_TO_QUICK_REQUEST
struct GroupMatchingConvertToQuickRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PUSHID = 4,
    VT_MATCHID = 6
  };
  int64_t pushId() const {
    return GetField<int64_t>(VT_PUSHID, 0);
  }
  uint32_t matchId() const {
    return GetField<uint32_t>(VT_MATCHID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PUSHID) &&
           VerifyField<uint32_t>(verifier, VT_MATCHID) &&
           verifier.EndTable();
  }
};

struct GroupMatchingConvertToQuickRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pushId(int64_t pushId) {
    fbb_.AddElement<int64_t>(GroupMatchingConvertToQuickRequest::VT_PUSHID, pushId, 0);
  }
  void add_matchId(uint32_t matchId) {
    fbb_.AddElement<uint32_t>(GroupMatchingConvertToQuickRequest::VT_MATCHID, matchId, 0);
  }
  explicit GroupMatchingConvertToQuickRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GroupMatchingConvertToQuickRequestBuilder &operator=(const GroupMatchingConvertToQuickRequestBuilder &);
  flatbuffers::Offset<GroupMatchingConvertToQuickRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GroupMatchingConvertToQuickRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GroupMatchingConvertToQuickRequest> CreateGroupMatchingConvertToQuickRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pushId = 0,
    uint32_t matchId = 0) {
  GroupMatchingConvertToQuickRequestBuilder builder_(_fbb);
  builder_.add_pushId(pushId);
  builder_.add_matchId(matchId);
  return builder_.Finish();
}

/// GROUP_MATCHING_CONVERT_TO_QUICK_RESPONSE
struct GroupMatchingConvertToQuickResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERR = 4,
    VT_PUSHID = 6,
    VT_MATCHID = 8
  };
  ErrorCode err() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERR, 0));
  }
  int64_t pushId() const {
    return GetField<int64_t>(VT_PUSHID, 0);
  }
  uint32_t matchId() const {
    return GetField<uint32_t>(VT_MATCHID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERR) &&
           VerifyField<int64_t>(verifier, VT_PUSHID) &&
           VerifyField<uint32_t>(verifier, VT_MATCHID) &&
           verifier.EndTable();
  }
};

struct GroupMatchingConvertToQuickResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_err(ErrorCode err) {
    fbb_.AddElement<int32_t>(GroupMatchingConvertToQuickResponse::VT_ERR, static_cast<int32_t>(err), 0);
  }
  void add_pushId(int64_t pushId) {
    fbb_.AddElement<int64_t>(GroupMatchingConvertToQuickResponse::VT_PUSHID, pushId, 0);
  }
  void add_matchId(uint32_t matchId) {
    fbb_.AddElement<uint32_t>(GroupMatchingConvertToQuickResponse::VT_MATCHID, matchId, 0);
  }
  explicit GroupMatchingConvertToQuickResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GroupMatchingConvertToQuickResponseBuilder &operator=(const GroupMatchingConvertToQuickResponseBuilder &);
  flatbuffers::Offset<GroupMatchingConvertToQuickResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GroupMatchingConvertToQuickResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GroupMatchingConvertToQuickResponse> CreateGroupMatchingConvertToQuickResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode err = ErrorCode_NONE,
    int64_t pushId = 0,
    uint32_t matchId = 0) {
  GroupMatchingConvertToQuickResponseBuilder builder_(_fbb);
  builder_.add_pushId(pushId);
  builder_.add_matchId(matchId);
  builder_.add_err(err);
  return builder_.Finish();
}

/// GROUP_MATCHING_REMATCHING_REQUEST
struct GroupMatchingRematchingRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PUSHID = 4,
    VT_MATCHID = 6
  };
  int64_t pushId() const {
    return GetField<int64_t>(VT_PUSHID, 0);
  }
  uint32_t matchId() const {
    return GetField<uint32_t>(VT_MATCHID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_PUSHID) &&
           VerifyField<uint32_t>(verifier, VT_MATCHID) &&
           verifier.EndTable();
  }
};

struct GroupMatchingRematchingRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pushId(int64_t pushId) {
    fbb_.AddElement<int64_t>(GroupMatchingRematchingRequest::VT_PUSHID, pushId, 0);
  }
  void add_matchId(uint32_t matchId) {
    fbb_.AddElement<uint32_t>(GroupMatchingRematchingRequest::VT_MATCHID, matchId, 0);
  }
  explicit GroupMatchingRematchingRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GroupMatchingRematchingRequestBuilder &operator=(const GroupMatchingRematchingRequestBuilder &);
  flatbuffers::Offset<GroupMatchingRematchingRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GroupMatchingRematchingRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GroupMatchingRematchingRequest> CreateGroupMatchingRematchingRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pushId = 0,
    uint32_t matchId = 0) {
  GroupMatchingRematchingRequestBuilder builder_(_fbb);
  builder_.add_pushId(pushId);
  builder_.add_matchId(matchId);
  return builder_.Finish();
}

/// GROUP_MATCHING_REMATCHING_RESPONSE
struct GroupMatchingRematchingResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERR = 4,
    VT_PUSHID = 6,
    VT_MATCHID = 8
  };
  ErrorCode err() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERR, 0));
  }
  int64_t pushId() const {
    return GetField<int64_t>(VT_PUSHID, 0);
  }
  uint32_t matchId() const {
    return GetField<uint32_t>(VT_MATCHID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERR) &&
           VerifyField<int64_t>(verifier, VT_PUSHID) &&
           VerifyField<uint32_t>(verifier, VT_MATCHID) &&
           verifier.EndTable();
  }
};

struct GroupMatchingRematchingResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_err(ErrorCode err) {
    fbb_.AddElement<int32_t>(GroupMatchingRematchingResponse::VT_ERR, static_cast<int32_t>(err), 0);
  }
  void add_pushId(int64_t pushId) {
    fbb_.AddElement<int64_t>(GroupMatchingRematchingResponse::VT_PUSHID, pushId, 0);
  }
  void add_matchId(uint32_t matchId) {
    fbb_.AddElement<uint32_t>(GroupMatchingRematchingResponse::VT_MATCHID, matchId, 0);
  }
  explicit GroupMatchingRematchingResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GroupMatchingRematchingResponseBuilder &operator=(const GroupMatchingRematchingResponseBuilder &);
  flatbuffers::Offset<GroupMatchingRematchingResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GroupMatchingRematchingResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GroupMatchingRematchingResponse> CreateGroupMatchingRematchingResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode err = ErrorCode_NONE,
    int64_t pushId = 0,
    uint32_t matchId = 0) {
  GroupMatchingRematchingResponseBuilder builder_(_fbb);
  builder_.add_pushId(pushId);
  builder_.add_matchId(matchId);
  builder_.add_err(err);
  return builder_.Finish();
}

struct GuildDungeonInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GuildDungeonInfoRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GuildDungeonInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildDungeonInfoRequestBuilder &operator=(const GuildDungeonInfoRequestBuilder &);
  flatbuffers::Offset<GuildDungeonInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildDungeonInfoRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildDungeonInfoRequest> CreateGuildDungeonInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GuildDungeonInfoRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GuildDungeonInfoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DAY = 4,
    VT_CLEARCOUNT = 6,
    VT_ENTERCOUNT = 8,
    VT_REWARDINDEX = 10,
    VT_SEASONENDDATETIMEUTC = 12
  };
  uint8_t day() const {
    return GetField<uint8_t>(VT_DAY, 0);
  }
  int32_t clearCount() const {
    return GetField<int32_t>(VT_CLEARCOUNT, 0);
  }
  uint16_t enterCount() const {
    return GetField<uint16_t>(VT_ENTERCOUNT, 0);
  }
  int8_t rewardIndex() const {
    return GetField<int8_t>(VT_REWARDINDEX, 0);
  }
  /// 시즌 종료 시간. 다음과 같이 변환해서 쓰세요
  /// new DateTime(ticks, DateTimeKind.Utc).ToLocalTime(); // local time
  int64_t seasonEndDateTimeUtc() const {
    return GetField<int64_t>(VT_SEASONENDDATETIMEUTC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DAY) &&
           VerifyField<int32_t>(verifier, VT_CLEARCOUNT) &&
           VerifyField<uint16_t>(verifier, VT_ENTERCOUNT) &&
           VerifyField<int8_t>(verifier, VT_REWARDINDEX) &&
           VerifyField<int64_t>(verifier, VT_SEASONENDDATETIMEUTC) &&
           verifier.EndTable();
  }
};

struct GuildDungeonInfoResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_day(uint8_t day) {
    fbb_.AddElement<uint8_t>(GuildDungeonInfoResponse::VT_DAY, day, 0);
  }
  void add_clearCount(int32_t clearCount) {
    fbb_.AddElement<int32_t>(GuildDungeonInfoResponse::VT_CLEARCOUNT, clearCount, 0);
  }
  void add_enterCount(uint16_t enterCount) {
    fbb_.AddElement<uint16_t>(GuildDungeonInfoResponse::VT_ENTERCOUNT, enterCount, 0);
  }
  void add_rewardIndex(int8_t rewardIndex) {
    fbb_.AddElement<int8_t>(GuildDungeonInfoResponse::VT_REWARDINDEX, rewardIndex, 0);
  }
  void add_seasonEndDateTimeUtc(int64_t seasonEndDateTimeUtc) {
    fbb_.AddElement<int64_t>(GuildDungeonInfoResponse::VT_SEASONENDDATETIMEUTC, seasonEndDateTimeUtc, 0);
  }
  explicit GuildDungeonInfoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildDungeonInfoResponseBuilder &operator=(const GuildDungeonInfoResponseBuilder &);
  flatbuffers::Offset<GuildDungeonInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildDungeonInfoResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildDungeonInfoResponse> CreateGuildDungeonInfoResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t day = 0,
    int32_t clearCount = 0,
    uint16_t enterCount = 0,
    int8_t rewardIndex = 0,
    int64_t seasonEndDateTimeUtc = 0) {
  GuildDungeonInfoResponseBuilder builder_(_fbb);
  builder_.add_seasonEndDateTimeUtc(seasonEndDateTimeUtc);
  builder_.add_clearCount(clearCount);
  builder_.add_enterCount(enterCount);
  builder_.add_rewardIndex(rewardIndex);
  builder_.add_day(day);
  return builder_.Finish();
}

struct GuildDungeonEnterFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4
  };
  ErrorCode errorCode() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERRORCODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           verifier.EndTable();
  }
};

struct GuildDungeonEnterFailedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(ErrorCode errorCode) {
    fbb_.AddElement<int32_t>(GuildDungeonEnterFailed::VT_ERRORCODE, static_cast<int32_t>(errorCode), 0);
  }
  explicit GuildDungeonEnterFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildDungeonEnterFailedBuilder &operator=(const GuildDungeonEnterFailedBuilder &);
  flatbuffers::Offset<GuildDungeonEnterFailed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildDungeonEnterFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildDungeonEnterFailed> CreateGuildDungeonEnterFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode errorCode = ErrorCode_NONE) {
  GuildDungeonEnterFailedBuilder builder_(_fbb);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

struct GuildDungeonClearNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULT = 4,
    VT_SUCCEED = 6,
    VT_ID = 8,
    VT_GUILDEXP = 10,
    VT_GUILDPOINT = 12,
    VT_CLEARCOUNT = 14,
    VT_REWARDS = 16,
    VT_GUILDNAME = 18,
    VT_GUILDCREST = 20
  };
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  bool succeed() const {
    return GetField<uint8_t>(VT_SUCCEED, 0) != 0;
  }
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  uint16_t guildExp() const {
    return GetField<uint16_t>(VT_GUILDEXP, 0);
  }
  uint16_t guildPoint() const {
    return GetField<uint16_t>(VT_GUILDPOINT, 0);
  }
  int32_t clearCount() const {
    return GetField<int32_t>(VT_CLEARCOUNT, 0);
  }
  const RewardInfo *rewards() const {
    return GetPointer<const RewardInfo *>(VT_REWARDS);
  }
  const flatbuffers::String *guildName() const {
    return GetPointer<const flatbuffers::String *>(VT_GUILDNAME);
  }
  const GuildCrest *guildCrest() const {
    return GetPointer<const GuildCrest *>(VT_GUILDCREST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           VerifyField<uint8_t>(verifier, VT_SUCCEED) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<uint16_t>(verifier, VT_GUILDEXP) &&
           VerifyField<uint16_t>(verifier, VT_GUILDPOINT) &&
           VerifyField<int32_t>(verifier, VT_CLEARCOUNT) &&
           VerifyOffsetRequired(verifier, VT_REWARDS) &&
           verifier.VerifyTable(rewards()) &&
           VerifyOffsetRequired(verifier, VT_GUILDNAME) &&
           verifier.VerifyString(guildName()) &&
           VerifyOffsetRequired(verifier, VT_GUILDCREST) &&
           verifier.VerifyTable(guildCrest()) &&
           verifier.EndTable();
  }
};

struct GuildDungeonClearNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(GuildDungeonClearNotify::VT_RESULT, result, 0);
  }
  void add_succeed(bool succeed) {
    fbb_.AddElement<uint8_t>(GuildDungeonClearNotify::VT_SUCCEED, static_cast<uint8_t>(succeed), 0);
  }
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(GuildDungeonClearNotify::VT_ID, id, 0);
  }
  void add_guildExp(uint16_t guildExp) {
    fbb_.AddElement<uint16_t>(GuildDungeonClearNotify::VT_GUILDEXP, guildExp, 0);
  }
  void add_guildPoint(uint16_t guildPoint) {
    fbb_.AddElement<uint16_t>(GuildDungeonClearNotify::VT_GUILDPOINT, guildPoint, 0);
  }
  void add_clearCount(int32_t clearCount) {
    fbb_.AddElement<int32_t>(GuildDungeonClearNotify::VT_CLEARCOUNT, clearCount, 0);
  }
  void add_rewards(flatbuffers::Offset<RewardInfo> rewards) {
    fbb_.AddOffset(GuildDungeonClearNotify::VT_REWARDS, rewards);
  }
  void add_guildName(flatbuffers::Offset<flatbuffers::String> guildName) {
    fbb_.AddOffset(GuildDungeonClearNotify::VT_GUILDNAME, guildName);
  }
  void add_guildCrest(flatbuffers::Offset<GuildCrest> guildCrest) {
    fbb_.AddOffset(GuildDungeonClearNotify::VT_GUILDCREST, guildCrest);
  }
  explicit GuildDungeonClearNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildDungeonClearNotifyBuilder &operator=(const GuildDungeonClearNotifyBuilder &);
  flatbuffers::Offset<GuildDungeonClearNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildDungeonClearNotify>(end);
    fbb_.Required(o, GuildDungeonClearNotify::VT_REWARDS);
    fbb_.Required(o, GuildDungeonClearNotify::VT_GUILDNAME);
    fbb_.Required(o, GuildDungeonClearNotify::VT_GUILDCREST);
    return o;
  }
};

inline flatbuffers::Offset<GuildDungeonClearNotify> CreateGuildDungeonClearNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    bool succeed = false,
    int32_t id = 0,
    uint16_t guildExp = 0,
    uint16_t guildPoint = 0,
    int32_t clearCount = 0,
    flatbuffers::Offset<RewardInfo> rewards = 0,
    flatbuffers::Offset<flatbuffers::String> guildName = 0,
    flatbuffers::Offset<GuildCrest> guildCrest = 0) {
  GuildDungeonClearNotifyBuilder builder_(_fbb);
  builder_.add_guildCrest(guildCrest);
  builder_.add_guildName(guildName);
  builder_.add_rewards(rewards);
  builder_.add_clearCount(clearCount);
  builder_.add_id(id);
  builder_.add_result(result);
  builder_.add_guildPoint(guildPoint);
  builder_.add_guildExp(guildExp);
  builder_.add_succeed(succeed);
  return builder_.Finish();
}

inline flatbuffers::Offset<GuildDungeonClearNotify> CreateGuildDungeonClearNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    bool succeed = false,
    int32_t id = 0,
    uint16_t guildExp = 0,
    uint16_t guildPoint = 0,
    int32_t clearCount = 0,
    flatbuffers::Offset<RewardInfo> rewards = 0,
    const char *guildName = nullptr,
    flatbuffers::Offset<GuildCrest> guildCrest = 0) {
  return LeanPacket::CreateGuildDungeonClearNotify(
      _fbb,
      result,
      succeed,
      id,
      guildExp,
      guildPoint,
      clearCount,
      rewards,
      guildName ? _fbb.CreateString(guildName) : 0,
      guildCrest);
}

struct GuildDungeonRewardRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GuildDungeonRewardRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GuildDungeonRewardRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildDungeonRewardRequestBuilder &operator=(const GuildDungeonRewardRequestBuilder &);
  flatbuffers::Offset<GuildDungeonRewardRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildDungeonRewardRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildDungeonRewardRequest> CreateGuildDungeonRewardRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GuildDungeonRewardRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GuildDungeonRewardResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULT = 4,
    VT_REMAINCLEARCOUNT = 6
  };
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  int32_t remainClearCount() const {
    return GetField<int32_t>(VT_REMAINCLEARCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           VerifyField<int32_t>(verifier, VT_REMAINCLEARCOUNT) &&
           verifier.EndTable();
  }
};

struct GuildDungeonRewardResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(GuildDungeonRewardResponse::VT_RESULT, result, 0);
  }
  void add_remainClearCount(int32_t remainClearCount) {
    fbb_.AddElement<int32_t>(GuildDungeonRewardResponse::VT_REMAINCLEARCOUNT, remainClearCount, 0);
  }
  explicit GuildDungeonRewardResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GuildDungeonRewardResponseBuilder &operator=(const GuildDungeonRewardResponseBuilder &);
  flatbuffers::Offset<GuildDungeonRewardResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GuildDungeonRewardResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GuildDungeonRewardResponse> CreateGuildDungeonRewardResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    int32_t remainClearCount = 0) {
  GuildDungeonRewardResponseBuilder builder_(_fbb);
  builder_.add_remainClearCount(remainClearCount);
  builder_.add_result(result);
  return builder_.Finish();
}

struct EquipCostumeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMOBJECTID = 4
  };
  uint64_t itemObjectId() const {
    return GetField<uint64_t>(VT_ITEMOBJECTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ITEMOBJECTID) &&
           verifier.EndTable();
  }
};

struct EquipCostumeRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemObjectId(uint64_t itemObjectId) {
    fbb_.AddElement<uint64_t>(EquipCostumeRequest::VT_ITEMOBJECTID, itemObjectId, 0);
  }
  explicit EquipCostumeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EquipCostumeRequestBuilder &operator=(const EquipCostumeRequestBuilder &);
  flatbuffers::Offset<EquipCostumeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EquipCostumeRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<EquipCostumeRequest> CreateEquipCostumeRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t itemObjectId = 0) {
  EquipCostumeRequestBuilder builder_(_fbb);
  builder_.add_itemObjectId(itemObjectId);
  return builder_.Finish();
}

///- EQUIP_COSTUME_RESPONSE --------------
struct EquipCostumeResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_ITEMOBJECTID = 6,
    VT_EQUIPCOSTUMESLOT = 8,
    VT_PCOBJECTID = 10,
    VT_EQUIPCOSTUMEPARTS = 12
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  uint64_t itemObjectId() const {
    return GetField<uint64_t>(VT_ITEMOBJECTID, 0);
  }
  int16_t equipCostumeSlot() const {
    return GetField<int16_t>(VT_EQUIPCOSTUMESLOT, 0);
  }
  uint64_t pcObjectId() const {
    return GetField<uint64_t>(VT_PCOBJECTID, 0);
  }
  const CostumePartsInfo *equipCostumeParts() const {
    return GetPointer<const CostumePartsInfo *>(VT_EQUIPCOSTUMEPARTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<uint64_t>(verifier, VT_ITEMOBJECTID) &&
           VerifyField<int16_t>(verifier, VT_EQUIPCOSTUMESLOT) &&
           VerifyField<uint64_t>(verifier, VT_PCOBJECTID) &&
           VerifyOffset(verifier, VT_EQUIPCOSTUMEPARTS) &&
           verifier.VerifyTable(equipCostumeParts()) &&
           verifier.EndTable();
  }
};

struct EquipCostumeResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(EquipCostumeResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_itemObjectId(uint64_t itemObjectId) {
    fbb_.AddElement<uint64_t>(EquipCostumeResponse::VT_ITEMOBJECTID, itemObjectId, 0);
  }
  void add_equipCostumeSlot(int16_t equipCostumeSlot) {
    fbb_.AddElement<int16_t>(EquipCostumeResponse::VT_EQUIPCOSTUMESLOT, equipCostumeSlot, 0);
  }
  void add_pcObjectId(uint64_t pcObjectId) {
    fbb_.AddElement<uint64_t>(EquipCostumeResponse::VT_PCOBJECTID, pcObjectId, 0);
  }
  void add_equipCostumeParts(flatbuffers::Offset<CostumePartsInfo> equipCostumeParts) {
    fbb_.AddOffset(EquipCostumeResponse::VT_EQUIPCOSTUMEPARTS, equipCostumeParts);
  }
  explicit EquipCostumeResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EquipCostumeResponseBuilder &operator=(const EquipCostumeResponseBuilder &);
  flatbuffers::Offset<EquipCostumeResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EquipCostumeResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<EquipCostumeResponse> CreateEquipCostumeResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    uint64_t itemObjectId = 0,
    int16_t equipCostumeSlot = 0,
    uint64_t pcObjectId = 0,
    flatbuffers::Offset<CostumePartsInfo> equipCostumeParts = 0) {
  EquipCostumeResponseBuilder builder_(_fbb);
  builder_.add_pcObjectId(pcObjectId);
  builder_.add_itemObjectId(itemObjectId);
  builder_.add_equipCostumeParts(equipCostumeParts);
  builder_.add_errorCode(errorCode);
  builder_.add_equipCostumeSlot(equipCostumeSlot);
  return builder_.Finish();
}

///- UNEQUIP_COSTUME_REQUEST --------------
struct UnequipCostumeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_UNEQUIPCOSTUMESLOT = 4
  };
  int8_t unequipCostumeSlot() const {
    return GetField<int8_t>(VT_UNEQUIPCOSTUMESLOT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_UNEQUIPCOSTUMESLOT) &&
           verifier.EndTable();
  }
};

struct UnequipCostumeRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_unequipCostumeSlot(int8_t unequipCostumeSlot) {
    fbb_.AddElement<int8_t>(UnequipCostumeRequest::VT_UNEQUIPCOSTUMESLOT, unequipCostumeSlot, 0);
  }
  explicit UnequipCostumeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnequipCostumeRequestBuilder &operator=(const UnequipCostumeRequestBuilder &);
  flatbuffers::Offset<UnequipCostumeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnequipCostumeRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnequipCostumeRequest> CreateUnequipCostumeRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t unequipCostumeSlot = 0) {
  UnequipCostumeRequestBuilder builder_(_fbb);
  builder_.add_unequipCostumeSlot(unequipCostumeSlot);
  return builder_.Finish();
}

///- UNEQUIP_COSTUME_RESPONSE --------------
struct UnequipCostumeResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_UNEQUIPCOSTUMESLOT = 6,
    VT_PCOBJECTID = 8
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  int16_t unequipCostumeSlot() const {
    return GetField<int16_t>(VT_UNEQUIPCOSTUMESLOT, 0);
  }
  uint64_t pcObjectId() const {
    return GetField<uint64_t>(VT_PCOBJECTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int16_t>(verifier, VT_UNEQUIPCOSTUMESLOT) &&
           VerifyField<uint64_t>(verifier, VT_PCOBJECTID) &&
           verifier.EndTable();
  }
};

struct UnequipCostumeResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(UnequipCostumeResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_unequipCostumeSlot(int16_t unequipCostumeSlot) {
    fbb_.AddElement<int16_t>(UnequipCostumeResponse::VT_UNEQUIPCOSTUMESLOT, unequipCostumeSlot, 0);
  }
  void add_pcObjectId(uint64_t pcObjectId) {
    fbb_.AddElement<uint64_t>(UnequipCostumeResponse::VT_PCOBJECTID, pcObjectId, 0);
  }
  explicit UnequipCostumeResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnequipCostumeResponseBuilder &operator=(const UnequipCostumeResponseBuilder &);
  flatbuffers::Offset<UnequipCostumeResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnequipCostumeResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnequipCostumeResponse> CreateUnequipCostumeResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    int16_t unequipCostumeSlot = 0,
    uint64_t pcObjectId = 0) {
  UnequipCostumeResponseBuilder builder_(_fbb);
  builder_.add_pcObjectId(pcObjectId);
  builder_.add_errorCode(errorCode);
  builder_.add_unequipCostumeSlot(unequipCostumeSlot);
  return builder_.Finish();
}

/// COSTUME_PRESET_CHANGE_REQUEST
struct CostumePresetChangeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRESETNO = 4
  };
  int16_t presetNo() const {
    return GetField<int16_t>(VT_PRESETNO, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_PRESETNO) &&
           verifier.EndTable();
  }
};

struct CostumePresetChangeRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_presetNo(int16_t presetNo) {
    fbb_.AddElement<int16_t>(CostumePresetChangeRequest::VT_PRESETNO, presetNo, 0);
  }
  explicit CostumePresetChangeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CostumePresetChangeRequestBuilder &operator=(const CostumePresetChangeRequestBuilder &);
  flatbuffers::Offset<CostumePresetChangeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CostumePresetChangeRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<CostumePresetChangeRequest> CreateCostumePresetChangeRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t presetNo = 0) {
  CostumePresetChangeRequestBuilder builder_(_fbb);
  builder_.add_presetNo(presetNo);
  return builder_.Finish();
}

/// COSTUME_PRESET_CHANGE_RESPONSE
struct CostumePresetChangeResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULT = 4,
    VT_COSTUMEPRESET = 6
  };
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  const CostumePresetInfo *costumePreset() const {
    return GetPointer<const CostumePresetInfo *>(VT_COSTUMEPRESET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           VerifyOffset(verifier, VT_COSTUMEPRESET) &&
           verifier.VerifyTable(costumePreset()) &&
           verifier.EndTable();
  }
};

struct CostumePresetChangeResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(CostumePresetChangeResponse::VT_RESULT, result, 0);
  }
  void add_costumePreset(flatbuffers::Offset<CostumePresetInfo> costumePreset) {
    fbb_.AddOffset(CostumePresetChangeResponse::VT_COSTUMEPRESET, costumePreset);
  }
  explicit CostumePresetChangeResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CostumePresetChangeResponseBuilder &operator=(const CostumePresetChangeResponseBuilder &);
  flatbuffers::Offset<CostumePresetChangeResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CostumePresetChangeResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<CostumePresetChangeResponse> CreateCostumePresetChangeResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    flatbuffers::Offset<CostumePresetInfo> costumePreset = 0) {
  CostumePresetChangeResponseBuilder builder_(_fbb);
  builder_.add_costumePreset(costumePreset);
  builder_.add_result(result);
  return builder_.Finish();
}

/// COSTUME_PRESET_COSTUMESLOT_UPDATE_NOTIFY
struct CostumePresetCostumeSlotUpdateNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRESETNO = 4,
    VT_COSTUMESLOT = 6
  };
  int16_t presetNo() const {
    return GetField<int16_t>(VT_PRESETNO, 0);
  }
  const PresetCostumeInfo *costumeSlot() const {
    return GetPointer<const PresetCostumeInfo *>(VT_COSTUMESLOT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_PRESETNO) &&
           VerifyOffsetRequired(verifier, VT_COSTUMESLOT) &&
           verifier.VerifyTable(costumeSlot()) &&
           verifier.EndTable();
  }
};

struct CostumePresetCostumeSlotUpdateNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_presetNo(int16_t presetNo) {
    fbb_.AddElement<int16_t>(CostumePresetCostumeSlotUpdateNotify::VT_PRESETNO, presetNo, 0);
  }
  void add_costumeSlot(flatbuffers::Offset<PresetCostumeInfo> costumeSlot) {
    fbb_.AddOffset(CostumePresetCostumeSlotUpdateNotify::VT_COSTUMESLOT, costumeSlot);
  }
  explicit CostumePresetCostumeSlotUpdateNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CostumePresetCostumeSlotUpdateNotifyBuilder &operator=(const CostumePresetCostumeSlotUpdateNotifyBuilder &);
  flatbuffers::Offset<CostumePresetCostumeSlotUpdateNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CostumePresetCostumeSlotUpdateNotify>(end);
    fbb_.Required(o, CostumePresetCostumeSlotUpdateNotify::VT_COSTUMESLOT);
    return o;
  }
};

inline flatbuffers::Offset<CostumePresetCostumeSlotUpdateNotify> CreateCostumePresetCostumeSlotUpdateNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t presetNo = 0,
    flatbuffers::Offset<PresetCostumeInfo> costumeSlot = 0) {
  CostumePresetCostumeSlotUpdateNotifyBuilder builder_(_fbb);
  builder_.add_costumeSlot(costumeSlot);
  builder_.add_presetNo(presetNo);
  return builder_.Finish();
}

///- ENCHANT_COSTUME_REQUEST --------------
struct EnchantCostumeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ENCHANTITEMOBJECTID = 4,
    VT_MATERIALITEMS = 6
  };
  uint64_t enchantItemObjectId() const {
    return GetField<uint64_t>(VT_ENCHANTITEMOBJECTID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ClientSItem>> *materialItems() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ClientSItem>> *>(VT_MATERIALITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ENCHANTITEMOBJECTID) &&
           VerifyOffsetRequired(verifier, VT_MATERIALITEMS) &&
           verifier.VerifyVector(materialItems()) &&
           verifier.VerifyVectorOfTables(materialItems()) &&
           verifier.EndTable();
  }
};

struct EnchantCostumeRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enchantItemObjectId(uint64_t enchantItemObjectId) {
    fbb_.AddElement<uint64_t>(EnchantCostumeRequest::VT_ENCHANTITEMOBJECTID, enchantItemObjectId, 0);
  }
  void add_materialItems(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ClientSItem>>> materialItems) {
    fbb_.AddOffset(EnchantCostumeRequest::VT_MATERIALITEMS, materialItems);
  }
  explicit EnchantCostumeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EnchantCostumeRequestBuilder &operator=(const EnchantCostumeRequestBuilder &);
  flatbuffers::Offset<EnchantCostumeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EnchantCostumeRequest>(end);
    fbb_.Required(o, EnchantCostumeRequest::VT_MATERIALITEMS);
    return o;
  }
};

inline flatbuffers::Offset<EnchantCostumeRequest> CreateEnchantCostumeRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t enchantItemObjectId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ClientSItem>>> materialItems = 0) {
  EnchantCostumeRequestBuilder builder_(_fbb);
  builder_.add_enchantItemObjectId(enchantItemObjectId);
  builder_.add_materialItems(materialItems);
  return builder_.Finish();
}

inline flatbuffers::Offset<EnchantCostumeRequest> CreateEnchantCostumeRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t enchantItemObjectId = 0,
    const std::vector<flatbuffers::Offset<ClientSItem>> *materialItems = nullptr) {
  return LeanPacket::CreateEnchantCostumeRequest(
      _fbb,
      enchantItemObjectId,
      materialItems ? _fbb.CreateVector<flatbuffers::Offset<ClientSItem>>(*materialItems) : 0);
}

///- ENCHANT_COSTUME_RESPONSE --------------
struct EnchantCostumeResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_BASEENCHANTEXP = 6,
    VT_ENCHANTEXP = 8,
    VT_LEVEL = 10,
    VT_ITEMOBJECTID = 12
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  int32_t baseEnchantExp() const {
    return GetField<int32_t>(VT_BASEENCHANTEXP, 0);
  }
  int32_t enchantExp() const {
    return GetField<int32_t>(VT_ENCHANTEXP, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  uint64_t itemObjectId() const {
    return GetField<uint64_t>(VT_ITEMOBJECTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int32_t>(verifier, VT_BASEENCHANTEXP) &&
           VerifyField<int32_t>(verifier, VT_ENCHANTEXP) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<uint64_t>(verifier, VT_ITEMOBJECTID) &&
           verifier.EndTable();
  }
};

struct EnchantCostumeResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(EnchantCostumeResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_baseEnchantExp(int32_t baseEnchantExp) {
    fbb_.AddElement<int32_t>(EnchantCostumeResponse::VT_BASEENCHANTEXP, baseEnchantExp, 0);
  }
  void add_enchantExp(int32_t enchantExp) {
    fbb_.AddElement<int32_t>(EnchantCostumeResponse::VT_ENCHANTEXP, enchantExp, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(EnchantCostumeResponse::VT_LEVEL, level, 0);
  }
  void add_itemObjectId(uint64_t itemObjectId) {
    fbb_.AddElement<uint64_t>(EnchantCostumeResponse::VT_ITEMOBJECTID, itemObjectId, 0);
  }
  explicit EnchantCostumeResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EnchantCostumeResponseBuilder &operator=(const EnchantCostumeResponseBuilder &);
  flatbuffers::Offset<EnchantCostumeResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EnchantCostumeResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<EnchantCostumeResponse> CreateEnchantCostumeResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    int32_t baseEnchantExp = 0,
    int32_t enchantExp = 0,
    int32_t level = 0,
    uint64_t itemObjectId = 0) {
  EnchantCostumeResponseBuilder builder_(_fbb);
  builder_.add_itemObjectId(itemObjectId);
  builder_.add_level(level);
  builder_.add_enchantExp(enchantExp);
  builder_.add_baseEnchantExp(baseEnchantExp);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

///- UPGRADE_COSTUME_REQUEST --------------
struct UpgradeCostumeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_UPGRADEITEMOBJECTID = 4
  };
  uint64_t upgradeItemObjectId() const {
    return GetField<uint64_t>(VT_UPGRADEITEMOBJECTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_UPGRADEITEMOBJECTID) &&
           verifier.EndTable();
  }
};

struct UpgradeCostumeRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_upgradeItemObjectId(uint64_t upgradeItemObjectId) {
    fbb_.AddElement<uint64_t>(UpgradeCostumeRequest::VT_UPGRADEITEMOBJECTID, upgradeItemObjectId, 0);
  }
  explicit UpgradeCostumeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UpgradeCostumeRequestBuilder &operator=(const UpgradeCostumeRequestBuilder &);
  flatbuffers::Offset<UpgradeCostumeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UpgradeCostumeRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<UpgradeCostumeRequest> CreateUpgradeCostumeRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t upgradeItemObjectId = 0) {
  UpgradeCostumeRequestBuilder builder_(_fbb);
  builder_.add_upgradeItemObjectId(upgradeItemObjectId);
  return builder_.Finish();
}

///- UPGRADE_COSTUME_RESPONSE --------------
struct UpgradeCostumeResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_GRADE = 6,
    VT_LEVEL = 8,
    VT_EXP = 10,
    VT_ITEMOBJECTID = 12
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  int16_t grade() const {
    return GetField<int16_t>(VT_GRADE, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int32_t exp() const {
    return GetField<int32_t>(VT_EXP, 0);
  }
  uint64_t itemObjectId() const {
    return GetField<uint64_t>(VT_ITEMOBJECTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int16_t>(verifier, VT_GRADE) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_EXP) &&
           VerifyField<uint64_t>(verifier, VT_ITEMOBJECTID) &&
           verifier.EndTable();
  }
};

struct UpgradeCostumeResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(UpgradeCostumeResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_grade(int16_t grade) {
    fbb_.AddElement<int16_t>(UpgradeCostumeResponse::VT_GRADE, grade, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(UpgradeCostumeResponse::VT_LEVEL, level, 0);
  }
  void add_exp(int32_t exp) {
    fbb_.AddElement<int32_t>(UpgradeCostumeResponse::VT_EXP, exp, 0);
  }
  void add_itemObjectId(uint64_t itemObjectId) {
    fbb_.AddElement<uint64_t>(UpgradeCostumeResponse::VT_ITEMOBJECTID, itemObjectId, 0);
  }
  explicit UpgradeCostumeResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UpgradeCostumeResponseBuilder &operator=(const UpgradeCostumeResponseBuilder &);
  flatbuffers::Offset<UpgradeCostumeResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UpgradeCostumeResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<UpgradeCostumeResponse> CreateUpgradeCostumeResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    int16_t grade = 0,
    int32_t level = 0,
    int32_t exp = 0,
    uint64_t itemObjectId = 0) {
  UpgradeCostumeResponseBuilder builder_(_fbb);
  builder_.add_itemObjectId(itemObjectId);
  builder_.add_exp(exp);
  builder_.add_level(level);
  builder_.add_errorCode(errorCode);
  builder_.add_grade(grade);
  return builder_.Finish();
}

///- SHOW_COSTUME_REQUEST --------------
struct ShowCostumeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SHOWCOSTUMESLOT = 4
  };
  int16_t showCostumeSlot() const {
    return GetField<int16_t>(VT_SHOWCOSTUMESLOT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_SHOWCOSTUMESLOT) &&
           verifier.EndTable();
  }
};

struct ShowCostumeRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_showCostumeSlot(int16_t showCostumeSlot) {
    fbb_.AddElement<int16_t>(ShowCostumeRequest::VT_SHOWCOSTUMESLOT, showCostumeSlot, 0);
  }
  explicit ShowCostumeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShowCostumeRequestBuilder &operator=(const ShowCostumeRequestBuilder &);
  flatbuffers::Offset<ShowCostumeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShowCostumeRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShowCostumeRequest> CreateShowCostumeRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t showCostumeSlot = 0) {
  ShowCostumeRequestBuilder builder_(_fbb);
  builder_.add_showCostumeSlot(showCostumeSlot);
  return builder_.Finish();
}

///- SHOW_COSTUME_RESPONSE --------------
struct ShowCostumeResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_SHOWCOSTUMESLOT = 6,
    VT_PCOBJECTID = 8
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  int16_t showCostumeSlot() const {
    return GetField<int16_t>(VT_SHOWCOSTUMESLOT, 0);
  }
  uint64_t pcObjectId() const {
    return GetField<uint64_t>(VT_PCOBJECTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int16_t>(verifier, VT_SHOWCOSTUMESLOT) &&
           VerifyField<uint64_t>(verifier, VT_PCOBJECTID) &&
           verifier.EndTable();
  }
};

struct ShowCostumeResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(ShowCostumeResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_showCostumeSlot(int16_t showCostumeSlot) {
    fbb_.AddElement<int16_t>(ShowCostumeResponse::VT_SHOWCOSTUMESLOT, showCostumeSlot, 0);
  }
  void add_pcObjectId(uint64_t pcObjectId) {
    fbb_.AddElement<uint64_t>(ShowCostumeResponse::VT_PCOBJECTID, pcObjectId, 0);
  }
  explicit ShowCostumeResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShowCostumeResponseBuilder &operator=(const ShowCostumeResponseBuilder &);
  flatbuffers::Offset<ShowCostumeResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShowCostumeResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShowCostumeResponse> CreateShowCostumeResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    int16_t showCostumeSlot = 0,
    uint64_t pcObjectId = 0) {
  ShowCostumeResponseBuilder builder_(_fbb);
  builder_.add_pcObjectId(pcObjectId);
  builder_.add_errorCode(errorCode);
  builder_.add_showCostumeSlot(showCostumeSlot);
  return builder_.Finish();
}

///- HIDE_COSTUME_REQUEST --------------
struct HideCostumeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HIDECOSTUMESLOT = 4
  };
  int16_t hideCostumeSlot() const {
    return GetField<int16_t>(VT_HIDECOSTUMESLOT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_HIDECOSTUMESLOT) &&
           verifier.EndTable();
  }
};

struct HideCostumeRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hideCostumeSlot(int16_t hideCostumeSlot) {
    fbb_.AddElement<int16_t>(HideCostumeRequest::VT_HIDECOSTUMESLOT, hideCostumeSlot, 0);
  }
  explicit HideCostumeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HideCostumeRequestBuilder &operator=(const HideCostumeRequestBuilder &);
  flatbuffers::Offset<HideCostumeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HideCostumeRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<HideCostumeRequest> CreateHideCostumeRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t hideCostumeSlot = 0) {
  HideCostumeRequestBuilder builder_(_fbb);
  builder_.add_hideCostumeSlot(hideCostumeSlot);
  return builder_.Finish();
}

///- HIDE_COSTUME_RESPONSE --------------
struct HideCostumeResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_HIDECOSTUMESLOT = 6,
    VT_PCOBJECTID = 8
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  int16_t hideCostumeSlot() const {
    return GetField<int16_t>(VT_HIDECOSTUMESLOT, 0);
  }
  uint64_t pcObjectId() const {
    return GetField<uint64_t>(VT_PCOBJECTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int16_t>(verifier, VT_HIDECOSTUMESLOT) &&
           VerifyField<uint64_t>(verifier, VT_PCOBJECTID) &&
           verifier.EndTable();
  }
};

struct HideCostumeResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(HideCostumeResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_hideCostumeSlot(int16_t hideCostumeSlot) {
    fbb_.AddElement<int16_t>(HideCostumeResponse::VT_HIDECOSTUMESLOT, hideCostumeSlot, 0);
  }
  void add_pcObjectId(uint64_t pcObjectId) {
    fbb_.AddElement<uint64_t>(HideCostumeResponse::VT_PCOBJECTID, pcObjectId, 0);
  }
  explicit HideCostumeResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HideCostumeResponseBuilder &operator=(const HideCostumeResponseBuilder &);
  flatbuffers::Offset<HideCostumeResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HideCostumeResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<HideCostumeResponse> CreateHideCostumeResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    int16_t hideCostumeSlot = 0,
    uint64_t pcObjectId = 0) {
  HideCostumeResponseBuilder builder_(_fbb);
  builder_.add_pcObjectId(pcObjectId);
  builder_.add_errorCode(errorCode);
  builder_.add_hideCostumeSlot(hideCostumeSlot);
  return builder_.Finish();
}

struct LiveEventTimestamp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIMESTAMP = 4
  };
  int32_t timestamp() const {
    return GetField<int32_t>(VT_TIMESTAMP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TIMESTAMP) &&
           verifier.EndTable();
  }
};

struct LiveEventTimestampBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(int32_t timestamp) {
    fbb_.AddElement<int32_t>(LiveEventTimestamp::VT_TIMESTAMP, timestamp, 0);
  }
  explicit LiveEventTimestampBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventTimestampBuilder &operator=(const LiveEventTimestampBuilder &);
  flatbuffers::Offset<LiveEventTimestamp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventTimestamp>(end);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventTimestamp> CreateLiveEventTimestamp(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t timestamp = 0) {
  LiveEventTimestampBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  return builder_.Finish();
}

struct LiveEventPeriod FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_START = 4,
    VT_END = 6
  };
  int64_t start() const {
    return GetField<int64_t>(VT_START, 0);
  }
  int64_t end() const {
    return GetField<int64_t>(VT_END, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_START) &&
           VerifyField<int64_t>(verifier, VT_END) &&
           verifier.EndTable();
  }
};

struct LiveEventPeriodBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_start(int64_t start) {
    fbb_.AddElement<int64_t>(LiveEventPeriod::VT_START, start, 0);
  }
  void add_end(int64_t end) {
    fbb_.AddElement<int64_t>(LiveEventPeriod::VT_END, end, 0);
  }
  explicit LiveEventPeriodBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventPeriodBuilder &operator=(const LiveEventPeriodBuilder &);
  flatbuffers::Offset<LiveEventPeriod> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventPeriod>(end);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventPeriod> CreateLiveEventPeriod(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t start = 0,
    int64_t end = 0) {
  LiveEventPeriodBuilder builder_(_fbb);
  builder_.add_end(end);
  builder_.add_start(start);
  return builder_.Finish();
}

struct LiveEventHeader FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_REALM = 4,
    VT_TIMESTAMP = 6,
    VT_PERIOD = 8
  };
  int32_t realm() const {
    return GetField<int32_t>(VT_REALM, 0);
  }
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  const LiveEventPeriod *period() const {
    return GetPointer<const LiveEventPeriod *>(VT_PERIOD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_REALM) &&
           VerifyOffsetRequired(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           VerifyOffsetRequired(verifier, VT_PERIOD) &&
           verifier.VerifyTable(period()) &&
           verifier.EndTable();
  }
};

struct LiveEventHeaderBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_realm(int32_t realm) {
    fbb_.AddElement<int32_t>(LiveEventHeader::VT_REALM, realm, 0);
  }
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventHeader::VT_TIMESTAMP, timestamp);
  }
  void add_period(flatbuffers::Offset<LiveEventPeriod> period) {
    fbb_.AddOffset(LiveEventHeader::VT_PERIOD, period);
  }
  explicit LiveEventHeaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventHeaderBuilder &operator=(const LiveEventHeaderBuilder &);
  flatbuffers::Offset<LiveEventHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventHeader>(end);
    fbb_.Required(o, LiveEventHeader::VT_TIMESTAMP);
    fbb_.Required(o, LiveEventHeader::VT_PERIOD);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventHeader> CreateLiveEventHeader(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t realm = 0,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    flatbuffers::Offset<LiveEventPeriod> period = 0) {
  LiveEventHeaderBuilder builder_(_fbb);
  builder_.add_period(period);
  builder_.add_timestamp(timestamp);
  builder_.add_realm(realm);
  return builder_.Finish();
}

struct LiveEventBuyLimit FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TARGET = 4,
    VT_TIME = 6,
    VT_LIMITCOUNT = 8
  };
  int32_t target() const {
    return GetField<int32_t>(VT_TARGET, 0);
  }
  int32_t time() const {
    return GetField<int32_t>(VT_TIME, 0);
  }
  int32_t limitCount() const {
    return GetField<int32_t>(VT_LIMITCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TARGET) &&
           VerifyField<int32_t>(verifier, VT_TIME) &&
           VerifyField<int32_t>(verifier, VT_LIMITCOUNT) &&
           verifier.EndTable();
  }
};

struct LiveEventBuyLimitBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_target(int32_t target) {
    fbb_.AddElement<int32_t>(LiveEventBuyLimit::VT_TARGET, target, 0);
  }
  void add_time(int32_t time) {
    fbb_.AddElement<int32_t>(LiveEventBuyLimit::VT_TIME, time, 0);
  }
  void add_limitCount(int32_t limitCount) {
    fbb_.AddElement<int32_t>(LiveEventBuyLimit::VT_LIMITCOUNT, limitCount, 0);
  }
  explicit LiveEventBuyLimitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventBuyLimitBuilder &operator=(const LiveEventBuyLimitBuilder &);
  flatbuffers::Offset<LiveEventBuyLimit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventBuyLimit>(end);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventBuyLimit> CreateLiveEventBuyLimit(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t target = 0,
    int32_t time = 0,
    int32_t limitCount = 0) {
  LiveEventBuyLimitBuilder builder_(_fbb);
  builder_.add_limitCount(limitCount);
  builder_.add_time(time);
  builder_.add_target(target);
  return builder_.Finish();
}

struct LiveEventTradeResultItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMID = 4,
    VT_STACKCOUNT = 6
  };
  int32_t itemId() const {
    return GetField<int32_t>(VT_ITEMID, 0);
  }
  int32_t stackCount() const {
    return GetField<int32_t>(VT_STACKCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ITEMID) &&
           VerifyField<int32_t>(verifier, VT_STACKCOUNT) &&
           verifier.EndTable();
  }
};

struct LiveEventTradeResultItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemId(int32_t itemId) {
    fbb_.AddElement<int32_t>(LiveEventTradeResultItem::VT_ITEMID, itemId, 0);
  }
  void add_stackCount(int32_t stackCount) {
    fbb_.AddElement<int32_t>(LiveEventTradeResultItem::VT_STACKCOUNT, stackCount, 0);
  }
  explicit LiveEventTradeResultItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventTradeResultItemBuilder &operator=(const LiveEventTradeResultItemBuilder &);
  flatbuffers::Offset<LiveEventTradeResultItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventTradeResultItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventTradeResultItem> CreateLiveEventTradeResultItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t itemId = 0,
    int32_t stackCount = 0) {
  LiveEventTradeResultItemBuilder builder_(_fbb);
  builder_.add_stackCount(stackCount);
  builder_.add_itemId(itemId);
  return builder_.Finish();
}

struct LiveEventTradeCostItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMID = 4,
    VT_STACKCOUNT = 6
  };
  int32_t itemId() const {
    return GetField<int32_t>(VT_ITEMID, 0);
  }
  int32_t stackCount() const {
    return GetField<int32_t>(VT_STACKCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ITEMID) &&
           VerifyField<int32_t>(verifier, VT_STACKCOUNT) &&
           verifier.EndTable();
  }
};

struct LiveEventTradeCostItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemId(int32_t itemId) {
    fbb_.AddElement<int32_t>(LiveEventTradeCostItem::VT_ITEMID, itemId, 0);
  }
  void add_stackCount(int32_t stackCount) {
    fbb_.AddElement<int32_t>(LiveEventTradeCostItem::VT_STACKCOUNT, stackCount, 0);
  }
  explicit LiveEventTradeCostItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventTradeCostItemBuilder &operator=(const LiveEventTradeCostItemBuilder &);
  flatbuffers::Offset<LiveEventTradeCostItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventTradeCostItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventTradeCostItem> CreateLiveEventTradeCostItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t itemId = 0,
    int32_t stackCount = 0) {
  LiveEventTradeCostItemBuilder builder_(_fbb);
  builder_.add_stackCount(stackCount);
  builder_.add_itemId(itemId);
  return builder_.Finish();
}

struct LiveEventTradeData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRODUCTID = 4,
    VT_RESULT = 6,
    VT_COST = 8,
    VT_LIMIT = 10
  };
  int32_t productId() const {
    return GetField<int32_t>(VT_PRODUCTID, 0);
  }
  const LiveEventTradeResultItem *result() const {
    return GetPointer<const LiveEventTradeResultItem *>(VT_RESULT);
  }
  const LiveEventTradeCostItem *cost() const {
    return GetPointer<const LiveEventTradeCostItem *>(VT_COST);
  }
  const LiveEventBuyLimit *limit() const {
    return GetPointer<const LiveEventBuyLimit *>(VT_LIMIT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PRODUCTID) &&
           VerifyOffsetRequired(verifier, VT_RESULT) &&
           verifier.VerifyTable(result()) &&
           VerifyOffsetRequired(verifier, VT_COST) &&
           verifier.VerifyTable(cost()) &&
           VerifyOffsetRequired(verifier, VT_LIMIT) &&
           verifier.VerifyTable(limit()) &&
           verifier.EndTable();
  }
};

struct LiveEventTradeDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_productId(int32_t productId) {
    fbb_.AddElement<int32_t>(LiveEventTradeData::VT_PRODUCTID, productId, 0);
  }
  void add_result(flatbuffers::Offset<LiveEventTradeResultItem> result) {
    fbb_.AddOffset(LiveEventTradeData::VT_RESULT, result);
  }
  void add_cost(flatbuffers::Offset<LiveEventTradeCostItem> cost) {
    fbb_.AddOffset(LiveEventTradeData::VT_COST, cost);
  }
  void add_limit(flatbuffers::Offset<LiveEventBuyLimit> limit) {
    fbb_.AddOffset(LiveEventTradeData::VT_LIMIT, limit);
  }
  explicit LiveEventTradeDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventTradeDataBuilder &operator=(const LiveEventTradeDataBuilder &);
  flatbuffers::Offset<LiveEventTradeData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventTradeData>(end);
    fbb_.Required(o, LiveEventTradeData::VT_RESULT);
    fbb_.Required(o, LiveEventTradeData::VT_COST);
    fbb_.Required(o, LiveEventTradeData::VT_LIMIT);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventTradeData> CreateLiveEventTradeData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t productId = 0,
    flatbuffers::Offset<LiveEventTradeResultItem> result = 0,
    flatbuffers::Offset<LiveEventTradeCostItem> cost = 0,
    flatbuffers::Offset<LiveEventBuyLimit> limit = 0) {
  LiveEventTradeDataBuilder builder_(_fbb);
  builder_.add_limit(limit);
  builder_.add_cost(cost);
  builder_.add_result(result);
  builder_.add_productId(productId);
  return builder_.Finish();
}

struct LiveEventDiaMissionRewardData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMID = 4,
    VT_STACKCOUNT = 6
  };
  int32_t itemId() const {
    return GetField<int32_t>(VT_ITEMID, 0);
  }
  int32_t stackCount() const {
    return GetField<int32_t>(VT_STACKCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ITEMID) &&
           VerifyField<int32_t>(verifier, VT_STACKCOUNT) &&
           verifier.EndTable();
  }
};

struct LiveEventDiaMissionRewardDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemId(int32_t itemId) {
    fbb_.AddElement<int32_t>(LiveEventDiaMissionRewardData::VT_ITEMID, itemId, 0);
  }
  void add_stackCount(int32_t stackCount) {
    fbb_.AddElement<int32_t>(LiveEventDiaMissionRewardData::VT_STACKCOUNT, stackCount, 0);
  }
  explicit LiveEventDiaMissionRewardDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventDiaMissionRewardDataBuilder &operator=(const LiveEventDiaMissionRewardDataBuilder &);
  flatbuffers::Offset<LiveEventDiaMissionRewardData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventDiaMissionRewardData>(end);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventDiaMissionRewardData> CreateLiveEventDiaMissionRewardData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t itemId = 0,
    int32_t stackCount = 0) {
  LiveEventDiaMissionRewardDataBuilder builder_(_fbb);
  builder_.add_stackCount(stackCount);
  builder_.add_itemId(itemId);
  return builder_.Finish();
}

struct LiveEventLevelRange FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STARTLV = 4,
    VT_LIMITLV = 6
  };
  int32_t startLv() const {
    return GetField<int32_t>(VT_STARTLV, 0);
  }
  int32_t limitLv() const {
    return GetField<int32_t>(VT_LIMITLV, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STARTLV) &&
           VerifyField<int32_t>(verifier, VT_LIMITLV) &&
           verifier.EndTable();
  }
};

struct LiveEventLevelRangeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_startLv(int32_t startLv) {
    fbb_.AddElement<int32_t>(LiveEventLevelRange::VT_STARTLV, startLv, 0);
  }
  void add_limitLv(int32_t limitLv) {
    fbb_.AddElement<int32_t>(LiveEventLevelRange::VT_LIMITLV, limitLv, 0);
  }
  explicit LiveEventLevelRangeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventLevelRangeBuilder &operator=(const LiveEventLevelRangeBuilder &);
  flatbuffers::Offset<LiveEventLevelRange> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventLevelRange>(end);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventLevelRange> CreateLiveEventLevelRange(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t startLv = 0,
    int32_t limitLv = 0) {
  LiveEventLevelRangeBuilder builder_(_fbb);
  builder_.add_limitLv(limitLv);
  builder_.add_startLv(startLv);
  return builder_.Finish();
}

struct LiveEventDiaMissionData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MISSIONID = 4,
    VT_ACHIEVEAMOUNT = 6,
    VT_REWARDS = 8
  };
  int32_t missionId() const {
    return GetField<int32_t>(VT_MISSIONID, 0);
  }
  int32_t achieveAmount() const {
    return GetField<int32_t>(VT_ACHIEVEAMOUNT, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<LiveEventDiaMissionRewardData>> *rewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LiveEventDiaMissionRewardData>> *>(VT_REWARDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MISSIONID) &&
           VerifyField<int32_t>(verifier, VT_ACHIEVEAMOUNT) &&
           VerifyOffsetRequired(verifier, VT_REWARDS) &&
           verifier.VerifyVector(rewards()) &&
           verifier.VerifyVectorOfTables(rewards()) &&
           verifier.EndTable();
  }
};

struct LiveEventDiaMissionDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_missionId(int32_t missionId) {
    fbb_.AddElement<int32_t>(LiveEventDiaMissionData::VT_MISSIONID, missionId, 0);
  }
  void add_achieveAmount(int32_t achieveAmount) {
    fbb_.AddElement<int32_t>(LiveEventDiaMissionData::VT_ACHIEVEAMOUNT, achieveAmount, 0);
  }
  void add_rewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventDiaMissionRewardData>>> rewards) {
    fbb_.AddOffset(LiveEventDiaMissionData::VT_REWARDS, rewards);
  }
  explicit LiveEventDiaMissionDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventDiaMissionDataBuilder &operator=(const LiveEventDiaMissionDataBuilder &);
  flatbuffers::Offset<LiveEventDiaMissionData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventDiaMissionData>(end);
    fbb_.Required(o, LiveEventDiaMissionData::VT_REWARDS);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventDiaMissionData> CreateLiveEventDiaMissionData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t missionId = 0,
    int32_t achieveAmount = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventDiaMissionRewardData>>> rewards = 0) {
  LiveEventDiaMissionDataBuilder builder_(_fbb);
  builder_.add_rewards(rewards);
  builder_.add_achieveAmount(achieveAmount);
  builder_.add_missionId(missionId);
  return builder_.Finish();
}

inline flatbuffers::Offset<LiveEventDiaMissionData> CreateLiveEventDiaMissionDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t missionId = 0,
    int32_t achieveAmount = 0,
    const std::vector<flatbuffers::Offset<LiveEventDiaMissionRewardData>> *rewards = nullptr) {
  return LeanPacket::CreateLiveEventDiaMissionData(
      _fbb,
      missionId,
      achieveAmount,
      rewards ? _fbb.CreateVector<flatbuffers::Offset<LiveEventDiaMissionRewardData>>(*rewards) : 0);
}

struct LiveEventDiaBuyDataSheet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HEADER = 4,
    VT_MISSIONS = 6
  };
  const LiveEventHeader *header() const {
    return GetPointer<const LiveEventHeader *>(VT_HEADER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<LiveEventDiaMissionData>> *missions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LiveEventDiaMissionData>> *>(VT_MISSIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_MISSIONS) &&
           verifier.VerifyVector(missions()) &&
           verifier.VerifyVectorOfTables(missions()) &&
           verifier.EndTable();
  }
};

struct LiveEventDiaBuyDataSheetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_header(flatbuffers::Offset<LiveEventHeader> header) {
    fbb_.AddOffset(LiveEventDiaBuyDataSheet::VT_HEADER, header);
  }
  void add_missions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventDiaMissionData>>> missions) {
    fbb_.AddOffset(LiveEventDiaBuyDataSheet::VT_MISSIONS, missions);
  }
  explicit LiveEventDiaBuyDataSheetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventDiaBuyDataSheetBuilder &operator=(const LiveEventDiaBuyDataSheetBuilder &);
  flatbuffers::Offset<LiveEventDiaBuyDataSheet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventDiaBuyDataSheet>(end);
    fbb_.Required(o, LiveEventDiaBuyDataSheet::VT_HEADER);
    fbb_.Required(o, LiveEventDiaBuyDataSheet::VT_MISSIONS);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventDiaBuyDataSheet> CreateLiveEventDiaBuyDataSheet(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventHeader> header = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventDiaMissionData>>> missions = 0) {
  LiveEventDiaBuyDataSheetBuilder builder_(_fbb);
  builder_.add_missions(missions);
  builder_.add_header(header);
  return builder_.Finish();
}

inline flatbuffers::Offset<LiveEventDiaBuyDataSheet> CreateLiveEventDiaBuyDataSheetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventHeader> header = 0,
    const std::vector<flatbuffers::Offset<LiveEventDiaMissionData>> *missions = nullptr) {
  return LeanPacket::CreateLiveEventDiaBuyDataSheet(
      _fbb,
      header,
      missions ? _fbb.CreateVector<flatbuffers::Offset<LiveEventDiaMissionData>>(*missions) : 0);
}

struct LiveEventDiaSpentDataSheet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HEADER = 4,
    VT_MISSIONS = 6
  };
  const LiveEventHeader *header() const {
    return GetPointer<const LiveEventHeader *>(VT_HEADER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<LiveEventDiaMissionData>> *missions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LiveEventDiaMissionData>> *>(VT_MISSIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_MISSIONS) &&
           verifier.VerifyVector(missions()) &&
           verifier.VerifyVectorOfTables(missions()) &&
           verifier.EndTable();
  }
};

struct LiveEventDiaSpentDataSheetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_header(flatbuffers::Offset<LiveEventHeader> header) {
    fbb_.AddOffset(LiveEventDiaSpentDataSheet::VT_HEADER, header);
  }
  void add_missions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventDiaMissionData>>> missions) {
    fbb_.AddOffset(LiveEventDiaSpentDataSheet::VT_MISSIONS, missions);
  }
  explicit LiveEventDiaSpentDataSheetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventDiaSpentDataSheetBuilder &operator=(const LiveEventDiaSpentDataSheetBuilder &);
  flatbuffers::Offset<LiveEventDiaSpentDataSheet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventDiaSpentDataSheet>(end);
    fbb_.Required(o, LiveEventDiaSpentDataSheet::VT_HEADER);
    fbb_.Required(o, LiveEventDiaSpentDataSheet::VT_MISSIONS);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventDiaSpentDataSheet> CreateLiveEventDiaSpentDataSheet(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventHeader> header = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventDiaMissionData>>> missions = 0) {
  LiveEventDiaSpentDataSheetBuilder builder_(_fbb);
  builder_.add_missions(missions);
  builder_.add_header(header);
  return builder_.Finish();
}

inline flatbuffers::Offset<LiveEventDiaSpentDataSheet> CreateLiveEventDiaSpentDataSheetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventHeader> header = 0,
    const std::vector<flatbuffers::Offset<LiveEventDiaMissionData>> *missions = nullptr) {
  return LeanPacket::CreateLiveEventDiaSpentDataSheet(
      _fbb,
      header,
      missions ? _fbb.CreateVector<flatbuffers::Offset<LiveEventDiaMissionData>>(*missions) : 0);
}

struct LiveEventTradeDataSheet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HEADER = 4,
    VT_PRODUCTS = 6
  };
  const LiveEventHeader *header() const {
    return GetPointer<const LiveEventHeader *>(VT_HEADER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<LiveEventTradeData>> *products() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LiveEventTradeData>> *>(VT_PRODUCTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_PRODUCTS) &&
           verifier.VerifyVector(products()) &&
           verifier.VerifyVectorOfTables(products()) &&
           verifier.EndTable();
  }
};

struct LiveEventTradeDataSheetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_header(flatbuffers::Offset<LiveEventHeader> header) {
    fbb_.AddOffset(LiveEventTradeDataSheet::VT_HEADER, header);
  }
  void add_products(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventTradeData>>> products) {
    fbb_.AddOffset(LiveEventTradeDataSheet::VT_PRODUCTS, products);
  }
  explicit LiveEventTradeDataSheetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventTradeDataSheetBuilder &operator=(const LiveEventTradeDataSheetBuilder &);
  flatbuffers::Offset<LiveEventTradeDataSheet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventTradeDataSheet>(end);
    fbb_.Required(o, LiveEventTradeDataSheet::VT_HEADER);
    fbb_.Required(o, LiveEventTradeDataSheet::VT_PRODUCTS);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventTradeDataSheet> CreateLiveEventTradeDataSheet(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventHeader> header = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventTradeData>>> products = 0) {
  LiveEventTradeDataSheetBuilder builder_(_fbb);
  builder_.add_products(products);
  builder_.add_header(header);
  return builder_.Finish();
}

inline flatbuffers::Offset<LiveEventTradeDataSheet> CreateLiveEventTradeDataSheetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventHeader> header = 0,
    const std::vector<flatbuffers::Offset<LiveEventTradeData>> *products = nullptr) {
  return LeanPacket::CreateLiveEventTradeDataSheet(
      _fbb,
      header,
      products ? _fbb.CreateVector<flatbuffers::Offset<LiveEventTradeData>>(*products) : 0);
}

struct LiveEventLimitShopResultItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMID = 4,
    VT_STACKCOUNT = 6
  };
  int32_t itemId() const {
    return GetField<int32_t>(VT_ITEMID, 0);
  }
  int32_t stackCount() const {
    return GetField<int32_t>(VT_STACKCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ITEMID) &&
           VerifyField<int32_t>(verifier, VT_STACKCOUNT) &&
           verifier.EndTable();
  }
};

struct LiveEventLimitShopResultItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemId(int32_t itemId) {
    fbb_.AddElement<int32_t>(LiveEventLimitShopResultItem::VT_ITEMID, itemId, 0);
  }
  void add_stackCount(int32_t stackCount) {
    fbb_.AddElement<int32_t>(LiveEventLimitShopResultItem::VT_STACKCOUNT, stackCount, 0);
  }
  explicit LiveEventLimitShopResultItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventLimitShopResultItemBuilder &operator=(const LiveEventLimitShopResultItemBuilder &);
  flatbuffers::Offset<LiveEventLimitShopResultItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventLimitShopResultItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventLimitShopResultItem> CreateLiveEventLimitShopResultItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t itemId = 0,
    int32_t stackCount = 0) {
  LiveEventLimitShopResultItemBuilder builder_(_fbb);
  builder_.add_stackCount(stackCount);
  builder_.add_itemId(itemId);
  return builder_.Finish();
}

struct LiveEventLimitShopCost FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COSTTYPE = 4,
    VT_AMOUNT = 6
  };
  int32_t costType() const {
    return GetField<int32_t>(VT_COSTTYPE, 0);
  }
  int32_t amount() const {
    return GetField<int32_t>(VT_AMOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_COSTTYPE) &&
           VerifyField<int32_t>(verifier, VT_AMOUNT) &&
           verifier.EndTable();
  }
};

struct LiveEventLimitShopCostBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_costType(int32_t costType) {
    fbb_.AddElement<int32_t>(LiveEventLimitShopCost::VT_COSTTYPE, costType, 0);
  }
  void add_amount(int32_t amount) {
    fbb_.AddElement<int32_t>(LiveEventLimitShopCost::VT_AMOUNT, amount, 0);
  }
  explicit LiveEventLimitShopCostBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventLimitShopCostBuilder &operator=(const LiveEventLimitShopCostBuilder &);
  flatbuffers::Offset<LiveEventLimitShopCost> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventLimitShopCost>(end);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventLimitShopCost> CreateLiveEventLimitShopCost(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t costType = 0,
    int32_t amount = 0) {
  LiveEventLimitShopCostBuilder builder_(_fbb);
  builder_.add_amount(amount);
  builder_.add_costType(costType);
  return builder_.Finish();
}

struct LiveEventLimitShopData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRODUCTID = 4,
    VT_RESULT = 6,
    VT_COST = 8,
    VT_LIMIT = 10
  };
  int32_t productId() const {
    return GetField<int32_t>(VT_PRODUCTID, 0);
  }
  const LiveEventLimitShopResultItem *result() const {
    return GetPointer<const LiveEventLimitShopResultItem *>(VT_RESULT);
  }
  const LiveEventLimitShopCost *cost() const {
    return GetPointer<const LiveEventLimitShopCost *>(VT_COST);
  }
  const LiveEventBuyLimit *limit() const {
    return GetPointer<const LiveEventBuyLimit *>(VT_LIMIT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PRODUCTID) &&
           VerifyOffsetRequired(verifier, VT_RESULT) &&
           verifier.VerifyTable(result()) &&
           VerifyOffsetRequired(verifier, VT_COST) &&
           verifier.VerifyTable(cost()) &&
           VerifyOffsetRequired(verifier, VT_LIMIT) &&
           verifier.VerifyTable(limit()) &&
           verifier.EndTable();
  }
};

struct LiveEventLimitShopDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_productId(int32_t productId) {
    fbb_.AddElement<int32_t>(LiveEventLimitShopData::VT_PRODUCTID, productId, 0);
  }
  void add_result(flatbuffers::Offset<LiveEventLimitShopResultItem> result) {
    fbb_.AddOffset(LiveEventLimitShopData::VT_RESULT, result);
  }
  void add_cost(flatbuffers::Offset<LiveEventLimitShopCost> cost) {
    fbb_.AddOffset(LiveEventLimitShopData::VT_COST, cost);
  }
  void add_limit(flatbuffers::Offset<LiveEventBuyLimit> limit) {
    fbb_.AddOffset(LiveEventLimitShopData::VT_LIMIT, limit);
  }
  explicit LiveEventLimitShopDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventLimitShopDataBuilder &operator=(const LiveEventLimitShopDataBuilder &);
  flatbuffers::Offset<LiveEventLimitShopData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventLimitShopData>(end);
    fbb_.Required(o, LiveEventLimitShopData::VT_RESULT);
    fbb_.Required(o, LiveEventLimitShopData::VT_COST);
    fbb_.Required(o, LiveEventLimitShopData::VT_LIMIT);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventLimitShopData> CreateLiveEventLimitShopData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t productId = 0,
    flatbuffers::Offset<LiveEventLimitShopResultItem> result = 0,
    flatbuffers::Offset<LiveEventLimitShopCost> cost = 0,
    flatbuffers::Offset<LiveEventBuyLimit> limit = 0) {
  LiveEventLimitShopDataBuilder builder_(_fbb);
  builder_.add_limit(limit);
  builder_.add_cost(cost);
  builder_.add_result(result);
  builder_.add_productId(productId);
  return builder_.Finish();
}

struct LiveEventLimitShopDataSheet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HEADER = 4,
    VT_PRODUCTS = 6
  };
  const LiveEventHeader *header() const {
    return GetPointer<const LiveEventHeader *>(VT_HEADER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<LiveEventLimitShopData>> *products() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LiveEventLimitShopData>> *>(VT_PRODUCTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_PRODUCTS) &&
           verifier.VerifyVector(products()) &&
           verifier.VerifyVectorOfTables(products()) &&
           verifier.EndTable();
  }
};

struct LiveEventLimitShopDataSheetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_header(flatbuffers::Offset<LiveEventHeader> header) {
    fbb_.AddOffset(LiveEventLimitShopDataSheet::VT_HEADER, header);
  }
  void add_products(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventLimitShopData>>> products) {
    fbb_.AddOffset(LiveEventLimitShopDataSheet::VT_PRODUCTS, products);
  }
  explicit LiveEventLimitShopDataSheetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventLimitShopDataSheetBuilder &operator=(const LiveEventLimitShopDataSheetBuilder &);
  flatbuffers::Offset<LiveEventLimitShopDataSheet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventLimitShopDataSheet>(end);
    fbb_.Required(o, LiveEventLimitShopDataSheet::VT_HEADER);
    fbb_.Required(o, LiveEventLimitShopDataSheet::VT_PRODUCTS);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventLimitShopDataSheet> CreateLiveEventLimitShopDataSheet(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventHeader> header = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventLimitShopData>>> products = 0) {
  LiveEventLimitShopDataSheetBuilder builder_(_fbb);
  builder_.add_products(products);
  builder_.add_header(header);
  return builder_.Finish();
}

inline flatbuffers::Offset<LiveEventLimitShopDataSheet> CreateLiveEventLimitShopDataSheetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventHeader> header = 0,
    const std::vector<flatbuffers::Offset<LiveEventLimitShopData>> *products = nullptr) {
  return LeanPacket::CreateLiveEventLimitShopDataSheet(
      _fbb,
      header,
      products ? _fbb.CreateVector<flatbuffers::Offset<LiveEventLimitShopData>>(*products) : 0);
}

struct LiveEventItemDropRewardData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMID = 4,
    VT_STACKCOUNT = 6,
    VT_DROPCHANCE = 8
  };
  int32_t itemId() const {
    return GetField<int32_t>(VT_ITEMID, 0);
  }
  int32_t stackCount() const {
    return GetField<int32_t>(VT_STACKCOUNT, 0);
  }
  int32_t dropChance() const {
    return GetField<int32_t>(VT_DROPCHANCE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ITEMID) &&
           VerifyField<int32_t>(verifier, VT_STACKCOUNT) &&
           VerifyField<int32_t>(verifier, VT_DROPCHANCE) &&
           verifier.EndTable();
  }
};

struct LiveEventItemDropRewardDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemId(int32_t itemId) {
    fbb_.AddElement<int32_t>(LiveEventItemDropRewardData::VT_ITEMID, itemId, 0);
  }
  void add_stackCount(int32_t stackCount) {
    fbb_.AddElement<int32_t>(LiveEventItemDropRewardData::VT_STACKCOUNT, stackCount, 0);
  }
  void add_dropChance(int32_t dropChance) {
    fbb_.AddElement<int32_t>(LiveEventItemDropRewardData::VT_DROPCHANCE, dropChance, 0);
  }
  explicit LiveEventItemDropRewardDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventItemDropRewardDataBuilder &operator=(const LiveEventItemDropRewardDataBuilder &);
  flatbuffers::Offset<LiveEventItemDropRewardData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventItemDropRewardData>(end);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventItemDropRewardData> CreateLiveEventItemDropRewardData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t itemId = 0,
    int32_t stackCount = 0,
    int32_t dropChance = 0) {
  LiveEventItemDropRewardDataBuilder builder_(_fbb);
  builder_.add_dropChance(dropChance);
  builder_.add_stackCount(stackCount);
  builder_.add_itemId(itemId);
  return builder_.Finish();
}

struct LiveEventItemDropData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONTENTTYPE = 4,
    VT_EVENTTYPE = 6,
    VT_CHAPTER = 8,
    VT_REWARDS = 10
  };
  int32_t contentType() const {
    return GetField<int32_t>(VT_CONTENTTYPE, 0);
  }
  int32_t eventType() const {
    return GetField<int32_t>(VT_EVENTTYPE, 0);
  }
  int32_t chapter() const {
    return GetField<int32_t>(VT_CHAPTER, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<LiveEventItemDropRewardData>> *rewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LiveEventItemDropRewardData>> *>(VT_REWARDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CONTENTTYPE) &&
           VerifyField<int32_t>(verifier, VT_EVENTTYPE) &&
           VerifyField<int32_t>(verifier, VT_CHAPTER) &&
           VerifyOffsetRequired(verifier, VT_REWARDS) &&
           verifier.VerifyVector(rewards()) &&
           verifier.VerifyVectorOfTables(rewards()) &&
           verifier.EndTable();
  }
};

struct LiveEventItemDropDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_contentType(int32_t contentType) {
    fbb_.AddElement<int32_t>(LiveEventItemDropData::VT_CONTENTTYPE, contentType, 0);
  }
  void add_eventType(int32_t eventType) {
    fbb_.AddElement<int32_t>(LiveEventItemDropData::VT_EVENTTYPE, eventType, 0);
  }
  void add_chapter(int32_t chapter) {
    fbb_.AddElement<int32_t>(LiveEventItemDropData::VT_CHAPTER, chapter, 0);
  }
  void add_rewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventItemDropRewardData>>> rewards) {
    fbb_.AddOffset(LiveEventItemDropData::VT_REWARDS, rewards);
  }
  explicit LiveEventItemDropDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventItemDropDataBuilder &operator=(const LiveEventItemDropDataBuilder &);
  flatbuffers::Offset<LiveEventItemDropData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventItemDropData>(end);
    fbb_.Required(o, LiveEventItemDropData::VT_REWARDS);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventItemDropData> CreateLiveEventItemDropData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t contentType = 0,
    int32_t eventType = 0,
    int32_t chapter = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventItemDropRewardData>>> rewards = 0) {
  LiveEventItemDropDataBuilder builder_(_fbb);
  builder_.add_rewards(rewards);
  builder_.add_chapter(chapter);
  builder_.add_eventType(eventType);
  builder_.add_contentType(contentType);
  return builder_.Finish();
}

inline flatbuffers::Offset<LiveEventItemDropData> CreateLiveEventItemDropDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t contentType = 0,
    int32_t eventType = 0,
    int32_t chapter = 0,
    const std::vector<flatbuffers::Offset<LiveEventItemDropRewardData>> *rewards = nullptr) {
  return LeanPacket::CreateLiveEventItemDropData(
      _fbb,
      contentType,
      eventType,
      chapter,
      rewards ? _fbb.CreateVector<flatbuffers::Offset<LiveEventItemDropRewardData>>(*rewards) : 0);
}

struct LiveEventItemDropDataSheet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HEADER = 4,
    VT_DROPS = 6
  };
  const LiveEventHeader *header() const {
    return GetPointer<const LiveEventHeader *>(VT_HEADER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<LiveEventItemDropData>> *drops() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LiveEventItemDropData>> *>(VT_DROPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_DROPS) &&
           verifier.VerifyVector(drops()) &&
           verifier.VerifyVectorOfTables(drops()) &&
           verifier.EndTable();
  }
};

struct LiveEventItemDropDataSheetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_header(flatbuffers::Offset<LiveEventHeader> header) {
    fbb_.AddOffset(LiveEventItemDropDataSheet::VT_HEADER, header);
  }
  void add_drops(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventItemDropData>>> drops) {
    fbb_.AddOffset(LiveEventItemDropDataSheet::VT_DROPS, drops);
  }
  explicit LiveEventItemDropDataSheetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventItemDropDataSheetBuilder &operator=(const LiveEventItemDropDataSheetBuilder &);
  flatbuffers::Offset<LiveEventItemDropDataSheet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventItemDropDataSheet>(end);
    fbb_.Required(o, LiveEventItemDropDataSheet::VT_HEADER);
    fbb_.Required(o, LiveEventItemDropDataSheet::VT_DROPS);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventItemDropDataSheet> CreateLiveEventItemDropDataSheet(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventHeader> header = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventItemDropData>>> drops = 0) {
  LiveEventItemDropDataSheetBuilder builder_(_fbb);
  builder_.add_drops(drops);
  builder_.add_header(header);
  return builder_.Finish();
}

inline flatbuffers::Offset<LiveEventItemDropDataSheet> CreateLiveEventItemDropDataSheetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventHeader> header = 0,
    const std::vector<flatbuffers::Offset<LiveEventItemDropData>> *drops = nullptr) {
  return LeanPacket::CreateLiveEventItemDropDataSheet(
      _fbb,
      header,
      drops ? _fbb.CreateVector<flatbuffers::Offset<LiveEventItemDropData>>(*drops) : 0);
}

/// LIVE_EVENT_STOP_NOTIFY
struct LiveEventStopNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_TIMESTAMP = 6
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffsetRequired(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           verifier.EndTable();
  }
};

struct LiveEventStopNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(LiveEventStopNotify::VT_TYPE, type, 0);
  }
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventStopNotify::VT_TIMESTAMP, timestamp);
  }
  explicit LiveEventStopNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventStopNotifyBuilder &operator=(const LiveEventStopNotifyBuilder &);
  flatbuffers::Offset<LiveEventStopNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventStopNotify>(end);
    fbb_.Required(o, LiveEventStopNotify::VT_TIMESTAMP);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventStopNotify> CreateLiveEventStopNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 0,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0) {
  LiveEventStopNotifyBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_type(type);
  return builder_.Finish();
}

struct LiveEventAttentionReward FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMID = 4,
    VT_COUNT = 6
  };
  int32_t itemId() const {
    return GetField<int32_t>(VT_ITEMID, 0);
  }
  int32_t count() const {
    return GetField<int32_t>(VT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ITEMID) &&
           VerifyField<int32_t>(verifier, VT_COUNT) &&
           verifier.EndTable();
  }
};

struct LiveEventAttentionRewardBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemId(int32_t itemId) {
    fbb_.AddElement<int32_t>(LiveEventAttentionReward::VT_ITEMID, itemId, 0);
  }
  void add_count(int32_t count) {
    fbb_.AddElement<int32_t>(LiveEventAttentionReward::VT_COUNT, count, 0);
  }
  explicit LiveEventAttentionRewardBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventAttentionRewardBuilder &operator=(const LiveEventAttentionRewardBuilder &);
  flatbuffers::Offset<LiveEventAttentionReward> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventAttentionReward>(end);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventAttentionReward> CreateLiveEventAttentionReward(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t itemId = 0,
    int32_t count = 0) {
  LiveEventAttentionRewardBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_itemId(itemId);
  return builder_.Finish();
}

struct LiveEventAttentionEndReward FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_REWARDS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<LiveEventAttentionReward>> *rewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LiveEventAttentionReward>> *>(VT_REWARDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_REWARDS) &&
           verifier.VerifyVector(rewards()) &&
           verifier.VerifyVectorOfTables(rewards()) &&
           verifier.EndTable();
  }
};

struct LiveEventAttentionEndRewardBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventAttentionReward>>> rewards) {
    fbb_.AddOffset(LiveEventAttentionEndReward::VT_REWARDS, rewards);
  }
  explicit LiveEventAttentionEndRewardBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventAttentionEndRewardBuilder &operator=(const LiveEventAttentionEndRewardBuilder &);
  flatbuffers::Offset<LiveEventAttentionEndReward> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventAttentionEndReward>(end);
    fbb_.Required(o, LiveEventAttentionEndReward::VT_REWARDS);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventAttentionEndReward> CreateLiveEventAttentionEndReward(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventAttentionReward>>> rewards = 0) {
  LiveEventAttentionEndRewardBuilder builder_(_fbb);
  builder_.add_rewards(rewards);
  return builder_.Finish();
}

inline flatbuffers::Offset<LiveEventAttentionEndReward> CreateLiveEventAttentionEndRewardDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<LiveEventAttentionReward>> *rewards = nullptr) {
  return LeanPacket::CreateLiveEventAttentionEndReward(
      _fbb,
      rewards ? _fbb.CreateVector<flatbuffers::Offset<LiveEventAttentionReward>>(*rewards) : 0);
}

struct LiveEventAttentionActiveReward FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACTIVEORDER = 4,
    VT_REWARDS = 6
  };
  int16_t activeOrder() const {
    return GetField<int16_t>(VT_ACTIVEORDER, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<LiveEventAttentionReward>> *rewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LiveEventAttentionReward>> *>(VT_REWARDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_ACTIVEORDER) &&
           VerifyOffsetRequired(verifier, VT_REWARDS) &&
           verifier.VerifyVector(rewards()) &&
           verifier.VerifyVectorOfTables(rewards()) &&
           verifier.EndTable();
  }
};

struct LiveEventAttentionActiveRewardBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_activeOrder(int16_t activeOrder) {
    fbb_.AddElement<int16_t>(LiveEventAttentionActiveReward::VT_ACTIVEORDER, activeOrder, 0);
  }
  void add_rewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventAttentionReward>>> rewards) {
    fbb_.AddOffset(LiveEventAttentionActiveReward::VT_REWARDS, rewards);
  }
  explicit LiveEventAttentionActiveRewardBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventAttentionActiveRewardBuilder &operator=(const LiveEventAttentionActiveRewardBuilder &);
  flatbuffers::Offset<LiveEventAttentionActiveReward> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventAttentionActiveReward>(end);
    fbb_.Required(o, LiveEventAttentionActiveReward::VT_REWARDS);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventAttentionActiveReward> CreateLiveEventAttentionActiveReward(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t activeOrder = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventAttentionReward>>> rewards = 0) {
  LiveEventAttentionActiveRewardBuilder builder_(_fbb);
  builder_.add_rewards(rewards);
  builder_.add_activeOrder(activeOrder);
  return builder_.Finish();
}

inline flatbuffers::Offset<LiveEventAttentionActiveReward> CreateLiveEventAttentionActiveRewardDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t activeOrder = 0,
    const std::vector<flatbuffers::Offset<LiveEventAttentionReward>> *rewards = nullptr) {
  return LeanPacket::CreateLiveEventAttentionActiveReward(
      _fbb,
      activeOrder,
      rewards ? _fbb.CreateVector<flatbuffers::Offset<LiveEventAttentionReward>>(*rewards) : 0);
}

struct LiveEventAttentionTarget FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_REALM = 4,
    VT_STARTLV = 6,
    VT_ENDLV = 8,
    VT_APPLYTIME = 10
  };
  int16_t realm() const {
    return GetField<int16_t>(VT_REALM, 0);
  }
  int16_t startLv() const {
    return GetField<int16_t>(VT_STARTLV, 0);
  }
  int16_t endLv() const {
    return GetField<int16_t>(VT_ENDLV, 0);
  }
  int64_t applyTime() const {
    return GetField<int64_t>(VT_APPLYTIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_REALM) &&
           VerifyField<int16_t>(verifier, VT_STARTLV) &&
           VerifyField<int16_t>(verifier, VT_ENDLV) &&
           VerifyField<int64_t>(verifier, VT_APPLYTIME) &&
           verifier.EndTable();
  }
};

struct LiveEventAttentionTargetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_realm(int16_t realm) {
    fbb_.AddElement<int16_t>(LiveEventAttentionTarget::VT_REALM, realm, 0);
  }
  void add_startLv(int16_t startLv) {
    fbb_.AddElement<int16_t>(LiveEventAttentionTarget::VT_STARTLV, startLv, 0);
  }
  void add_endLv(int16_t endLv) {
    fbb_.AddElement<int16_t>(LiveEventAttentionTarget::VT_ENDLV, endLv, 0);
  }
  void add_applyTime(int64_t applyTime) {
    fbb_.AddElement<int64_t>(LiveEventAttentionTarget::VT_APPLYTIME, applyTime, 0);
  }
  explicit LiveEventAttentionTargetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventAttentionTargetBuilder &operator=(const LiveEventAttentionTargetBuilder &);
  flatbuffers::Offset<LiveEventAttentionTarget> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventAttentionTarget>(end);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventAttentionTarget> CreateLiveEventAttentionTarget(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t realm = 0,
    int16_t startLv = 0,
    int16_t endLv = 0,
    int64_t applyTime = 0) {
  LiveEventAttentionTargetBuilder builder_(_fbb);
  builder_.add_applyTime(applyTime);
  builder_.add_endLv(endLv);
  builder_.add_startLv(startLv);
  builder_.add_realm(realm);
  return builder_.Finish();
}

struct LiveEventAttentionDataSheet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_HEADER = 6,
    VT_REWARDS = 8,
    VT_ENDREWARD = 10,
    VT_ENDACTIVEORDER = 12,
    VT_TARGETINFO = 14
  };
  int16_t type() const {
    return GetField<int16_t>(VT_TYPE, 0);
  }
  const LiveEventHeader *header() const {
    return GetPointer<const LiveEventHeader *>(VT_HEADER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<LiveEventAttentionActiveReward>> *rewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LiveEventAttentionActiveReward>> *>(VT_REWARDS);
  }
  const LiveEventAttentionEndReward *endReward() const {
    return GetPointer<const LiveEventAttentionEndReward *>(VT_ENDREWARD);
  }
  int16_t endActiveOrder() const {
    return GetField<int16_t>(VT_ENDACTIVEORDER, 0);
  }
  const LiveEventAttentionTarget *targetInfo() const {
    return GetPointer<const LiveEventAttentionTarget *>(VT_TARGETINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPE) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_REWARDS) &&
           verifier.VerifyVector(rewards()) &&
           verifier.VerifyVectorOfTables(rewards()) &&
           VerifyOffset(verifier, VT_ENDREWARD) &&
           verifier.VerifyTable(endReward()) &&
           VerifyField<int16_t>(verifier, VT_ENDACTIVEORDER) &&
           VerifyOffsetRequired(verifier, VT_TARGETINFO) &&
           verifier.VerifyTable(targetInfo()) &&
           verifier.EndTable();
  }
};

struct LiveEventAttentionDataSheetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int16_t type) {
    fbb_.AddElement<int16_t>(LiveEventAttentionDataSheet::VT_TYPE, type, 0);
  }
  void add_header(flatbuffers::Offset<LiveEventHeader> header) {
    fbb_.AddOffset(LiveEventAttentionDataSheet::VT_HEADER, header);
  }
  void add_rewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventAttentionActiveReward>>> rewards) {
    fbb_.AddOffset(LiveEventAttentionDataSheet::VT_REWARDS, rewards);
  }
  void add_endReward(flatbuffers::Offset<LiveEventAttentionEndReward> endReward) {
    fbb_.AddOffset(LiveEventAttentionDataSheet::VT_ENDREWARD, endReward);
  }
  void add_endActiveOrder(int16_t endActiveOrder) {
    fbb_.AddElement<int16_t>(LiveEventAttentionDataSheet::VT_ENDACTIVEORDER, endActiveOrder, 0);
  }
  void add_targetInfo(flatbuffers::Offset<LiveEventAttentionTarget> targetInfo) {
    fbb_.AddOffset(LiveEventAttentionDataSheet::VT_TARGETINFO, targetInfo);
  }
  explicit LiveEventAttentionDataSheetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventAttentionDataSheetBuilder &operator=(const LiveEventAttentionDataSheetBuilder &);
  flatbuffers::Offset<LiveEventAttentionDataSheet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventAttentionDataSheet>(end);
    fbb_.Required(o, LiveEventAttentionDataSheet::VT_HEADER);
    fbb_.Required(o, LiveEventAttentionDataSheet::VT_REWARDS);
    fbb_.Required(o, LiveEventAttentionDataSheet::VT_TARGETINFO);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventAttentionDataSheet> CreateLiveEventAttentionDataSheet(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t type = 0,
    flatbuffers::Offset<LiveEventHeader> header = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventAttentionActiveReward>>> rewards = 0,
    flatbuffers::Offset<LiveEventAttentionEndReward> endReward = 0,
    int16_t endActiveOrder = 0,
    flatbuffers::Offset<LiveEventAttentionTarget> targetInfo = 0) {
  LiveEventAttentionDataSheetBuilder builder_(_fbb);
  builder_.add_targetInfo(targetInfo);
  builder_.add_endReward(endReward);
  builder_.add_rewards(rewards);
  builder_.add_header(header);
  builder_.add_endActiveOrder(endActiveOrder);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<LiveEventAttentionDataSheet> CreateLiveEventAttentionDataSheetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t type = 0,
    flatbuffers::Offset<LiveEventHeader> header = 0,
    const std::vector<flatbuffers::Offset<LiveEventAttentionActiveReward>> *rewards = nullptr,
    flatbuffers::Offset<LiveEventAttentionEndReward> endReward = 0,
    int16_t endActiveOrder = 0,
    flatbuffers::Offset<LiveEventAttentionTarget> targetInfo = 0) {
  return LeanPacket::CreateLiveEventAttentionDataSheet(
      _fbb,
      type,
      header,
      rewards ? _fbb.CreateVector<flatbuffers::Offset<LiveEventAttentionActiveReward>>(*rewards) : 0,
      endReward,
      endActiveOrder,
      targetInfo);
}

/// LIVE_EVENT_TRADE_DATA_NOTIFY
struct LiveEventTradeDataNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATA = 4
  };
  const LiveEventTradeDataSheet *data() const {
    return GetPointer<const LiveEventTradeDataSheet *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyTable(data()) &&
           verifier.EndTable();
  }
};

struct LiveEventTradeDataNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<LiveEventTradeDataSheet> data) {
    fbb_.AddOffset(LiveEventTradeDataNotify::VT_DATA, data);
  }
  explicit LiveEventTradeDataNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventTradeDataNotifyBuilder &operator=(const LiveEventTradeDataNotifyBuilder &);
  flatbuffers::Offset<LiveEventTradeDataNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventTradeDataNotify>(end);
    fbb_.Required(o, LiveEventTradeDataNotify::VT_DATA);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventTradeDataNotify> CreateLiveEventTradeDataNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventTradeDataSheet> data = 0) {
  LiveEventTradeDataNotifyBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

struct LiveEventBuffData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BUFFID = 4,
    VT_LEVEL = 6
  };
  int32_t buffId() const {
    return GetField<int32_t>(VT_BUFFID, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BUFFID) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           verifier.EndTable();
  }
};

struct LiveEventBuffDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_buffId(int32_t buffId) {
    fbb_.AddElement<int32_t>(LiveEventBuffData::VT_BUFFID, buffId, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(LiveEventBuffData::VT_LEVEL, level, 0);
  }
  explicit LiveEventBuffDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventBuffDataBuilder &operator=(const LiveEventBuffDataBuilder &);
  flatbuffers::Offset<LiveEventBuffData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventBuffData>(end);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventBuffData> CreateLiveEventBuffData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t buffId = 0,
    int32_t level = 0) {
  LiveEventBuffDataBuilder builder_(_fbb);
  builder_.add_level(level);
  builder_.add_buffId(buffId);
  return builder_.Finish();
}

struct LiveEventBuffDataSheet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HEADER = 4,
    VT_BUFFINFOS = 6,
    VT_LVLRANGE = 8
  };
  const LiveEventHeader *header() const {
    return GetPointer<const LiveEventHeader *>(VT_HEADER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<LiveEventBuffData>> *buffInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LiveEventBuffData>> *>(VT_BUFFINFOS);
  }
  const LiveEventLevelRange *lvlRange() const {
    return GetPointer<const LiveEventLevelRange *>(VT_LVLRANGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_BUFFINFOS) &&
           verifier.VerifyVector(buffInfos()) &&
           verifier.VerifyVectorOfTables(buffInfos()) &&
           VerifyOffset(verifier, VT_LVLRANGE) &&
           verifier.VerifyTable(lvlRange()) &&
           verifier.EndTable();
  }
};

struct LiveEventBuffDataSheetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_header(flatbuffers::Offset<LiveEventHeader> header) {
    fbb_.AddOffset(LiveEventBuffDataSheet::VT_HEADER, header);
  }
  void add_buffInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventBuffData>>> buffInfos) {
    fbb_.AddOffset(LiveEventBuffDataSheet::VT_BUFFINFOS, buffInfos);
  }
  void add_lvlRange(flatbuffers::Offset<LiveEventLevelRange> lvlRange) {
    fbb_.AddOffset(LiveEventBuffDataSheet::VT_LVLRANGE, lvlRange);
  }
  explicit LiveEventBuffDataSheetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventBuffDataSheetBuilder &operator=(const LiveEventBuffDataSheetBuilder &);
  flatbuffers::Offset<LiveEventBuffDataSheet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventBuffDataSheet>(end);
    fbb_.Required(o, LiveEventBuffDataSheet::VT_HEADER);
    fbb_.Required(o, LiveEventBuffDataSheet::VT_BUFFINFOS);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventBuffDataSheet> CreateLiveEventBuffDataSheet(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventHeader> header = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventBuffData>>> buffInfos = 0,
    flatbuffers::Offset<LiveEventLevelRange> lvlRange = 0) {
  LiveEventBuffDataSheetBuilder builder_(_fbb);
  builder_.add_lvlRange(lvlRange);
  builder_.add_buffInfos(buffInfos);
  builder_.add_header(header);
  return builder_.Finish();
}

inline flatbuffers::Offset<LiveEventBuffDataSheet> CreateLiveEventBuffDataSheetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventHeader> header = 0,
    const std::vector<flatbuffers::Offset<LiveEventBuffData>> *buffInfos = nullptr,
    flatbuffers::Offset<LiveEventLevelRange> lvlRange = 0) {
  return LeanPacket::CreateLiveEventBuffDataSheet(
      _fbb,
      header,
      buffInfos ? _fbb.CreateVector<flatbuffers::Offset<LiveEventBuffData>>(*buffInfos) : 0,
      lvlRange);
}

/// LIVE_EVENT_BUFF_DATA_NOTIFY
struct LiveEventBuffDataNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATA = 4
  };
  const LiveEventBuffDataSheet *data() const {
    return GetPointer<const LiveEventBuffDataSheet *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyTable(data()) &&
           verifier.EndTable();
  }
};

struct LiveEventBuffDataNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<LiveEventBuffDataSheet> data) {
    fbb_.AddOffset(LiveEventBuffDataNotify::VT_DATA, data);
  }
  explicit LiveEventBuffDataNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventBuffDataNotifyBuilder &operator=(const LiveEventBuffDataNotifyBuilder &);
  flatbuffers::Offset<LiveEventBuffDataNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventBuffDataNotify>(end);
    fbb_.Required(o, LiveEventBuffDataNotify::VT_DATA);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventBuffDataNotify> CreateLiveEventBuffDataNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventBuffDataSheet> data = 0) {
  LiveEventBuffDataNotifyBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

/// LIVE_EVENT_ATTENTION_DATA_NOTIFY
struct LiveEventAttentionDataNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATA = 4
  };
  const LiveEventAttentionDataSheet *data() const {
    return GetPointer<const LiveEventAttentionDataSheet *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyTable(data()) &&
           verifier.EndTable();
  }
};

struct LiveEventAttentionDataNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<LiveEventAttentionDataSheet> data) {
    fbb_.AddOffset(LiveEventAttentionDataNotify::VT_DATA, data);
  }
  explicit LiveEventAttentionDataNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventAttentionDataNotifyBuilder &operator=(const LiveEventAttentionDataNotifyBuilder &);
  flatbuffers::Offset<LiveEventAttentionDataNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventAttentionDataNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventAttentionDataNotify> CreateLiveEventAttentionDataNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventAttentionDataSheet> data = 0) {
  LiveEventAttentionDataNotifyBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

/// LIVE_EVENT_NEWBIE_ATTENTION_DATA_NOTIFY
struct LiveEventNewbieAttentionDataNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATA = 4
  };
  const LiveEventAttentionDataSheet *data() const {
    return GetPointer<const LiveEventAttentionDataSheet *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyTable(data()) &&
           verifier.EndTable();
  }
};

struct LiveEventNewbieAttentionDataNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<LiveEventAttentionDataSheet> data) {
    fbb_.AddOffset(LiveEventNewbieAttentionDataNotify::VT_DATA, data);
  }
  explicit LiveEventNewbieAttentionDataNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventNewbieAttentionDataNotifyBuilder &operator=(const LiveEventNewbieAttentionDataNotifyBuilder &);
  flatbuffers::Offset<LiveEventNewbieAttentionDataNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventNewbieAttentionDataNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventNewbieAttentionDataNotify> CreateLiveEventNewbieAttentionDataNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventAttentionDataSheet> data = 0) {
  LiveEventNewbieAttentionDataNotifyBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

/// LIVE_EVENT_RETURN_ATTENTION_DATA_NOTIFY
struct LiveEventReturnAttentionDataNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATA = 4
  };
  const LiveEventAttentionDataSheet *data() const {
    return GetPointer<const LiveEventAttentionDataSheet *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyTable(data()) &&
           verifier.EndTable();
  }
};

struct LiveEventReturnAttentionDataNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<LiveEventAttentionDataSheet> data) {
    fbb_.AddOffset(LiveEventReturnAttentionDataNotify::VT_DATA, data);
  }
  explicit LiveEventReturnAttentionDataNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventReturnAttentionDataNotifyBuilder &operator=(const LiveEventReturnAttentionDataNotifyBuilder &);
  flatbuffers::Offset<LiveEventReturnAttentionDataNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventReturnAttentionDataNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventReturnAttentionDataNotify> CreateLiveEventReturnAttentionDataNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventAttentionDataSheet> data = 0) {
  LiveEventReturnAttentionDataNotifyBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

/// LIVE_EVENT_DIA_BUY_DATA_NOTIFY
struct LiveEventDiaBuyDataNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATA = 4
  };
  const LiveEventDiaBuyDataSheet *data() const {
    return GetPointer<const LiveEventDiaBuyDataSheet *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyTable(data()) &&
           verifier.EndTable();
  }
};

struct LiveEventDiaBuyDataNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<LiveEventDiaBuyDataSheet> data) {
    fbb_.AddOffset(LiveEventDiaBuyDataNotify::VT_DATA, data);
  }
  explicit LiveEventDiaBuyDataNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventDiaBuyDataNotifyBuilder &operator=(const LiveEventDiaBuyDataNotifyBuilder &);
  flatbuffers::Offset<LiveEventDiaBuyDataNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventDiaBuyDataNotify>(end);
    fbb_.Required(o, LiveEventDiaBuyDataNotify::VT_DATA);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventDiaBuyDataNotify> CreateLiveEventDiaBuyDataNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventDiaBuyDataSheet> data = 0) {
  LiveEventDiaBuyDataNotifyBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

/// LIVE_EVENT_DIA_SPENT_DATA_NOTIFY
struct LiveEventDiaSpentDataNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATA = 4
  };
  const LiveEventDiaSpentDataSheet *data() const {
    return GetPointer<const LiveEventDiaSpentDataSheet *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyTable(data()) &&
           verifier.EndTable();
  }
};

struct LiveEventDiaSpentDataNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<LiveEventDiaSpentDataSheet> data) {
    fbb_.AddOffset(LiveEventDiaSpentDataNotify::VT_DATA, data);
  }
  explicit LiveEventDiaSpentDataNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventDiaSpentDataNotifyBuilder &operator=(const LiveEventDiaSpentDataNotifyBuilder &);
  flatbuffers::Offset<LiveEventDiaSpentDataNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventDiaSpentDataNotify>(end);
    fbb_.Required(o, LiveEventDiaSpentDataNotify::VT_DATA);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventDiaSpentDataNotify> CreateLiveEventDiaSpentDataNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventDiaSpentDataSheet> data = 0) {
  LiveEventDiaSpentDataNotifyBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

/// LIVE_EVENT_LIMIT_SELL_SHOP_DATA_NOTIFY
struct LiveEventLimitSellShopDataNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATA = 4
  };
  const LiveEventLimitShopDataSheet *data() const {
    return GetPointer<const LiveEventLimitShopDataSheet *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyTable(data()) &&
           verifier.EndTable();
  }
};

struct LiveEventLimitSellShopDataNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<LiveEventLimitShopDataSheet> data) {
    fbb_.AddOffset(LiveEventLimitSellShopDataNotify::VT_DATA, data);
  }
  explicit LiveEventLimitSellShopDataNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventLimitSellShopDataNotifyBuilder &operator=(const LiveEventLimitSellShopDataNotifyBuilder &);
  flatbuffers::Offset<LiveEventLimitSellShopDataNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventLimitSellShopDataNotify>(end);
    fbb_.Required(o, LiveEventLimitSellShopDataNotify::VT_DATA);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventLimitSellShopDataNotify> CreateLiveEventLimitSellShopDataNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventLimitShopDataSheet> data = 0) {
  LiveEventLimitSellShopDataNotifyBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

/// LIVE_EVENT_ITEM_DROP_DATA_NOTIFY
struct LiveEventItemDropDataNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATA = 4
  };
  const LiveEventItemDropDataSheet *data() const {
    return GetPointer<const LiveEventItemDropDataSheet *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyTable(data()) &&
           verifier.EndTable();
  }
};

struct LiveEventItemDropDataNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<LiveEventItemDropDataSheet> data) {
    fbb_.AddOffset(LiveEventItemDropDataNotify::VT_DATA, data);
  }
  explicit LiveEventItemDropDataNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventItemDropDataNotifyBuilder &operator=(const LiveEventItemDropDataNotifyBuilder &);
  flatbuffers::Offset<LiveEventItemDropDataNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventItemDropDataNotify>(end);
    fbb_.Required(o, LiveEventItemDropDataNotify::VT_DATA);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventItemDropDataNotify> CreateLiveEventItemDropDataNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventItemDropDataSheet> data = 0) {
  LiveEventItemDropDataNotifyBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

/// 라이브 이벤트 재화 교환 상점 구매 정보
struct LiveEventTradeProductInstance FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRODUCTID = 4,
    VT_PURCHASECOUNT = 6,
    VT_LASTPURCHASETIME = 8
  };
  int32_t productId() const {
    return GetField<int32_t>(VT_PRODUCTID, 0);
  }
  int32_t purchaseCount() const {
    return GetField<int32_t>(VT_PURCHASECOUNT, 0);
  }
  int64_t lastPurchaseTime() const {
    return GetField<int64_t>(VT_LASTPURCHASETIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PRODUCTID) &&
           VerifyField<int32_t>(verifier, VT_PURCHASECOUNT) &&
           VerifyField<int64_t>(verifier, VT_LASTPURCHASETIME) &&
           verifier.EndTable();
  }
};

struct LiveEventTradeProductInstanceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_productId(int32_t productId) {
    fbb_.AddElement<int32_t>(LiveEventTradeProductInstance::VT_PRODUCTID, productId, 0);
  }
  void add_purchaseCount(int32_t purchaseCount) {
    fbb_.AddElement<int32_t>(LiveEventTradeProductInstance::VT_PURCHASECOUNT, purchaseCount, 0);
  }
  void add_lastPurchaseTime(int64_t lastPurchaseTime) {
    fbb_.AddElement<int64_t>(LiveEventTradeProductInstance::VT_LASTPURCHASETIME, lastPurchaseTime, 0);
  }
  explicit LiveEventTradeProductInstanceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventTradeProductInstanceBuilder &operator=(const LiveEventTradeProductInstanceBuilder &);
  flatbuffers::Offset<LiveEventTradeProductInstance> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventTradeProductInstance>(end);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventTradeProductInstance> CreateLiveEventTradeProductInstance(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t productId = 0,
    int32_t purchaseCount = 0,
    int64_t lastPurchaseTime = 0) {
  LiveEventTradeProductInstanceBuilder builder_(_fbb);
  builder_.add_lastPurchaseTime(lastPurchaseTime);
  builder_.add_purchaseCount(purchaseCount);
  builder_.add_productId(productId);
  return builder_.Finish();
}

struct LiveEventTradeInstance FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIMESTAMP = 4,
    VT_PRODUCTS = 6
  };
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  const flatbuffers::Vector<flatbuffers::Offset<LiveEventTradeProductInstance>> *products() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LiveEventTradeProductInstance>> *>(VT_PRODUCTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           VerifyOffsetRequired(verifier, VT_PRODUCTS) &&
           verifier.VerifyVector(products()) &&
           verifier.VerifyVectorOfTables(products()) &&
           verifier.EndTable();
  }
};

struct LiveEventTradeInstanceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventTradeInstance::VT_TIMESTAMP, timestamp);
  }
  void add_products(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventTradeProductInstance>>> products) {
    fbb_.AddOffset(LiveEventTradeInstance::VT_PRODUCTS, products);
  }
  explicit LiveEventTradeInstanceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventTradeInstanceBuilder &operator=(const LiveEventTradeInstanceBuilder &);
  flatbuffers::Offset<LiveEventTradeInstance> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventTradeInstance>(end);
    fbb_.Required(o, LiveEventTradeInstance::VT_PRODUCTS);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventTradeInstance> CreateLiveEventTradeInstance(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventTradeProductInstance>>> products = 0) {
  LiveEventTradeInstanceBuilder builder_(_fbb);
  builder_.add_products(products);
  builder_.add_timestamp(timestamp);
  return builder_.Finish();
}

inline flatbuffers::Offset<LiveEventTradeInstance> CreateLiveEventTradeInstanceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    const std::vector<flatbuffers::Offset<LiveEventTradeProductInstance>> *products = nullptr) {
  return LeanPacket::CreateLiveEventTradeInstance(
      _fbb,
      timestamp,
      products ? _fbb.CreateVector<flatbuffers::Offset<LiveEventTradeProductInstance>>(*products) : 0);
}

struct LiveEventBuffInstance FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIMESTAMP = 4,
    VT_BUFFS = 6
  };
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  const flatbuffers::Vector<flatbuffers::Offset<LiveEventBuffInfoInstance>> *buffs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LiveEventBuffInfoInstance>> *>(VT_BUFFS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           VerifyOffsetRequired(verifier, VT_BUFFS) &&
           verifier.VerifyVector(buffs()) &&
           verifier.VerifyVectorOfTables(buffs()) &&
           verifier.EndTable();
  }
};

struct LiveEventBuffInstanceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventBuffInstance::VT_TIMESTAMP, timestamp);
  }
  void add_buffs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventBuffInfoInstance>>> buffs) {
    fbb_.AddOffset(LiveEventBuffInstance::VT_BUFFS, buffs);
  }
  explicit LiveEventBuffInstanceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventBuffInstanceBuilder &operator=(const LiveEventBuffInstanceBuilder &);
  flatbuffers::Offset<LiveEventBuffInstance> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventBuffInstance>(end);
    fbb_.Required(o, LiveEventBuffInstance::VT_BUFFS);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventBuffInstance> CreateLiveEventBuffInstance(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventBuffInfoInstance>>> buffs = 0) {
  LiveEventBuffInstanceBuilder builder_(_fbb);
  builder_.add_buffs(buffs);
  builder_.add_timestamp(timestamp);
  return builder_.Finish();
}

inline flatbuffers::Offset<LiveEventBuffInstance> CreateLiveEventBuffInstanceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    const std::vector<flatbuffers::Offset<LiveEventBuffInfoInstance>> *buffs = nullptr) {
  return LeanPacket::CreateLiveEventBuffInstance(
      _fbb,
      timestamp,
      buffs ? _fbb.CreateVector<flatbuffers::Offset<LiveEventBuffInfoInstance>>(*buffs) : 0);
}

/// LIVE_EVENT_TRADE_INSTANCE_NOTIFY
struct LiveEventTradeInstaceNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INSTANCE = 4
  };
  const LiveEventTradeInstance *instance() const {
    return GetPointer<const LiveEventTradeInstance *>(VT_INSTANCE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_INSTANCE) &&
           verifier.VerifyTable(instance()) &&
           verifier.EndTable();
  }
};

struct LiveEventTradeInstaceNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_instance(flatbuffers::Offset<LiveEventTradeInstance> instance) {
    fbb_.AddOffset(LiveEventTradeInstaceNotify::VT_INSTANCE, instance);
  }
  explicit LiveEventTradeInstaceNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventTradeInstaceNotifyBuilder &operator=(const LiveEventTradeInstaceNotifyBuilder &);
  flatbuffers::Offset<LiveEventTradeInstaceNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventTradeInstaceNotify>(end);
    fbb_.Required(o, LiveEventTradeInstaceNotify::VT_INSTANCE);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventTradeInstaceNotify> CreateLiveEventTradeInstaceNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventTradeInstance> instance = 0) {
  LiveEventTradeInstaceNotifyBuilder builder_(_fbb);
  builder_.add_instance(instance);
  return builder_.Finish();
}

struct LiveEventTradeInstancePurchaseExpireNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIMESTAMP = 4,
    VT_IDLIST = 6
  };
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  const flatbuffers::Vector<int32_t> *idList() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_IDLIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           VerifyOffsetRequired(verifier, VT_IDLIST) &&
           verifier.VerifyVector(idList()) &&
           verifier.EndTable();
  }
};

struct LiveEventTradeInstancePurchaseExpireNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventTradeInstancePurchaseExpireNotify::VT_TIMESTAMP, timestamp);
  }
  void add_idList(flatbuffers::Offset<flatbuffers::Vector<int32_t>> idList) {
    fbb_.AddOffset(LiveEventTradeInstancePurchaseExpireNotify::VT_IDLIST, idList);
  }
  explicit LiveEventTradeInstancePurchaseExpireNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventTradeInstancePurchaseExpireNotifyBuilder &operator=(const LiveEventTradeInstancePurchaseExpireNotifyBuilder &);
  flatbuffers::Offset<LiveEventTradeInstancePurchaseExpireNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventTradeInstancePurchaseExpireNotify>(end);
    fbb_.Required(o, LiveEventTradeInstancePurchaseExpireNotify::VT_IDLIST);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventTradeInstancePurchaseExpireNotify> CreateLiveEventTradeInstancePurchaseExpireNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> idList = 0) {
  LiveEventTradeInstancePurchaseExpireNotifyBuilder builder_(_fbb);
  builder_.add_idList(idList);
  builder_.add_timestamp(timestamp);
  return builder_.Finish();
}

inline flatbuffers::Offset<LiveEventTradeInstancePurchaseExpireNotify> CreateLiveEventTradeInstancePurchaseExpireNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    const std::vector<int32_t> *idList = nullptr) {
  return LeanPacket::CreateLiveEventTradeInstancePurchaseExpireNotify(
      _fbb,
      timestamp,
      idList ? _fbb.CreateVector<int32_t>(*idList) : 0);
}

struct LiveEventTradePurchaseRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIMESTAMP = 4,
    VT_PRODUCTID = 6
  };
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  int32_t productId() const {
    return GetField<int32_t>(VT_PRODUCTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           VerifyField<int32_t>(verifier, VT_PRODUCTID) &&
           verifier.EndTable();
  }
};

struct LiveEventTradePurchaseRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventTradePurchaseRequest::VT_TIMESTAMP, timestamp);
  }
  void add_productId(int32_t productId) {
    fbb_.AddElement<int32_t>(LiveEventTradePurchaseRequest::VT_PRODUCTID, productId, 0);
  }
  explicit LiveEventTradePurchaseRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventTradePurchaseRequestBuilder &operator=(const LiveEventTradePurchaseRequestBuilder &);
  flatbuffers::Offset<LiveEventTradePurchaseRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventTradePurchaseRequest>(end);
    fbb_.Required(o, LiveEventTradePurchaseRequest::VT_TIMESTAMP);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventTradePurchaseRequest> CreateLiveEventTradePurchaseRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    int32_t productId = 0) {
  LiveEventTradePurchaseRequestBuilder builder_(_fbb);
  builder_.add_productId(productId);
  builder_.add_timestamp(timestamp);
  return builder_.Finish();
}

struct LiveEventTradePurchaseResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRODUCTID = 4,
    VT_ERROR = 6,
    VT_TIMESTAMP = 8,
    VT_PRODUCTINSTANCE = 10
  };
  int32_t productId() const {
    return GetField<int32_t>(VT_PRODUCTID, 0);
  }
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  const LiveEventTradeProductInstance *productInstance() const {
    return GetPointer<const LiveEventTradeProductInstance *>(VT_PRODUCTINSTANCE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PRODUCTID) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           VerifyOffset(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           VerifyOffset(verifier, VT_PRODUCTINSTANCE) &&
           verifier.VerifyTable(productInstance()) &&
           verifier.EndTable();
  }
};

struct LiveEventTradePurchaseResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_productId(int32_t productId) {
    fbb_.AddElement<int32_t>(LiveEventTradePurchaseResponse::VT_PRODUCTID, productId, 0);
  }
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(LiveEventTradePurchaseResponse::VT_ERROR, error, 0);
  }
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventTradePurchaseResponse::VT_TIMESTAMP, timestamp);
  }
  void add_productInstance(flatbuffers::Offset<LiveEventTradeProductInstance> productInstance) {
    fbb_.AddOffset(LiveEventTradePurchaseResponse::VT_PRODUCTINSTANCE, productInstance);
  }
  explicit LiveEventTradePurchaseResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventTradePurchaseResponseBuilder &operator=(const LiveEventTradePurchaseResponseBuilder &);
  flatbuffers::Offset<LiveEventTradePurchaseResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventTradePurchaseResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventTradePurchaseResponse> CreateLiveEventTradePurchaseResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t productId = 0,
    int32_t error = 0,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    flatbuffers::Offset<LiveEventTradeProductInstance> productInstance = 0) {
  LiveEventTradePurchaseResponseBuilder builder_(_fbb);
  builder_.add_productInstance(productInstance);
  builder_.add_timestamp(timestamp);
  builder_.add_error(error);
  builder_.add_productId(productId);
  return builder_.Finish();
}

struct LiveEventDiaMission FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MISSIONID = 4,
    VT_STATE = 6,
    VT_UPDATETIME = 8
  };
  int32_t missionId() const {
    return GetField<int32_t>(VT_MISSIONID, 0);
  }
  LeanType::LiveEventDiaMissionState state() const {
    return static_cast<LeanType::LiveEventDiaMissionState>(GetField<int16_t>(VT_STATE, 0));
  }
  int64_t updateTime() const {
    return GetField<int64_t>(VT_UPDATETIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MISSIONID) &&
           VerifyField<int16_t>(verifier, VT_STATE) &&
           VerifyField<int64_t>(verifier, VT_UPDATETIME) &&
           verifier.EndTable();
  }
};

struct LiveEventDiaMissionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_missionId(int32_t missionId) {
    fbb_.AddElement<int32_t>(LiveEventDiaMission::VT_MISSIONID, missionId, 0);
  }
  void add_state(LeanType::LiveEventDiaMissionState state) {
    fbb_.AddElement<int16_t>(LiveEventDiaMission::VT_STATE, static_cast<int16_t>(state), 0);
  }
  void add_updateTime(int64_t updateTime) {
    fbb_.AddElement<int64_t>(LiveEventDiaMission::VT_UPDATETIME, updateTime, 0);
  }
  explicit LiveEventDiaMissionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventDiaMissionBuilder &operator=(const LiveEventDiaMissionBuilder &);
  flatbuffers::Offset<LiveEventDiaMission> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventDiaMission>(end);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventDiaMission> CreateLiveEventDiaMission(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t missionId = 0,
    LeanType::LiveEventDiaMissionState state = LeanType::LiveEventDiaMissionState_LEMS_PROGRESS,
    int64_t updateTime = 0) {
  LiveEventDiaMissionBuilder builder_(_fbb);
  builder_.add_updateTime(updateTime);
  builder_.add_missionId(missionId);
  builder_.add_state(state);
  return builder_.Finish();
}

struct LiveEventDiaBuyInstance FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIMESTAMP = 4,
    VT_AMOUNT = 6,
    VT_MISSIONS = 8
  };
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  int32_t amount() const {
    return GetField<int32_t>(VT_AMOUNT, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<LiveEventDiaMission>> *missions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LiveEventDiaMission>> *>(VT_MISSIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           VerifyField<int32_t>(verifier, VT_AMOUNT) &&
           VerifyOffsetRequired(verifier, VT_MISSIONS) &&
           verifier.VerifyVector(missions()) &&
           verifier.VerifyVectorOfTables(missions()) &&
           verifier.EndTable();
  }
};

struct LiveEventDiaBuyInstanceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventDiaBuyInstance::VT_TIMESTAMP, timestamp);
  }
  void add_amount(int32_t amount) {
    fbb_.AddElement<int32_t>(LiveEventDiaBuyInstance::VT_AMOUNT, amount, 0);
  }
  void add_missions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventDiaMission>>> missions) {
    fbb_.AddOffset(LiveEventDiaBuyInstance::VT_MISSIONS, missions);
  }
  explicit LiveEventDiaBuyInstanceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventDiaBuyInstanceBuilder &operator=(const LiveEventDiaBuyInstanceBuilder &);
  flatbuffers::Offset<LiveEventDiaBuyInstance> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventDiaBuyInstance>(end);
    fbb_.Required(o, LiveEventDiaBuyInstance::VT_MISSIONS);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventDiaBuyInstance> CreateLiveEventDiaBuyInstance(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    int32_t amount = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventDiaMission>>> missions = 0) {
  LiveEventDiaBuyInstanceBuilder builder_(_fbb);
  builder_.add_missions(missions);
  builder_.add_amount(amount);
  builder_.add_timestamp(timestamp);
  return builder_.Finish();
}

inline flatbuffers::Offset<LiveEventDiaBuyInstance> CreateLiveEventDiaBuyInstanceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    int32_t amount = 0,
    const std::vector<flatbuffers::Offset<LiveEventDiaMission>> *missions = nullptr) {
  return LeanPacket::CreateLiveEventDiaBuyInstance(
      _fbb,
      timestamp,
      amount,
      missions ? _fbb.CreateVector<flatbuffers::Offset<LiveEventDiaMission>>(*missions) : 0);
}

struct LiveEventDiaBuyNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INSTANCE = 4
  };
  const LiveEventDiaBuyInstance *instance() const {
    return GetPointer<const LiveEventDiaBuyInstance *>(VT_INSTANCE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_INSTANCE) &&
           verifier.VerifyTable(instance()) &&
           verifier.EndTable();
  }
};

struct LiveEventDiaBuyNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_instance(flatbuffers::Offset<LiveEventDiaBuyInstance> instance) {
    fbb_.AddOffset(LiveEventDiaBuyNotify::VT_INSTANCE, instance);
  }
  explicit LiveEventDiaBuyNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventDiaBuyNotifyBuilder &operator=(const LiveEventDiaBuyNotifyBuilder &);
  flatbuffers::Offset<LiveEventDiaBuyNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventDiaBuyNotify>(end);
    fbb_.Required(o, LiveEventDiaBuyNotify::VT_INSTANCE);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventDiaBuyNotify> CreateLiveEventDiaBuyNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventDiaBuyInstance> instance = 0) {
  LiveEventDiaBuyNotifyBuilder builder_(_fbb);
  builder_.add_instance(instance);
  return builder_.Finish();
}

struct LiveEventDiaBuyMissionUpdateNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIMESTAMP = 4,
    VT_MISSION = 6
  };
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  const LiveEventDiaMission *mission() const {
    return GetPointer<const LiveEventDiaMission *>(VT_MISSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           VerifyOffsetRequired(verifier, VT_MISSION) &&
           verifier.VerifyTable(mission()) &&
           verifier.EndTable();
  }
};

struct LiveEventDiaBuyMissionUpdateNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventDiaBuyMissionUpdateNotify::VT_TIMESTAMP, timestamp);
  }
  void add_mission(flatbuffers::Offset<LiveEventDiaMission> mission) {
    fbb_.AddOffset(LiveEventDiaBuyMissionUpdateNotify::VT_MISSION, mission);
  }
  explicit LiveEventDiaBuyMissionUpdateNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventDiaBuyMissionUpdateNotifyBuilder &operator=(const LiveEventDiaBuyMissionUpdateNotifyBuilder &);
  flatbuffers::Offset<LiveEventDiaBuyMissionUpdateNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventDiaBuyMissionUpdateNotify>(end);
    fbb_.Required(o, LiveEventDiaBuyMissionUpdateNotify::VT_MISSION);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventDiaBuyMissionUpdateNotify> CreateLiveEventDiaBuyMissionUpdateNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    flatbuffers::Offset<LiveEventDiaMission> mission = 0) {
  LiveEventDiaBuyMissionUpdateNotifyBuilder builder_(_fbb);
  builder_.add_mission(mission);
  builder_.add_timestamp(timestamp);
  return builder_.Finish();
}

struct LiveEventDiaBuyAmountUpdateNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIMESTAMP = 4,
    VT_AMOUNT = 6
  };
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  int32_t amount() const {
    return GetField<int32_t>(VT_AMOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           VerifyField<int32_t>(verifier, VT_AMOUNT) &&
           verifier.EndTable();
  }
};

struct LiveEventDiaBuyAmountUpdateNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventDiaBuyAmountUpdateNotify::VT_TIMESTAMP, timestamp);
  }
  void add_amount(int32_t amount) {
    fbb_.AddElement<int32_t>(LiveEventDiaBuyAmountUpdateNotify::VT_AMOUNT, amount, 0);
  }
  explicit LiveEventDiaBuyAmountUpdateNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventDiaBuyAmountUpdateNotifyBuilder &operator=(const LiveEventDiaBuyAmountUpdateNotifyBuilder &);
  flatbuffers::Offset<LiveEventDiaBuyAmountUpdateNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventDiaBuyAmountUpdateNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventDiaBuyAmountUpdateNotify> CreateLiveEventDiaBuyAmountUpdateNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    int32_t amount = 0) {
  LiveEventDiaBuyAmountUpdateNotifyBuilder builder_(_fbb);
  builder_.add_amount(amount);
  builder_.add_timestamp(timestamp);
  return builder_.Finish();
}

struct LiveEventDiaBuyRewardRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIMESTAMP = 4,
    VT_MISSIONID = 6
  };
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  int32_t missionId() const {
    return GetField<int32_t>(VT_MISSIONID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           VerifyField<int32_t>(verifier, VT_MISSIONID) &&
           verifier.EndTable();
  }
};

struct LiveEventDiaBuyRewardRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventDiaBuyRewardRequest::VT_TIMESTAMP, timestamp);
  }
  void add_missionId(int32_t missionId) {
    fbb_.AddElement<int32_t>(LiveEventDiaBuyRewardRequest::VT_MISSIONID, missionId, 0);
  }
  explicit LiveEventDiaBuyRewardRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventDiaBuyRewardRequestBuilder &operator=(const LiveEventDiaBuyRewardRequestBuilder &);
  flatbuffers::Offset<LiveEventDiaBuyRewardRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventDiaBuyRewardRequest>(end);
    fbb_.Required(o, LiveEventDiaBuyRewardRequest::VT_TIMESTAMP);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventDiaBuyRewardRequest> CreateLiveEventDiaBuyRewardRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    int32_t missionId = 0) {
  LiveEventDiaBuyRewardRequestBuilder builder_(_fbb);
  builder_.add_missionId(missionId);
  builder_.add_timestamp(timestamp);
  return builder_.Finish();
}

struct LiveEventDiaBuyRewardResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MISSIONID = 4,
    VT_ERROR = 6
  };
  int32_t missionId() const {
    return GetField<int32_t>(VT_MISSIONID, 0);
  }
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MISSIONID) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           verifier.EndTable();
  }
};

struct LiveEventDiaBuyRewardResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_missionId(int32_t missionId) {
    fbb_.AddElement<int32_t>(LiveEventDiaBuyRewardResponse::VT_MISSIONID, missionId, 0);
  }
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(LiveEventDiaBuyRewardResponse::VT_ERROR, error, 0);
  }
  explicit LiveEventDiaBuyRewardResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventDiaBuyRewardResponseBuilder &operator=(const LiveEventDiaBuyRewardResponseBuilder &);
  flatbuffers::Offset<LiveEventDiaBuyRewardResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventDiaBuyRewardResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventDiaBuyRewardResponse> CreateLiveEventDiaBuyRewardResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t missionId = 0,
    int32_t error = 0) {
  LiveEventDiaBuyRewardResponseBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_missionId(missionId);
  return builder_.Finish();
}

struct LiveEventDiaSpentInstance FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIMESTAMP = 4,
    VT_AMOUNT = 6,
    VT_MISSIONS = 8
  };
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  int32_t amount() const {
    return GetField<int32_t>(VT_AMOUNT, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<LiveEventDiaMission>> *missions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LiveEventDiaMission>> *>(VT_MISSIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           VerifyField<int32_t>(verifier, VT_AMOUNT) &&
           VerifyOffsetRequired(verifier, VT_MISSIONS) &&
           verifier.VerifyVector(missions()) &&
           verifier.VerifyVectorOfTables(missions()) &&
           verifier.EndTable();
  }
};

struct LiveEventDiaSpentInstanceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventDiaSpentInstance::VT_TIMESTAMP, timestamp);
  }
  void add_amount(int32_t amount) {
    fbb_.AddElement<int32_t>(LiveEventDiaSpentInstance::VT_AMOUNT, amount, 0);
  }
  void add_missions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventDiaMission>>> missions) {
    fbb_.AddOffset(LiveEventDiaSpentInstance::VT_MISSIONS, missions);
  }
  explicit LiveEventDiaSpentInstanceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventDiaSpentInstanceBuilder &operator=(const LiveEventDiaSpentInstanceBuilder &);
  flatbuffers::Offset<LiveEventDiaSpentInstance> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventDiaSpentInstance>(end);
    fbb_.Required(o, LiveEventDiaSpentInstance::VT_MISSIONS);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventDiaSpentInstance> CreateLiveEventDiaSpentInstance(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    int32_t amount = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventDiaMission>>> missions = 0) {
  LiveEventDiaSpentInstanceBuilder builder_(_fbb);
  builder_.add_missions(missions);
  builder_.add_amount(amount);
  builder_.add_timestamp(timestamp);
  return builder_.Finish();
}

inline flatbuffers::Offset<LiveEventDiaSpentInstance> CreateLiveEventDiaSpentInstanceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    int32_t amount = 0,
    const std::vector<flatbuffers::Offset<LiveEventDiaMission>> *missions = nullptr) {
  return LeanPacket::CreateLiveEventDiaSpentInstance(
      _fbb,
      timestamp,
      amount,
      missions ? _fbb.CreateVector<flatbuffers::Offset<LiveEventDiaMission>>(*missions) : 0);
}

struct LiveEventDiaSpentNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INSTANCE = 4
  };
  const LiveEventDiaSpentInstance *instance() const {
    return GetPointer<const LiveEventDiaSpentInstance *>(VT_INSTANCE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_INSTANCE) &&
           verifier.VerifyTable(instance()) &&
           verifier.EndTable();
  }
};

struct LiveEventDiaSpentNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_instance(flatbuffers::Offset<LiveEventDiaSpentInstance> instance) {
    fbb_.AddOffset(LiveEventDiaSpentNotify::VT_INSTANCE, instance);
  }
  explicit LiveEventDiaSpentNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventDiaSpentNotifyBuilder &operator=(const LiveEventDiaSpentNotifyBuilder &);
  flatbuffers::Offset<LiveEventDiaSpentNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventDiaSpentNotify>(end);
    fbb_.Required(o, LiveEventDiaSpentNotify::VT_INSTANCE);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventDiaSpentNotify> CreateLiveEventDiaSpentNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventDiaSpentInstance> instance = 0) {
  LiveEventDiaSpentNotifyBuilder builder_(_fbb);
  builder_.add_instance(instance);
  return builder_.Finish();
}

struct LiveEventDiaSpentMissionNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIMESTAMP = 4,
    VT_MISSION = 6
  };
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  const LiveEventDiaMission *mission() const {
    return GetPointer<const LiveEventDiaMission *>(VT_MISSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           VerifyOffsetRequired(verifier, VT_MISSION) &&
           verifier.VerifyTable(mission()) &&
           verifier.EndTable();
  }
};

struct LiveEventDiaSpentMissionNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventDiaSpentMissionNotify::VT_TIMESTAMP, timestamp);
  }
  void add_mission(flatbuffers::Offset<LiveEventDiaMission> mission) {
    fbb_.AddOffset(LiveEventDiaSpentMissionNotify::VT_MISSION, mission);
  }
  explicit LiveEventDiaSpentMissionNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventDiaSpentMissionNotifyBuilder &operator=(const LiveEventDiaSpentMissionNotifyBuilder &);
  flatbuffers::Offset<LiveEventDiaSpentMissionNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventDiaSpentMissionNotify>(end);
    fbb_.Required(o, LiveEventDiaSpentMissionNotify::VT_MISSION);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventDiaSpentMissionNotify> CreateLiveEventDiaSpentMissionNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    flatbuffers::Offset<LiveEventDiaMission> mission = 0) {
  LiveEventDiaSpentMissionNotifyBuilder builder_(_fbb);
  builder_.add_mission(mission);
  builder_.add_timestamp(timestamp);
  return builder_.Finish();
}

struct LiveEventDiaSpentAmountUpdateNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIMESTAMP = 4,
    VT_AMOUNT = 6
  };
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  int32_t amount() const {
    return GetField<int32_t>(VT_AMOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           VerifyField<int32_t>(verifier, VT_AMOUNT) &&
           verifier.EndTable();
  }
};

struct LiveEventDiaSpentAmountUpdateNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventDiaSpentAmountUpdateNotify::VT_TIMESTAMP, timestamp);
  }
  void add_amount(int32_t amount) {
    fbb_.AddElement<int32_t>(LiveEventDiaSpentAmountUpdateNotify::VT_AMOUNT, amount, 0);
  }
  explicit LiveEventDiaSpentAmountUpdateNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventDiaSpentAmountUpdateNotifyBuilder &operator=(const LiveEventDiaSpentAmountUpdateNotifyBuilder &);
  flatbuffers::Offset<LiveEventDiaSpentAmountUpdateNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventDiaSpentAmountUpdateNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventDiaSpentAmountUpdateNotify> CreateLiveEventDiaSpentAmountUpdateNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    int32_t amount = 0) {
  LiveEventDiaSpentAmountUpdateNotifyBuilder builder_(_fbb);
  builder_.add_amount(amount);
  builder_.add_timestamp(timestamp);
  return builder_.Finish();
}

struct LiveEventDiaSpentRewardRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIMESTAMP = 4,
    VT_MISSIONID = 6
  };
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  int32_t missionId() const {
    return GetField<int32_t>(VT_MISSIONID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           VerifyField<int32_t>(verifier, VT_MISSIONID) &&
           verifier.EndTable();
  }
};

struct LiveEventDiaSpentRewardRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventDiaSpentRewardRequest::VT_TIMESTAMP, timestamp);
  }
  void add_missionId(int32_t missionId) {
    fbb_.AddElement<int32_t>(LiveEventDiaSpentRewardRequest::VT_MISSIONID, missionId, 0);
  }
  explicit LiveEventDiaSpentRewardRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventDiaSpentRewardRequestBuilder &operator=(const LiveEventDiaSpentRewardRequestBuilder &);
  flatbuffers::Offset<LiveEventDiaSpentRewardRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventDiaSpentRewardRequest>(end);
    fbb_.Required(o, LiveEventDiaSpentRewardRequest::VT_TIMESTAMP);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventDiaSpentRewardRequest> CreateLiveEventDiaSpentRewardRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    int32_t missionId = 0) {
  LiveEventDiaSpentRewardRequestBuilder builder_(_fbb);
  builder_.add_missionId(missionId);
  builder_.add_timestamp(timestamp);
  return builder_.Finish();
}

struct LiveEventDiaSpentRewardResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MISSIONID = 4,
    VT_ERROR = 6
  };
  int32_t missionId() const {
    return GetField<int32_t>(VT_MISSIONID, 0);
  }
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MISSIONID) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           verifier.EndTable();
  }
};

struct LiveEventDiaSpentRewardResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_missionId(int32_t missionId) {
    fbb_.AddElement<int32_t>(LiveEventDiaSpentRewardResponse::VT_MISSIONID, missionId, 0);
  }
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(LiveEventDiaSpentRewardResponse::VT_ERROR, error, 0);
  }
  explicit LiveEventDiaSpentRewardResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventDiaSpentRewardResponseBuilder &operator=(const LiveEventDiaSpentRewardResponseBuilder &);
  flatbuffers::Offset<LiveEventDiaSpentRewardResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventDiaSpentRewardResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventDiaSpentRewardResponse> CreateLiveEventDiaSpentRewardResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t missionId = 0,
    int32_t error = 0) {
  LiveEventDiaSpentRewardResponseBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_missionId(missionId);
  return builder_.Finish();
}

struct LiveEventLimitSellShopProductInstance FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRODUCTID = 4,
    VT_PURCHASECOUNT = 6,
    VT_LASTPURCHASETIME = 8
  };
  int32_t productId() const {
    return GetField<int32_t>(VT_PRODUCTID, 0);
  }
  int32_t purchaseCount() const {
    return GetField<int32_t>(VT_PURCHASECOUNT, 0);
  }
  int64_t lastPurchaseTime() const {
    return GetField<int64_t>(VT_LASTPURCHASETIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PRODUCTID) &&
           VerifyField<int32_t>(verifier, VT_PURCHASECOUNT) &&
           VerifyField<int64_t>(verifier, VT_LASTPURCHASETIME) &&
           verifier.EndTable();
  }
};

struct LiveEventLimitSellShopProductInstanceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_productId(int32_t productId) {
    fbb_.AddElement<int32_t>(LiveEventLimitSellShopProductInstance::VT_PRODUCTID, productId, 0);
  }
  void add_purchaseCount(int32_t purchaseCount) {
    fbb_.AddElement<int32_t>(LiveEventLimitSellShopProductInstance::VT_PURCHASECOUNT, purchaseCount, 0);
  }
  void add_lastPurchaseTime(int64_t lastPurchaseTime) {
    fbb_.AddElement<int64_t>(LiveEventLimitSellShopProductInstance::VT_LASTPURCHASETIME, lastPurchaseTime, 0);
  }
  explicit LiveEventLimitSellShopProductInstanceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventLimitSellShopProductInstanceBuilder &operator=(const LiveEventLimitSellShopProductInstanceBuilder &);
  flatbuffers::Offset<LiveEventLimitSellShopProductInstance> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventLimitSellShopProductInstance>(end);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventLimitSellShopProductInstance> CreateLiveEventLimitSellShopProductInstance(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t productId = 0,
    int32_t purchaseCount = 0,
    int64_t lastPurchaseTime = 0) {
  LiveEventLimitSellShopProductInstanceBuilder builder_(_fbb);
  builder_.add_lastPurchaseTime(lastPurchaseTime);
  builder_.add_purchaseCount(purchaseCount);
  builder_.add_productId(productId);
  return builder_.Finish();
}

struct LiveEventLimitSellShopInstance FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIMESTAMP = 4,
    VT_PRODUCTS = 6
  };
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  const flatbuffers::Vector<flatbuffers::Offset<LiveEventLimitSellShopProductInstance>> *products() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LiveEventLimitSellShopProductInstance>> *>(VT_PRODUCTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           VerifyOffsetRequired(verifier, VT_PRODUCTS) &&
           verifier.VerifyVector(products()) &&
           verifier.VerifyVectorOfTables(products()) &&
           verifier.EndTable();
  }
};

struct LiveEventLimitSellShopInstanceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventLimitSellShopInstance::VT_TIMESTAMP, timestamp);
  }
  void add_products(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventLimitSellShopProductInstance>>> products) {
    fbb_.AddOffset(LiveEventLimitSellShopInstance::VT_PRODUCTS, products);
  }
  explicit LiveEventLimitSellShopInstanceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventLimitSellShopInstanceBuilder &operator=(const LiveEventLimitSellShopInstanceBuilder &);
  flatbuffers::Offset<LiveEventLimitSellShopInstance> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventLimitSellShopInstance>(end);
    fbb_.Required(o, LiveEventLimitSellShopInstance::VT_PRODUCTS);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventLimitSellShopInstance> CreateLiveEventLimitSellShopInstance(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventLimitSellShopProductInstance>>> products = 0) {
  LiveEventLimitSellShopInstanceBuilder builder_(_fbb);
  builder_.add_products(products);
  builder_.add_timestamp(timestamp);
  return builder_.Finish();
}

inline flatbuffers::Offset<LiveEventLimitSellShopInstance> CreateLiveEventLimitSellShopInstanceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    const std::vector<flatbuffers::Offset<LiveEventLimitSellShopProductInstance>> *products = nullptr) {
  return LeanPacket::CreateLiveEventLimitSellShopInstance(
      _fbb,
      timestamp,
      products ? _fbb.CreateVector<flatbuffers::Offset<LiveEventLimitSellShopProductInstance>>(*products) : 0);
}

struct LiveEventBuffInfoInstance FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BUFFID = 4,
    VT_LEVEL = 6
  };
  int32_t buffId() const {
    return GetField<int32_t>(VT_BUFFID, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BUFFID) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           verifier.EndTable();
  }
};

struct LiveEventBuffInfoInstanceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_buffId(int32_t buffId) {
    fbb_.AddElement<int32_t>(LiveEventBuffInfoInstance::VT_BUFFID, buffId, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(LiveEventBuffInfoInstance::VT_LEVEL, level, 0);
  }
  explicit LiveEventBuffInfoInstanceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventBuffInfoInstanceBuilder &operator=(const LiveEventBuffInfoInstanceBuilder &);
  flatbuffers::Offset<LiveEventBuffInfoInstance> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventBuffInfoInstance>(end);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventBuffInfoInstance> CreateLiveEventBuffInfoInstance(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t buffId = 0,
    int32_t level = 0) {
  LiveEventBuffInfoInstanceBuilder builder_(_fbb);
  builder_.add_level(level);
  builder_.add_buffId(buffId);
  return builder_.Finish();
}

struct LiveEventLimitSellShopInstanceNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INSTANCE = 4
  };
  const LiveEventLimitSellShopInstance *instance() const {
    return GetPointer<const LiveEventLimitSellShopInstance *>(VT_INSTANCE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_INSTANCE) &&
           verifier.VerifyTable(instance()) &&
           verifier.EndTable();
  }
};

struct LiveEventLimitSellShopInstanceNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_instance(flatbuffers::Offset<LiveEventLimitSellShopInstance> instance) {
    fbb_.AddOffset(LiveEventLimitSellShopInstanceNotify::VT_INSTANCE, instance);
  }
  explicit LiveEventLimitSellShopInstanceNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventLimitSellShopInstanceNotifyBuilder &operator=(const LiveEventLimitSellShopInstanceNotifyBuilder &);
  flatbuffers::Offset<LiveEventLimitSellShopInstanceNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventLimitSellShopInstanceNotify>(end);
    fbb_.Required(o, LiveEventLimitSellShopInstanceNotify::VT_INSTANCE);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventLimitSellShopInstanceNotify> CreateLiveEventLimitSellShopInstanceNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventLimitSellShopInstance> instance = 0) {
  LiveEventLimitSellShopInstanceNotifyBuilder builder_(_fbb);
  builder_.add_instance(instance);
  return builder_.Finish();
}

struct LiveEventLimitSellShopInstanceExpireNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIMESTAMP = 4,
    VT_IDLIST = 6
  };
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  const flatbuffers::Vector<int32_t> *idList() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_IDLIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           VerifyOffsetRequired(verifier, VT_IDLIST) &&
           verifier.VerifyVector(idList()) &&
           verifier.EndTable();
  }
};

struct LiveEventLimitSellShopInstanceExpireNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventLimitSellShopInstanceExpireNotify::VT_TIMESTAMP, timestamp);
  }
  void add_idList(flatbuffers::Offset<flatbuffers::Vector<int32_t>> idList) {
    fbb_.AddOffset(LiveEventLimitSellShopInstanceExpireNotify::VT_IDLIST, idList);
  }
  explicit LiveEventLimitSellShopInstanceExpireNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventLimitSellShopInstanceExpireNotifyBuilder &operator=(const LiveEventLimitSellShopInstanceExpireNotifyBuilder &);
  flatbuffers::Offset<LiveEventLimitSellShopInstanceExpireNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventLimitSellShopInstanceExpireNotify>(end);
    fbb_.Required(o, LiveEventLimitSellShopInstanceExpireNotify::VT_IDLIST);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventLimitSellShopInstanceExpireNotify> CreateLiveEventLimitSellShopInstanceExpireNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> idList = 0) {
  LiveEventLimitSellShopInstanceExpireNotifyBuilder builder_(_fbb);
  builder_.add_idList(idList);
  builder_.add_timestamp(timestamp);
  return builder_.Finish();
}

inline flatbuffers::Offset<LiveEventLimitSellShopInstanceExpireNotify> CreateLiveEventLimitSellShopInstanceExpireNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    const std::vector<int32_t> *idList = nullptr) {
  return LeanPacket::CreateLiveEventLimitSellShopInstanceExpireNotify(
      _fbb,
      timestamp,
      idList ? _fbb.CreateVector<int32_t>(*idList) : 0);
}

struct LiveEventLimitSellShopPurchaseRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIMESTAMP = 4,
    VT_PRODUCTID = 6
  };
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  int32_t productId() const {
    return GetField<int32_t>(VT_PRODUCTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           VerifyField<int32_t>(verifier, VT_PRODUCTID) &&
           verifier.EndTable();
  }
};

struct LiveEventLimitSellShopPurchaseRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventLimitSellShopPurchaseRequest::VT_TIMESTAMP, timestamp);
  }
  void add_productId(int32_t productId) {
    fbb_.AddElement<int32_t>(LiveEventLimitSellShopPurchaseRequest::VT_PRODUCTID, productId, 0);
  }
  explicit LiveEventLimitSellShopPurchaseRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventLimitSellShopPurchaseRequestBuilder &operator=(const LiveEventLimitSellShopPurchaseRequestBuilder &);
  flatbuffers::Offset<LiveEventLimitSellShopPurchaseRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventLimitSellShopPurchaseRequest>(end);
    fbb_.Required(o, LiveEventLimitSellShopPurchaseRequest::VT_TIMESTAMP);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventLimitSellShopPurchaseRequest> CreateLiveEventLimitSellShopPurchaseRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    int32_t productId = 0) {
  LiveEventLimitSellShopPurchaseRequestBuilder builder_(_fbb);
  builder_.add_productId(productId);
  builder_.add_timestamp(timestamp);
  return builder_.Finish();
}

struct LiveEventLimitSellShopPurchaseResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRODUCTID = 4,
    VT_ERROR = 6,
    VT_TIMESTAMP = 8,
    VT_PRODUCTINSTANCE = 10
  };
  int32_t productId() const {
    return GetField<int32_t>(VT_PRODUCTID, 0);
  }
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  const LiveEventLimitSellShopProductInstance *productInstance() const {
    return GetPointer<const LiveEventLimitSellShopProductInstance *>(VT_PRODUCTINSTANCE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PRODUCTID) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           VerifyOffset(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           VerifyOffset(verifier, VT_PRODUCTINSTANCE) &&
           verifier.VerifyTable(productInstance()) &&
           verifier.EndTable();
  }
};

struct LiveEventLimitSellShopPurchaseResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_productId(int32_t productId) {
    fbb_.AddElement<int32_t>(LiveEventLimitSellShopPurchaseResponse::VT_PRODUCTID, productId, 0);
  }
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(LiveEventLimitSellShopPurchaseResponse::VT_ERROR, error, 0);
  }
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventLimitSellShopPurchaseResponse::VT_TIMESTAMP, timestamp);
  }
  void add_productInstance(flatbuffers::Offset<LiveEventLimitSellShopProductInstance> productInstance) {
    fbb_.AddOffset(LiveEventLimitSellShopPurchaseResponse::VT_PRODUCTINSTANCE, productInstance);
  }
  explicit LiveEventLimitSellShopPurchaseResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventLimitSellShopPurchaseResponseBuilder &operator=(const LiveEventLimitSellShopPurchaseResponseBuilder &);
  flatbuffers::Offset<LiveEventLimitSellShopPurchaseResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventLimitSellShopPurchaseResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventLimitSellShopPurchaseResponse> CreateLiveEventLimitSellShopPurchaseResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t productId = 0,
    int32_t error = 0,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    flatbuffers::Offset<LiveEventLimitSellShopProductInstance> productInstance = 0) {
  LiveEventLimitSellShopPurchaseResponseBuilder builder_(_fbb);
  builder_.add_productInstance(productInstance);
  builder_.add_timestamp(timestamp);
  builder_.add_error(error);
  builder_.add_productId(productId);
  return builder_.Finish();
}

struct LiveEventBuffInfoInstanceNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INSTANCE = 4
  };
  const LiveEventBuffInfoInstance *instance() const {
    return GetPointer<const LiveEventBuffInfoInstance *>(VT_INSTANCE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_INSTANCE) &&
           verifier.VerifyTable(instance()) &&
           verifier.EndTable();
  }
};

struct LiveEventBuffInfoInstanceNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_instance(flatbuffers::Offset<LiveEventBuffInfoInstance> instance) {
    fbb_.AddOffset(LiveEventBuffInfoInstanceNotify::VT_INSTANCE, instance);
  }
  explicit LiveEventBuffInfoInstanceNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventBuffInfoInstanceNotifyBuilder &operator=(const LiveEventBuffInfoInstanceNotifyBuilder &);
  flatbuffers::Offset<LiveEventBuffInfoInstanceNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventBuffInfoInstanceNotify>(end);
    fbb_.Required(o, LiveEventBuffInfoInstanceNotify::VT_INSTANCE);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventBuffInfoInstanceNotify> CreateLiveEventBuffInfoInstanceNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventBuffInfoInstance> instance = 0) {
  LiveEventBuffInfoInstanceNotifyBuilder builder_(_fbb);
  builder_.add_instance(instance);
  return builder_.Finish();
}

struct LiveEventAttentionReceive FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACTIVEORDER = 4,
    VT_STATE = 6,
    VT_RECEIVETIME = 8
  };
  int16_t activeOrder() const {
    return GetField<int16_t>(VT_ACTIVEORDER, 0);
  }
  int16_t state() const {
    return GetField<int16_t>(VT_STATE, 0);
  }
  int64_t receiveTime() const {
    return GetField<int64_t>(VT_RECEIVETIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_ACTIVEORDER) &&
           VerifyField<int16_t>(verifier, VT_STATE) &&
           VerifyField<int64_t>(verifier, VT_RECEIVETIME) &&
           verifier.EndTable();
  }
};

struct LiveEventAttentionReceiveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_activeOrder(int16_t activeOrder) {
    fbb_.AddElement<int16_t>(LiveEventAttentionReceive::VT_ACTIVEORDER, activeOrder, 0);
  }
  void add_state(int16_t state) {
    fbb_.AddElement<int16_t>(LiveEventAttentionReceive::VT_STATE, state, 0);
  }
  void add_receiveTime(int64_t receiveTime) {
    fbb_.AddElement<int64_t>(LiveEventAttentionReceive::VT_RECEIVETIME, receiveTime, 0);
  }
  explicit LiveEventAttentionReceiveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventAttentionReceiveBuilder &operator=(const LiveEventAttentionReceiveBuilder &);
  flatbuffers::Offset<LiveEventAttentionReceive> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventAttentionReceive>(end);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventAttentionReceive> CreateLiveEventAttentionReceive(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t activeOrder = 0,
    int16_t state = 0,
    int64_t receiveTime = 0) {
  LiveEventAttentionReceiveBuilder builder_(_fbb);
  builder_.add_receiveTime(receiveTime);
  builder_.add_state(state);
  builder_.add_activeOrder(activeOrder);
  return builder_.Finish();
}

struct LiveEventAttentionInstance FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ATTENTIONTYPE = 4,
    VT_TIMESTAMP = 6,
    VT_RECEIVEINFOS = 8,
    VT_ENDRECEIVEINFO = 10
  };
  int32_t attentionType() const {
    return GetField<int32_t>(VT_ATTENTIONTYPE, 0);
  }
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  const flatbuffers::Vector<flatbuffers::Offset<LiveEventAttentionReceive>> *receiveInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LiveEventAttentionReceive>> *>(VT_RECEIVEINFOS);
  }
  const LiveEventAttentionReceive *endReceiveInfo() const {
    return GetPointer<const LiveEventAttentionReceive *>(VT_ENDRECEIVEINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ATTENTIONTYPE) &&
           VerifyOffset(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           VerifyOffsetRequired(verifier, VT_RECEIVEINFOS) &&
           verifier.VerifyVector(receiveInfos()) &&
           verifier.VerifyVectorOfTables(receiveInfos()) &&
           VerifyOffset(verifier, VT_ENDRECEIVEINFO) &&
           verifier.VerifyTable(endReceiveInfo()) &&
           verifier.EndTable();
  }
};

struct LiveEventAttentionInstanceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_attentionType(int32_t attentionType) {
    fbb_.AddElement<int32_t>(LiveEventAttentionInstance::VT_ATTENTIONTYPE, attentionType, 0);
  }
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventAttentionInstance::VT_TIMESTAMP, timestamp);
  }
  void add_receiveInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventAttentionReceive>>> receiveInfos) {
    fbb_.AddOffset(LiveEventAttentionInstance::VT_RECEIVEINFOS, receiveInfos);
  }
  void add_endReceiveInfo(flatbuffers::Offset<LiveEventAttentionReceive> endReceiveInfo) {
    fbb_.AddOffset(LiveEventAttentionInstance::VT_ENDRECEIVEINFO, endReceiveInfo);
  }
  explicit LiveEventAttentionInstanceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventAttentionInstanceBuilder &operator=(const LiveEventAttentionInstanceBuilder &);
  flatbuffers::Offset<LiveEventAttentionInstance> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventAttentionInstance>(end);
    fbb_.Required(o, LiveEventAttentionInstance::VT_RECEIVEINFOS);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventAttentionInstance> CreateLiveEventAttentionInstance(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t attentionType = 0,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventAttentionReceive>>> receiveInfos = 0,
    flatbuffers::Offset<LiveEventAttentionReceive> endReceiveInfo = 0) {
  LiveEventAttentionInstanceBuilder builder_(_fbb);
  builder_.add_endReceiveInfo(endReceiveInfo);
  builder_.add_receiveInfos(receiveInfos);
  builder_.add_timestamp(timestamp);
  builder_.add_attentionType(attentionType);
  return builder_.Finish();
}

inline flatbuffers::Offset<LiveEventAttentionInstance> CreateLiveEventAttentionInstanceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t attentionType = 0,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    const std::vector<flatbuffers::Offset<LiveEventAttentionReceive>> *receiveInfos = nullptr,
    flatbuffers::Offset<LiveEventAttentionReceive> endReceiveInfo = 0) {
  return LeanPacket::CreateLiveEventAttentionInstance(
      _fbb,
      attentionType,
      timestamp,
      receiveInfos ? _fbb.CreateVector<flatbuffers::Offset<LiveEventAttentionReceive>>(*receiveInfos) : 0,
      endReceiveInfo);
}

struct LiveEventAttentionNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INSTANCES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<LiveEventAttentionInstance>> *instances() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LiveEventAttentionInstance>> *>(VT_INSTANCES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_INSTANCES) &&
           verifier.VerifyVector(instances()) &&
           verifier.VerifyVectorOfTables(instances()) &&
           verifier.EndTable();
  }
};

struct LiveEventAttentionNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_instances(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventAttentionInstance>>> instances) {
    fbb_.AddOffset(LiveEventAttentionNotify::VT_INSTANCES, instances);
  }
  explicit LiveEventAttentionNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventAttentionNotifyBuilder &operator=(const LiveEventAttentionNotifyBuilder &);
  flatbuffers::Offset<LiveEventAttentionNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventAttentionNotify>(end);
    fbb_.Required(o, LiveEventAttentionNotify::VT_INSTANCES);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventAttentionNotify> CreateLiveEventAttentionNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventAttentionInstance>>> instances = 0) {
  LiveEventAttentionNotifyBuilder builder_(_fbb);
  builder_.add_instances(instances);
  return builder_.Finish();
}

inline flatbuffers::Offset<LiveEventAttentionNotify> CreateLiveEventAttentionNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<LiveEventAttentionInstance>> *instances = nullptr) {
  return LeanPacket::CreateLiveEventAttentionNotify(
      _fbb,
      instances ? _fbb.CreateVector<flatbuffers::Offset<LiveEventAttentionInstance>>(*instances) : 0);
}

struct LiveEventAttentionReceiveNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ATTENTIONTYPE = 4,
    VT_TIMESTAMP = 6,
    VT_ACTIVEORDER = 8,
    VT_STATE = 10
  };
  int32_t attentionType() const {
    return GetField<int32_t>(VT_ATTENTIONTYPE, 0);
  }
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  int16_t activeOrder() const {
    return GetField<int16_t>(VT_ACTIVEORDER, 0);
  }
  int16_t state() const {
    return GetField<int16_t>(VT_STATE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ATTENTIONTYPE) &&
           VerifyOffset(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           VerifyField<int16_t>(verifier, VT_ACTIVEORDER) &&
           VerifyField<int16_t>(verifier, VT_STATE) &&
           verifier.EndTable();
  }
};

struct LiveEventAttentionReceiveNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_attentionType(int32_t attentionType) {
    fbb_.AddElement<int32_t>(LiveEventAttentionReceiveNotify::VT_ATTENTIONTYPE, attentionType, 0);
  }
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventAttentionReceiveNotify::VT_TIMESTAMP, timestamp);
  }
  void add_activeOrder(int16_t activeOrder) {
    fbb_.AddElement<int16_t>(LiveEventAttentionReceiveNotify::VT_ACTIVEORDER, activeOrder, 0);
  }
  void add_state(int16_t state) {
    fbb_.AddElement<int16_t>(LiveEventAttentionReceiveNotify::VT_STATE, state, 0);
  }
  explicit LiveEventAttentionReceiveNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventAttentionReceiveNotifyBuilder &operator=(const LiveEventAttentionReceiveNotifyBuilder &);
  flatbuffers::Offset<LiveEventAttentionReceiveNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventAttentionReceiveNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventAttentionReceiveNotify> CreateLiveEventAttentionReceiveNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t attentionType = 0,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    int16_t activeOrder = 0,
    int16_t state = 0) {
  LiveEventAttentionReceiveNotifyBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_attentionType(attentionType);
  builder_.add_state(state);
  builder_.add_activeOrder(activeOrder);
  return builder_.Finish();
}

struct LiveEventAttentionEndReceiveNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ATTENTIONTYPE = 4,
    VT_TIMESTAMP = 6,
    VT_STATE = 8
  };
  int32_t attentionType() const {
    return GetField<int32_t>(VT_ATTENTIONTYPE, 0);
  }
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  int16_t state() const {
    return GetField<int16_t>(VT_STATE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ATTENTIONTYPE) &&
           VerifyOffset(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           VerifyField<int16_t>(verifier, VT_STATE) &&
           verifier.EndTable();
  }
};

struct LiveEventAttentionEndReceiveNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_attentionType(int32_t attentionType) {
    fbb_.AddElement<int32_t>(LiveEventAttentionEndReceiveNotify::VT_ATTENTIONTYPE, attentionType, 0);
  }
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventAttentionEndReceiveNotify::VT_TIMESTAMP, timestamp);
  }
  void add_state(int16_t state) {
    fbb_.AddElement<int16_t>(LiveEventAttentionEndReceiveNotify::VT_STATE, state, 0);
  }
  explicit LiveEventAttentionEndReceiveNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventAttentionEndReceiveNotifyBuilder &operator=(const LiveEventAttentionEndReceiveNotifyBuilder &);
  flatbuffers::Offset<LiveEventAttentionEndReceiveNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventAttentionEndReceiveNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventAttentionEndReceiveNotify> CreateLiveEventAttentionEndReceiveNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t attentionType = 0,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    int16_t state = 0) {
  LiveEventAttentionEndReceiveNotifyBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_attentionType(attentionType);
  builder_.add_state(state);
  return builder_.Finish();
}

struct LiveEventLevelBuffDataNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATA = 4
  };
  const LiveEventBuffDataSheet *data() const {
    return GetPointer<const LiveEventBuffDataSheet *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyTable(data()) &&
           verifier.EndTable();
  }
};

struct LiveEventLevelBuffDataNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<LiveEventBuffDataSheet> data) {
    fbb_.AddOffset(LiveEventLevelBuffDataNotify::VT_DATA, data);
  }
  explicit LiveEventLevelBuffDataNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventLevelBuffDataNotifyBuilder &operator=(const LiveEventLevelBuffDataNotifyBuilder &);
  flatbuffers::Offset<LiveEventLevelBuffDataNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventLevelBuffDataNotify>(end);
    fbb_.Required(o, LiveEventLevelBuffDataNotify::VT_DATA);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventLevelBuffDataNotify> CreateLiveEventLevelBuffDataNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventBuffDataSheet> data = 0) {
  LiveEventLevelBuffDataNotifyBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

struct LiveEventNewbieBuffDataNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATA = 4
  };
  const LiveEventBuffDataSheet *data() const {
    return GetPointer<const LiveEventBuffDataSheet *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyTable(data()) &&
           verifier.EndTable();
  }
};

struct LiveEventNewbieBuffDataNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<LiveEventBuffDataSheet> data) {
    fbb_.AddOffset(LiveEventNewbieBuffDataNotify::VT_DATA, data);
  }
  explicit LiveEventNewbieBuffDataNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventNewbieBuffDataNotifyBuilder &operator=(const LiveEventNewbieBuffDataNotifyBuilder &);
  flatbuffers::Offset<LiveEventNewbieBuffDataNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventNewbieBuffDataNotify>(end);
    fbb_.Required(o, LiveEventNewbieBuffDataNotify::VT_DATA);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventNewbieBuffDataNotify> CreateLiveEventNewbieBuffDataNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventBuffDataSheet> data = 0) {
  LiveEventNewbieBuffDataNotifyBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

struct LiveEventAttentionRewardReceiveRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIMESTAMP = 4,
    VT_ACTIVEORDER = 6
  };
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  int16_t activeOrder() const {
    return GetField<int16_t>(VT_ACTIVEORDER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           VerifyField<int16_t>(verifier, VT_ACTIVEORDER) &&
           verifier.EndTable();
  }
};

struct LiveEventAttentionRewardReceiveRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventAttentionRewardReceiveRequest::VT_TIMESTAMP, timestamp);
  }
  void add_activeOrder(int16_t activeOrder) {
    fbb_.AddElement<int16_t>(LiveEventAttentionRewardReceiveRequest::VT_ACTIVEORDER, activeOrder, 0);
  }
  explicit LiveEventAttentionRewardReceiveRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventAttentionRewardReceiveRequestBuilder &operator=(const LiveEventAttentionRewardReceiveRequestBuilder &);
  flatbuffers::Offset<LiveEventAttentionRewardReceiveRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventAttentionRewardReceiveRequest>(end);
    fbb_.Required(o, LiveEventAttentionRewardReceiveRequest::VT_TIMESTAMP);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventAttentionRewardReceiveRequest> CreateLiveEventAttentionRewardReceiveRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    int16_t activeOrder = 0) {
  LiveEventAttentionRewardReceiveRequestBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_activeOrder(activeOrder);
  return builder_.Finish();
}

struct LiveEventAttentionRewardReceiveResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACTIVEORDER = 4,
    VT_ERROR = 6,
    VT_TIMESTAMP = 8
  };
  int16_t activeOrder() const {
    return GetField<int16_t>(VT_ACTIVEORDER, 0);
  }
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_ACTIVEORDER) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           VerifyOffsetRequired(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           verifier.EndTable();
  }
};

struct LiveEventAttentionRewardReceiveResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_activeOrder(int16_t activeOrder) {
    fbb_.AddElement<int16_t>(LiveEventAttentionRewardReceiveResponse::VT_ACTIVEORDER, activeOrder, 0);
  }
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(LiveEventAttentionRewardReceiveResponse::VT_ERROR, error, 0);
  }
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventAttentionRewardReceiveResponse::VT_TIMESTAMP, timestamp);
  }
  explicit LiveEventAttentionRewardReceiveResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventAttentionRewardReceiveResponseBuilder &operator=(const LiveEventAttentionRewardReceiveResponseBuilder &);
  flatbuffers::Offset<LiveEventAttentionRewardReceiveResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventAttentionRewardReceiveResponse>(end);
    fbb_.Required(o, LiveEventAttentionRewardReceiveResponse::VT_TIMESTAMP);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventAttentionRewardReceiveResponse> CreateLiveEventAttentionRewardReceiveResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t activeOrder = 0,
    int32_t error = 0,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0) {
  LiveEventAttentionRewardReceiveResponseBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_error(error);
  builder_.add_activeOrder(activeOrder);
  return builder_.Finish();
}

struct LiveEventAttentionReturnRewardReceiveRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIMESTAMP = 4,
    VT_ACTIVEORDER = 6
  };
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  int16_t activeOrder() const {
    return GetField<int16_t>(VT_ACTIVEORDER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           VerifyField<int16_t>(verifier, VT_ACTIVEORDER) &&
           verifier.EndTable();
  }
};

struct LiveEventAttentionReturnRewardReceiveRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventAttentionReturnRewardReceiveRequest::VT_TIMESTAMP, timestamp);
  }
  void add_activeOrder(int16_t activeOrder) {
    fbb_.AddElement<int16_t>(LiveEventAttentionReturnRewardReceiveRequest::VT_ACTIVEORDER, activeOrder, 0);
  }
  explicit LiveEventAttentionReturnRewardReceiveRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventAttentionReturnRewardReceiveRequestBuilder &operator=(const LiveEventAttentionReturnRewardReceiveRequestBuilder &);
  flatbuffers::Offset<LiveEventAttentionReturnRewardReceiveRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventAttentionReturnRewardReceiveRequest>(end);
    fbb_.Required(o, LiveEventAttentionReturnRewardReceiveRequest::VT_TIMESTAMP);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventAttentionReturnRewardReceiveRequest> CreateLiveEventAttentionReturnRewardReceiveRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    int16_t activeOrder = 0) {
  LiveEventAttentionReturnRewardReceiveRequestBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_activeOrder(activeOrder);
  return builder_.Finish();
}

struct LiveEventAttentionReturnRewardReceiveResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACTIVEORDER = 4,
    VT_ERROR = 6,
    VT_TIMESTAMP = 8
  };
  int16_t activeOrder() const {
    return GetField<int16_t>(VT_ACTIVEORDER, 0);
  }
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_ACTIVEORDER) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           VerifyOffsetRequired(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           verifier.EndTable();
  }
};

struct LiveEventAttentionReturnRewardReceiveResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_activeOrder(int16_t activeOrder) {
    fbb_.AddElement<int16_t>(LiveEventAttentionReturnRewardReceiveResponse::VT_ACTIVEORDER, activeOrder, 0);
  }
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(LiveEventAttentionReturnRewardReceiveResponse::VT_ERROR, error, 0);
  }
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventAttentionReturnRewardReceiveResponse::VT_TIMESTAMP, timestamp);
  }
  explicit LiveEventAttentionReturnRewardReceiveResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventAttentionReturnRewardReceiveResponseBuilder &operator=(const LiveEventAttentionReturnRewardReceiveResponseBuilder &);
  flatbuffers::Offset<LiveEventAttentionReturnRewardReceiveResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventAttentionReturnRewardReceiveResponse>(end);
    fbb_.Required(o, LiveEventAttentionReturnRewardReceiveResponse::VT_TIMESTAMP);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventAttentionReturnRewardReceiveResponse> CreateLiveEventAttentionReturnRewardReceiveResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t activeOrder = 0,
    int32_t error = 0,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0) {
  LiveEventAttentionReturnRewardReceiveResponseBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_error(error);
  builder_.add_activeOrder(activeOrder);
  return builder_.Finish();
}

struct LiveEventAttentionNewbieRewardReceiveRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIMESTAMP = 4,
    VT_ACTIVEORDER = 6
  };
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  int16_t activeOrder() const {
    return GetField<int16_t>(VT_ACTIVEORDER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           VerifyField<int16_t>(verifier, VT_ACTIVEORDER) &&
           verifier.EndTable();
  }
};

struct LiveEventAttentionNewbieRewardReceiveRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventAttentionNewbieRewardReceiveRequest::VT_TIMESTAMP, timestamp);
  }
  void add_activeOrder(int16_t activeOrder) {
    fbb_.AddElement<int16_t>(LiveEventAttentionNewbieRewardReceiveRequest::VT_ACTIVEORDER, activeOrder, 0);
  }
  explicit LiveEventAttentionNewbieRewardReceiveRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventAttentionNewbieRewardReceiveRequestBuilder &operator=(const LiveEventAttentionNewbieRewardReceiveRequestBuilder &);
  flatbuffers::Offset<LiveEventAttentionNewbieRewardReceiveRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventAttentionNewbieRewardReceiveRequest>(end);
    fbb_.Required(o, LiveEventAttentionNewbieRewardReceiveRequest::VT_TIMESTAMP);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventAttentionNewbieRewardReceiveRequest> CreateLiveEventAttentionNewbieRewardReceiveRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    int16_t activeOrder = 0) {
  LiveEventAttentionNewbieRewardReceiveRequestBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_activeOrder(activeOrder);
  return builder_.Finish();
}

struct LiveEventAttentionNewbieRewardReceiveResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACTIVEORDER = 4,
    VT_ERROR = 6,
    VT_TIMESTAMP = 8
  };
  int16_t activeOrder() const {
    return GetField<int16_t>(VT_ACTIVEORDER, 0);
  }
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_ACTIVEORDER) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           VerifyOffsetRequired(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           verifier.EndTable();
  }
};

struct LiveEventAttentionNewbieRewardReceiveResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_activeOrder(int16_t activeOrder) {
    fbb_.AddElement<int16_t>(LiveEventAttentionNewbieRewardReceiveResponse::VT_ACTIVEORDER, activeOrder, 0);
  }
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(LiveEventAttentionNewbieRewardReceiveResponse::VT_ERROR, error, 0);
  }
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventAttentionNewbieRewardReceiveResponse::VT_TIMESTAMP, timestamp);
  }
  explicit LiveEventAttentionNewbieRewardReceiveResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventAttentionNewbieRewardReceiveResponseBuilder &operator=(const LiveEventAttentionNewbieRewardReceiveResponseBuilder &);
  flatbuffers::Offset<LiveEventAttentionNewbieRewardReceiveResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventAttentionNewbieRewardReceiveResponse>(end);
    fbb_.Required(o, LiveEventAttentionNewbieRewardReceiveResponse::VT_TIMESTAMP);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventAttentionNewbieRewardReceiveResponse> CreateLiveEventAttentionNewbieRewardReceiveResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t activeOrder = 0,
    int32_t error = 0,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0) {
  LiveEventAttentionNewbieRewardReceiveResponseBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_error(error);
  builder_.add_activeOrder(activeOrder);
  return builder_.Finish();
}

struct LiveEventAttentionEndRewardReceiveRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIMESTAMP = 4,
    VT_ACTIVEORDER = 6
  };
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  int16_t activeOrder() const {
    return GetField<int16_t>(VT_ACTIVEORDER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           VerifyField<int16_t>(verifier, VT_ACTIVEORDER) &&
           verifier.EndTable();
  }
};

struct LiveEventAttentionEndRewardReceiveRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventAttentionEndRewardReceiveRequest::VT_TIMESTAMP, timestamp);
  }
  void add_activeOrder(int16_t activeOrder) {
    fbb_.AddElement<int16_t>(LiveEventAttentionEndRewardReceiveRequest::VT_ACTIVEORDER, activeOrder, 0);
  }
  explicit LiveEventAttentionEndRewardReceiveRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventAttentionEndRewardReceiveRequestBuilder &operator=(const LiveEventAttentionEndRewardReceiveRequestBuilder &);
  flatbuffers::Offset<LiveEventAttentionEndRewardReceiveRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventAttentionEndRewardReceiveRequest>(end);
    fbb_.Required(o, LiveEventAttentionEndRewardReceiveRequest::VT_TIMESTAMP);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventAttentionEndRewardReceiveRequest> CreateLiveEventAttentionEndRewardReceiveRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    int16_t activeOrder = 0) {
  LiveEventAttentionEndRewardReceiveRequestBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_activeOrder(activeOrder);
  return builder_.Finish();
}

struct LiveEventAttentionEndRewardReceiveResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACTIVEORDER = 4,
    VT_ERROR = 6,
    VT_TIMESTAMP = 8
  };
  int16_t activeOrder() const {
    return GetField<int16_t>(VT_ACTIVEORDER, 0);
  }
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_ACTIVEORDER) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           VerifyOffsetRequired(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           verifier.EndTable();
  }
};

struct LiveEventAttentionEndRewardReceiveResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_activeOrder(int16_t activeOrder) {
    fbb_.AddElement<int16_t>(LiveEventAttentionEndRewardReceiveResponse::VT_ACTIVEORDER, activeOrder, 0);
  }
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(LiveEventAttentionEndRewardReceiveResponse::VT_ERROR, error, 0);
  }
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventAttentionEndRewardReceiveResponse::VT_TIMESTAMP, timestamp);
  }
  explicit LiveEventAttentionEndRewardReceiveResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventAttentionEndRewardReceiveResponseBuilder &operator=(const LiveEventAttentionEndRewardReceiveResponseBuilder &);
  flatbuffers::Offset<LiveEventAttentionEndRewardReceiveResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventAttentionEndRewardReceiveResponse>(end);
    fbb_.Required(o, LiveEventAttentionEndRewardReceiveResponse::VT_TIMESTAMP);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventAttentionEndRewardReceiveResponse> CreateLiveEventAttentionEndRewardReceiveResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t activeOrder = 0,
    int32_t error = 0,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0) {
  LiveEventAttentionEndRewardReceiveResponseBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_error(error);
  builder_.add_activeOrder(activeOrder);
  return builder_.Finish();
}

struct LiveEventAttentionEndReturnRewardReceiveRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIMESTAMP = 4,
    VT_ACTIVEORDER = 6
  };
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  int16_t activeOrder() const {
    return GetField<int16_t>(VT_ACTIVEORDER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           VerifyField<int16_t>(verifier, VT_ACTIVEORDER) &&
           verifier.EndTable();
  }
};

struct LiveEventAttentionEndReturnRewardReceiveRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventAttentionEndReturnRewardReceiveRequest::VT_TIMESTAMP, timestamp);
  }
  void add_activeOrder(int16_t activeOrder) {
    fbb_.AddElement<int16_t>(LiveEventAttentionEndReturnRewardReceiveRequest::VT_ACTIVEORDER, activeOrder, 0);
  }
  explicit LiveEventAttentionEndReturnRewardReceiveRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventAttentionEndReturnRewardReceiveRequestBuilder &operator=(const LiveEventAttentionEndReturnRewardReceiveRequestBuilder &);
  flatbuffers::Offset<LiveEventAttentionEndReturnRewardReceiveRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventAttentionEndReturnRewardReceiveRequest>(end);
    fbb_.Required(o, LiveEventAttentionEndReturnRewardReceiveRequest::VT_TIMESTAMP);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventAttentionEndReturnRewardReceiveRequest> CreateLiveEventAttentionEndReturnRewardReceiveRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    int16_t activeOrder = 0) {
  LiveEventAttentionEndReturnRewardReceiveRequestBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_activeOrder(activeOrder);
  return builder_.Finish();
}

struct LiveEventAttentionEndReturnRewardReceiveResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACTIVEORDER = 4,
    VT_ERROR = 6,
    VT_TIMESTAMP = 8
  };
  int16_t activeOrder() const {
    return GetField<int16_t>(VT_ACTIVEORDER, 0);
  }
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_ACTIVEORDER) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           VerifyOffsetRequired(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           verifier.EndTable();
  }
};

struct LiveEventAttentionEndReturnRewardReceiveResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_activeOrder(int16_t activeOrder) {
    fbb_.AddElement<int16_t>(LiveEventAttentionEndReturnRewardReceiveResponse::VT_ACTIVEORDER, activeOrder, 0);
  }
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(LiveEventAttentionEndReturnRewardReceiveResponse::VT_ERROR, error, 0);
  }
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventAttentionEndReturnRewardReceiveResponse::VT_TIMESTAMP, timestamp);
  }
  explicit LiveEventAttentionEndReturnRewardReceiveResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventAttentionEndReturnRewardReceiveResponseBuilder &operator=(const LiveEventAttentionEndReturnRewardReceiveResponseBuilder &);
  flatbuffers::Offset<LiveEventAttentionEndReturnRewardReceiveResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventAttentionEndReturnRewardReceiveResponse>(end);
    fbb_.Required(o, LiveEventAttentionEndReturnRewardReceiveResponse::VT_TIMESTAMP);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventAttentionEndReturnRewardReceiveResponse> CreateLiveEventAttentionEndReturnRewardReceiveResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t activeOrder = 0,
    int32_t error = 0,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0) {
  LiveEventAttentionEndReturnRewardReceiveResponseBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_error(error);
  builder_.add_activeOrder(activeOrder);
  return builder_.Finish();
}

struct LiveEventAttentionEndNewbieRewardReceiveRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIMESTAMP = 4,
    VT_ACTIVEORDER = 6
  };
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  int16_t activeOrder() const {
    return GetField<int16_t>(VT_ACTIVEORDER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           VerifyField<int16_t>(verifier, VT_ACTIVEORDER) &&
           verifier.EndTable();
  }
};

struct LiveEventAttentionEndNewbieRewardReceiveRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventAttentionEndNewbieRewardReceiveRequest::VT_TIMESTAMP, timestamp);
  }
  void add_activeOrder(int16_t activeOrder) {
    fbb_.AddElement<int16_t>(LiveEventAttentionEndNewbieRewardReceiveRequest::VT_ACTIVEORDER, activeOrder, 0);
  }
  explicit LiveEventAttentionEndNewbieRewardReceiveRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventAttentionEndNewbieRewardReceiveRequestBuilder &operator=(const LiveEventAttentionEndNewbieRewardReceiveRequestBuilder &);
  flatbuffers::Offset<LiveEventAttentionEndNewbieRewardReceiveRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventAttentionEndNewbieRewardReceiveRequest>(end);
    fbb_.Required(o, LiveEventAttentionEndNewbieRewardReceiveRequest::VT_TIMESTAMP);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventAttentionEndNewbieRewardReceiveRequest> CreateLiveEventAttentionEndNewbieRewardReceiveRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    int16_t activeOrder = 0) {
  LiveEventAttentionEndNewbieRewardReceiveRequestBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_activeOrder(activeOrder);
  return builder_.Finish();
}

struct LiveEventAttentionEndNewbieRewardReceiveResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACTIVEORDER = 4,
    VT_ERROR = 6,
    VT_TIMESTAMP = 8
  };
  int16_t activeOrder() const {
    return GetField<int16_t>(VT_ACTIVEORDER, 0);
  }
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_ACTIVEORDER) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           VerifyOffsetRequired(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           verifier.EndTable();
  }
};

struct LiveEventAttentionEndNewbieRewardReceiveResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_activeOrder(int16_t activeOrder) {
    fbb_.AddElement<int16_t>(LiveEventAttentionEndNewbieRewardReceiveResponse::VT_ACTIVEORDER, activeOrder, 0);
  }
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(LiveEventAttentionEndNewbieRewardReceiveResponse::VT_ERROR, error, 0);
  }
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventAttentionEndNewbieRewardReceiveResponse::VT_TIMESTAMP, timestamp);
  }
  explicit LiveEventAttentionEndNewbieRewardReceiveResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventAttentionEndNewbieRewardReceiveResponseBuilder &operator=(const LiveEventAttentionEndNewbieRewardReceiveResponseBuilder &);
  flatbuffers::Offset<LiveEventAttentionEndNewbieRewardReceiveResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventAttentionEndNewbieRewardReceiveResponse>(end);
    fbb_.Required(o, LiveEventAttentionEndNewbieRewardReceiveResponse::VT_TIMESTAMP);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventAttentionEndNewbieRewardReceiveResponse> CreateLiveEventAttentionEndNewbieRewardReceiveResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t activeOrder = 0,
    int32_t error = 0,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0) {
  LiveEventAttentionEndNewbieRewardReceiveResponseBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_error(error);
  builder_.add_activeOrder(activeOrder);
  return builder_.Finish();
}

struct LiveEventLevelUpReward FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMID = 4,
    VT_COSTTYPE = 6,
    VT_COUNT = 8
  };
  int32_t itemId() const {
    return GetField<int32_t>(VT_ITEMID, 0);
  }
  int32_t costType() const {
    return GetField<int32_t>(VT_COSTTYPE, 0);
  }
  int32_t count() const {
    return GetField<int32_t>(VT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ITEMID) &&
           VerifyField<int32_t>(verifier, VT_COSTTYPE) &&
           VerifyField<int32_t>(verifier, VT_COUNT) &&
           verifier.EndTable();
  }
};

struct LiveEventLevelUpRewardBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemId(int32_t itemId) {
    fbb_.AddElement<int32_t>(LiveEventLevelUpReward::VT_ITEMID, itemId, 0);
  }
  void add_costType(int32_t costType) {
    fbb_.AddElement<int32_t>(LiveEventLevelUpReward::VT_COSTTYPE, costType, 0);
  }
  void add_count(int32_t count) {
    fbb_.AddElement<int32_t>(LiveEventLevelUpReward::VT_COUNT, count, 0);
  }
  explicit LiveEventLevelUpRewardBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventLevelUpRewardBuilder &operator=(const LiveEventLevelUpRewardBuilder &);
  flatbuffers::Offset<LiveEventLevelUpReward> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventLevelUpReward>(end);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventLevelUpReward> CreateLiveEventLevelUpReward(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t itemId = 0,
    int32_t costType = 0,
    int32_t count = 0) {
  LiveEventLevelUpRewardBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_costType(costType);
  builder_.add_itemId(itemId);
  return builder_.Finish();
}

struct LiveEventLevelUpData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GOALLEVEL = 4,
    VT_REWARDS = 6
  };
  int32_t goalLevel() const {
    return GetField<int32_t>(VT_GOALLEVEL, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<LiveEventLevelUpReward>> *rewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LiveEventLevelUpReward>> *>(VT_REWARDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_GOALLEVEL) &&
           VerifyOffsetRequired(verifier, VT_REWARDS) &&
           verifier.VerifyVector(rewards()) &&
           verifier.VerifyVectorOfTables(rewards()) &&
           verifier.EndTable();
  }
};

struct LiveEventLevelUpDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_goalLevel(int32_t goalLevel) {
    fbb_.AddElement<int32_t>(LiveEventLevelUpData::VT_GOALLEVEL, goalLevel, 0);
  }
  void add_rewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventLevelUpReward>>> rewards) {
    fbb_.AddOffset(LiveEventLevelUpData::VT_REWARDS, rewards);
  }
  explicit LiveEventLevelUpDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventLevelUpDataBuilder &operator=(const LiveEventLevelUpDataBuilder &);
  flatbuffers::Offset<LiveEventLevelUpData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventLevelUpData>(end);
    fbb_.Required(o, LiveEventLevelUpData::VT_REWARDS);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventLevelUpData> CreateLiveEventLevelUpData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t goalLevel = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventLevelUpReward>>> rewards = 0) {
  LiveEventLevelUpDataBuilder builder_(_fbb);
  builder_.add_rewards(rewards);
  builder_.add_goalLevel(goalLevel);
  return builder_.Finish();
}

inline flatbuffers::Offset<LiveEventLevelUpData> CreateLiveEventLevelUpDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t goalLevel = 0,
    const std::vector<flatbuffers::Offset<LiveEventLevelUpReward>> *rewards = nullptr) {
  return LeanPacket::CreateLiveEventLevelUpData(
      _fbb,
      goalLevel,
      rewards ? _fbb.CreateVector<flatbuffers::Offset<LiveEventLevelUpReward>>(*rewards) : 0);
}

struct LiveEventLevelUpDataSheet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HEADER = 4,
    VT_RETURNTIME = 6,
    VT_LEVELUP = 8
  };
  const LiveEventHeader *header() const {
    return GetPointer<const LiveEventHeader *>(VT_HEADER);
  }
  int64_t returnTime() const {
    return GetField<int64_t>(VT_RETURNTIME, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<LiveEventLevelUpData>> *levelUp() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LiveEventLevelUpData>> *>(VT_LEVELUP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<int64_t>(verifier, VT_RETURNTIME) &&
           VerifyOffsetRequired(verifier, VT_LEVELUP) &&
           verifier.VerifyVector(levelUp()) &&
           verifier.VerifyVectorOfTables(levelUp()) &&
           verifier.EndTable();
  }
};

struct LiveEventLevelUpDataSheetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_header(flatbuffers::Offset<LiveEventHeader> header) {
    fbb_.AddOffset(LiveEventLevelUpDataSheet::VT_HEADER, header);
  }
  void add_returnTime(int64_t returnTime) {
    fbb_.AddElement<int64_t>(LiveEventLevelUpDataSheet::VT_RETURNTIME, returnTime, 0);
  }
  void add_levelUp(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventLevelUpData>>> levelUp) {
    fbb_.AddOffset(LiveEventLevelUpDataSheet::VT_LEVELUP, levelUp);
  }
  explicit LiveEventLevelUpDataSheetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventLevelUpDataSheetBuilder &operator=(const LiveEventLevelUpDataSheetBuilder &);
  flatbuffers::Offset<LiveEventLevelUpDataSheet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventLevelUpDataSheet>(end);
    fbb_.Required(o, LiveEventLevelUpDataSheet::VT_HEADER);
    fbb_.Required(o, LiveEventLevelUpDataSheet::VT_LEVELUP);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventLevelUpDataSheet> CreateLiveEventLevelUpDataSheet(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventHeader> header = 0,
    int64_t returnTime = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventLevelUpData>>> levelUp = 0) {
  LiveEventLevelUpDataSheetBuilder builder_(_fbb);
  builder_.add_returnTime(returnTime);
  builder_.add_levelUp(levelUp);
  builder_.add_header(header);
  return builder_.Finish();
}

inline flatbuffers::Offset<LiveEventLevelUpDataSheet> CreateLiveEventLevelUpDataSheetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventHeader> header = 0,
    int64_t returnTime = 0,
    const std::vector<flatbuffers::Offset<LiveEventLevelUpData>> *levelUp = nullptr) {
  return LeanPacket::CreateLiveEventLevelUpDataSheet(
      _fbb,
      header,
      returnTime,
      levelUp ? _fbb.CreateVector<flatbuffers::Offset<LiveEventLevelUpData>>(*levelUp) : 0);
}

/// LIVE_EVENT_LEVELUP_EVENT_DATA_NOTIFY
/// LIVE_EVENT_LEVELUP_NEWBIE_DATA_NOTIFY
/// LIVE_EVENT_LEVELUP_RETURN_DATA_NOTIFY
struct LiveEventLevelUpDataNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATA = 4
  };
  const LiveEventLevelUpDataSheet *data() const {
    return GetPointer<const LiveEventLevelUpDataSheet *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyTable(data()) &&
           verifier.EndTable();
  }
};

struct LiveEventLevelUpDataNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<LiveEventLevelUpDataSheet> data) {
    fbb_.AddOffset(LiveEventLevelUpDataNotify::VT_DATA, data);
  }
  explicit LiveEventLevelUpDataNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventLevelUpDataNotifyBuilder &operator=(const LiveEventLevelUpDataNotifyBuilder &);
  flatbuffers::Offset<LiveEventLevelUpDataNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventLevelUpDataNotify>(end);
    fbb_.Required(o, LiveEventLevelUpDataNotify::VT_DATA);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventLevelUpDataNotify> CreateLiveEventLevelUpDataNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LiveEventLevelUpDataSheet> data = 0) {
  LiveEventLevelUpDataNotifyBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

struct LiveEventLevelUpReceive FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GOALLEVEL = 4,
    VT_STATE = 6,
    VT_RECEIVETIME = 8
  };
  int32_t goalLevel() const {
    return GetField<int32_t>(VT_GOALLEVEL, 0);
  }
  int16_t state() const {
    return GetField<int16_t>(VT_STATE, 0);
  }
  int64_t receiveTime() const {
    return GetField<int64_t>(VT_RECEIVETIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_GOALLEVEL) &&
           VerifyField<int16_t>(verifier, VT_STATE) &&
           VerifyField<int64_t>(verifier, VT_RECEIVETIME) &&
           verifier.EndTable();
  }
};

struct LiveEventLevelUpReceiveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_goalLevel(int32_t goalLevel) {
    fbb_.AddElement<int32_t>(LiveEventLevelUpReceive::VT_GOALLEVEL, goalLevel, 0);
  }
  void add_state(int16_t state) {
    fbb_.AddElement<int16_t>(LiveEventLevelUpReceive::VT_STATE, state, 0);
  }
  void add_receiveTime(int64_t receiveTime) {
    fbb_.AddElement<int64_t>(LiveEventLevelUpReceive::VT_RECEIVETIME, receiveTime, 0);
  }
  explicit LiveEventLevelUpReceiveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventLevelUpReceiveBuilder &operator=(const LiveEventLevelUpReceiveBuilder &);
  flatbuffers::Offset<LiveEventLevelUpReceive> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventLevelUpReceive>(end);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventLevelUpReceive> CreateLiveEventLevelUpReceive(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t goalLevel = 0,
    int16_t state = 0,
    int64_t receiveTime = 0) {
  LiveEventLevelUpReceiveBuilder builder_(_fbb);
  builder_.add_receiveTime(receiveTime);
  builder_.add_goalLevel(goalLevel);
  builder_.add_state(state);
  return builder_.Finish();
}

struct LiveEventLevelUpInstance FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EVENTTYPE = 4,
    VT_TIMESTAMP = 6,
    VT_RECEIVEINFOS = 8
  };
  int32_t eventType() const {
    return GetField<int32_t>(VT_EVENTTYPE, 0);
  }
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  const flatbuffers::Vector<flatbuffers::Offset<LiveEventLevelUpReceive>> *receiveInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LiveEventLevelUpReceive>> *>(VT_RECEIVEINFOS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_EVENTTYPE) &&
           VerifyOffsetRequired(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           VerifyOffsetRequired(verifier, VT_RECEIVEINFOS) &&
           verifier.VerifyVector(receiveInfos()) &&
           verifier.VerifyVectorOfTables(receiveInfos()) &&
           verifier.EndTable();
  }
};

struct LiveEventLevelUpInstanceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eventType(int32_t eventType) {
    fbb_.AddElement<int32_t>(LiveEventLevelUpInstance::VT_EVENTTYPE, eventType, 0);
  }
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventLevelUpInstance::VT_TIMESTAMP, timestamp);
  }
  void add_receiveInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventLevelUpReceive>>> receiveInfos) {
    fbb_.AddOffset(LiveEventLevelUpInstance::VT_RECEIVEINFOS, receiveInfos);
  }
  explicit LiveEventLevelUpInstanceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventLevelUpInstanceBuilder &operator=(const LiveEventLevelUpInstanceBuilder &);
  flatbuffers::Offset<LiveEventLevelUpInstance> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventLevelUpInstance>(end);
    fbb_.Required(o, LiveEventLevelUpInstance::VT_TIMESTAMP);
    fbb_.Required(o, LiveEventLevelUpInstance::VT_RECEIVEINFOS);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventLevelUpInstance> CreateLiveEventLevelUpInstance(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t eventType = 0,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventLevelUpReceive>>> receiveInfos = 0) {
  LiveEventLevelUpInstanceBuilder builder_(_fbb);
  builder_.add_receiveInfos(receiveInfos);
  builder_.add_timestamp(timestamp);
  builder_.add_eventType(eventType);
  return builder_.Finish();
}

inline flatbuffers::Offset<LiveEventLevelUpInstance> CreateLiveEventLevelUpInstanceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t eventType = 0,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    const std::vector<flatbuffers::Offset<LiveEventLevelUpReceive>> *receiveInfos = nullptr) {
  return LeanPacket::CreateLiveEventLevelUpInstance(
      _fbb,
      eventType,
      timestamp,
      receiveInfos ? _fbb.CreateVector<flatbuffers::Offset<LiveEventLevelUpReceive>>(*receiveInfos) : 0);
}

struct LiveEventLevelUpNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INSTANCES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<LiveEventLevelUpInstance>> *instances() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LiveEventLevelUpInstance>> *>(VT_INSTANCES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_INSTANCES) &&
           verifier.VerifyVector(instances()) &&
           verifier.VerifyVectorOfTables(instances()) &&
           verifier.EndTable();
  }
};

struct LiveEventLevelUpNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_instances(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventLevelUpInstance>>> instances) {
    fbb_.AddOffset(LiveEventLevelUpNotify::VT_INSTANCES, instances);
  }
  explicit LiveEventLevelUpNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventLevelUpNotifyBuilder &operator=(const LiveEventLevelUpNotifyBuilder &);
  flatbuffers::Offset<LiveEventLevelUpNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventLevelUpNotify>(end);
    fbb_.Required(o, LiveEventLevelUpNotify::VT_INSTANCES);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventLevelUpNotify> CreateLiveEventLevelUpNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiveEventLevelUpInstance>>> instances = 0) {
  LiveEventLevelUpNotifyBuilder builder_(_fbb);
  builder_.add_instances(instances);
  return builder_.Finish();
}

inline flatbuffers::Offset<LiveEventLevelUpNotify> CreateLiveEventLevelUpNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<LiveEventLevelUpInstance>> *instances = nullptr) {
  return LeanPacket::CreateLiveEventLevelUpNotify(
      _fbb,
      instances ? _fbb.CreateVector<flatbuffers::Offset<LiveEventLevelUpInstance>>(*instances) : 0);
}

struct LiveEventLevelUpReceiveNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EVENTTYPE = 4,
    VT_TIMESTAMP = 6,
    VT_GOALLEVEL = 8,
    VT_STATE = 10
  };
  int32_t eventType() const {
    return GetField<int32_t>(VT_EVENTTYPE, 0);
  }
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  int32_t goalLevel() const {
    return GetField<int32_t>(VT_GOALLEVEL, 0);
  }
  int16_t state() const {
    return GetField<int16_t>(VT_STATE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_EVENTTYPE) &&
           VerifyOffsetRequired(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           VerifyField<int32_t>(verifier, VT_GOALLEVEL) &&
           VerifyField<int16_t>(verifier, VT_STATE) &&
           verifier.EndTable();
  }
};

struct LiveEventLevelUpReceiveNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eventType(int32_t eventType) {
    fbb_.AddElement<int32_t>(LiveEventLevelUpReceiveNotify::VT_EVENTTYPE, eventType, 0);
  }
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventLevelUpReceiveNotify::VT_TIMESTAMP, timestamp);
  }
  void add_goalLevel(int32_t goalLevel) {
    fbb_.AddElement<int32_t>(LiveEventLevelUpReceiveNotify::VT_GOALLEVEL, goalLevel, 0);
  }
  void add_state(int16_t state) {
    fbb_.AddElement<int16_t>(LiveEventLevelUpReceiveNotify::VT_STATE, state, 0);
  }
  explicit LiveEventLevelUpReceiveNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventLevelUpReceiveNotifyBuilder &operator=(const LiveEventLevelUpReceiveNotifyBuilder &);
  flatbuffers::Offset<LiveEventLevelUpReceiveNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventLevelUpReceiveNotify>(end);
    fbb_.Required(o, LiveEventLevelUpReceiveNotify::VT_TIMESTAMP);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventLevelUpReceiveNotify> CreateLiveEventLevelUpReceiveNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t eventType = 0,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    int32_t goalLevel = 0,
    int16_t state = 0) {
  LiveEventLevelUpReceiveNotifyBuilder builder_(_fbb);
  builder_.add_goalLevel(goalLevel);
  builder_.add_timestamp(timestamp);
  builder_.add_eventType(eventType);
  builder_.add_state(state);
  return builder_.Finish();
}

struct LiveEventLevelUpRewardReceiveRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EVENTTYPE = 4,
    VT_TIMESTAMP = 6,
    VT_GOALLEVEL = 8
  };
  int32_t eventType() const {
    return GetField<int32_t>(VT_EVENTTYPE, 0);
  }
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  int32_t goalLevel() const {
    return GetField<int32_t>(VT_GOALLEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_EVENTTYPE) &&
           VerifyOffsetRequired(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           VerifyField<int32_t>(verifier, VT_GOALLEVEL) &&
           verifier.EndTable();
  }
};

struct LiveEventLevelUpRewardReceiveRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eventType(int32_t eventType) {
    fbb_.AddElement<int32_t>(LiveEventLevelUpRewardReceiveRequest::VT_EVENTTYPE, eventType, 0);
  }
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventLevelUpRewardReceiveRequest::VT_TIMESTAMP, timestamp);
  }
  void add_goalLevel(int32_t goalLevel) {
    fbb_.AddElement<int32_t>(LiveEventLevelUpRewardReceiveRequest::VT_GOALLEVEL, goalLevel, 0);
  }
  explicit LiveEventLevelUpRewardReceiveRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventLevelUpRewardReceiveRequestBuilder &operator=(const LiveEventLevelUpRewardReceiveRequestBuilder &);
  flatbuffers::Offset<LiveEventLevelUpRewardReceiveRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventLevelUpRewardReceiveRequest>(end);
    fbb_.Required(o, LiveEventLevelUpRewardReceiveRequest::VT_TIMESTAMP);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventLevelUpRewardReceiveRequest> CreateLiveEventLevelUpRewardReceiveRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t eventType = 0,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    int32_t goalLevel = 0) {
  LiveEventLevelUpRewardReceiveRequestBuilder builder_(_fbb);
  builder_.add_goalLevel(goalLevel);
  builder_.add_timestamp(timestamp);
  builder_.add_eventType(eventType);
  return builder_.Finish();
}

struct LiveEventLevelUpRewardReceiveResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EVENTTYPE = 4,
    VT_GOALLEVEL = 6,
    VT_TIMESTAMP = 8,
    VT_ERROR = 10
  };
  int32_t eventType() const {
    return GetField<int32_t>(VT_EVENTTYPE, 0);
  }
  int32_t goalLevel() const {
    return GetField<int32_t>(VT_GOALLEVEL, 0);
  }
  const LiveEventTimestamp *timestamp() const {
    return GetPointer<const LiveEventTimestamp *>(VT_TIMESTAMP);
  }
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_EVENTTYPE) &&
           VerifyField<int32_t>(verifier, VT_GOALLEVEL) &&
           VerifyOffsetRequired(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           verifier.EndTable();
  }
};

struct LiveEventLevelUpRewardReceiveResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eventType(int32_t eventType) {
    fbb_.AddElement<int32_t>(LiveEventLevelUpRewardReceiveResponse::VT_EVENTTYPE, eventType, 0);
  }
  void add_goalLevel(int32_t goalLevel) {
    fbb_.AddElement<int32_t>(LiveEventLevelUpRewardReceiveResponse::VT_GOALLEVEL, goalLevel, 0);
  }
  void add_timestamp(flatbuffers::Offset<LiveEventTimestamp> timestamp) {
    fbb_.AddOffset(LiveEventLevelUpRewardReceiveResponse::VT_TIMESTAMP, timestamp);
  }
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(LiveEventLevelUpRewardReceiveResponse::VT_ERROR, error, 0);
  }
  explicit LiveEventLevelUpRewardReceiveResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiveEventLevelUpRewardReceiveResponseBuilder &operator=(const LiveEventLevelUpRewardReceiveResponseBuilder &);
  flatbuffers::Offset<LiveEventLevelUpRewardReceiveResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveEventLevelUpRewardReceiveResponse>(end);
    fbb_.Required(o, LiveEventLevelUpRewardReceiveResponse::VT_TIMESTAMP);
    return o;
  }
};

inline flatbuffers::Offset<LiveEventLevelUpRewardReceiveResponse> CreateLiveEventLevelUpRewardReceiveResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t eventType = 0,
    int32_t goalLevel = 0,
    flatbuffers::Offset<LiveEventTimestamp> timestamp = 0,
    int32_t error = 0) {
  LiveEventLevelUpRewardReceiveResponseBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_timestamp(timestamp);
  builder_.add_goalLevel(goalLevel);
  builder_.add_eventType(eventType);
  return builder_.Finish();
}

struct StorageSlotExpansionRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_SIZE = 6
  };
  int16_t type() const {
    return GetField<int16_t>(VT_TYPE, 0);
  }
  int16_t size() const {
    return GetField<int16_t>(VT_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPE) &&
           VerifyField<int16_t>(verifier, VT_SIZE) &&
           verifier.EndTable();
  }
};

struct StorageSlotExpansionRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int16_t type) {
    fbb_.AddElement<int16_t>(StorageSlotExpansionRequest::VT_TYPE, type, 0);
  }
  void add_size(int16_t size) {
    fbb_.AddElement<int16_t>(StorageSlotExpansionRequest::VT_SIZE, size, 0);
  }
  explicit StorageSlotExpansionRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StorageSlotExpansionRequestBuilder &operator=(const StorageSlotExpansionRequestBuilder &);
  flatbuffers::Offset<StorageSlotExpansionRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StorageSlotExpansionRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<StorageSlotExpansionRequest> CreateStorageSlotExpansionRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t type = 0,
    int16_t size = 0) {
  StorageSlotExpansionRequestBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_type(type);
  return builder_.Finish();
}

struct StorageSlotExpansionResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_SIZE = 6,
    VT_ERROR = 8,
    VT_STORAGE = 10
  };
  int16_t type() const {
    return GetField<int16_t>(VT_TYPE, 0);
  }
  int16_t size() const {
    return GetField<int16_t>(VT_SIZE, 0);
  }
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  const StorageData *storage() const {
    return GetPointer<const StorageData *>(VT_STORAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPE) &&
           VerifyField<int16_t>(verifier, VT_SIZE) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           VerifyOffset(verifier, VT_STORAGE) &&
           verifier.VerifyTable(storage()) &&
           verifier.EndTable();
  }
};

struct StorageSlotExpansionResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int16_t type) {
    fbb_.AddElement<int16_t>(StorageSlotExpansionResponse::VT_TYPE, type, 0);
  }
  void add_size(int16_t size) {
    fbb_.AddElement<int16_t>(StorageSlotExpansionResponse::VT_SIZE, size, 0);
  }
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(StorageSlotExpansionResponse::VT_ERROR, error, 0);
  }
  void add_storage(flatbuffers::Offset<StorageData> storage) {
    fbb_.AddOffset(StorageSlotExpansionResponse::VT_STORAGE, storage);
  }
  explicit StorageSlotExpansionResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StorageSlotExpansionResponseBuilder &operator=(const StorageSlotExpansionResponseBuilder &);
  flatbuffers::Offset<StorageSlotExpansionResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StorageSlotExpansionResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<StorageSlotExpansionResponse> CreateStorageSlotExpansionResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t type = 0,
    int16_t size = 0,
    int32_t error = 0,
    flatbuffers::Offset<StorageData> storage = 0) {
  StorageSlotExpansionResponseBuilder builder_(_fbb);
  builder_.add_storage(storage);
  builder_.add_error(error);
  builder_.add_size(size);
  builder_.add_type(type);
  return builder_.Finish();
}

/// BRAWL_TIME_INFO_REQUEST
struct BrawlTimeInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct BrawlTimeInfoRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BrawlTimeInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BrawlTimeInfoRequestBuilder &operator=(const BrawlTimeInfoRequestBuilder &);
  flatbuffers::Offset<BrawlTimeInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BrawlTimeInfoRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<BrawlTimeInfoRequest> CreateBrawlTimeInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BrawlTimeInfoRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// BRAWL_TIME_INFO_NOTIFY
struct BrawlTimeInfoNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FREEREMAINSEC = 4,
    VT_PAIDREMAINSEC = 6
  };
  int32_t freeRemainSec() const {
    return GetField<int32_t>(VT_FREEREMAINSEC, 0);
  }
  int32_t paidRemainSec() const {
    return GetField<int32_t>(VT_PAIDREMAINSEC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FREEREMAINSEC) &&
           VerifyField<int32_t>(verifier, VT_PAIDREMAINSEC) &&
           verifier.EndTable();
  }
};

struct BrawlTimeInfoNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_freeRemainSec(int32_t freeRemainSec) {
    fbb_.AddElement<int32_t>(BrawlTimeInfoNotify::VT_FREEREMAINSEC, freeRemainSec, 0);
  }
  void add_paidRemainSec(int32_t paidRemainSec) {
    fbb_.AddElement<int32_t>(BrawlTimeInfoNotify::VT_PAIDREMAINSEC, paidRemainSec, 0);
  }
  explicit BrawlTimeInfoNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BrawlTimeInfoNotifyBuilder &operator=(const BrawlTimeInfoNotifyBuilder &);
  flatbuffers::Offset<BrawlTimeInfoNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BrawlTimeInfoNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<BrawlTimeInfoNotify> CreateBrawlTimeInfoNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t freeRemainSec = 0,
    int32_t paidRemainSec = 0) {
  BrawlTimeInfoNotifyBuilder builder_(_fbb);
  builder_.add_paidRemainSec(paidRemainSec);
  builder_.add_freeRemainSec(freeRemainSec);
  return builder_.Finish();
}

/// BRAWL_TIME_INFO_RESPONSE
struct BrawlTimeInfoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FREEREMAINSEC = 4,
    VT_PAIDREMAINSEC = 6
  };
  int32_t freeRemainSec() const {
    return GetField<int32_t>(VT_FREEREMAINSEC, 0);
  }
  int32_t paidRemainSec() const {
    return GetField<int32_t>(VT_PAIDREMAINSEC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FREEREMAINSEC) &&
           VerifyField<int32_t>(verifier, VT_PAIDREMAINSEC) &&
           verifier.EndTable();
  }
};

struct BrawlTimeInfoResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_freeRemainSec(int32_t freeRemainSec) {
    fbb_.AddElement<int32_t>(BrawlTimeInfoResponse::VT_FREEREMAINSEC, freeRemainSec, 0);
  }
  void add_paidRemainSec(int32_t paidRemainSec) {
    fbb_.AddElement<int32_t>(BrawlTimeInfoResponse::VT_PAIDREMAINSEC, paidRemainSec, 0);
  }
  explicit BrawlTimeInfoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BrawlTimeInfoResponseBuilder &operator=(const BrawlTimeInfoResponseBuilder &);
  flatbuffers::Offset<BrawlTimeInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BrawlTimeInfoResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<BrawlTimeInfoResponse> CreateBrawlTimeInfoResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t freeRemainSec = 0,
    int32_t paidRemainSec = 0) {
  BrawlTimeInfoResponseBuilder builder_(_fbb);
  builder_.add_paidRemainSec(paidRemainSec);
  builder_.add_freeRemainSec(freeRemainSec);
  return builder_.Finish();
}

/// BRAWL_TIME_EXPIRED_NOTIFY
struct BrawlTimeExpiredNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct BrawlTimeExpiredNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BrawlTimeExpiredNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BrawlTimeExpiredNotifyBuilder &operator=(const BrawlTimeExpiredNotifyBuilder &);
  flatbuffers::Offset<BrawlTimeExpiredNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BrawlTimeExpiredNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<BrawlTimeExpiredNotify> CreateBrawlTimeExpiredNotify(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BrawlTimeExpiredNotifyBuilder builder_(_fbb);
  return builder_.Finish();
}

/// BRAWL_FREE_TIME_EXPIRED_NOTIFY
struct BrawlFreeTimeExpiredNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct BrawlFreeTimeExpiredNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BrawlFreeTimeExpiredNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BrawlFreeTimeExpiredNotifyBuilder &operator=(const BrawlFreeTimeExpiredNotifyBuilder &);
  flatbuffers::Offset<BrawlFreeTimeExpiredNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BrawlFreeTimeExpiredNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<BrawlFreeTimeExpiredNotify> CreateBrawlFreeTimeExpiredNotify(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BrawlFreeTimeExpiredNotifyBuilder builder_(_fbb);
  return builder_.Finish();
}

/// BRAWL_REMAIN_TIME_NOTIFY
struct BrawlRemainTimeNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_REMAINSEC = 4
  };
  int32_t remainSec() const {
    return GetField<int32_t>(VT_REMAINSEC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_REMAINSEC) &&
           verifier.EndTable();
  }
};

struct BrawlRemainTimeNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_remainSec(int32_t remainSec) {
    fbb_.AddElement<int32_t>(BrawlRemainTimeNotify::VT_REMAINSEC, remainSec, 0);
  }
  explicit BrawlRemainTimeNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BrawlRemainTimeNotifyBuilder &operator=(const BrawlRemainTimeNotifyBuilder &);
  flatbuffers::Offset<BrawlRemainTimeNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BrawlRemainTimeNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<BrawlRemainTimeNotify> CreateBrawlRemainTimeNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t remainSec = 0) {
  BrawlRemainTimeNotifyBuilder builder_(_fbb);
  builder_.add_remainSec(remainSec);
  return builder_.Finish();
}

struct BrawlShortTermInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STEPID = 4,
    VT_KILLCOUNT = 6,
    VT_ISREWARDTAKEN = 8
  };
  int32_t stepId() const {
    return GetField<int32_t>(VT_STEPID, 0);
  }
  int32_t killCount() const {
    return GetField<int32_t>(VT_KILLCOUNT, 0);
  }
  bool isRewardTaken() const {
    return GetField<uint8_t>(VT_ISREWARDTAKEN, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STEPID) &&
           VerifyField<int32_t>(verifier, VT_KILLCOUNT) &&
           VerifyField<uint8_t>(verifier, VT_ISREWARDTAKEN) &&
           verifier.EndTable();
  }
};

struct BrawlShortTermInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stepId(int32_t stepId) {
    fbb_.AddElement<int32_t>(BrawlShortTermInfo::VT_STEPID, stepId, 0);
  }
  void add_killCount(int32_t killCount) {
    fbb_.AddElement<int32_t>(BrawlShortTermInfo::VT_KILLCOUNT, killCount, 0);
  }
  void add_isRewardTaken(bool isRewardTaken) {
    fbb_.AddElement<uint8_t>(BrawlShortTermInfo::VT_ISREWARDTAKEN, static_cast<uint8_t>(isRewardTaken), 0);
  }
  explicit BrawlShortTermInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BrawlShortTermInfoBuilder &operator=(const BrawlShortTermInfoBuilder &);
  flatbuffers::Offset<BrawlShortTermInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BrawlShortTermInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<BrawlShortTermInfo> CreateBrawlShortTermInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t stepId = 0,
    int32_t killCount = 0,
    bool isRewardTaken = false) {
  BrawlShortTermInfoBuilder builder_(_fbb);
  builder_.add_killCount(killCount);
  builder_.add_stepId(stepId);
  builder_.add_isRewardTaken(isRewardTaken);
  return builder_.Finish();
}

/// BRAWL_SHORT_TERM_DATA_NOTIFY
struct BrawlShortTermDataNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATAS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<BrawlShortTermInfo>> *datas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BrawlShortTermInfo>> *>(VT_DATAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATAS) &&
           verifier.VerifyVector(datas()) &&
           verifier.VerifyVectorOfTables(datas()) &&
           verifier.EndTable();
  }
};

struct BrawlShortTermDataNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_datas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BrawlShortTermInfo>>> datas) {
    fbb_.AddOffset(BrawlShortTermDataNotify::VT_DATAS, datas);
  }
  explicit BrawlShortTermDataNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BrawlShortTermDataNotifyBuilder &operator=(const BrawlShortTermDataNotifyBuilder &);
  flatbuffers::Offset<BrawlShortTermDataNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BrawlShortTermDataNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<BrawlShortTermDataNotify> CreateBrawlShortTermDataNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BrawlShortTermInfo>>> datas = 0) {
  BrawlShortTermDataNotifyBuilder builder_(_fbb);
  builder_.add_datas(datas);
  return builder_.Finish();
}

inline flatbuffers::Offset<BrawlShortTermDataNotify> CreateBrawlShortTermDataNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<BrawlShortTermInfo>> *datas = nullptr) {
  return LeanPacket::CreateBrawlShortTermDataNotify(
      _fbb,
      datas ? _fbb.CreateVector<flatbuffers::Offset<BrawlShortTermInfo>>(*datas) : 0);
}

/// BRAWL_SHORT_TERM_REWARD_REQUEST
struct BrawlShortTermRewardRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STEPID = 4
  };
  int32_t stepId() const {
    return GetField<int32_t>(VT_STEPID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STEPID) &&
           verifier.EndTable();
  }
};

struct BrawlShortTermRewardRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stepId(int32_t stepId) {
    fbb_.AddElement<int32_t>(BrawlShortTermRewardRequest::VT_STEPID, stepId, 0);
  }
  explicit BrawlShortTermRewardRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BrawlShortTermRewardRequestBuilder &operator=(const BrawlShortTermRewardRequestBuilder &);
  flatbuffers::Offset<BrawlShortTermRewardRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BrawlShortTermRewardRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<BrawlShortTermRewardRequest> CreateBrawlShortTermRewardRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t stepId = 0) {
  BrawlShortTermRewardRequestBuilder builder_(_fbb);
  builder_.add_stepId(stepId);
  return builder_.Finish();
}

/// BRAWL_SHORT_TERM_REWARD_RESPONSE
struct BrawlShortTermRewardResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STEPID = 4,
    VT_ERR = 6
  };
  int32_t stepId() const {
    return GetField<int32_t>(VT_STEPID, 0);
  }
  ErrorCode err() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERR, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STEPID) &&
           VerifyField<int32_t>(verifier, VT_ERR) &&
           verifier.EndTable();
  }
};

struct BrawlShortTermRewardResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stepId(int32_t stepId) {
    fbb_.AddElement<int32_t>(BrawlShortTermRewardResponse::VT_STEPID, stepId, 0);
  }
  void add_err(ErrorCode err) {
    fbb_.AddElement<int32_t>(BrawlShortTermRewardResponse::VT_ERR, static_cast<int32_t>(err), 0);
  }
  explicit BrawlShortTermRewardResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BrawlShortTermRewardResponseBuilder &operator=(const BrawlShortTermRewardResponseBuilder &);
  flatbuffers::Offset<BrawlShortTermRewardResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BrawlShortTermRewardResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<BrawlShortTermRewardResponse> CreateBrawlShortTermRewardResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t stepId = 0,
    ErrorCode err = ErrorCode_NONE) {
  BrawlShortTermRewardResponseBuilder builder_(_fbb);
  builder_.add_err(err);
  builder_.add_stepId(stepId);
  return builder_.Finish();
}

/// BRAWL_SHORT_TERM_DATA_REQUEST
struct BrawlShortTermDataRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct BrawlShortTermDataRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BrawlShortTermDataRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BrawlShortTermDataRequestBuilder &operator=(const BrawlShortTermDataRequestBuilder &);
  flatbuffers::Offset<BrawlShortTermDataRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BrawlShortTermDataRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<BrawlShortTermDataRequest> CreateBrawlShortTermDataRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BrawlShortTermDataRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// BRAWL_SHORT_TERM_DATA_RESPONSE
struct BrawlShortTermDataResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATAS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<BrawlShortTermInfo>> *datas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BrawlShortTermInfo>> *>(VT_DATAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATAS) &&
           verifier.VerifyVector(datas()) &&
           verifier.VerifyVectorOfTables(datas()) &&
           verifier.EndTable();
  }
};

struct BrawlShortTermDataResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_datas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BrawlShortTermInfo>>> datas) {
    fbb_.AddOffset(BrawlShortTermDataResponse::VT_DATAS, datas);
  }
  explicit BrawlShortTermDataResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BrawlShortTermDataResponseBuilder &operator=(const BrawlShortTermDataResponseBuilder &);
  flatbuffers::Offset<BrawlShortTermDataResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BrawlShortTermDataResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<BrawlShortTermDataResponse> CreateBrawlShortTermDataResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BrawlShortTermInfo>>> datas = 0) {
  BrawlShortTermDataResponseBuilder builder_(_fbb);
  builder_.add_datas(datas);
  return builder_.Finish();
}

inline flatbuffers::Offset<BrawlShortTermDataResponse> CreateBrawlShortTermDataResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<BrawlShortTermInfo>> *datas = nullptr) {
  return LeanPacket::CreateBrawlShortTermDataResponse(
      _fbb,
      datas ? _fbb.CreateVector<flatbuffers::Offset<BrawlShortTermInfo>>(*datas) : 0);
}

/// BRAWL_PK_NOTIFY
struct BrawlPKNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_KILLEROBJECTID = 4,
    VT_KILLEDOBJECTID = 6
  };
  int64_t killerObjectId() const {
    return GetField<int64_t>(VT_KILLEROBJECTID, 0);
  }
  int64_t killedObjectId() const {
    return GetField<int64_t>(VT_KILLEDOBJECTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_KILLEROBJECTID) &&
           VerifyField<int64_t>(verifier, VT_KILLEDOBJECTID) &&
           verifier.EndTable();
  }
};

struct BrawlPKNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_killerObjectId(int64_t killerObjectId) {
    fbb_.AddElement<int64_t>(BrawlPKNotify::VT_KILLEROBJECTID, killerObjectId, 0);
  }
  void add_killedObjectId(int64_t killedObjectId) {
    fbb_.AddElement<int64_t>(BrawlPKNotify::VT_KILLEDOBJECTID, killedObjectId, 0);
  }
  explicit BrawlPKNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BrawlPKNotifyBuilder &operator=(const BrawlPKNotifyBuilder &);
  flatbuffers::Offset<BrawlPKNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BrawlPKNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<BrawlPKNotify> CreateBrawlPKNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t killerObjectId = 0,
    int64_t killedObjectId = 0) {
  BrawlPKNotifyBuilder builder_(_fbb);
  builder_.add_killedObjectId(killedObjectId);
  builder_.add_killerObjectId(killerObjectId);
  return builder_.Finish();
}

/// BRAWL_SHORT_TERM_MAX_NOTIFY
struct BrawlShortTermMaxNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SHORTTERMSTEPID = 4
  };
  int32_t shortTermStepId() const {
    return GetField<int32_t>(VT_SHORTTERMSTEPID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SHORTTERMSTEPID) &&
           verifier.EndTable();
  }
};

struct BrawlShortTermMaxNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_shortTermStepId(int32_t shortTermStepId) {
    fbb_.AddElement<int32_t>(BrawlShortTermMaxNotify::VT_SHORTTERMSTEPID, shortTermStepId, 0);
  }
  explicit BrawlShortTermMaxNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BrawlShortTermMaxNotifyBuilder &operator=(const BrawlShortTermMaxNotifyBuilder &);
  flatbuffers::Offset<BrawlShortTermMaxNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BrawlShortTermMaxNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<BrawlShortTermMaxNotify> CreateBrawlShortTermMaxNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t shortTermStepId = 0) {
  BrawlShortTermMaxNotifyBuilder builder_(_fbb);
  builder_.add_shortTermStepId(shortTermStepId);
  return builder_.Finish();
}

/// BRAWL_OTHER_PC_SHORT_TERM_MAX_NOTIFY
struct BrawlOtherPcShortTermMaxNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PCNAME = 4,
    VT_PCIFF = 6,
    VT_PCCLASSTYPE = 8,
    VT_SHORTTERMSTEPID = 10
  };
  const flatbuffers::String *pcName() const {
    return GetPointer<const flatbuffers::String *>(VT_PCNAME);
  }
  int32_t pcIff() const {
    return GetField<int32_t>(VT_PCIFF, 0);
  }
  int32_t pcClassType() const {
    return GetField<int32_t>(VT_PCCLASSTYPE, 0);
  }
  int32_t shortTermStepId() const {
    return GetField<int32_t>(VT_SHORTTERMSTEPID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PCNAME) &&
           verifier.VerifyString(pcName()) &&
           VerifyField<int32_t>(verifier, VT_PCIFF) &&
           VerifyField<int32_t>(verifier, VT_PCCLASSTYPE) &&
           VerifyField<int32_t>(verifier, VT_SHORTTERMSTEPID) &&
           verifier.EndTable();
  }
};

struct BrawlOtherPcShortTermMaxNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pcName(flatbuffers::Offset<flatbuffers::String> pcName) {
    fbb_.AddOffset(BrawlOtherPcShortTermMaxNotify::VT_PCNAME, pcName);
  }
  void add_pcIff(int32_t pcIff) {
    fbb_.AddElement<int32_t>(BrawlOtherPcShortTermMaxNotify::VT_PCIFF, pcIff, 0);
  }
  void add_pcClassType(int32_t pcClassType) {
    fbb_.AddElement<int32_t>(BrawlOtherPcShortTermMaxNotify::VT_PCCLASSTYPE, pcClassType, 0);
  }
  void add_shortTermStepId(int32_t shortTermStepId) {
    fbb_.AddElement<int32_t>(BrawlOtherPcShortTermMaxNotify::VT_SHORTTERMSTEPID, shortTermStepId, 0);
  }
  explicit BrawlOtherPcShortTermMaxNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BrawlOtherPcShortTermMaxNotifyBuilder &operator=(const BrawlOtherPcShortTermMaxNotifyBuilder &);
  flatbuffers::Offset<BrawlOtherPcShortTermMaxNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BrawlOtherPcShortTermMaxNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<BrawlOtherPcShortTermMaxNotify> CreateBrawlOtherPcShortTermMaxNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> pcName = 0,
    int32_t pcIff = 0,
    int32_t pcClassType = 0,
    int32_t shortTermStepId = 0) {
  BrawlOtherPcShortTermMaxNotifyBuilder builder_(_fbb);
  builder_.add_shortTermStepId(shortTermStepId);
  builder_.add_pcClassType(pcClassType);
  builder_.add_pcIff(pcIff);
  builder_.add_pcName(pcName);
  return builder_.Finish();
}

inline flatbuffers::Offset<BrawlOtherPcShortTermMaxNotify> CreateBrawlOtherPcShortTermMaxNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *pcName = nullptr,
    int32_t pcIff = 0,
    int32_t pcClassType = 0,
    int32_t shortTermStepId = 0) {
  return LeanPacket::CreateBrawlOtherPcShortTermMaxNotify(
      _fbb,
      pcName ? _fbb.CreateString(pcName) : 0,
      pcIff,
      pcClassType,
      shortTermStepId);
}

/// BRAWL_POINT_NOTIFY
struct BrawlPointNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BRAWLPOINT = 4,
    VT_TODAYAQUIREDBRAWLPOINT = 6
  };
  int32_t brawlPoint() const {
    return GetField<int32_t>(VT_BRAWLPOINT, 0);
  }
  int32_t todayAquiredBrawlPoint() const {
    return GetField<int32_t>(VT_TODAYAQUIREDBRAWLPOINT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BRAWLPOINT) &&
           VerifyField<int32_t>(verifier, VT_TODAYAQUIREDBRAWLPOINT) &&
           verifier.EndTable();
  }
};

struct BrawlPointNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_brawlPoint(int32_t brawlPoint) {
    fbb_.AddElement<int32_t>(BrawlPointNotify::VT_BRAWLPOINT, brawlPoint, 0);
  }
  void add_todayAquiredBrawlPoint(int32_t todayAquiredBrawlPoint) {
    fbb_.AddElement<int32_t>(BrawlPointNotify::VT_TODAYAQUIREDBRAWLPOINT, todayAquiredBrawlPoint, 0);
  }
  explicit BrawlPointNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BrawlPointNotifyBuilder &operator=(const BrawlPointNotifyBuilder &);
  flatbuffers::Offset<BrawlPointNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BrawlPointNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<BrawlPointNotify> CreateBrawlPointNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t brawlPoint = 0,
    int32_t todayAquiredBrawlPoint = 0) {
  BrawlPointNotifyBuilder builder_(_fbb);
  builder_.add_todayAquiredBrawlPoint(todayAquiredBrawlPoint);
  builder_.add_brawlPoint(brawlPoint);
  return builder_.Finish();
}

struct BrawlEnhanceInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_LEVEL = 6
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           verifier.EndTable();
  }
};

struct BrawlEnhanceInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(BrawlEnhanceInfo::VT_TYPE, type, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(BrawlEnhanceInfo::VT_LEVEL, level, 0);
  }
  explicit BrawlEnhanceInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BrawlEnhanceInfoBuilder &operator=(const BrawlEnhanceInfoBuilder &);
  flatbuffers::Offset<BrawlEnhanceInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BrawlEnhanceInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<BrawlEnhanceInfo> CreateBrawlEnhanceInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 0,
    int32_t level = 0) {
  BrawlEnhanceInfoBuilder builder_(_fbb);
  builder_.add_level(level);
  builder_.add_type(type);
  return builder_.Finish();
}

/// BRAWL_ENHANCE_DATA_NOTIFY
struct BrawlEnhanceDataNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATAS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<BrawlEnhanceInfo>> *datas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BrawlEnhanceInfo>> *>(VT_DATAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATAS) &&
           verifier.VerifyVector(datas()) &&
           verifier.VerifyVectorOfTables(datas()) &&
           verifier.EndTable();
  }
};

struct BrawlEnhanceDataNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_datas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BrawlEnhanceInfo>>> datas) {
    fbb_.AddOffset(BrawlEnhanceDataNotify::VT_DATAS, datas);
  }
  explicit BrawlEnhanceDataNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BrawlEnhanceDataNotifyBuilder &operator=(const BrawlEnhanceDataNotifyBuilder &);
  flatbuffers::Offset<BrawlEnhanceDataNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BrawlEnhanceDataNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<BrawlEnhanceDataNotify> CreateBrawlEnhanceDataNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BrawlEnhanceInfo>>> datas = 0) {
  BrawlEnhanceDataNotifyBuilder builder_(_fbb);
  builder_.add_datas(datas);
  return builder_.Finish();
}

inline flatbuffers::Offset<BrawlEnhanceDataNotify> CreateBrawlEnhanceDataNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<BrawlEnhanceInfo>> *datas = nullptr) {
  return LeanPacket::CreateBrawlEnhanceDataNotify(
      _fbb,
      datas ? _fbb.CreateVector<flatbuffers::Offset<BrawlEnhanceInfo>>(*datas) : 0);
}

/// BRAWL_ENHANCE_LEVEL_UP_REQUEST
struct BrawlEnhanceLevelUpRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_CURRENTLEVEL = 6,
    VT_COSTBRAWLPOINT = 8,
    VT_COSTITEMID = 10,
    VT_COSTITEMAMOUNT = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  int32_t currentLevel() const {
    return GetField<int32_t>(VT_CURRENTLEVEL, 0);
  }
  int32_t costBrawlPoint() const {
    return GetField<int32_t>(VT_COSTBRAWLPOINT, 0);
  }
  int32_t costItemId() const {
    return GetField<int32_t>(VT_COSTITEMID, 0);
  }
  int32_t costItemAmount() const {
    return GetField<int32_t>(VT_COSTITEMAMOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_CURRENTLEVEL) &&
           VerifyField<int32_t>(verifier, VT_COSTBRAWLPOINT) &&
           VerifyField<int32_t>(verifier, VT_COSTITEMID) &&
           VerifyField<int32_t>(verifier, VT_COSTITEMAMOUNT) &&
           verifier.EndTable();
  }
};

struct BrawlEnhanceLevelUpRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(BrawlEnhanceLevelUpRequest::VT_TYPE, type, 0);
  }
  void add_currentLevel(int32_t currentLevel) {
    fbb_.AddElement<int32_t>(BrawlEnhanceLevelUpRequest::VT_CURRENTLEVEL, currentLevel, 0);
  }
  void add_costBrawlPoint(int32_t costBrawlPoint) {
    fbb_.AddElement<int32_t>(BrawlEnhanceLevelUpRequest::VT_COSTBRAWLPOINT, costBrawlPoint, 0);
  }
  void add_costItemId(int32_t costItemId) {
    fbb_.AddElement<int32_t>(BrawlEnhanceLevelUpRequest::VT_COSTITEMID, costItemId, 0);
  }
  void add_costItemAmount(int32_t costItemAmount) {
    fbb_.AddElement<int32_t>(BrawlEnhanceLevelUpRequest::VT_COSTITEMAMOUNT, costItemAmount, 0);
  }
  explicit BrawlEnhanceLevelUpRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BrawlEnhanceLevelUpRequestBuilder &operator=(const BrawlEnhanceLevelUpRequestBuilder &);
  flatbuffers::Offset<BrawlEnhanceLevelUpRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BrawlEnhanceLevelUpRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<BrawlEnhanceLevelUpRequest> CreateBrawlEnhanceLevelUpRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 0,
    int32_t currentLevel = 0,
    int32_t costBrawlPoint = 0,
    int32_t costItemId = 0,
    int32_t costItemAmount = 0) {
  BrawlEnhanceLevelUpRequestBuilder builder_(_fbb);
  builder_.add_costItemAmount(costItemAmount);
  builder_.add_costItemId(costItemId);
  builder_.add_costBrawlPoint(costBrawlPoint);
  builder_.add_currentLevel(currentLevel);
  builder_.add_type(type);
  return builder_.Finish();
}

/// BRAWL_ENHANCE_LEVEL_UP_RESPONSE
struct BrawlEnhanceLevelUpResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_REQUESTLEVEL = 6,
    VT_CURRENTLEVEL = 8,
    VT_ERR = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  int32_t requestLevel() const {
    return GetField<int32_t>(VT_REQUESTLEVEL, 0);
  }
  int32_t currentLevel() const {
    return GetField<int32_t>(VT_CURRENTLEVEL, 0);
  }
  ErrorCode err() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERR, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_REQUESTLEVEL) &&
           VerifyField<int32_t>(verifier, VT_CURRENTLEVEL) &&
           VerifyField<int32_t>(verifier, VT_ERR) &&
           verifier.EndTable();
  }
};

struct BrawlEnhanceLevelUpResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(BrawlEnhanceLevelUpResponse::VT_TYPE, type, 0);
  }
  void add_requestLevel(int32_t requestLevel) {
    fbb_.AddElement<int32_t>(BrawlEnhanceLevelUpResponse::VT_REQUESTLEVEL, requestLevel, 0);
  }
  void add_currentLevel(int32_t currentLevel) {
    fbb_.AddElement<int32_t>(BrawlEnhanceLevelUpResponse::VT_CURRENTLEVEL, currentLevel, 0);
  }
  void add_err(ErrorCode err) {
    fbb_.AddElement<int32_t>(BrawlEnhanceLevelUpResponse::VT_ERR, static_cast<int32_t>(err), 0);
  }
  explicit BrawlEnhanceLevelUpResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BrawlEnhanceLevelUpResponseBuilder &operator=(const BrawlEnhanceLevelUpResponseBuilder &);
  flatbuffers::Offset<BrawlEnhanceLevelUpResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BrawlEnhanceLevelUpResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<BrawlEnhanceLevelUpResponse> CreateBrawlEnhanceLevelUpResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 0,
    int32_t requestLevel = 0,
    int32_t currentLevel = 0,
    ErrorCode err = ErrorCode_NONE) {
  BrawlEnhanceLevelUpResponseBuilder builder_(_fbb);
  builder_.add_err(err);
  builder_.add_currentLevel(currentLevel);
  builder_.add_requestLevel(requestLevel);
  builder_.add_type(type);
  return builder_.Finish();
}

/// ADD_ITEM_FAILED_NOT_ENOUGH_STORAGE_SPACE_NOTIFY
struct AddItemFailedNotEnoughStorageSpaceNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AddItemFailedNotEnoughStorageSpaceNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AddItemFailedNotEnoughStorageSpaceNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddItemFailedNotEnoughStorageSpaceNotifyBuilder &operator=(const AddItemFailedNotEnoughStorageSpaceNotifyBuilder &);
  flatbuffers::Offset<AddItemFailedNotEnoughStorageSpaceNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddItemFailedNotEnoughStorageSpaceNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddItemFailedNotEnoughStorageSpaceNotify> CreateAddItemFailedNotEnoughStorageSpaceNotify(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AddItemFailedNotEnoughStorageSpaceNotifyBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ScrollQuestInProgressInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SCROLLQUESTID = 4,
    VT_COUNT = 6,
    VT_STATE = 8
  };
  int32_t scrollQuestId() const {
    return GetField<int32_t>(VT_SCROLLQUESTID, 0);
  }
  int32_t count() const {
    return GetField<int32_t>(VT_COUNT, 0);
  }
  ScrollQuestState state() const {
    return static_cast<ScrollQuestState>(GetField<int16_t>(VT_STATE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SCROLLQUESTID) &&
           VerifyField<int32_t>(verifier, VT_COUNT) &&
           VerifyField<int16_t>(verifier, VT_STATE) &&
           verifier.EndTable();
  }
};

struct ScrollQuestInProgressInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scrollQuestId(int32_t scrollQuestId) {
    fbb_.AddElement<int32_t>(ScrollQuestInProgressInfo::VT_SCROLLQUESTID, scrollQuestId, 0);
  }
  void add_count(int32_t count) {
    fbb_.AddElement<int32_t>(ScrollQuestInProgressInfo::VT_COUNT, count, 0);
  }
  void add_state(ScrollQuestState state) {
    fbb_.AddElement<int16_t>(ScrollQuestInProgressInfo::VT_STATE, static_cast<int16_t>(state), 0);
  }
  explicit ScrollQuestInProgressInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScrollQuestInProgressInfoBuilder &operator=(const ScrollQuestInProgressInfoBuilder &);
  flatbuffers::Offset<ScrollQuestInProgressInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScrollQuestInProgressInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScrollQuestInProgressInfo> CreateScrollQuestInProgressInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t scrollQuestId = 0,
    int32_t count = 0,
    ScrollQuestState state = ScrollQuestState_SCROLL_QUEST_STATE_INIT) {
  ScrollQuestInProgressInfoBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_scrollQuestId(scrollQuestId);
  builder_.add_state(state);
  return builder_.Finish();
}

/// SCROLL_QUEST_DAILY_INFO_NOTIFY
struct ScrollQuestDailyInfoNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COMPLETECOUNT = 4
  };
  int16_t completeCount() const {
    return GetField<int16_t>(VT_COMPLETECOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_COMPLETECOUNT) &&
           verifier.EndTable();
  }
};

struct ScrollQuestDailyInfoNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_completeCount(int16_t completeCount) {
    fbb_.AddElement<int16_t>(ScrollQuestDailyInfoNotify::VT_COMPLETECOUNT, completeCount, 0);
  }
  explicit ScrollQuestDailyInfoNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScrollQuestDailyInfoNotifyBuilder &operator=(const ScrollQuestDailyInfoNotifyBuilder &);
  flatbuffers::Offset<ScrollQuestDailyInfoNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScrollQuestDailyInfoNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScrollQuestDailyInfoNotify> CreateScrollQuestDailyInfoNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t completeCount = 0) {
  ScrollQuestDailyInfoNotifyBuilder builder_(_fbb);
  builder_.add_completeCount(completeCount);
  return builder_.Finish();
}

/// SCROLL_QUEST_PROGRESS_INFO_NOTIFY
struct ScrollQuestProgressInfoNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATA = 4
  };
  const ScrollQuestInProgressInfo *data() const {
    return GetPointer<const ScrollQuestInProgressInfo *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyTable(data()) &&
           verifier.EndTable();
  }
};

struct ScrollQuestProgressInfoNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<ScrollQuestInProgressInfo> data) {
    fbb_.AddOffset(ScrollQuestProgressInfoNotify::VT_DATA, data);
  }
  explicit ScrollQuestProgressInfoNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScrollQuestProgressInfoNotifyBuilder &operator=(const ScrollQuestProgressInfoNotifyBuilder &);
  flatbuffers::Offset<ScrollQuestProgressInfoNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScrollQuestProgressInfoNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScrollQuestProgressInfoNotify> CreateScrollQuestProgressInfoNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ScrollQuestInProgressInfo> data = 0) {
  ScrollQuestProgressInfoNotifyBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

/// SCROLL_QUEST_START_PROGRESS_REQUEST
struct ScrollQuestStartProgressRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SCROLLQUESTID = 4
  };
  int32_t scrollQuestId() const {
    return GetField<int32_t>(VT_SCROLLQUESTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SCROLLQUESTID) &&
           verifier.EndTable();
  }
};

struct ScrollQuestStartProgressRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scrollQuestId(int32_t scrollQuestId) {
    fbb_.AddElement<int32_t>(ScrollQuestStartProgressRequest::VT_SCROLLQUESTID, scrollQuestId, 0);
  }
  explicit ScrollQuestStartProgressRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScrollQuestStartProgressRequestBuilder &operator=(const ScrollQuestStartProgressRequestBuilder &);
  flatbuffers::Offset<ScrollQuestStartProgressRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScrollQuestStartProgressRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScrollQuestStartProgressRequest> CreateScrollQuestStartProgressRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t scrollQuestId = 0) {
  ScrollQuestStartProgressRequestBuilder builder_(_fbb);
  builder_.add_scrollQuestId(scrollQuestId);
  return builder_.Finish();
}

/// SCROLL_QUEST_START_PROGRESS_RESPONSE
struct ScrollQuestStartProgressResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SCROLLQUESTID = 4,
    VT_ERR = 6
  };
  int32_t scrollQuestId() const {
    return GetField<int32_t>(VT_SCROLLQUESTID, 0);
  }
  ErrorCode err() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERR, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SCROLLQUESTID) &&
           VerifyField<int32_t>(verifier, VT_ERR) &&
           verifier.EndTable();
  }
};

struct ScrollQuestStartProgressResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scrollQuestId(int32_t scrollQuestId) {
    fbb_.AddElement<int32_t>(ScrollQuestStartProgressResponse::VT_SCROLLQUESTID, scrollQuestId, 0);
  }
  void add_err(ErrorCode err) {
    fbb_.AddElement<int32_t>(ScrollQuestStartProgressResponse::VT_ERR, static_cast<int32_t>(err), 0);
  }
  explicit ScrollQuestStartProgressResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScrollQuestStartProgressResponseBuilder &operator=(const ScrollQuestStartProgressResponseBuilder &);
  flatbuffers::Offset<ScrollQuestStartProgressResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScrollQuestStartProgressResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScrollQuestStartProgressResponse> CreateScrollQuestStartProgressResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t scrollQuestId = 0,
    ErrorCode err = ErrorCode_NONE) {
  ScrollQuestStartProgressResponseBuilder builder_(_fbb);
  builder_.add_err(err);
  builder_.add_scrollQuestId(scrollQuestId);
  return builder_.Finish();
}

/// SCROLL_QUEST_GIVE_UP_REQUEST
struct ScrollQuestGiveUpRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SCROLLQUESTID = 4
  };
  int32_t scrollQuestId() const {
    return GetField<int32_t>(VT_SCROLLQUESTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SCROLLQUESTID) &&
           verifier.EndTable();
  }
};

struct ScrollQuestGiveUpRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scrollQuestId(int32_t scrollQuestId) {
    fbb_.AddElement<int32_t>(ScrollQuestGiveUpRequest::VT_SCROLLQUESTID, scrollQuestId, 0);
  }
  explicit ScrollQuestGiveUpRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScrollQuestGiveUpRequestBuilder &operator=(const ScrollQuestGiveUpRequestBuilder &);
  flatbuffers::Offset<ScrollQuestGiveUpRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScrollQuestGiveUpRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScrollQuestGiveUpRequest> CreateScrollQuestGiveUpRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t scrollQuestId = 0) {
  ScrollQuestGiveUpRequestBuilder builder_(_fbb);
  builder_.add_scrollQuestId(scrollQuestId);
  return builder_.Finish();
}

/// SCROLL_QUEST_GIVE_UP_RESPONSE
struct ScrollQuestGiveUpResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SCROLLQUESTID = 4,
    VT_ERR = 6
  };
  int32_t scrollQuestId() const {
    return GetField<int32_t>(VT_SCROLLQUESTID, 0);
  }
  ErrorCode err() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERR, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SCROLLQUESTID) &&
           VerifyField<int32_t>(verifier, VT_ERR) &&
           verifier.EndTable();
  }
};

struct ScrollQuestGiveUpResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scrollQuestId(int32_t scrollQuestId) {
    fbb_.AddElement<int32_t>(ScrollQuestGiveUpResponse::VT_SCROLLQUESTID, scrollQuestId, 0);
  }
  void add_err(ErrorCode err) {
    fbb_.AddElement<int32_t>(ScrollQuestGiveUpResponse::VT_ERR, static_cast<int32_t>(err), 0);
  }
  explicit ScrollQuestGiveUpResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScrollQuestGiveUpResponseBuilder &operator=(const ScrollQuestGiveUpResponseBuilder &);
  flatbuffers::Offset<ScrollQuestGiveUpResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScrollQuestGiveUpResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScrollQuestGiveUpResponse> CreateScrollQuestGiveUpResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t scrollQuestId = 0,
    ErrorCode err = ErrorCode_NONE) {
  ScrollQuestGiveUpResponseBuilder builder_(_fbb);
  builder_.add_err(err);
  builder_.add_scrollQuestId(scrollQuestId);
  return builder_.Finish();
}

/// SCROLL_QUEST_REWARD_REQUEST
struct ScrollQuestRewardRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SCROLLQUESTID = 4,
    VT_REWARDID = 6,
    VT_SELECTEDREWARDGROUPID = 8,
    VT_SELECTEDREWARDIDX = 10
  };
  int32_t scrollQuestId() const {
    return GetField<int32_t>(VT_SCROLLQUESTID, 0);
  }
  int32_t rewardId() const {
    return GetField<int32_t>(VT_REWARDID, 0);
  }
  int32_t selectedRewardGroupId() const {
    return GetField<int32_t>(VT_SELECTEDREWARDGROUPID, 0);
  }
  int32_t selectedRewardIdx() const {
    return GetField<int32_t>(VT_SELECTEDREWARDIDX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SCROLLQUESTID) &&
           VerifyField<int32_t>(verifier, VT_REWARDID) &&
           VerifyField<int32_t>(verifier, VT_SELECTEDREWARDGROUPID) &&
           VerifyField<int32_t>(verifier, VT_SELECTEDREWARDIDX) &&
           verifier.EndTable();
  }
};

struct ScrollQuestRewardRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scrollQuestId(int32_t scrollQuestId) {
    fbb_.AddElement<int32_t>(ScrollQuestRewardRequest::VT_SCROLLQUESTID, scrollQuestId, 0);
  }
  void add_rewardId(int32_t rewardId) {
    fbb_.AddElement<int32_t>(ScrollQuestRewardRequest::VT_REWARDID, rewardId, 0);
  }
  void add_selectedRewardGroupId(int32_t selectedRewardGroupId) {
    fbb_.AddElement<int32_t>(ScrollQuestRewardRequest::VT_SELECTEDREWARDGROUPID, selectedRewardGroupId, 0);
  }
  void add_selectedRewardIdx(int32_t selectedRewardIdx) {
    fbb_.AddElement<int32_t>(ScrollQuestRewardRequest::VT_SELECTEDREWARDIDX, selectedRewardIdx, 0);
  }
  explicit ScrollQuestRewardRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScrollQuestRewardRequestBuilder &operator=(const ScrollQuestRewardRequestBuilder &);
  flatbuffers::Offset<ScrollQuestRewardRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScrollQuestRewardRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScrollQuestRewardRequest> CreateScrollQuestRewardRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t scrollQuestId = 0,
    int32_t rewardId = 0,
    int32_t selectedRewardGroupId = 0,
    int32_t selectedRewardIdx = 0) {
  ScrollQuestRewardRequestBuilder builder_(_fbb);
  builder_.add_selectedRewardIdx(selectedRewardIdx);
  builder_.add_selectedRewardGroupId(selectedRewardGroupId);
  builder_.add_rewardId(rewardId);
  builder_.add_scrollQuestId(scrollQuestId);
  return builder_.Finish();
}

/// SCROLL_QUEST_REWARD_RESPONSE
struct ScrollQuestRewardResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SCROLLQUESTID = 4,
    VT_ERR = 6
  };
  int32_t scrollQuestId() const {
    return GetField<int32_t>(VT_SCROLLQUESTID, 0);
  }
  ErrorCode err() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERR, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SCROLLQUESTID) &&
           VerifyField<int32_t>(verifier, VT_ERR) &&
           verifier.EndTable();
  }
};

struct ScrollQuestRewardResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scrollQuestId(int32_t scrollQuestId) {
    fbb_.AddElement<int32_t>(ScrollQuestRewardResponse::VT_SCROLLQUESTID, scrollQuestId, 0);
  }
  void add_err(ErrorCode err) {
    fbb_.AddElement<int32_t>(ScrollQuestRewardResponse::VT_ERR, static_cast<int32_t>(err), 0);
  }
  explicit ScrollQuestRewardResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScrollQuestRewardResponseBuilder &operator=(const ScrollQuestRewardResponseBuilder &);
  flatbuffers::Offset<ScrollQuestRewardResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScrollQuestRewardResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScrollQuestRewardResponse> CreateScrollQuestRewardResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t scrollQuestId = 0,
    ErrorCode err = ErrorCode_NONE) {
  ScrollQuestRewardResponseBuilder builder_(_fbb);
  builder_.add_err(err);
  builder_.add_scrollQuestId(scrollQuestId);
  return builder_.Finish();
}

/// BRAWL_LAST_LEAVED_TIME_REQUEST
struct BrawlLastLeavedTimeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct BrawlLastLeavedTimeRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BrawlLastLeavedTimeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BrawlLastLeavedTimeRequestBuilder &operator=(const BrawlLastLeavedTimeRequestBuilder &);
  flatbuffers::Offset<BrawlLastLeavedTimeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BrawlLastLeavedTimeRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<BrawlLastLeavedTimeRequest> CreateBrawlLastLeavedTimeRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BrawlLastLeavedTimeRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// BRAWL_LAST_LEAVED_TIME_RESPONSE
struct BrawlLastLeavedTimeResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LASTLEAVEDTIMEUTC = 4
  };
  int64_t lastLeavedTimeUtc() const {
    return GetField<int64_t>(VT_LASTLEAVEDTIMEUTC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_LASTLEAVEDTIMEUTC) &&
           verifier.EndTable();
  }
};

struct BrawlLastLeavedTimeResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_lastLeavedTimeUtc(int64_t lastLeavedTimeUtc) {
    fbb_.AddElement<int64_t>(BrawlLastLeavedTimeResponse::VT_LASTLEAVEDTIMEUTC, lastLeavedTimeUtc, 0);
  }
  explicit BrawlLastLeavedTimeResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BrawlLastLeavedTimeResponseBuilder &operator=(const BrawlLastLeavedTimeResponseBuilder &);
  flatbuffers::Offset<BrawlLastLeavedTimeResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BrawlLastLeavedTimeResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<BrawlLastLeavedTimeResponse> CreateBrawlLastLeavedTimeResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t lastLeavedTimeUtc = 0) {
  BrawlLastLeavedTimeResponseBuilder builder_(_fbb);
  builder_.add_lastLeavedTimeUtc(lastLeavedTimeUtc);
  return builder_.Finish();
}

/// BRAWL_LAST_LEAVED_TIME_NOTIFY
struct BrawlLastLeavedTimeNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LASTLEAVEDTIMEUTC = 4
  };
  int64_t lastLeavedTimeUtc() const {
    return GetField<int64_t>(VT_LASTLEAVEDTIMEUTC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_LASTLEAVEDTIMEUTC) &&
           verifier.EndTable();
  }
};

struct BrawlLastLeavedTimeNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_lastLeavedTimeUtc(int64_t lastLeavedTimeUtc) {
    fbb_.AddElement<int64_t>(BrawlLastLeavedTimeNotify::VT_LASTLEAVEDTIMEUTC, lastLeavedTimeUtc, 0);
  }
  explicit BrawlLastLeavedTimeNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BrawlLastLeavedTimeNotifyBuilder &operator=(const BrawlLastLeavedTimeNotifyBuilder &);
  flatbuffers::Offset<BrawlLastLeavedTimeNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BrawlLastLeavedTimeNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<BrawlLastLeavedTimeNotify> CreateBrawlLastLeavedTimeNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t lastLeavedTimeUtc = 0) {
  BrawlLastLeavedTimeNotifyBuilder builder_(_fbb);
  builder_.add_lastLeavedTimeUtc(lastLeavedTimeUtc);
  return builder_.Finish();
}

struct PetStat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GROUPTYPE = 4,
    VT_ID = 6,
    VT_VALUE = 8
  };
  int16_t groupType() const {
    return GetField<int16_t>(VT_GROUPTYPE, 0);
  }
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_GROUPTYPE) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct PetStatBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_groupType(int16_t groupType) {
    fbb_.AddElement<int16_t>(PetStat::VT_GROUPTYPE, groupType, 0);
  }
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(PetStat::VT_ID, id, 0);
  }
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(PetStat::VT_VALUE, value, 0);
  }
  explicit PetStatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetStatBuilder &operator=(const PetStatBuilder &);
  flatbuffers::Offset<PetStat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetStat>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetStat> CreatePetStat(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t groupType = 0,
    int32_t id = 0,
    int32_t value = 0) {
  PetStatBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_id(id);
  builder_.add_groupType(groupType);
  return builder_.Finish();
}

struct Pet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_STATE = 6,
    VT_GRADE = 8,
    VT_LOOK = 10,
    VT_LEVEL = 12,
    VT_EXP = 14,
    VT_STATS = 16,
    VT_REMAINDIGESTIONTICK = 18,
    VT_ISSAFEGUARDED = 20
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  PetState state() const {
    return static_cast<PetState>(GetField<int16_t>(VT_STATE, 0));
  }
  int16_t grade() const {
    return GetField<int16_t>(VT_GRADE, 0);
  }
  int16_t look() const {
    return GetField<int16_t>(VT_LOOK, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int32_t exp() const {
    return GetField<int32_t>(VT_EXP, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PetStat>> *stats() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PetStat>> *>(VT_STATS);
  }
  int64_t remainDigestionTick() const {
    return GetField<int64_t>(VT_REMAINDIGESTIONTICK, 0);
  }
  bool isSafeGuarded() const {
    return GetField<uint8_t>(VT_ISSAFEGUARDED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<int16_t>(verifier, VT_STATE) &&
           VerifyField<int16_t>(verifier, VT_GRADE) &&
           VerifyField<int16_t>(verifier, VT_LOOK) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_EXP) &&
           VerifyOffset(verifier, VT_STATS) &&
           verifier.VerifyVector(stats()) &&
           verifier.VerifyVectorOfTables(stats()) &&
           VerifyField<int64_t>(verifier, VT_REMAINDIGESTIONTICK) &&
           VerifyField<uint8_t>(verifier, VT_ISSAFEGUARDED) &&
           verifier.EndTable();
  }
};

struct PetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(Pet::VT_ID, id, 0);
  }
  void add_state(PetState state) {
    fbb_.AddElement<int16_t>(Pet::VT_STATE, static_cast<int16_t>(state), 0);
  }
  void add_grade(int16_t grade) {
    fbb_.AddElement<int16_t>(Pet::VT_GRADE, grade, 0);
  }
  void add_look(int16_t look) {
    fbb_.AddElement<int16_t>(Pet::VT_LOOK, look, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(Pet::VT_LEVEL, level, 0);
  }
  void add_exp(int32_t exp) {
    fbb_.AddElement<int32_t>(Pet::VT_EXP, exp, 0);
  }
  void add_stats(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PetStat>>> stats) {
    fbb_.AddOffset(Pet::VT_STATS, stats);
  }
  void add_remainDigestionTick(int64_t remainDigestionTick) {
    fbb_.AddElement<int64_t>(Pet::VT_REMAINDIGESTIONTICK, remainDigestionTick, 0);
  }
  void add_isSafeGuarded(bool isSafeGuarded) {
    fbb_.AddElement<uint8_t>(Pet::VT_ISSAFEGUARDED, static_cast<uint8_t>(isSafeGuarded), 0);
  }
  explicit PetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetBuilder &operator=(const PetBuilder &);
  flatbuffers::Offset<Pet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pet>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pet> CreatePet(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    PetState state = PetState_PET_STATE_SUMMONED,
    int16_t grade = 0,
    int16_t look = 0,
    int32_t level = 0,
    int32_t exp = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PetStat>>> stats = 0,
    int64_t remainDigestionTick = 0,
    bool isSafeGuarded = false) {
  PetBuilder builder_(_fbb);
  builder_.add_remainDigestionTick(remainDigestionTick);
  builder_.add_stats(stats);
  builder_.add_exp(exp);
  builder_.add_level(level);
  builder_.add_id(id);
  builder_.add_look(look);
  builder_.add_grade(grade);
  builder_.add_state(state);
  builder_.add_isSafeGuarded(isSafeGuarded);
  return builder_.Finish();
}

inline flatbuffers::Offset<Pet> CreatePetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    PetState state = PetState_PET_STATE_SUMMONED,
    int16_t grade = 0,
    int16_t look = 0,
    int32_t level = 0,
    int32_t exp = 0,
    const std::vector<flatbuffers::Offset<PetStat>> *stats = nullptr,
    int64_t remainDigestionTick = 0,
    bool isSafeGuarded = false) {
  return LeanPacket::CreatePet(
      _fbb,
      id,
      state,
      grade,
      look,
      level,
      exp,
      stats ? _fbb.CreateVector<flatbuffers::Offset<PetStat>>(*stats) : 0,
      remainDigestionTick,
      isSafeGuarded);
}

/// PET_CREATED_NOTIFY
struct PetCreatedNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PET = 4
  };
  const Pet *pet() const {
    return GetPointer<const Pet *>(VT_PET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PET) &&
           verifier.VerifyTable(pet()) &&
           verifier.EndTable();
  }
};

struct PetCreatedNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pet(flatbuffers::Offset<Pet> pet) {
    fbb_.AddOffset(PetCreatedNotify::VT_PET, pet);
  }
  explicit PetCreatedNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetCreatedNotifyBuilder &operator=(const PetCreatedNotifyBuilder &);
  flatbuffers::Offset<PetCreatedNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetCreatedNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetCreatedNotify> CreatePetCreatedNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Pet> pet = 0) {
  PetCreatedNotifyBuilder builder_(_fbb);
  builder_.add_pet(pet);
  return builder_.Finish();
}

/// PET_CREATED_WITH_EFFECT_NOTIFY
struct PetCreatedWithEffectNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PETS = 4,
    VT_SHOPPRODUCTID = 6,
    VT_ISSHOPBONUS = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<Pet>> *pets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pet>> *>(VT_PETS);
  }
  int32_t shopProductId() const {
    return GetField<int32_t>(VT_SHOPPRODUCTID, 0);
  }
  bool isShopBonus() const {
    return GetField<uint8_t>(VT_ISSHOPBONUS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PETS) &&
           verifier.VerifyVector(pets()) &&
           verifier.VerifyVectorOfTables(pets()) &&
           VerifyField<int32_t>(verifier, VT_SHOPPRODUCTID) &&
           VerifyField<uint8_t>(verifier, VT_ISSHOPBONUS) &&
           verifier.EndTable();
  }
};

struct PetCreatedWithEffectNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pet>>> pets) {
    fbb_.AddOffset(PetCreatedWithEffectNotify::VT_PETS, pets);
  }
  void add_shopProductId(int32_t shopProductId) {
    fbb_.AddElement<int32_t>(PetCreatedWithEffectNotify::VT_SHOPPRODUCTID, shopProductId, 0);
  }
  void add_isShopBonus(bool isShopBonus) {
    fbb_.AddElement<uint8_t>(PetCreatedWithEffectNotify::VT_ISSHOPBONUS, static_cast<uint8_t>(isShopBonus), 0);
  }
  explicit PetCreatedWithEffectNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetCreatedWithEffectNotifyBuilder &operator=(const PetCreatedWithEffectNotifyBuilder &);
  flatbuffers::Offset<PetCreatedWithEffectNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetCreatedWithEffectNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetCreatedWithEffectNotify> CreatePetCreatedWithEffectNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pet>>> pets = 0,
    int32_t shopProductId = 0,
    bool isShopBonus = false) {
  PetCreatedWithEffectNotifyBuilder builder_(_fbb);
  builder_.add_shopProductId(shopProductId);
  builder_.add_pets(pets);
  builder_.add_isShopBonus(isShopBonus);
  return builder_.Finish();
}

inline flatbuffers::Offset<PetCreatedWithEffectNotify> CreatePetCreatedWithEffectNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Pet>> *pets = nullptr,
    int32_t shopProductId = 0,
    bool isShopBonus = false) {
  return LeanPacket::CreatePetCreatedWithEffectNotify(
      _fbb,
      pets ? _fbb.CreateVector<flatbuffers::Offset<Pet>>(*pets) : 0,
      shopProductId,
      isShopBonus);
}

/// PET_DELETED_NOTIFY
struct PetDeletedNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PETID = 4
  };
  int32_t petId() const {
    return GetField<int32_t>(VT_PETID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PETID) &&
           verifier.EndTable();
  }
};

struct PetDeletedNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_petId(int32_t petId) {
    fbb_.AddElement<int32_t>(PetDeletedNotify::VT_PETID, petId, 0);
  }
  explicit PetDeletedNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetDeletedNotifyBuilder &operator=(const PetDeletedNotifyBuilder &);
  flatbuffers::Offset<PetDeletedNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetDeletedNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetDeletedNotify> CreatePetDeletedNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t petId = 0) {
  PetDeletedNotifyBuilder builder_(_fbb);
  builder_.add_petId(petId);
  return builder_.Finish();
}

/// PET_DATA_NOTIFY
struct PetDataNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PETS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Pet>> *pets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pet>> *>(VT_PETS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PETS) &&
           verifier.VerifyVector(pets()) &&
           verifier.VerifyVectorOfTables(pets()) &&
           verifier.EndTable();
  }
};

struct PetDataNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pet>>> pets) {
    fbb_.AddOffset(PetDataNotify::VT_PETS, pets);
  }
  explicit PetDataNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetDataNotifyBuilder &operator=(const PetDataNotifyBuilder &);
  flatbuffers::Offset<PetDataNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetDataNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetDataNotify> CreatePetDataNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pet>>> pets = 0) {
  PetDataNotifyBuilder builder_(_fbb);
  builder_.add_pets(pets);
  return builder_.Finish();
}

inline flatbuffers::Offset<PetDataNotify> CreatePetDataNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Pet>> *pets = nullptr) {
  return LeanPacket::CreatePetDataNotify(
      _fbb,
      pets ? _fbb.CreateVector<flatbuffers::Offset<Pet>>(*pets) : 0);
}

/// PET_FEED_REQUEST
struct PetFeedRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PETID = 4,
    VT_ITEMID = 6
  };
  int32_t petId() const {
    return GetField<int32_t>(VT_PETID, 0);
  }
  int32_t itemId() const {
    return GetField<int32_t>(VT_ITEMID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PETID) &&
           VerifyField<int32_t>(verifier, VT_ITEMID) &&
           verifier.EndTable();
  }
};

struct PetFeedRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_petId(int32_t petId) {
    fbb_.AddElement<int32_t>(PetFeedRequest::VT_PETID, petId, 0);
  }
  void add_itemId(int32_t itemId) {
    fbb_.AddElement<int32_t>(PetFeedRequest::VT_ITEMID, itemId, 0);
  }
  explicit PetFeedRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetFeedRequestBuilder &operator=(const PetFeedRequestBuilder &);
  flatbuffers::Offset<PetFeedRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetFeedRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetFeedRequest> CreatePetFeedRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t petId = 0,
    int32_t itemId = 0) {
  PetFeedRequestBuilder builder_(_fbb);
  builder_.add_itemId(itemId);
  builder_.add_petId(petId);
  return builder_.Finish();
}

/// PET_FEED_RESPONSE
struct PetFeedResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PETID = 4,
    VT_ERR = 6,
    VT_REMAINDIGESTIONTICK = 8
  };
  int32_t petId() const {
    return GetField<int32_t>(VT_PETID, 0);
  }
  ErrorCode err() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERR, 0));
  }
  int64_t remainDigestionTick() const {
    return GetField<int64_t>(VT_REMAINDIGESTIONTICK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PETID) &&
           VerifyField<int32_t>(verifier, VT_ERR) &&
           VerifyField<int64_t>(verifier, VT_REMAINDIGESTIONTICK) &&
           verifier.EndTable();
  }
};

struct PetFeedResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_petId(int32_t petId) {
    fbb_.AddElement<int32_t>(PetFeedResponse::VT_PETID, petId, 0);
  }
  void add_err(ErrorCode err) {
    fbb_.AddElement<int32_t>(PetFeedResponse::VT_ERR, static_cast<int32_t>(err), 0);
  }
  void add_remainDigestionTick(int64_t remainDigestionTick) {
    fbb_.AddElement<int64_t>(PetFeedResponse::VT_REMAINDIGESTIONTICK, remainDigestionTick, 0);
  }
  explicit PetFeedResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetFeedResponseBuilder &operator=(const PetFeedResponseBuilder &);
  flatbuffers::Offset<PetFeedResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetFeedResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetFeedResponse> CreatePetFeedResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t petId = 0,
    ErrorCode err = ErrorCode_NONE,
    int64_t remainDigestionTick = 0) {
  PetFeedResponseBuilder builder_(_fbb);
  builder_.add_remainDigestionTick(remainDigestionTick);
  builder_.add_err(err);
  builder_.add_petId(petId);
  return builder_.Finish();
}

/// PET_DIGESTION_COMPLETE_NOTIFY
struct PetDigestionCompleteNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PETID = 4
  };
  int32_t petId() const {
    return GetField<int32_t>(VT_PETID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PETID) &&
           verifier.EndTable();
  }
};

struct PetDigestionCompleteNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_petId(int32_t petId) {
    fbb_.AddElement<int32_t>(PetDigestionCompleteNotify::VT_PETID, petId, 0);
  }
  explicit PetDigestionCompleteNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetDigestionCompleteNotifyBuilder &operator=(const PetDigestionCompleteNotifyBuilder &);
  flatbuffers::Offset<PetDigestionCompleteNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetDigestionCompleteNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetDigestionCompleteNotify> CreatePetDigestionCompleteNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t petId = 0) {
  PetDigestionCompleteNotifyBuilder builder_(_fbb);
  builder_.add_petId(petId);
  return builder_.Finish();
}

/// PET_SUMMON_REQUEST
struct PetSummonRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PETID = 4
  };
  int32_t petId() const {
    return GetField<int32_t>(VT_PETID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PETID) &&
           verifier.EndTable();
  }
};

struct PetSummonRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_petId(int32_t petId) {
    fbb_.AddElement<int32_t>(PetSummonRequest::VT_PETID, petId, 0);
  }
  explicit PetSummonRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetSummonRequestBuilder &operator=(const PetSummonRequestBuilder &);
  flatbuffers::Offset<PetSummonRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetSummonRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetSummonRequest> CreatePetSummonRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t petId = 0) {
  PetSummonRequestBuilder builder_(_fbb);
  builder_.add_petId(petId);
  return builder_.Finish();
}

/// PET_SUMMON_RESPONSE
struct PetSummonResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PETID = 4,
    VT_ERR = 6
  };
  int32_t petId() const {
    return GetField<int32_t>(VT_PETID, 0);
  }
  ErrorCode err() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERR, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PETID) &&
           VerifyField<int32_t>(verifier, VT_ERR) &&
           verifier.EndTable();
  }
};

struct PetSummonResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_petId(int32_t petId) {
    fbb_.AddElement<int32_t>(PetSummonResponse::VT_PETID, petId, 0);
  }
  void add_err(ErrorCode err) {
    fbb_.AddElement<int32_t>(PetSummonResponse::VT_ERR, static_cast<int32_t>(err), 0);
  }
  explicit PetSummonResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetSummonResponseBuilder &operator=(const PetSummonResponseBuilder &);
  flatbuffers::Offset<PetSummonResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetSummonResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetSummonResponse> CreatePetSummonResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t petId = 0,
    ErrorCode err = ErrorCode_NONE) {
  PetSummonResponseBuilder builder_(_fbb);
  builder_.add_err(err);
  builder_.add_petId(petId);
  return builder_.Finish();
}

/// PET_SUMMON_CANCEL_REQUEST
struct PetSummonCancelRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PETID = 4
  };
  int32_t petId() const {
    return GetField<int32_t>(VT_PETID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PETID) &&
           verifier.EndTable();
  }
};

struct PetSummonCancelRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_petId(int32_t petId) {
    fbb_.AddElement<int32_t>(PetSummonCancelRequest::VT_PETID, petId, 0);
  }
  explicit PetSummonCancelRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetSummonCancelRequestBuilder &operator=(const PetSummonCancelRequestBuilder &);
  flatbuffers::Offset<PetSummonCancelRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetSummonCancelRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetSummonCancelRequest> CreatePetSummonCancelRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t petId = 0) {
  PetSummonCancelRequestBuilder builder_(_fbb);
  builder_.add_petId(petId);
  return builder_.Finish();
}

/// PET_SUMMON_CANCEL_RESPONSE
struct PetSummonCancelResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PETID = 4,
    VT_ERR = 6,
    VT_REMAINDIGESTIONTICK = 8
  };
  int32_t petId() const {
    return GetField<int32_t>(VT_PETID, 0);
  }
  ErrorCode err() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERR, 0));
  }
  int64_t remainDigestionTick() const {
    return GetField<int64_t>(VT_REMAINDIGESTIONTICK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PETID) &&
           VerifyField<int32_t>(verifier, VT_ERR) &&
           VerifyField<int64_t>(verifier, VT_REMAINDIGESTIONTICK) &&
           verifier.EndTable();
  }
};

struct PetSummonCancelResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_petId(int32_t petId) {
    fbb_.AddElement<int32_t>(PetSummonCancelResponse::VT_PETID, petId, 0);
  }
  void add_err(ErrorCode err) {
    fbb_.AddElement<int32_t>(PetSummonCancelResponse::VT_ERR, static_cast<int32_t>(err), 0);
  }
  void add_remainDigestionTick(int64_t remainDigestionTick) {
    fbb_.AddElement<int64_t>(PetSummonCancelResponse::VT_REMAINDIGESTIONTICK, remainDigestionTick, 0);
  }
  explicit PetSummonCancelResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetSummonCancelResponseBuilder &operator=(const PetSummonCancelResponseBuilder &);
  flatbuffers::Offset<PetSummonCancelResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetSummonCancelResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetSummonCancelResponse> CreatePetSummonCancelResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t petId = 0,
    ErrorCode err = ErrorCode_NONE,
    int64_t remainDigestionTick = 0) {
  PetSummonCancelResponseBuilder builder_(_fbb);
  builder_.add_remainDigestionTick(remainDigestionTick);
  builder_.add_err(err);
  builder_.add_petId(petId);
  return builder_.Finish();
}

/// PET_SUPPORT_REQUEST
struct PetSupportRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PETID = 4
  };
  int32_t petId() const {
    return GetField<int32_t>(VT_PETID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PETID) &&
           verifier.EndTable();
  }
};

struct PetSupportRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_petId(int32_t petId) {
    fbb_.AddElement<int32_t>(PetSupportRequest::VT_PETID, petId, 0);
  }
  explicit PetSupportRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetSupportRequestBuilder &operator=(const PetSupportRequestBuilder &);
  flatbuffers::Offset<PetSupportRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetSupportRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetSupportRequest> CreatePetSupportRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t petId = 0) {
  PetSupportRequestBuilder builder_(_fbb);
  builder_.add_petId(petId);
  return builder_.Finish();
}

/// PET_SUPPORT_RESPONSE
struct PetSupportResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PETID = 4,
    VT_ERR = 6
  };
  int32_t petId() const {
    return GetField<int32_t>(VT_PETID, 0);
  }
  ErrorCode err() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERR, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PETID) &&
           VerifyField<int32_t>(verifier, VT_ERR) &&
           verifier.EndTable();
  }
};

struct PetSupportResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_petId(int32_t petId) {
    fbb_.AddElement<int32_t>(PetSupportResponse::VT_PETID, petId, 0);
  }
  void add_err(ErrorCode err) {
    fbb_.AddElement<int32_t>(PetSupportResponse::VT_ERR, static_cast<int32_t>(err), 0);
  }
  explicit PetSupportResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetSupportResponseBuilder &operator=(const PetSupportResponseBuilder &);
  flatbuffers::Offset<PetSupportResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetSupportResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetSupportResponse> CreatePetSupportResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t petId = 0,
    ErrorCode err = ErrorCode_NONE) {
  PetSupportResponseBuilder builder_(_fbb);
  builder_.add_err(err);
  builder_.add_petId(petId);
  return builder_.Finish();
}

/// PET_SUPPORT_CANCEL_REQUEST
struct PetSupportCancelRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PETID = 4
  };
  int32_t petId() const {
    return GetField<int32_t>(VT_PETID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PETID) &&
           verifier.EndTable();
  }
};

struct PetSupportCancelRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_petId(int32_t petId) {
    fbb_.AddElement<int32_t>(PetSupportCancelRequest::VT_PETID, petId, 0);
  }
  explicit PetSupportCancelRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetSupportCancelRequestBuilder &operator=(const PetSupportCancelRequestBuilder &);
  flatbuffers::Offset<PetSupportCancelRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetSupportCancelRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetSupportCancelRequest> CreatePetSupportCancelRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t petId = 0) {
  PetSupportCancelRequestBuilder builder_(_fbb);
  builder_.add_petId(petId);
  return builder_.Finish();
}

/// PET_SUPPORT_CANCEL_RESPONSE
struct PetSupportCancelResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PETID = 4,
    VT_ERR = 6,
    VT_REMAINDIGESTIONTICK = 8
  };
  int32_t petId() const {
    return GetField<int32_t>(VT_PETID, 0);
  }
  ErrorCode err() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERR, 0));
  }
  int64_t remainDigestionTick() const {
    return GetField<int64_t>(VT_REMAINDIGESTIONTICK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PETID) &&
           VerifyField<int32_t>(verifier, VT_ERR) &&
           VerifyField<int64_t>(verifier, VT_REMAINDIGESTIONTICK) &&
           verifier.EndTable();
  }
};

struct PetSupportCancelResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_petId(int32_t petId) {
    fbb_.AddElement<int32_t>(PetSupportCancelResponse::VT_PETID, petId, 0);
  }
  void add_err(ErrorCode err) {
    fbb_.AddElement<int32_t>(PetSupportCancelResponse::VT_ERR, static_cast<int32_t>(err), 0);
  }
  void add_remainDigestionTick(int64_t remainDigestionTick) {
    fbb_.AddElement<int64_t>(PetSupportCancelResponse::VT_REMAINDIGESTIONTICK, remainDigestionTick, 0);
  }
  explicit PetSupportCancelResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetSupportCancelResponseBuilder &operator=(const PetSupportCancelResponseBuilder &);
  flatbuffers::Offset<PetSupportCancelResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetSupportCancelResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetSupportCancelResponse> CreatePetSupportCancelResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t petId = 0,
    ErrorCode err = ErrorCode_NONE,
    int64_t remainDigestionTick = 0) {
  PetSupportCancelResponseBuilder builder_(_fbb);
  builder_.add_remainDigestionTick(remainDigestionTick);
  builder_.add_err(err);
  builder_.add_petId(petId);
  return builder_.Finish();
}

struct PetDigestionTime FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PETID = 4,
    VT_REMAINDIGESTIONTICK = 6
  };
  int32_t petId() const {
    return GetField<int32_t>(VT_PETID, 0);
  }
  int64_t remainDigestionTick() const {
    return GetField<int64_t>(VT_REMAINDIGESTIONTICK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PETID) &&
           VerifyField<int64_t>(verifier, VT_REMAINDIGESTIONTICK) &&
           verifier.EndTable();
  }
};

struct PetDigestionTimeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_petId(int32_t petId) {
    fbb_.AddElement<int32_t>(PetDigestionTime::VT_PETID, petId, 0);
  }
  void add_remainDigestionTick(int64_t remainDigestionTick) {
    fbb_.AddElement<int64_t>(PetDigestionTime::VT_REMAINDIGESTIONTICK, remainDigestionTick, 0);
  }
  explicit PetDigestionTimeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetDigestionTimeBuilder &operator=(const PetDigestionTimeBuilder &);
  flatbuffers::Offset<PetDigestionTime> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetDigestionTime>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetDigestionTime> CreatePetDigestionTime(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t petId = 0,
    int64_t remainDigestionTick = 0) {
  PetDigestionTimeBuilder builder_(_fbb);
  builder_.add_remainDigestionTick(remainDigestionTick);
  builder_.add_petId(petId);
  return builder_.Finish();
}

/// PET_REMAIN_DIGESTION_TIME_REQUEST
struct PetRemainDigestionTimeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct PetRemainDigestionTimeRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PetRemainDigestionTimeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetRemainDigestionTimeRequestBuilder &operator=(const PetRemainDigestionTimeRequestBuilder &);
  flatbuffers::Offset<PetRemainDigestionTimeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetRemainDigestionTimeRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetRemainDigestionTimeRequest> CreatePetRemainDigestionTimeRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PetRemainDigestionTimeRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// PET_REMAIN_DIGESTION_TIME_RESPONSE
struct PetRemainDigestionTimeResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATAS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<PetDigestionTime>> *datas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PetDigestionTime>> *>(VT_DATAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATAS) &&
           verifier.VerifyVector(datas()) &&
           verifier.VerifyVectorOfTables(datas()) &&
           verifier.EndTable();
  }
};

struct PetRemainDigestionTimeResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_datas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PetDigestionTime>>> datas) {
    fbb_.AddOffset(PetRemainDigestionTimeResponse::VT_DATAS, datas);
  }
  explicit PetRemainDigestionTimeResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetRemainDigestionTimeResponseBuilder &operator=(const PetRemainDigestionTimeResponseBuilder &);
  flatbuffers::Offset<PetRemainDigestionTimeResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetRemainDigestionTimeResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetRemainDigestionTimeResponse> CreatePetRemainDigestionTimeResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PetDigestionTime>>> datas = 0) {
  PetRemainDigestionTimeResponseBuilder builder_(_fbb);
  builder_.add_datas(datas);
  return builder_.Finish();
}

inline flatbuffers::Offset<PetRemainDigestionTimeResponse> CreatePetRemainDigestionTimeResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<PetDigestionTime>> *datas = nullptr) {
  return LeanPacket::CreatePetRemainDigestionTimeResponse(
      _fbb,
      datas ? _fbb.CreateVector<flatbuffers::Offset<PetDigestionTime>>(*datas) : 0);
}

/// PET_FUSION_REQUEST
struct PetFusionRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SOURCEPETIDS = 4,
    VT_SELECTEDLOOKPETID = 6,
    VT_SELECTEDSPECIALSTATPETID = 8,
    VT_SELECTEDNORMALSTATPETID = 10
  };
  const flatbuffers::Vector<int32_t> *sourcePetIds() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SOURCEPETIDS);
  }
  int32_t selectedLookPetId() const {
    return GetField<int32_t>(VT_SELECTEDLOOKPETID, 0);
  }
  int32_t selectedSpecialStatPetId() const {
    return GetField<int32_t>(VT_SELECTEDSPECIALSTATPETID, 0);
  }
  int32_t selectedNormalStatPetId() const {
    return GetField<int32_t>(VT_SELECTEDNORMALSTATPETID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SOURCEPETIDS) &&
           verifier.VerifyVector(sourcePetIds()) &&
           VerifyField<int32_t>(verifier, VT_SELECTEDLOOKPETID) &&
           VerifyField<int32_t>(verifier, VT_SELECTEDSPECIALSTATPETID) &&
           VerifyField<int32_t>(verifier, VT_SELECTEDNORMALSTATPETID) &&
           verifier.EndTable();
  }
};

struct PetFusionRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sourcePetIds(flatbuffers::Offset<flatbuffers::Vector<int32_t>> sourcePetIds) {
    fbb_.AddOffset(PetFusionRequest::VT_SOURCEPETIDS, sourcePetIds);
  }
  void add_selectedLookPetId(int32_t selectedLookPetId) {
    fbb_.AddElement<int32_t>(PetFusionRequest::VT_SELECTEDLOOKPETID, selectedLookPetId, 0);
  }
  void add_selectedSpecialStatPetId(int32_t selectedSpecialStatPetId) {
    fbb_.AddElement<int32_t>(PetFusionRequest::VT_SELECTEDSPECIALSTATPETID, selectedSpecialStatPetId, 0);
  }
  void add_selectedNormalStatPetId(int32_t selectedNormalStatPetId) {
    fbb_.AddElement<int32_t>(PetFusionRequest::VT_SELECTEDNORMALSTATPETID, selectedNormalStatPetId, 0);
  }
  explicit PetFusionRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetFusionRequestBuilder &operator=(const PetFusionRequestBuilder &);
  flatbuffers::Offset<PetFusionRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetFusionRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetFusionRequest> CreatePetFusionRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> sourcePetIds = 0,
    int32_t selectedLookPetId = 0,
    int32_t selectedSpecialStatPetId = 0,
    int32_t selectedNormalStatPetId = 0) {
  PetFusionRequestBuilder builder_(_fbb);
  builder_.add_selectedNormalStatPetId(selectedNormalStatPetId);
  builder_.add_selectedSpecialStatPetId(selectedSpecialStatPetId);
  builder_.add_selectedLookPetId(selectedLookPetId);
  builder_.add_sourcePetIds(sourcePetIds);
  return builder_.Finish();
}

inline flatbuffers::Offset<PetFusionRequest> CreatePetFusionRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *sourcePetIds = nullptr,
    int32_t selectedLookPetId = 0,
    int32_t selectedSpecialStatPetId = 0,
    int32_t selectedNormalStatPetId = 0) {
  return LeanPacket::CreatePetFusionRequest(
      _fbb,
      sourcePetIds ? _fbb.CreateVector<int32_t>(*sourcePetIds) : 0,
      selectedLookPetId,
      selectedSpecialStatPetId,
      selectedNormalStatPetId);
}

/// PET_FUSION_RESPONSE
struct PetFusionResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERR = 4,
    VT_NEWPET = 6
  };
  ErrorCode err() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERR, 0));
  }
  const Pet *newPet() const {
    return GetPointer<const Pet *>(VT_NEWPET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERR) &&
           VerifyOffset(verifier, VT_NEWPET) &&
           verifier.VerifyTable(newPet()) &&
           verifier.EndTable();
  }
};

struct PetFusionResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_err(ErrorCode err) {
    fbb_.AddElement<int32_t>(PetFusionResponse::VT_ERR, static_cast<int32_t>(err), 0);
  }
  void add_newPet(flatbuffers::Offset<Pet> newPet) {
    fbb_.AddOffset(PetFusionResponse::VT_NEWPET, newPet);
  }
  explicit PetFusionResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetFusionResponseBuilder &operator=(const PetFusionResponseBuilder &);
  flatbuffers::Offset<PetFusionResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetFusionResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetFusionResponse> CreatePetFusionResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode err = ErrorCode_NONE,
    flatbuffers::Offset<Pet> newPet = 0) {
  PetFusionResponseBuilder builder_(_fbb);
  builder_.add_newPet(newPet);
  builder_.add_err(err);
  return builder_.Finish();
}

/// PET_LEVEL_EXP_UP_NOTIFY
struct PetLevelExpUpNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PETID = 4,
    VT_LEVEL = 6,
    VT_EXP = 8,
    VT_STATS = 10
  };
  int32_t petId() const {
    return GetField<int32_t>(VT_PETID, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int32_t exp() const {
    return GetField<int32_t>(VT_EXP, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PetStat>> *stats() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PetStat>> *>(VT_STATS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PETID) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_EXP) &&
           VerifyOffset(verifier, VT_STATS) &&
           verifier.VerifyVector(stats()) &&
           verifier.VerifyVectorOfTables(stats()) &&
           verifier.EndTable();
  }
};

struct PetLevelExpUpNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_petId(int32_t petId) {
    fbb_.AddElement<int32_t>(PetLevelExpUpNotify::VT_PETID, petId, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(PetLevelExpUpNotify::VT_LEVEL, level, 0);
  }
  void add_exp(int32_t exp) {
    fbb_.AddElement<int32_t>(PetLevelExpUpNotify::VT_EXP, exp, 0);
  }
  void add_stats(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PetStat>>> stats) {
    fbb_.AddOffset(PetLevelExpUpNotify::VT_STATS, stats);
  }
  explicit PetLevelExpUpNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetLevelExpUpNotifyBuilder &operator=(const PetLevelExpUpNotifyBuilder &);
  flatbuffers::Offset<PetLevelExpUpNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetLevelExpUpNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetLevelExpUpNotify> CreatePetLevelExpUpNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t petId = 0,
    int32_t level = 0,
    int32_t exp = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PetStat>>> stats = 0) {
  PetLevelExpUpNotifyBuilder builder_(_fbb);
  builder_.add_stats(stats);
  builder_.add_exp(exp);
  builder_.add_level(level);
  builder_.add_petId(petId);
  return builder_.Finish();
}

inline flatbuffers::Offset<PetLevelExpUpNotify> CreatePetLevelExpUpNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t petId = 0,
    int32_t level = 0,
    int32_t exp = 0,
    const std::vector<flatbuffers::Offset<PetStat>> *stats = nullptr) {
  return LeanPacket::CreatePetLevelExpUpNotify(
      _fbb,
      petId,
      level,
      exp,
      stats ? _fbb.CreateVector<flatbuffers::Offset<PetStat>>(*stats) : 0);
}

/// PET_TOGGLE_SAFE_GUARD_REQUEST
struct PetToggleSafeGuardRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PETID = 4
  };
  int32_t petId() const {
    return GetField<int32_t>(VT_PETID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PETID) &&
           verifier.EndTable();
  }
};

struct PetToggleSafeGuardRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_petId(int32_t petId) {
    fbb_.AddElement<int32_t>(PetToggleSafeGuardRequest::VT_PETID, petId, 0);
  }
  explicit PetToggleSafeGuardRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetToggleSafeGuardRequestBuilder &operator=(const PetToggleSafeGuardRequestBuilder &);
  flatbuffers::Offset<PetToggleSafeGuardRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetToggleSafeGuardRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetToggleSafeGuardRequest> CreatePetToggleSafeGuardRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t petId = 0) {
  PetToggleSafeGuardRequestBuilder builder_(_fbb);
  builder_.add_petId(petId);
  return builder_.Finish();
}

/// PET_TOGGLE_SAFE_GUARD_RESPONSE
struct PetToggleSafeGuardResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PETID = 4,
    VT_ERR = 6,
    VT_ISSAFEGUARDED = 8
  };
  int32_t petId() const {
    return GetField<int32_t>(VT_PETID, 0);
  }
  ErrorCode err() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERR, 0));
  }
  bool isSafeGuarded() const {
    return GetField<uint8_t>(VT_ISSAFEGUARDED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PETID) &&
           VerifyField<int32_t>(verifier, VT_ERR) &&
           VerifyField<uint8_t>(verifier, VT_ISSAFEGUARDED) &&
           verifier.EndTable();
  }
};

struct PetToggleSafeGuardResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_petId(int32_t petId) {
    fbb_.AddElement<int32_t>(PetToggleSafeGuardResponse::VT_PETID, petId, 0);
  }
  void add_err(ErrorCode err) {
    fbb_.AddElement<int32_t>(PetToggleSafeGuardResponse::VT_ERR, static_cast<int32_t>(err), 0);
  }
  void add_isSafeGuarded(bool isSafeGuarded) {
    fbb_.AddElement<uint8_t>(PetToggleSafeGuardResponse::VT_ISSAFEGUARDED, static_cast<uint8_t>(isSafeGuarded), 0);
  }
  explicit PetToggleSafeGuardResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetToggleSafeGuardResponseBuilder &operator=(const PetToggleSafeGuardResponseBuilder &);
  flatbuffers::Offset<PetToggleSafeGuardResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetToggleSafeGuardResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetToggleSafeGuardResponse> CreatePetToggleSafeGuardResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t petId = 0,
    ErrorCode err = ErrorCode_NONE,
    bool isSafeGuarded = false) {
  PetToggleSafeGuardResponseBuilder builder_(_fbb);
  builder_.add_err(err);
  builder_.add_petId(petId);
  builder_.add_isSafeGuarded(isSafeGuarded);
  return builder_.Finish();
}

/////////////////////////////////////
/////////////////////////////////////
struct AltarActiveSkill FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_LEVEL = 6
  };
  int16_t type() const {
    return GetField<int16_t>(VT_TYPE, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           verifier.EndTable();
  }
};

struct AltarActiveSkillBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int16_t type) {
    fbb_.AddElement<int16_t>(AltarActiveSkill::VT_TYPE, type, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(AltarActiveSkill::VT_LEVEL, level, 0);
  }
  explicit AltarActiveSkillBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AltarActiveSkillBuilder &operator=(const AltarActiveSkillBuilder &);
  flatbuffers::Offset<AltarActiveSkill> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AltarActiveSkill>(end);
    return o;
  }
};

inline flatbuffers::Offset<AltarActiveSkill> CreateAltarActiveSkill(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t type = 0,
    int32_t level = 0) {
  AltarActiveSkillBuilder builder_(_fbb);
  builder_.add_level(level);
  builder_.add_type(type);
  return builder_.Finish();
}

struct PetAltar FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LEVEL = 4,
    VT_EXP = 6,
    VT_SKILLS = 8
  };
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int32_t exp() const {
    return GetField<int32_t>(VT_EXP, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AltarActiveSkill>> *skills() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AltarActiveSkill>> *>(VT_SKILLS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_EXP) &&
           VerifyOffset(verifier, VT_SKILLS) &&
           verifier.VerifyVector(skills()) &&
           verifier.VerifyVectorOfTables(skills()) &&
           verifier.EndTable();
  }
};

struct PetAltarBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(PetAltar::VT_LEVEL, level, 0);
  }
  void add_exp(int32_t exp) {
    fbb_.AddElement<int32_t>(PetAltar::VT_EXP, exp, 0);
  }
  void add_skills(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AltarActiveSkill>>> skills) {
    fbb_.AddOffset(PetAltar::VT_SKILLS, skills);
  }
  explicit PetAltarBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetAltarBuilder &operator=(const PetAltarBuilder &);
  flatbuffers::Offset<PetAltar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetAltar>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetAltar> CreatePetAltar(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t level = 0,
    int32_t exp = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AltarActiveSkill>>> skills = 0) {
  PetAltarBuilder builder_(_fbb);
  builder_.add_skills(skills);
  builder_.add_exp(exp);
  builder_.add_level(level);
  return builder_.Finish();
}

inline flatbuffers::Offset<PetAltar> CreatePetAltarDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t level = 0,
    int32_t exp = 0,
    const std::vector<flatbuffers::Offset<AltarActiveSkill>> *skills = nullptr) {
  return LeanPacket::CreatePetAltar(
      _fbb,
      level,
      exp,
      skills ? _fbb.CreateVector<flatbuffers::Offset<AltarActiveSkill>>(*skills) : 0);
}

/// PET_ALTAR_DATA_NOTIFY
struct PetAltarDataNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ALTAR = 4
  };
  const PetAltar *altar() const {
    return GetPointer<const PetAltar *>(VT_ALTAR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ALTAR) &&
           verifier.VerifyTable(altar()) &&
           verifier.EndTable();
  }
};

struct PetAltarDataNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_altar(flatbuffers::Offset<PetAltar> altar) {
    fbb_.AddOffset(PetAltarDataNotify::VT_ALTAR, altar);
  }
  explicit PetAltarDataNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetAltarDataNotifyBuilder &operator=(const PetAltarDataNotifyBuilder &);
  flatbuffers::Offset<PetAltarDataNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetAltarDataNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetAltarDataNotify> CreatePetAltarDataNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<PetAltar> altar = 0) {
  PetAltarDataNotifyBuilder builder_(_fbb);
  builder_.add_altar(altar);
  return builder_.Finish();
}

/// PET_ALTAR_LEVEL_EXP_NOTIFY
struct PetAltarLevelExpNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LEVEL = 4,
    VT_EXP = 6
  };
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int32_t exp() const {
    return GetField<int32_t>(VT_EXP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_EXP) &&
           verifier.EndTable();
  }
};

struct PetAltarLevelExpNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(PetAltarLevelExpNotify::VT_LEVEL, level, 0);
  }
  void add_exp(int32_t exp) {
    fbb_.AddElement<int32_t>(PetAltarLevelExpNotify::VT_EXP, exp, 0);
  }
  explicit PetAltarLevelExpNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetAltarLevelExpNotifyBuilder &operator=(const PetAltarLevelExpNotifyBuilder &);
  flatbuffers::Offset<PetAltarLevelExpNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetAltarLevelExpNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetAltarLevelExpNotify> CreatePetAltarLevelExpNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t level = 0,
    int32_t exp = 0) {
  PetAltarLevelExpNotifyBuilder builder_(_fbb);
  builder_.add_exp(exp);
  builder_.add_level(level);
  return builder_.Finish();
}

/// PET_ALTAR_POINT_NOTIFY
struct PetAltarPointNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_POINT = 4
  };
  int32_t point() const {
    return GetField<int32_t>(VT_POINT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_POINT) &&
           verifier.EndTable();
  }
};

struct PetAltarPointNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_point(int32_t point) {
    fbb_.AddElement<int32_t>(PetAltarPointNotify::VT_POINT, point, 0);
  }
  explicit PetAltarPointNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetAltarPointNotifyBuilder &operator=(const PetAltarPointNotifyBuilder &);
  flatbuffers::Offset<PetAltarPointNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetAltarPointNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetAltarPointNotify> CreatePetAltarPointNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t point = 0) {
  PetAltarPointNotifyBuilder builder_(_fbb);
  builder_.add_point(point);
  return builder_.Finish();
}

struct AltarDonateItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMID = 4,
    VT_COUNT = 6
  };
  int32_t itemId() const {
    return GetField<int32_t>(VT_ITEMID, 0);
  }
  int32_t count() const {
    return GetField<int32_t>(VT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ITEMID) &&
           VerifyField<int32_t>(verifier, VT_COUNT) &&
           verifier.EndTable();
  }
};

struct AltarDonateItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemId(int32_t itemId) {
    fbb_.AddElement<int32_t>(AltarDonateItem::VT_ITEMID, itemId, 0);
  }
  void add_count(int32_t count) {
    fbb_.AddElement<int32_t>(AltarDonateItem::VT_COUNT, count, 0);
  }
  explicit AltarDonateItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AltarDonateItemBuilder &operator=(const AltarDonateItemBuilder &);
  flatbuffers::Offset<AltarDonateItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AltarDonateItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<AltarDonateItem> CreateAltarDonateItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t itemId = 0,
    int32_t count = 0) {
  AltarDonateItemBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_itemId(itemId);
  return builder_.Finish();
}

/// PET_ALTAR_DONATE_REQUEST
struct PetAltarDonateRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<AltarDonateItem>> *items() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AltarDonateItem>> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.VerifyVectorOfTables(items()) &&
           verifier.EndTable();
  }
};

struct PetAltarDonateRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AltarDonateItem>>> items) {
    fbb_.AddOffset(PetAltarDonateRequest::VT_ITEMS, items);
  }
  explicit PetAltarDonateRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetAltarDonateRequestBuilder &operator=(const PetAltarDonateRequestBuilder &);
  flatbuffers::Offset<PetAltarDonateRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetAltarDonateRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetAltarDonateRequest> CreatePetAltarDonateRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AltarDonateItem>>> items = 0) {
  PetAltarDonateRequestBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<PetAltarDonateRequest> CreatePetAltarDonateRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<AltarDonateItem>> *items = nullptr) {
  return LeanPacket::CreatePetAltarDonateRequest(
      _fbb,
      items ? _fbb.CreateVector<flatbuffers::Offset<AltarDonateItem>>(*items) : 0);
}

/// PET_ALTAR_DONATE_RESPONSE
struct PetAltarDonateResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERR = 4,
    VT_ACQUIREPOINT = 6,
    VT_ACQUIREEXP = 8
  };
  ErrorCode err() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERR, 0));
  }
  int32_t acquirePoint() const {
    return GetField<int32_t>(VT_ACQUIREPOINT, 0);
  }
  int32_t acquireExp() const {
    return GetField<int32_t>(VT_ACQUIREEXP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERR) &&
           VerifyField<int32_t>(verifier, VT_ACQUIREPOINT) &&
           VerifyField<int32_t>(verifier, VT_ACQUIREEXP) &&
           verifier.EndTable();
  }
};

struct PetAltarDonateResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_err(ErrorCode err) {
    fbb_.AddElement<int32_t>(PetAltarDonateResponse::VT_ERR, static_cast<int32_t>(err), 0);
  }
  void add_acquirePoint(int32_t acquirePoint) {
    fbb_.AddElement<int32_t>(PetAltarDonateResponse::VT_ACQUIREPOINT, acquirePoint, 0);
  }
  void add_acquireExp(int32_t acquireExp) {
    fbb_.AddElement<int32_t>(PetAltarDonateResponse::VT_ACQUIREEXP, acquireExp, 0);
  }
  explicit PetAltarDonateResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetAltarDonateResponseBuilder &operator=(const PetAltarDonateResponseBuilder &);
  flatbuffers::Offset<PetAltarDonateResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetAltarDonateResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetAltarDonateResponse> CreatePetAltarDonateResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode err = ErrorCode_NONE,
    int32_t acquirePoint = 0,
    int32_t acquireExp = 0) {
  PetAltarDonateResponseBuilder builder_(_fbb);
  builder_.add_acquireExp(acquireExp);
  builder_.add_acquirePoint(acquirePoint);
  builder_.add_err(err);
  return builder_.Finish();
}

/// PET_ALTAR_ACTIVE_SKILL_LEVEL_UP_REQUEST
struct PetAltarActiveSkillLevelUpRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SKILL = 4,
    VT_COSTPETPOINT = 6
  };
  const AltarActiveSkill *skill() const {
    return GetPointer<const AltarActiveSkill *>(VT_SKILL);
  }
  int32_t costPetPoint() const {
    return GetField<int32_t>(VT_COSTPETPOINT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SKILL) &&
           verifier.VerifyTable(skill()) &&
           VerifyField<int32_t>(verifier, VT_COSTPETPOINT) &&
           verifier.EndTable();
  }
};

struct PetAltarActiveSkillLevelUpRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_skill(flatbuffers::Offset<AltarActiveSkill> skill) {
    fbb_.AddOffset(PetAltarActiveSkillLevelUpRequest::VT_SKILL, skill);
  }
  void add_costPetPoint(int32_t costPetPoint) {
    fbb_.AddElement<int32_t>(PetAltarActiveSkillLevelUpRequest::VT_COSTPETPOINT, costPetPoint, 0);
  }
  explicit PetAltarActiveSkillLevelUpRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetAltarActiveSkillLevelUpRequestBuilder &operator=(const PetAltarActiveSkillLevelUpRequestBuilder &);
  flatbuffers::Offset<PetAltarActiveSkillLevelUpRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetAltarActiveSkillLevelUpRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetAltarActiveSkillLevelUpRequest> CreatePetAltarActiveSkillLevelUpRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<AltarActiveSkill> skill = 0,
    int32_t costPetPoint = 0) {
  PetAltarActiveSkillLevelUpRequestBuilder builder_(_fbb);
  builder_.add_costPetPoint(costPetPoint);
  builder_.add_skill(skill);
  return builder_.Finish();
}

/// PET_ALTAR_ACTIVE_SKILL_LEVEL_UP_RESPONSE
struct PetAltarActiveSKillLevelUpResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERR = 4,
    VT_SKILL = 6
  };
  ErrorCode err() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERR, 0));
  }
  const AltarActiveSkill *skill() const {
    return GetPointer<const AltarActiveSkill *>(VT_SKILL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERR) &&
           VerifyOffset(verifier, VT_SKILL) &&
           verifier.VerifyTable(skill()) &&
           verifier.EndTable();
  }
};

struct PetAltarActiveSKillLevelUpResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_err(ErrorCode err) {
    fbb_.AddElement<int32_t>(PetAltarActiveSKillLevelUpResponse::VT_ERR, static_cast<int32_t>(err), 0);
  }
  void add_skill(flatbuffers::Offset<AltarActiveSkill> skill) {
    fbb_.AddOffset(PetAltarActiveSKillLevelUpResponse::VT_SKILL, skill);
  }
  explicit PetAltarActiveSKillLevelUpResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetAltarActiveSKillLevelUpResponseBuilder &operator=(const PetAltarActiveSKillLevelUpResponseBuilder &);
  flatbuffers::Offset<PetAltarActiveSKillLevelUpResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetAltarActiveSKillLevelUpResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetAltarActiveSKillLevelUpResponse> CreatePetAltarActiveSKillLevelUpResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode err = ErrorCode_NONE,
    flatbuffers::Offset<AltarActiveSkill> skill = 0) {
  PetAltarActiveSKillLevelUpResponseBuilder builder_(_fbb);
  builder_.add_skill(skill);
  builder_.add_err(err);
  return builder_.Finish();
}

struct PetHatchery FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HATCHERYID = 4,
    VT_STATE = 6,
    VT_HATCHTIMEUTC = 8
  };
  int32_t hatcheryId() const {
    return GetField<int32_t>(VT_HATCHERYID, 0);
  }
  PetHatcheryState state() const {
    return static_cast<PetHatcheryState>(GetField<int16_t>(VT_STATE, 0));
  }
  int64_t hatchTimeUtc() const {
    return GetField<int64_t>(VT_HATCHTIMEUTC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_HATCHERYID) &&
           VerifyField<int16_t>(verifier, VT_STATE) &&
           VerifyField<int64_t>(verifier, VT_HATCHTIMEUTC) &&
           verifier.EndTable();
  }
};

struct PetHatcheryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hatcheryId(int32_t hatcheryId) {
    fbb_.AddElement<int32_t>(PetHatchery::VT_HATCHERYID, hatcheryId, 0);
  }
  void add_state(PetHatcheryState state) {
    fbb_.AddElement<int16_t>(PetHatchery::VT_STATE, static_cast<int16_t>(state), 0);
  }
  void add_hatchTimeUtc(int64_t hatchTimeUtc) {
    fbb_.AddElement<int64_t>(PetHatchery::VT_HATCHTIMEUTC, hatchTimeUtc, 0);
  }
  explicit PetHatcheryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetHatcheryBuilder &operator=(const PetHatcheryBuilder &);
  flatbuffers::Offset<PetHatchery> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetHatchery>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetHatchery> CreatePetHatchery(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t hatcheryId = 0,
    PetHatcheryState state = PetHatcheryState_PET_HATCHERY_STATE_SPAWN_READY,
    int64_t hatchTimeUtc = 0) {
  PetHatcheryBuilder builder_(_fbb);
  builder_.add_hatchTimeUtc(hatchTimeUtc);
  builder_.add_hatcheryId(hatcheryId);
  builder_.add_state(state);
  return builder_.Finish();
}

/// PET_HATCHERY_DATA_NOTIFY
struct PetHatcheryDataNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HATCHERYS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<PetHatchery>> *hatcherys() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PetHatchery>> *>(VT_HATCHERYS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HATCHERYS) &&
           verifier.VerifyVector(hatcherys()) &&
           verifier.VerifyVectorOfTables(hatcherys()) &&
           verifier.EndTable();
  }
};

struct PetHatcheryDataNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hatcherys(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PetHatchery>>> hatcherys) {
    fbb_.AddOffset(PetHatcheryDataNotify::VT_HATCHERYS, hatcherys);
  }
  explicit PetHatcheryDataNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetHatcheryDataNotifyBuilder &operator=(const PetHatcheryDataNotifyBuilder &);
  flatbuffers::Offset<PetHatcheryDataNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetHatcheryDataNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetHatcheryDataNotify> CreatePetHatcheryDataNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PetHatchery>>> hatcherys = 0) {
  PetHatcheryDataNotifyBuilder builder_(_fbb);
  builder_.add_hatcherys(hatcherys);
  return builder_.Finish();
}

inline flatbuffers::Offset<PetHatcheryDataNotify> CreatePetHatcheryDataNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<PetHatchery>> *hatcherys = nullptr) {
  return LeanPacket::CreatePetHatcheryDataNotify(
      _fbb,
      hatcherys ? _fbb.CreateVector<flatbuffers::Offset<PetHatchery>>(*hatcherys) : 0);
}

/// PET_HATCHERY_SPAWN_REQUEST
struct PetHatcherySpawnRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HATCHERYID = 4
  };
  int32_t hatcheryId() const {
    return GetField<int32_t>(VT_HATCHERYID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_HATCHERYID) &&
           verifier.EndTable();
  }
};

struct PetHatcherySpawnRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hatcheryId(int32_t hatcheryId) {
    fbb_.AddElement<int32_t>(PetHatcherySpawnRequest::VT_HATCHERYID, hatcheryId, 0);
  }
  explicit PetHatcherySpawnRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetHatcherySpawnRequestBuilder &operator=(const PetHatcherySpawnRequestBuilder &);
  flatbuffers::Offset<PetHatcherySpawnRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetHatcherySpawnRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetHatcherySpawnRequest> CreatePetHatcherySpawnRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t hatcheryId = 0) {
  PetHatcherySpawnRequestBuilder builder_(_fbb);
  builder_.add_hatcheryId(hatcheryId);
  return builder_.Finish();
}

/// PET_HATCHERY_SPAWN_RESPONSE
struct PetHatcherySpawnResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HATCHERYID = 4,
    VT_ERR = 6,
    VT_HATCHTIMEUTC = 8
  };
  int32_t hatcheryId() const {
    return GetField<int32_t>(VT_HATCHERYID, 0);
  }
  ErrorCode err() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERR, 0));
  }
  int64_t hatchTimeUtc() const {
    return GetField<int64_t>(VT_HATCHTIMEUTC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_HATCHERYID) &&
           VerifyField<int32_t>(verifier, VT_ERR) &&
           VerifyField<int64_t>(verifier, VT_HATCHTIMEUTC) &&
           verifier.EndTable();
  }
};

struct PetHatcherySpawnResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hatcheryId(int32_t hatcheryId) {
    fbb_.AddElement<int32_t>(PetHatcherySpawnResponse::VT_HATCHERYID, hatcheryId, 0);
  }
  void add_err(ErrorCode err) {
    fbb_.AddElement<int32_t>(PetHatcherySpawnResponse::VT_ERR, static_cast<int32_t>(err), 0);
  }
  void add_hatchTimeUtc(int64_t hatchTimeUtc) {
    fbb_.AddElement<int64_t>(PetHatcherySpawnResponse::VT_HATCHTIMEUTC, hatchTimeUtc, 0);
  }
  explicit PetHatcherySpawnResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetHatcherySpawnResponseBuilder &operator=(const PetHatcherySpawnResponseBuilder &);
  flatbuffers::Offset<PetHatcherySpawnResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetHatcherySpawnResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetHatcherySpawnResponse> CreatePetHatcherySpawnResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t hatcheryId = 0,
    ErrorCode err = ErrorCode_NONE,
    int64_t hatchTimeUtc = 0) {
  PetHatcherySpawnResponseBuilder builder_(_fbb);
  builder_.add_hatchTimeUtc(hatchTimeUtc);
  builder_.add_err(err);
  builder_.add_hatcheryId(hatcheryId);
  return builder_.Finish();
}

/// PET_HATCHERY_HATCH_REQUEST
struct PetHatcheryHatchRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HATCHERYID = 4
  };
  int32_t hatcheryId() const {
    return GetField<int32_t>(VT_HATCHERYID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_HATCHERYID) &&
           verifier.EndTable();
  }
};

struct PetHatcheryHatchRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hatcheryId(int32_t hatcheryId) {
    fbb_.AddElement<int32_t>(PetHatcheryHatchRequest::VT_HATCHERYID, hatcheryId, 0);
  }
  explicit PetHatcheryHatchRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetHatcheryHatchRequestBuilder &operator=(const PetHatcheryHatchRequestBuilder &);
  flatbuffers::Offset<PetHatcheryHatchRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetHatcheryHatchRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetHatcheryHatchRequest> CreatePetHatcheryHatchRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t hatcheryId = 0) {
  PetHatcheryHatchRequestBuilder builder_(_fbb);
  builder_.add_hatcheryId(hatcheryId);
  return builder_.Finish();
}

/// PET_HATCHERY_HATCH_RESPONSE	
struct PetHatcheryHatchResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HATCHERYID = 4,
    VT_ERR = 6
  };
  int32_t hatcheryId() const {
    return GetField<int32_t>(VT_HATCHERYID, 0);
  }
  ErrorCode err() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERR, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_HATCHERYID) &&
           VerifyField<int32_t>(verifier, VT_ERR) &&
           verifier.EndTable();
  }
};

struct PetHatcheryHatchResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hatcheryId(int32_t hatcheryId) {
    fbb_.AddElement<int32_t>(PetHatcheryHatchResponse::VT_HATCHERYID, hatcheryId, 0);
  }
  void add_err(ErrorCode err) {
    fbb_.AddElement<int32_t>(PetHatcheryHatchResponse::VT_ERR, static_cast<int32_t>(err), 0);
  }
  explicit PetHatcheryHatchResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PetHatcheryHatchResponseBuilder &operator=(const PetHatcheryHatchResponseBuilder &);
  flatbuffers::Offset<PetHatcheryHatchResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PetHatcheryHatchResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<PetHatcheryHatchResponse> CreatePetHatcheryHatchResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t hatcheryId = 0,
    ErrorCode err = ErrorCode_NONE) {
  PetHatcheryHatchResponseBuilder builder_(_fbb);
  builder_.add_err(err);
  builder_.add_hatcheryId(hatcheryId);
  return builder_.Finish();
}

/////////////////////////////////////
/////////////////////////////////////
struct InheritCostumeResultInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMOBJECTID = 4,
    VT_LEVEL = 6,
    VT_EXP = 8,
    VT_GRADE = 10
  };
  uint64_t itemObjectId() const {
    return GetField<uint64_t>(VT_ITEMOBJECTID, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int32_t exp() const {
    return GetField<int32_t>(VT_EXP, 0);
  }
  int16_t grade() const {
    return GetField<int16_t>(VT_GRADE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ITEMOBJECTID) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_EXP) &&
           VerifyField<int16_t>(verifier, VT_GRADE) &&
           verifier.EndTable();
  }
};

struct InheritCostumeResultInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemObjectId(uint64_t itemObjectId) {
    fbb_.AddElement<uint64_t>(InheritCostumeResultInfo::VT_ITEMOBJECTID, itemObjectId, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(InheritCostumeResultInfo::VT_LEVEL, level, 0);
  }
  void add_exp(int32_t exp) {
    fbb_.AddElement<int32_t>(InheritCostumeResultInfo::VT_EXP, exp, 0);
  }
  void add_grade(int16_t grade) {
    fbb_.AddElement<int16_t>(InheritCostumeResultInfo::VT_GRADE, grade, 0);
  }
  explicit InheritCostumeResultInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InheritCostumeResultInfoBuilder &operator=(const InheritCostumeResultInfoBuilder &);
  flatbuffers::Offset<InheritCostumeResultInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InheritCostumeResultInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<InheritCostumeResultInfo> CreateInheritCostumeResultInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t itemObjectId = 0,
    int32_t level = 0,
    int32_t exp = 0,
    int16_t grade = 0) {
  InheritCostumeResultInfoBuilder builder_(_fbb);
  builder_.add_itemObjectId(itemObjectId);
  builder_.add_exp(exp);
  builder_.add_level(level);
  builder_.add_grade(grade);
  return builder_.Finish();
}

///- INHERIT_COSTUME_REQUEST --------------
struct InheritCostumeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TARGETITEMOBJECTID = 4,
    VT_MATERIALITEMOBJECTID = 6
  };
  uint64_t targetItemObjectId() const {
    return GetField<uint64_t>(VT_TARGETITEMOBJECTID, 0);
  }
  uint64_t materialItemObjectId() const {
    return GetField<uint64_t>(VT_MATERIALITEMOBJECTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TARGETITEMOBJECTID) &&
           VerifyField<uint64_t>(verifier, VT_MATERIALITEMOBJECTID) &&
           verifier.EndTable();
  }
};

struct InheritCostumeRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_targetItemObjectId(uint64_t targetItemObjectId) {
    fbb_.AddElement<uint64_t>(InheritCostumeRequest::VT_TARGETITEMOBJECTID, targetItemObjectId, 0);
  }
  void add_materialItemObjectId(uint64_t materialItemObjectId) {
    fbb_.AddElement<uint64_t>(InheritCostumeRequest::VT_MATERIALITEMOBJECTID, materialItemObjectId, 0);
  }
  explicit InheritCostumeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InheritCostumeRequestBuilder &operator=(const InheritCostumeRequestBuilder &);
  flatbuffers::Offset<InheritCostumeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InheritCostumeRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<InheritCostumeRequest> CreateInheritCostumeRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t targetItemObjectId = 0,
    uint64_t materialItemObjectId = 0) {
  InheritCostumeRequestBuilder builder_(_fbb);
  builder_.add_materialItemObjectId(materialItemObjectId);
  builder_.add_targetItemObjectId(targetItemObjectId);
  return builder_.Finish();
}

///- INHERIT_COSTUME_RESPONSE --------------
struct InheritCostumeResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_TARGET = 6,
    VT_MATERIAL = 8
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  const InheritCostumeResultInfo *target() const {
    return GetPointer<const InheritCostumeResultInfo *>(VT_TARGET);
  }
  const InheritCostumeResultInfo *material() const {
    return GetPointer<const InheritCostumeResultInfo *>(VT_MATERIAL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyOffsetRequired(verifier, VT_TARGET) &&
           verifier.VerifyTable(target()) &&
           VerifyOffsetRequired(verifier, VT_MATERIAL) &&
           verifier.VerifyTable(material()) &&
           verifier.EndTable();
  }
};

struct InheritCostumeResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(InheritCostumeResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_target(flatbuffers::Offset<InheritCostumeResultInfo> target) {
    fbb_.AddOffset(InheritCostumeResponse::VT_TARGET, target);
  }
  void add_material(flatbuffers::Offset<InheritCostumeResultInfo> material) {
    fbb_.AddOffset(InheritCostumeResponse::VT_MATERIAL, material);
  }
  explicit InheritCostumeResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InheritCostumeResponseBuilder &operator=(const InheritCostumeResponseBuilder &);
  flatbuffers::Offset<InheritCostumeResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InheritCostumeResponse>(end);
    fbb_.Required(o, InheritCostumeResponse::VT_TARGET);
    fbb_.Required(o, InheritCostumeResponse::VT_MATERIAL);
    return o;
  }
};

inline flatbuffers::Offset<InheritCostumeResponse> CreateInheritCostumeResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    flatbuffers::Offset<InheritCostumeResultInfo> target = 0,
    flatbuffers::Offset<InheritCostumeResultInfo> material = 0) {
  InheritCostumeResponseBuilder builder_(_fbb);
  builder_.add_material(material);
  builder_.add_target(target);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

/////////////////////////////////////
/////////////////////////////////////	
/// 천상석 변환 횟수 정보
struct CrystalItemChangeCountInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMOBJECTID = 4,
    VT_CHANGEITEMSTACKCOUNT = 6
  };
  uint64_t itemObjectId() const {
    return GetField<uint64_t>(VT_ITEMOBJECTID, 0);
  }
  int32_t changeItemStackCount() const {
    return GetField<int32_t>(VT_CHANGEITEMSTACKCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ITEMOBJECTID) &&
           VerifyField<int32_t>(verifier, VT_CHANGEITEMSTACKCOUNT) &&
           verifier.EndTable();
  }
};

struct CrystalItemChangeCountInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemObjectId(uint64_t itemObjectId) {
    fbb_.AddElement<uint64_t>(CrystalItemChangeCountInfo::VT_ITEMOBJECTID, itemObjectId, 0);
  }
  void add_changeItemStackCount(int32_t changeItemStackCount) {
    fbb_.AddElement<int32_t>(CrystalItemChangeCountInfo::VT_CHANGEITEMSTACKCOUNT, changeItemStackCount, 0);
  }
  explicit CrystalItemChangeCountInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CrystalItemChangeCountInfoBuilder &operator=(const CrystalItemChangeCountInfoBuilder &);
  flatbuffers::Offset<CrystalItemChangeCountInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CrystalItemChangeCountInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<CrystalItemChangeCountInfo> CreateCrystalItemChangeCountInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t itemObjectId = 0,
    int32_t changeItemStackCount = 0) {
  CrystalItemChangeCountInfoBuilder builder_(_fbb);
  builder_.add_itemObjectId(itemObjectId);
  builder_.add_changeItemStackCount(changeItemStackCount);
  return builder_.Finish();
}

/// CHANGE_CRYSTAL_ITEM_REQUEST
struct ChangeCrystalItemRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CRAFTID = 4,
    VT_ITEMOBJECTID = 6
  };
  int32_t craftId() const {
    return GetField<int32_t>(VT_CRAFTID, 0);
  }
  uint64_t itemObjectId() const {
    return GetField<uint64_t>(VT_ITEMOBJECTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CRAFTID) &&
           VerifyField<uint64_t>(verifier, VT_ITEMOBJECTID) &&
           verifier.EndTable();
  }
};

struct ChangeCrystalItemRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_craftId(int32_t craftId) {
    fbb_.AddElement<int32_t>(ChangeCrystalItemRequest::VT_CRAFTID, craftId, 0);
  }
  void add_itemObjectId(uint64_t itemObjectId) {
    fbb_.AddElement<uint64_t>(ChangeCrystalItemRequest::VT_ITEMOBJECTID, itemObjectId, 0);
  }
  explicit ChangeCrystalItemRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChangeCrystalItemRequestBuilder &operator=(const ChangeCrystalItemRequestBuilder &);
  flatbuffers::Offset<ChangeCrystalItemRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChangeCrystalItemRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChangeCrystalItemRequest> CreateChangeCrystalItemRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t craftId = 0,
    uint64_t itemObjectId = 0) {
  ChangeCrystalItemRequestBuilder builder_(_fbb);
  builder_.add_itemObjectId(itemObjectId);
  builder_.add_craftId(craftId);
  return builder_.Finish();
}

/// CHANGE_CRYSTAL_ITEM_RESPONSE
struct ChangeCrystalItemResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORCODE = 4,
    VT_CRAFTID = 6,
    VT_CLIENTLITEM = 8,
    VT_CHANGECOUNTINFO = 10
  };
  int32_t errorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  int32_t craftId() const {
    return GetField<int32_t>(VT_CRAFTID, 0);
  }
  const ClientLItem *clientLItem() const {
    return GetPointer<const ClientLItem *>(VT_CLIENTLITEM);
  }
  const CrystalItemChangeCountInfo *changeCountInfo() const {
    return GetPointer<const CrystalItemChangeCountInfo *>(VT_CHANGECOUNTINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int32_t>(verifier, VT_CRAFTID) &&
           VerifyOffset(verifier, VT_CLIENTLITEM) &&
           verifier.VerifyTable(clientLItem()) &&
           VerifyOffset(verifier, VT_CHANGECOUNTINFO) &&
           verifier.VerifyTable(changeCountInfo()) &&
           verifier.EndTable();
  }
};

struct ChangeCrystalItemResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errorCode(int32_t errorCode) {
    fbb_.AddElement<int32_t>(ChangeCrystalItemResponse::VT_ERRORCODE, errorCode, 0);
  }
  void add_craftId(int32_t craftId) {
    fbb_.AddElement<int32_t>(ChangeCrystalItemResponse::VT_CRAFTID, craftId, 0);
  }
  void add_clientLItem(flatbuffers::Offset<ClientLItem> clientLItem) {
    fbb_.AddOffset(ChangeCrystalItemResponse::VT_CLIENTLITEM, clientLItem);
  }
  void add_changeCountInfo(flatbuffers::Offset<CrystalItemChangeCountInfo> changeCountInfo) {
    fbb_.AddOffset(ChangeCrystalItemResponse::VT_CHANGECOUNTINFO, changeCountInfo);
  }
  explicit ChangeCrystalItemResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChangeCrystalItemResponseBuilder &operator=(const ChangeCrystalItemResponseBuilder &);
  flatbuffers::Offset<ChangeCrystalItemResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChangeCrystalItemResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChangeCrystalItemResponse> CreateChangeCrystalItemResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorCode = 0,
    int32_t craftId = 0,
    flatbuffers::Offset<ClientLItem> clientLItem = 0,
    flatbuffers::Offset<CrystalItemChangeCountInfo> changeCountInfo = 0) {
  ChangeCrystalItemResponseBuilder builder_(_fbb);
  builder_.add_changeCountInfo(changeCountInfo);
  builder_.add_clientLItem(clientLItem);
  builder_.add_craftId(craftId);
  builder_.add_errorCode(errorCode);
  return builder_.Finish();
}

/// CRYSTAL_ITEM_CHANGE_COUNT_NOTIFY
struct CrystalItemChangeCountNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATAS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<CrystalItemChangeCountInfo>> *datas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CrystalItemChangeCountInfo>> *>(VT_DATAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DATAS) &&
           verifier.VerifyVector(datas()) &&
           verifier.VerifyVectorOfTables(datas()) &&
           verifier.EndTable();
  }
};

struct CrystalItemChangeCountNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_datas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CrystalItemChangeCountInfo>>> datas) {
    fbb_.AddOffset(CrystalItemChangeCountNotify::VT_DATAS, datas);
  }
  explicit CrystalItemChangeCountNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CrystalItemChangeCountNotifyBuilder &operator=(const CrystalItemChangeCountNotifyBuilder &);
  flatbuffers::Offset<CrystalItemChangeCountNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CrystalItemChangeCountNotify>(end);
    fbb_.Required(o, CrystalItemChangeCountNotify::VT_DATAS);
    return o;
  }
};

inline flatbuffers::Offset<CrystalItemChangeCountNotify> CreateCrystalItemChangeCountNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CrystalItemChangeCountInfo>>> datas = 0) {
  CrystalItemChangeCountNotifyBuilder builder_(_fbb);
  builder_.add_datas(datas);
  return builder_.Finish();
}

inline flatbuffers::Offset<CrystalItemChangeCountNotify> CreateCrystalItemChangeCountNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<CrystalItemChangeCountInfo>> *datas = nullptr) {
  return LeanPacket::CreateCrystalItemChangeCountNotify(
      _fbb,
      datas ? _fbb.CreateVector<flatbuffers::Offset<CrystalItemChangeCountInfo>>(*datas) : 0);
}

/// NOTICE_ELITE_MONSTER_KILL_NOTIFY
struct NoticeEliteMonsterKillNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_REALM = 4,
    VT_MONSTERID = 6,
    VT_PCCLASSTYPE = 8,
    VT_PCNAME = 10
  };
  int16_t realm() const {
    return GetField<int16_t>(VT_REALM, 0);
  }
  int32_t monsterId() const {
    return GetField<int32_t>(VT_MONSTERID, 0);
  }
  int32_t pcClassType() const {
    return GetField<int32_t>(VT_PCCLASSTYPE, 0);
  }
  const flatbuffers::String *pcName() const {
    return GetPointer<const flatbuffers::String *>(VT_PCNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_REALM) &&
           VerifyField<int32_t>(verifier, VT_MONSTERID) &&
           VerifyField<int32_t>(verifier, VT_PCCLASSTYPE) &&
           VerifyOffset(verifier, VT_PCNAME) &&
           verifier.VerifyString(pcName()) &&
           verifier.EndTable();
  }
};

struct NoticeEliteMonsterKillNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_realm(int16_t realm) {
    fbb_.AddElement<int16_t>(NoticeEliteMonsterKillNotify::VT_REALM, realm, 0);
  }
  void add_monsterId(int32_t monsterId) {
    fbb_.AddElement<int32_t>(NoticeEliteMonsterKillNotify::VT_MONSTERID, monsterId, 0);
  }
  void add_pcClassType(int32_t pcClassType) {
    fbb_.AddElement<int32_t>(NoticeEliteMonsterKillNotify::VT_PCCLASSTYPE, pcClassType, 0);
  }
  void add_pcName(flatbuffers::Offset<flatbuffers::String> pcName) {
    fbb_.AddOffset(NoticeEliteMonsterKillNotify::VT_PCNAME, pcName);
  }
  explicit NoticeEliteMonsterKillNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NoticeEliteMonsterKillNotifyBuilder &operator=(const NoticeEliteMonsterKillNotifyBuilder &);
  flatbuffers::Offset<NoticeEliteMonsterKillNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NoticeEliteMonsterKillNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<NoticeEliteMonsterKillNotify> CreateNoticeEliteMonsterKillNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t realm = 0,
    int32_t monsterId = 0,
    int32_t pcClassType = 0,
    flatbuffers::Offset<flatbuffers::String> pcName = 0) {
  NoticeEliteMonsterKillNotifyBuilder builder_(_fbb);
  builder_.add_pcName(pcName);
  builder_.add_pcClassType(pcClassType);
  builder_.add_monsterId(monsterId);
  builder_.add_realm(realm);
  return builder_.Finish();
}

inline flatbuffers::Offset<NoticeEliteMonsterKillNotify> CreateNoticeEliteMonsterKillNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t realm = 0,
    int32_t monsterId = 0,
    int32_t pcClassType = 0,
    const char *pcName = nullptr) {
  return LeanPacket::CreateNoticeEliteMonsterKillNotify(
      _fbb,
      realm,
      monsterId,
      pcClassType,
      pcName ? _fbb.CreateString(pcName) : 0);
}

/////////////////////////////////////
/////////////////////////////////////	
/// CONFLICT_FIELD_MOVE_HOME_SERVER_REQUEST
struct ConflictFieldMoveHomeServerRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ConflictFieldMoveHomeServerRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ConflictFieldMoveHomeServerRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConflictFieldMoveHomeServerRequestBuilder &operator=(const ConflictFieldMoveHomeServerRequestBuilder &);
  flatbuffers::Offset<ConflictFieldMoveHomeServerRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConflictFieldMoveHomeServerRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConflictFieldMoveHomeServerRequest> CreateConflictFieldMoveHomeServerRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ConflictFieldMoveHomeServerRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// CONFLICT_FIELD_MOVE_HOME_SERVER_RESPONSE
struct ConflictFieldMoveHomeServerResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERR = 4
  };
  ErrorCode err() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERR, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERR) &&
           verifier.EndTable();
  }
};

struct ConflictFieldMoveHomeServerResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_err(ErrorCode err) {
    fbb_.AddElement<int32_t>(ConflictFieldMoveHomeServerResponse::VT_ERR, static_cast<int32_t>(err), 0);
  }
  explicit ConflictFieldMoveHomeServerResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConflictFieldMoveHomeServerResponseBuilder &operator=(const ConflictFieldMoveHomeServerResponseBuilder &);
  flatbuffers::Offset<ConflictFieldMoveHomeServerResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConflictFieldMoveHomeServerResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConflictFieldMoveHomeServerResponse> CreateConflictFieldMoveHomeServerResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode err = ErrorCode_NONE) {
  ConflictFieldMoveHomeServerResponseBuilder builder_(_fbb);
  builder_.add_err(err);
  return builder_.Finish();
}

/// KINGSROAD_QUERY_MAINSTREAM_QUEST_REQUEST
struct KingsRoadMainStreamQuestRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_QUESTID = 4
  };
  int32_t questId() const {
    return GetField<int32_t>(VT_QUESTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_QUESTID) &&
           verifier.EndTable();
  }
};

struct KingsRoadMainStreamQuestRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_questId(int32_t questId) {
    fbb_.AddElement<int32_t>(KingsRoadMainStreamQuestRequest::VT_QUESTID, questId, 0);
  }
  explicit KingsRoadMainStreamQuestRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  KingsRoadMainStreamQuestRequestBuilder &operator=(const KingsRoadMainStreamQuestRequestBuilder &);
  flatbuffers::Offset<KingsRoadMainStreamQuestRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KingsRoadMainStreamQuestRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<KingsRoadMainStreamQuestRequest> CreateKingsRoadMainStreamQuestRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t questId = 0) {
  KingsRoadMainStreamQuestRequestBuilder builder_(_fbb);
  builder_.add_questId(questId);
  return builder_.Finish();
}

/// KINGSROAD_QUERY_MAINSTREAM_QUEST_RESPONSE 
struct KingsRoadMainStreamQuestResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_QUESTID = 4,
    VT_ERR = 6
  };
  int32_t questId() const {
    return GetField<int32_t>(VT_QUESTID, 0);
  }
  ErrorCode err() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERR, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_QUESTID) &&
           VerifyField<int32_t>(verifier, VT_ERR) &&
           verifier.EndTable();
  }
};

struct KingsRoadMainStreamQuestResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_questId(int32_t questId) {
    fbb_.AddElement<int32_t>(KingsRoadMainStreamQuestResponse::VT_QUESTID, questId, 0);
  }
  void add_err(ErrorCode err) {
    fbb_.AddElement<int32_t>(KingsRoadMainStreamQuestResponse::VT_ERR, static_cast<int32_t>(err), 0);
  }
  explicit KingsRoadMainStreamQuestResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  KingsRoadMainStreamQuestResponseBuilder &operator=(const KingsRoadMainStreamQuestResponseBuilder &);
  flatbuffers::Offset<KingsRoadMainStreamQuestResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KingsRoadMainStreamQuestResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<KingsRoadMainStreamQuestResponse> CreateKingsRoadMainStreamQuestResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t questId = 0,
    ErrorCode err = ErrorCode_NONE) {
  KingsRoadMainStreamQuestResponseBuilder builder_(_fbb);
  builder_.add_err(err);
  builder_.add_questId(questId);
  return builder_.Finish();
}

struct RVRPointPerRealm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_REALM = 4,
    VT_POINT = 6
  };
  int16_t realm() const {
    return GetField<int16_t>(VT_REALM, 0);
  }
  int32_t point() const {
    return GetField<int32_t>(VT_POINT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_REALM) &&
           VerifyField<int32_t>(verifier, VT_POINT) &&
           verifier.EndTable();
  }
};

struct RVRPointPerRealmBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_realm(int16_t realm) {
    fbb_.AddElement<int16_t>(RVRPointPerRealm::VT_REALM, realm, 0);
  }
  void add_point(int32_t point) {
    fbb_.AddElement<int32_t>(RVRPointPerRealm::VT_POINT, point, 0);
  }
  explicit RVRPointPerRealmBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRPointPerRealmBuilder &operator=(const RVRPointPerRealmBuilder &);
  flatbuffers::Offset<RVRPointPerRealm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRPointPerRealm>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRPointPerRealm> CreateRVRPointPerRealm(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t realm = 0,
    int32_t point = 0) {
  RVRPointPerRealmBuilder builder_(_fbb);
  builder_.add_point(point);
  builder_.add_realm(realm);
  return builder_.Finish();
}

/// RVR_MAIN_HUD_POINT_INFO_NOTIFY
struct RVRMainHudPointInfoNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_POINTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<RVRPointPerRealm>> *points() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<RVRPointPerRealm>> *>(VT_POINTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.VerifyVectorOfTables(points()) &&
           verifier.EndTable();
  }
};

struct RVRMainHudPointInfoNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_points(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RVRPointPerRealm>>> points) {
    fbb_.AddOffset(RVRMainHudPointInfoNotify::VT_POINTS, points);
  }
  explicit RVRMainHudPointInfoNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVRMainHudPointInfoNotifyBuilder &operator=(const RVRMainHudPointInfoNotifyBuilder &);
  flatbuffers::Offset<RVRMainHudPointInfoNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVRMainHudPointInfoNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVRMainHudPointInfoNotify> CreateRVRMainHudPointInfoNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RVRPointPerRealm>>> points = 0) {
  RVRMainHudPointInfoNotifyBuilder builder_(_fbb);
  builder_.add_points(points);
  return builder_.Finish();
}

inline flatbuffers::Offset<RVRMainHudPointInfoNotify> CreateRVRMainHudPointInfoNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<RVRPointPerRealm>> *points = nullptr) {
  return LeanPacket::CreateRVRMainHudPointInfoNotify(
      _fbb,
      points ? _fbb.CreateVector<flatbuffers::Offset<RVRPointPerRealm>>(*points) : 0);
}

struct RVROccupyingGaugePerRealm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_REALM = 4,
    VT_GAUGE = 6
  };
  int16_t realm() const {
    return GetField<int16_t>(VT_REALM, 0);
  }
  int32_t gauge() const {
    return GetField<int32_t>(VT_GAUGE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_REALM) &&
           VerifyField<int32_t>(verifier, VT_GAUGE) &&
           verifier.EndTable();
  }
};

struct RVROccupyingGaugePerRealmBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_realm(int16_t realm) {
    fbb_.AddElement<int16_t>(RVROccupyingGaugePerRealm::VT_REALM, realm, 0);
  }
  void add_gauge(int32_t gauge) {
    fbb_.AddElement<int32_t>(RVROccupyingGaugePerRealm::VT_GAUGE, gauge, 0);
  }
  explicit RVROccupyingGaugePerRealmBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVROccupyingGaugePerRealmBuilder &operator=(const RVROccupyingGaugePerRealmBuilder &);
  flatbuffers::Offset<RVROccupyingGaugePerRealm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVROccupyingGaugePerRealm>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVROccupyingGaugePerRealm> CreateRVROccupyingGaugePerRealm(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t realm = 0,
    int32_t gauge = 0) {
  RVROccupyingGaugePerRealmBuilder builder_(_fbb);
  builder_.add_gauge(gauge);
  builder_.add_realm(realm);
  return builder_.Finish();
}

struct RVROccupyingGaugeInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NPCCONTENTSID = 4,
    VT_CUROCCUPIEDREALM = 6,
    VT_GAUGES = 8
  };
  int32_t npcContentsId() const {
    return GetField<int32_t>(VT_NPCCONTENTSID, 0);
  }
  int16_t curOccupiedRealm() const {
    return GetField<int16_t>(VT_CUROCCUPIEDREALM, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<RVROccupyingGaugePerRealm>> *gauges() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<RVROccupyingGaugePerRealm>> *>(VT_GAUGES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NPCCONTENTSID) &&
           VerifyField<int16_t>(verifier, VT_CUROCCUPIEDREALM) &&
           VerifyOffset(verifier, VT_GAUGES) &&
           verifier.VerifyVector(gauges()) &&
           verifier.VerifyVectorOfTables(gauges()) &&
           verifier.EndTable();
  }
};

struct RVROccupyingGaugeInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_npcContentsId(int32_t npcContentsId) {
    fbb_.AddElement<int32_t>(RVROccupyingGaugeInfo::VT_NPCCONTENTSID, npcContentsId, 0);
  }
  void add_curOccupiedRealm(int16_t curOccupiedRealm) {
    fbb_.AddElement<int16_t>(RVROccupyingGaugeInfo::VT_CUROCCUPIEDREALM, curOccupiedRealm, 0);
  }
  void add_gauges(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RVROccupyingGaugePerRealm>>> gauges) {
    fbb_.AddOffset(RVROccupyingGaugeInfo::VT_GAUGES, gauges);
  }
  explicit RVROccupyingGaugeInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVROccupyingGaugeInfoBuilder &operator=(const RVROccupyingGaugeInfoBuilder &);
  flatbuffers::Offset<RVROccupyingGaugeInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVROccupyingGaugeInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVROccupyingGaugeInfo> CreateRVROccupyingGaugeInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t npcContentsId = 0,
    int16_t curOccupiedRealm = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RVROccupyingGaugePerRealm>>> gauges = 0) {
  RVROccupyingGaugeInfoBuilder builder_(_fbb);
  builder_.add_gauges(gauges);
  builder_.add_npcContentsId(npcContentsId);
  builder_.add_curOccupiedRealm(curOccupiedRealm);
  return builder_.Finish();
}

inline flatbuffers::Offset<RVROccupyingGaugeInfo> CreateRVROccupyingGaugeInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t npcContentsId = 0,
    int16_t curOccupiedRealm = 0,
    const std::vector<flatbuffers::Offset<RVROccupyingGaugePerRealm>> *gauges = nullptr) {
  return LeanPacket::CreateRVROccupyingGaugeInfo(
      _fbb,
      npcContentsId,
      curOccupiedRealm,
      gauges ? _fbb.CreateVector<flatbuffers::Offset<RVROccupyingGaugePerRealm>>(*gauges) : 0);
}

/// RVR_OCCUPYING_GAUGE_APPROXIMATE_INFO_NOTIFY
struct RVROccupyingGaugeApproximateInfoNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INFO = 4
  };
  const RVROccupyingGaugeInfo *info() const {
    return GetPointer<const RVROccupyingGaugeInfo *>(VT_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           verifier.EndTable();
  }
};

struct RVROccupyingGaugeApproximateInfoNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_info(flatbuffers::Offset<RVROccupyingGaugeInfo> info) {
    fbb_.AddOffset(RVROccupyingGaugeApproximateInfoNotify::VT_INFO, info);
  }
  explicit RVROccupyingGaugeApproximateInfoNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVROccupyingGaugeApproximateInfoNotifyBuilder &operator=(const RVROccupyingGaugeApproximateInfoNotifyBuilder &);
  flatbuffers::Offset<RVROccupyingGaugeApproximateInfoNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVROccupyingGaugeApproximateInfoNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVROccupyingGaugeApproximateInfoNotify> CreateRVROccupyingGaugeApproximateInfoNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<RVROccupyingGaugeInfo> info = 0) {
  RVROccupyingGaugeApproximateInfoNotifyBuilder builder_(_fbb);
  builder_.add_info(info);
  return builder_.Finish();
}

/// RVR_OCCUPYING_GAUGE_INFO_NOTIFY
struct RVROccupyingGaugeInfoNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INFO = 4
  };
  const RVROccupyingGaugeInfo *info() const {
    return GetPointer<const RVROccupyingGaugeInfo *>(VT_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           verifier.EndTable();
  }
};

struct RVROccupyingGaugeInfoNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_info(flatbuffers::Offset<RVROccupyingGaugeInfo> info) {
    fbb_.AddOffset(RVROccupyingGaugeInfoNotify::VT_INFO, info);
  }
  explicit RVROccupyingGaugeInfoNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RVROccupyingGaugeInfoNotifyBuilder &operator=(const RVROccupyingGaugeInfoNotifyBuilder &);
  flatbuffers::Offset<RVROccupyingGaugeInfoNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RVROccupyingGaugeInfoNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<RVROccupyingGaugeInfoNotify> CreateRVROccupyingGaugeInfoNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<RVROccupyingGaugeInfo> info = 0) {
  RVROccupyingGaugeInfoNotifyBuilder builder_(_fbb);
  builder_.add_info(info);
  return builder_.Finish();
}

}  // namespace LeanPacket

#endif  // FLATBUFFERS_GENERATED_LEANPACKET_LEANPACKET_H_
